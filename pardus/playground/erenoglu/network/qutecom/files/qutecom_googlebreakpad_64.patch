diff --git a/libs/3rdparty/googlebreakpad/CMakeLists-internal-unix.txt b/libs/3rdparty/googlebreakpad/CMakeLists-internal-unix.txt
--- a/libs/3rdparty/googlebreakpad/CMakeLists-internal-unix.txt
+++ b/libs/3rdparty/googlebreakpad/CMakeLists-internal-unix.txt
@@ -18,7 +18,10 @@
  	src/client/minidump_file_writer.cc
  	src/client/linux/handler/exception_handler.cc
  	src/client/linux/handler/linux_thread.cc
-	src/client/linux/handler/minidump_generator.cc	
+	src/client/linux/handler/minidump_generator.cc
+  src/client/linux/handler/sigcontext.cc
+  src/client/linux/handler/cpu_context.cc
+  src/client/linux/handler/gettid.cc
 )
 
 ow_create_project_binary()
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/Makefile b/libs/3rdparty/googlebreakpad/src/client/linux/handler/Makefile
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/Makefile
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/Makefile
@@ -1,35 +1,34 @@
 CXX=g++
 CC=gcc
+#ARCH=-m64 -fno-omit-frame-pointer
 
-CXXFLAGS=-gstabs -I../../.. -Wall -D_REENTRANT
+CXXFLAGS=-gstabs -I../../.. -Wall -D_REENTRANT $(ARCH)
+CFLAGS=-gstabs  -I../../.. -Wall -D_REENTRANT  $(ARCH)
 LDFLAGS=-lpthread
 
 OBJ_DIR=.
 BIN_DIR=.
 
-THREAD_SRC=linux_thread.cc
-SHARE_SRC=../../minidump_file_writer.cc\
-	  ../../../common/string_conversion.cc\
-	  ../../../common/linux/file_id.cc\
-	  minidump_generator.cc
-HANDLER_SRC=exception_handler.cc\
-	    ../../../common/linux/guid_creator.cc
+SHARE_CXX_SRC=../../../common/linux/file_id.cc\
+	      ../../../common/linux/guid_creator.cc\
+	      ../../../common/string_conversion.cc\
+	      ../../../common/md5.cc\
+	      ../../minidump_file_writer.cc\
+	      gettid.cc\
+	      sigcontext.cc\
+	      cpu_context.cc\
+	      linux_thread.cc\
+	      minidump_generator.cc\
+	      exception_handler.cc
 SHARE_C_SRC=../../../common/convert_UTF.c
 
 THREAD_TEST_SRC=linux_thread_test.cc
 MINIDUMP_TEST_SRC=minidump_test.cc
 EXCEPTION_TEST_SRC=exception_handler_test.cc
 
-THREAD_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(THREAD_SRC))
-SHARE_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(SHARE_SRC))
-HANDLER_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(HANDLER_SRC))
-SHARE_C_OBJ=$(patsubst %.c,$(OBJ_DIR)/%.o,$(SHARE_C_SRC)) md5.o
-THREAD_TEST_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o, $(THREAD_TEST_SRC))\
-		$(THREAD_OBJ)
-MINIDUMP_TEST_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o, $(MINIDUMP_TEST_SRC))\
-		  $(THREAD_OBJ) $(SHARE_OBJ) $(SHARE_C_OBJ)
-EXCEPTION_TEST_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o, $(EXCEPTION_TEST_SRC))\
-		   $(THREAD_OBJ) $(SHARE_OBJ) $(SHARE_C_OBJ) $(HANDLER_SRC)
+SHARE_CXX_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(SHARE_CXX_SRC))
+SHARE_C_OBJ=$(patsubst %.c,$(OBJ_DIR)/%.o,$(SHARE_C_SRC))
+SHARE_OBJ=$(SHARE_CXX_OBJ) $(SHARE_C_OBJ)
 
 BIN=$(BIN_DIR)/minidump_test\
     $(BIN_DIR)/linux_thread_test\
@@ -39,17 +38,14 @@
 
 all:$(BIN)
 
-$(BIN_DIR)/linux_thread_test:$(THREAD_TEST_OBJ)
+$(BIN_DIR)/linux_thread_test:linux_thread_test.o $(SHARE_OBJ)
 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $^ -o $@
 
-$(BIN_DIR)/minidump_test:$(MINIDUMP_TEST_OBJ)
+$(BIN_DIR)/minidump_test:minidump_test.o $(SHARE_OBJ)
 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $^ -o $@
 
-$(BIN_DIR)/exception_handler_test:$(EXCEPTION_TEST_OBJ)
+$(BIN_DIR)/exception_handler_test:exception_handler_test.o $(SHARE_OBJ)
 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $^ -o $@
 
-md5.o:../../../common/md5.c
-	$(CC) $(CXXFLAGS) -c $^
-
 clean:
-	rm -f $(BIN) *.o *.dmp
+	rm -f $(BIN) *.o *.dmp $(SHARE_OBJ)
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.cc
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.cc
@@ -0,0 +1,168 @@
+
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+
+#include <cassert>
+#include <cstring>
+#include <sys/types.h>
+#include <sys/user.h>
+
+#include "client/linux/handler/cpu_context.h"
+#include "client/linux/handler/linux_thread.h"
+
+namespace google_breakpad {
+
+CPUContext::CPUContext(const struct user_regs_struct *user_regs,
+                       const struct user_fpregs_struct *fp_regs,
+                       const DebugRegs *debug_regs) :
+    user_regs_(user_regs),
+    fp_regs_(fp_regs),
+    debug_regs_(debug_regs) {
+}
+
+uintptr_t CPUContext::GetFramePointer() const {
+  assert(user_regs_);
+#ifdef __i386__
+  return user_regs_->ebp;
+#elif defined(__x86_64__)
+  return user_regs_->rbp;
+#endif
+}
+
+uintptr_t CPUContext::GetStackPointer() const {
+  assert(user_regs_);
+#ifdef __i386__
+  return user_regs_->esp;
+#elif defined(__x86_64__)
+  return user_regs_->rsp;
+#endif
+}
+
+bool CPUContext::CopyTo(RawContext *context) const {
+  assert(user_regs_ || fp_regs_ || debug_regs_);
+  if (!(user_regs_ || fp_regs_ || debug_regs_))
+    return false;
+
+  if (user_regs_)
+    CopyGeneralRegisters(context);
+  if (fp_regs_)
+    CopyFloatingPointRegisters(context);
+  if (debug_regs_)
+    CopyDebugRegisters(context);
+
+  return true;
+}
+
+#ifdef __i386__
+void CPUContext::CopyGeneralRegisters(RawContext *context) const {
+  context->context_flags = MD_CONTEXT_X86_FULL;
+  context->cs = user_regs_->xcs;
+  context->ds = user_regs_->xds;
+  context->es = user_regs_->xes;
+  context->fs = user_regs_->xfs;
+  context->gs = user_regs_->xgs;
+  context->ss = user_regs_->xss;
+  context->edi = user_regs_->edi;
+  context->esi = user_regs_->esi;
+  context->ebx = user_regs_->ebx;
+  context->edx = user_regs_->edx;
+  context->ecx = user_regs_->ecx;
+  context->eax = user_regs_->eax;
+  context->ebp = user_regs_->ebp;
+  context->eip = user_regs_->eip;
+  context->esp = user_regs_->esp;
+  context->eflags = user_regs_->eflags;
+}
+#endif
+
+#ifdef __x86_64__
+void CPUContext::CopyGeneralRegisters(RawContext *context) const {
+  context->context_flags = MD_CONTEXT_AMD64_CONTROL |
+                           MD_CONTEXT_AMD64_INTEGER |
+                           MD_CONTEXT_AMD64_SEGMENTS;
+  context->cs = user_regs_->cs;
+  context->ds = user_regs_->ds;
+  context->es = user_regs_->es;
+  context->fs = user_regs_->fs;
+  context->gs = user_regs_->gs;
+  context->ss = user_regs_->ss;
+  context->eflags = user_regs_->eflags;
+  context->rip = user_regs_->rip;
+  context->rax = user_regs_->rax;
+  context->rbx = user_regs_->rbx;
+  context->rcx = user_regs_->rcx;
+  context->rdx = user_regs_->rdx;
+  context->rsp = user_regs_->rsp;
+  context->rbp = user_regs_->rbp;
+  context->rsi = user_regs_->rsi;
+  context->rdi = user_regs_->rdi;
+  context->r8 = user_regs_->r8;
+  context->r9 = user_regs_->r9;
+  context->r10 = user_regs_->r10;
+  context->r11 = user_regs_->r11;
+  context->r12 = user_regs_->r12;
+  context->r13 = user_regs_->r13;
+  context->r14 = user_regs_->r14;
+  context->r15 = user_regs_->r15;
+}
+#endif
+
+void CPUContext::CopyFloatingPointRegisters(RawContext *context) const {
+#ifdef __i386__
+  context->context_flags |= MD_CONTEXT_X86_FLOATING_POINT;
+  context->float_save.control_word = fp_regs_->cwd;
+  context->float_save.status_word = fp_regs_->swd;
+  context->float_save.tag_word = fp_regs_->twd;
+  context->float_save.error_offset = fp_regs_->fip;
+  context->float_save.error_selector = fp_regs_->fcs;
+  context->float_save.data_offset = fp_regs_->foo;
+  context->float_save.data_selector = fp_regs_->fos;
+  context->float_save.data_selector = fp_regs_->fos;
+
+  memcpy(context->float_save.register_area,
+         fp_regs_->st_space,
+         sizeof(context->float_save.register_area));
+#endif
+}
+
+void CPUContext::CopyDebugRegisters(RawContext *context) const {
+#ifdef __i386__
+  context->context_flags |= MD_CONTEXT_X86_DEBUG_REGISTERS;
+  context->dr0 = debug_regs_->dr0;
+  context->dr1 = debug_regs_->dr1;
+  context->dr2 = debug_regs_->dr2;
+  context->dr3 = debug_regs_->dr3;
+  context->dr6 = debug_regs_->dr6;
+  context->dr7 = debug_regs_->dr7;
+#endif
+}
+
+}  // namespace google_breakpad
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.h
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/cpu_context.h
@@ -0,0 +1,94 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+#ifndef CLIENT_LINUX_HANDLER_CPU_CONTEXT_H__
+#define CLIENT_LINUX_HANDLER_CPU_CONTEXT_H__
+
+#include <stdint.h>
+
+#include "google_breakpad/common/minidump_format.h"
+
+#ifdef __i386__
+typedef MDRawContextX86 RawContext;
+#elif defined(__x86_64__)
+typedef MDRawContextAMD64 RawContext;
+#else
+#error "Unsupported platform!"
+#endif
+
+// Fowards
+// System defined registers.
+struct user_regs_struct;
+struct user_fpregs_struct;
+
+namespace google_breakpad {
+
+// Fowards
+// Debug register set.
+struct DebugRegs;
+
+// CPUContext
+//
+// A wrapper class around the raw cpu context dependent on each CPU type(i386
+// and x86_64).
+// It provides CPU independant way of accessing common cpu contexts by wrapping
+// those details into this class.
+class CPUContext {
+  public:
+    CPUContext(const struct user_regs_struct *user_regs,
+               const struct user_fpregs_struct *fp_regs,
+               const DebugRegs *debug_regs);
+
+    // Get the frame pointer.
+    uintptr_t GetFramePointer() const;
+
+    // Get the stack pointer.
+    uintptr_t GetStackPointer() const;
+
+    // Fill the minidump context section with the current context.
+    bool CopyTo(RawContext *context) const;
+
+  private:
+    void CopyGeneralRegisters(RawContext *context) const;
+    void CopyFloatingPointRegisters(RawContext *context) const;
+    void CopyDebugRegisters(RawContext *context) const;
+
+    // General purpose registers.
+    const struct user_regs_struct *user_regs_;
+    // Floating pointers.
+    const struct user_fpregs_struct *fp_regs_;
+    // Debug registers.
+    const DebugRegs *debug_regs_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_HANDLER_CPU_CONTEXT_H__
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.cc
@@ -29,17 +29,20 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+#include <limits.h>
 #include <signal.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <string.h>
 #include <unistd.h>
 
 #include <cassert>
 #include <cstdlib>
 #include <ctime>
-#include <linux/limits.h>
 
 #include "client/linux/handler/exception_handler.h"
+#include "client/linux/handler/minidump_generator.h"
+#include "client/linux/handler/sigcontext.h"
 #include "common/linux/guid_creator.h"
 #include "google_breakpad/common/minidump_format.h"
 
@@ -78,7 +81,8 @@
       callback_(callback),
       callback_context_(callback_context),
       dump_path_(),
-      installed_handler_(install_handler) {
+      installed_handler_(install_handler),
+      minidump_generator_(new MinidumpGenerator) {
   set_dump_path(dump_path);
 
   if (install_handler) {
@@ -94,16 +98,18 @@
 ExceptionHandler::~ExceptionHandler() {
   TeardownAllHandler();
   pthread_mutex_lock(&handler_stack_mutex_);
-  if (handler_stack_->back() == this) {
-    handler_stack_->pop_back();
-  } else {
-    fprintf(stderr, "warning: removing Breakpad handler out of order\n");
-    for (std::vector<ExceptionHandler *>::iterator iterator =
-         handler_stack_->begin();
-         iterator != handler_stack_->end();
-         ++iterator) {
-      if (*iterator == this) {
-        handler_stack_->erase(iterator);
+  if (installed_handler_) {
+    if (handler_stack_->back() == this) {
+      handler_stack_->pop_back();
+    } else {
+      fprintf(stderr, "Warning: removing Breakpad handler out of order\n");
+      for (std::vector<ExceptionHandler *>::iterator iterator =
+           handler_stack_->begin();
+           iterator != handler_stack_->end();
+           ++iterator) {
+        if (*iterator == this) {
+          handler_stack_->erase(iterator);
+        }
       }
     }
   }
@@ -115,6 +121,7 @@
     handler_stack_ = NULL;
   }
   pthread_mutex_unlock(&handler_stack_mutex_);
+  delete minidump_generator_;
 }
 
 bool ExceptionHandler::WriteMinidump() {
@@ -148,8 +155,9 @@
 
 void ExceptionHandler::SetupHandler(int signo) {
   struct sigaction act, old_act;
-  act.sa_handler = HandleException;
-  act.sa_flags = SA_ONSTACK;
+  memset(&act, 0, sizeof(struct sigaction));
+  act.sa_sigaction = HandleException;
+  act.sa_flags = SA_ONSTACK | SA_SIGINFO;
   if (sigaction(signo, &act, &old_act) < 0)
     return;
   old_handlers_[signo] = old_act.sa_handler;
@@ -158,6 +166,7 @@
 void ExceptionHandler::TeardownHandler(int signo) {
   if (old_handlers_.find(signo) != old_handlers_.end()) {
     struct sigaction act;
+    memset(&act, 0, sizeof(struct sigaction));
     act.sa_handler = old_handlers_[signo];
     act.sa_flags = 0;
     sigaction(signo, &act, 0);
@@ -171,7 +180,9 @@
 }
 
 // static
-void ExceptionHandler::HandleException(int signo) {
+void ExceptionHandler::HandleException(int signo,
+                              siginfo_t *siginfo,
+                              void *ucontext) {
   // In Linux, the context information about the signal is put on the stack of
   // the signal handler frame as value parameter. For some reasons, the
   // prototype of the handler doesn't declare this information as parameter, we
@@ -179,12 +190,26 @@
   // However, if we are being called by another signal handler passing the
   // signal up the chain, then we may not have this random extra parameter,
   // so we may have to walk the stack to find it.  We do the actual work
-  // on another thread, where it's a little safer, but we want the ebp
-  // from this frame to find it.
-  uintptr_t current_ebp = 0;
+  // on another thread, where it's a little safer, but we want the frame
+  // pointer from this frame to find it.
+  uintptr_t frame_pointer = 0;
+#ifdef __i386__
   asm volatile ("movl %%ebp, %0"
-                :"=m"(current_ebp));
+                :"=r"(frame_pointer));
+#elif defined(__x86_64__)
+  asm volatile ("mov %%rbp, %0"
+                :"=r"(frame_pointer));
 
+  if (siginfo == NULL || ucontext == NULL) {
+    // In this case, we can't get the context of the signal, can we can do
+    // nothing, just return.
+    fprintf(stderr, "Error: Unable to get signal context!");
+    signal(signo, SIG_DFL);
+    return;
+  }
+#else
+#error "Unsupported platform!"
+#endif
   pthread_mutex_lock(&handler_stack_mutex_);
   ExceptionHandler *current_handler =
     handler_stack_->at(handler_stack_->size() - ++handler_stack_index_);
@@ -193,18 +218,21 @@
   // Restore original handler.
   current_handler->TeardownHandler(signo);
 
-  struct sigcontext *sig_ctx = NULL;
-  if (current_handler->InternalWriteMinidump(signo, current_ebp, &sig_ctx)) {
+  SignalContext sig_ctx;
+#ifdef __x86_64__
+  sig_ctx.SetUContext(static_cast<ucontext_t *>(ucontext));
+#endif
+  if (current_handler->InternalWriteMinidump(signo, frame_pointer, &sig_ctx)) {
     // Fully handled this exception, safe to exit.
     exit(EXIT_FAILURE);
   } else {
     // Exception not fully handled, will call the next handler in stack to
     // process it.
-    typedef void (*SignalHandler)(int signo, struct sigcontext);
+    typedef void (*SignalHandler)(int, siginfo_t *, void *);
     SignalHandler old_handler =
       reinterpret_cast<SignalHandler>(current_handler->old_handlers_[signo]);
-    if (old_handler != NULL && sig_ctx != NULL)
-      old_handler(signo, *sig_ctx);
+    if (old_handler != NULL)
+      old_handler(signo, siginfo, ucontext);
   }
 
   pthread_mutex_lock(&handler_stack_mutex_);
@@ -221,8 +249,8 @@
 }
 
 bool ExceptionHandler::InternalWriteMinidump(int signo,
-                                             uintptr_t sighandler_ebp,
-                                             struct sigcontext **sig_ctx) {
+                                             uintptr_t sighandler_frame_pointer,
+                                             SignalContext *sig_ctx) {
   if (filter_ && !filter_(callback_context_))
     return false;
 
@@ -248,8 +276,11 @@
                       "failed to block signals.\n");
     }
 
-    success = minidump_generator_.WriteMinidumpToFile(
-                       minidump_path, signo, sighandler_ebp, sig_ctx);
+    success = minidump_generator_->WriteMinidumpToFile(
+        minidump_path,
+        signo,
+        sighandler_frame_pointer,
+        sig_ctx);
 
     // Unblock the signals.
     if (blocked) {
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.h
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.h
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler.h
@@ -37,13 +37,12 @@
 #include <map>
 #include <string>
 #include <vector>
-
-#include "client/linux/handler/minidump_generator.h"
-
-// Context information when exception occured.
-struct sigcontex;
+#include <signal.h>
 
 namespace google_breakpad {
+
+class MinidumpGenerator;
+struct SignalContext;
 
 using std::string;
 
@@ -149,7 +148,9 @@
   void TeardownAllHandler();
 
   // Signal handler.
-  static void HandleException(int signo);
+  static void HandleException(int signo,
+                              siginfo_t *siginfo,
+                              void *ucontext);
 
   // If called from a signal handler, sighandler_ebp is the ebp of
   // that signal handler's frame, and sig_ctx is an out parameter
@@ -158,7 +159,7 @@
   // for the second and third parameters if you are not calling
   // this from a signal handler.
   bool InternalWriteMinidump(int signo, uintptr_t sighandler_ebp,
-                             struct sigcontext **sig_ctx);
+                             SignalContext *sig_ctx);
 
  private:
   FilterCallback filter_;
@@ -189,7 +190,7 @@
   static pthread_mutex_t handler_stack_mutex_;
 
   // The minidump generator.
-  MinidumpGenerator minidump_generator_;
+  MinidumpGenerator *minidump_generator_;
 
   // disallow copy ctor and operator=
   explicit ExceptionHandler(const ExceptionHandler &);
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler_test.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler_test.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler_test.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/exception_handler_test.cc
@@ -36,8 +36,12 @@
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
+#include <errno.h>
+#include <sys/types.h>
+#include <linux/unistd.h>
 
 #include "client/linux/handler/exception_handler.h"
+#include "client/linux/handler/gettid.h"
 #include "client/linux/handler/linux_thread.h"
 
 using namespace google_breakpad;
@@ -49,7 +53,7 @@
   // Stack variable, used for debugging stack dumps.
   /*DDDebug*/printf("%s:%d\n", __FUNCTION__, __LINE__);
   int c = 0xcccccccc;
-  fprintf(stderr, "Thread trying to crash: %x\n", getpid());
+  fprintf(stderr, "Thread trying to crash: %x\n", gettid());
   c = *reinterpret_cast<int *>(0x5);
   return c;
 }
@@ -96,8 +100,8 @@
                              const char *minidump_id,
                              void *context,
                              bool succeeded) {
-  int index = reinterpret_cast<int>(context);
-  printf("%d %s: %s is dumped\n", index, __FUNCTION__, minidump_id);
+  long index = reinterpret_cast<int>(context);
+  printf("%ld %s: %s is dumped\n", index, __FUNCTION__, minidump_id);
   if (index == 0) {
     should_exit = true;
     return true;
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.cc
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.cc
@@ -0,0 +1,42 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "client/linux/handler/gettid.h"
+
+#ifdef _syscall0
+_syscall0(pid_t,gettid)
+#else
+#include <unistd.h>
+
+pid_t gettid() {
+  return syscall(__NR_gettid);
+}
+#endif
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.h
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/gettid.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_HANDLER_GETTID_H__
+#define CLIENT_LINUX_HANDLER_GETTID_H__
+
+#include <sys/types.h>
+#include <linux/unistd.h>
+#include <errno.h>
+
+pid_t gettid(void);
+
+#endif  // CLIENT_LINUX_HANDLER_GETTID_H__
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.cc
@@ -32,12 +32,12 @@
 #include <errno.h>
 #include <dirent.h>
 #include <fcntl.h>
+#include <string.h>
 #include <sys/ptrace.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 #include <sys/wait.h>
-#include <string.h>
 
 #include <algorithm>
 #include <cassert>
@@ -46,6 +46,7 @@
 #include <functional>
 
 #include "client/linux/handler/linux_thread.h"
+#include "client/linux/handler/sigcontext.h"
 
 using namespace google_breakpad;
 
@@ -62,12 +63,12 @@
   }
 };
 
-// Convert from string to int.
-bool LocalAtoi(char *s, int *r) {
+// Convert from string to long.
+bool LocalAtol(char *s, long *r) {
   assert(s != NULL);
   assert(r != NULL);
   char *endptr = NULL;
-  int ret = strtol(s, &endptr, 10);
+  long ret = strtol(s, &endptr, 10);
   if (endptr == s)
     return false;
   *r = ret;
@@ -75,18 +76,18 @@
 }
 
 // Fill the proc path of a thread given its id.
-void FillProcPath(int pid, char *path, int path_size) {
+void FillProcPath(pid_t pid, char *path, size_t path_size) {
   char pid_str[32];
   snprintf(pid_str, sizeof(pid_str), "%d", pid);
   snprintf(path, path_size, "/proc/%s/", pid_str);
 }
 
 // Read thread info from /proc/$pid/status.
-bool ReadThreadInfo(int pid, ThreadInfo *info) {
+bool ReadThreadInfo(pid_t pid, ThreadInfo *info) {
   assert(info != NULL);
   char status_path[80];
   // Max size we want to read from status file.
-  static const int kStatusMaxSize = 1024;
+  static const size_t kStatusMaxSize = 1024;
   char status_content[kStatusMaxSize];
 
   FillProcPath(pid, status_path, sizeof(status_path));
@@ -95,7 +96,7 @@
   if (fd < 0)
     return false;
 
-  int num_read = read(fd, status_content, kStatusMaxSize - 1);
+  size_t num_read = read(fd, status_content, kStatusMaxSize - 1);
   if (num_read < 0) {
     close(fd);
     return false;
@@ -131,25 +132,37 @@
   return !addr->is_mapped;
 }
 
-#if defined(__i386__) && !defined(NO_FRAME_POINTER)
-void *GetNextFrame(void **last_ebp) {
-  void *sp = *last_ebp;
-  if ((unsigned long)sp == (unsigned long)last_ebp)
-    return NULL;
-  if ((unsigned long)sp & (sizeof(void *) - 1))
-    return NULL;
-  if ((unsigned long)sp - (unsigned long)last_ebp > 100000)
-    return NULL;
+#if (defined(__i386__) || defined(__x86_64__)) && !defined(NO_FRAME_POINTER)
+uintptr_t GetNextFrame(uintptr_t *frame_pointer) {
+  uintptr_t sp = *frame_pointer;
+  if (sp == 0)
+    return 0;
+
+  if (sp == reinterpret_cast<uintptr_t>(frame_pointer))
+    return 0;
+
+  if (sp & (sizeof(void *) - 1))
+    return 0;
+
+  // Test the return address, it should not be 0.
+  uintptr_t ret_addr = *(reinterpret_cast<uintptr_t *>(sp) + 1);
+  if (ret_addr == 0)
+    return 0;
+
+#ifdef __i386__
+  // On 64-bit machines, the stack pointer can be very close to
+  // 0xffffffff, so we explicitly check for a pointer into the
+  // last two pages in the address space
+  if (sp >= 0xffffe000) return 0;
+#endif
   return sp;
 }
 #else
-void *GetNextFrame(void **last_ebp) {
-  return reinterpret_cast<void*>(last_ebp);
-}
+#error "Unsupported platform!"
 #endif
 
 // Suspend a thread by attaching to it.
-bool SuspendThread(int pid, void *context) {
+bool SuspendThread(pid_t pid, void *context) {
   // This may fail if the thread has just died or debugged.
   errno = 0;
   if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) != 0 &&
@@ -166,13 +179,13 @@
 }
 
 // Resume a thread by detaching from it.
-bool ResumeThread(int pid, void *context) {
+bool ResumeThread(pid_t pid, void *context) {
   return ptrace(PTRACE_DETACH, pid, NULL, NULL) >= 0;
 }
 
 // Callback to get the thread information.
 // Will be called for each thread found.
-bool ThreadInfoCallback(int pid, void *context) {
+bool ThreadInfoCallback(pid_t pid, void *context) {
   CallbackParam<ThreadCallback> *thread_callback =
     reinterpret_cast<CallbackParam<ThreadCallback> *>(context);
   ThreadInfo thread_info;
@@ -187,7 +200,7 @@
 
 namespace google_breakpad {
 
-LinuxThread::LinuxThread(int pid) : pid_(pid) , threads_suspened_(false) {
+LinuxThread::LinuxThread(pid_t pid) : pid_(pid) , threads_suspened_(false) {
 }
 
 LinuxThread::~LinuxThread() {
@@ -219,8 +232,9 @@
   return IterateProcSelfTask(pid_, &callback_param);
 }
 
-bool LinuxThread::GetRegisters(int pid, user_regs_struct *regs) const {
+bool LinuxThread::GetRegisters(pid_t pid, user_regs_struct *regs) const {
   assert(regs);
+  errno = 0;
   return (regs != NULL &&
           (ptrace(PTRACE_GETREGS, pid, NULL, regs) == 0) &&
           errno == 0);
@@ -228,21 +242,23 @@
 
 // Get the floating-point registers of a thread.
 // The caller must get the thread pid by ListThreads.
-bool LinuxThread::GetFPRegisters(int pid, user_fpregs_struct *regs) const {
+bool LinuxThread::GetFPRegisters(pid_t pid, user_fpregs_struct *regs) const {
   assert(regs);
   return (regs != NULL &&
           (ptrace(PTRACE_GETREGS, pid, NULL, regs) ==0) &&
           errno == 0);
 }
 
-bool LinuxThread::GetFPXRegisters(int pid, user_fpxregs_struct *regs) const {
+#ifndef __x86_64__
+bool LinuxThread::GetFPXRegisters(pid_t pid, user_fpxregs_struct *regs) const {
   assert(regs);
   return (regs != NULL &&
           (ptrace(PTRACE_GETFPREGS, pid, NULL, regs) != 0) &&
           errno == 0);
 }
+#endif
 
-bool LinuxThread::GetDebugRegisters(int pid, DebugRegs *regs) const {
+bool LinuxThread::GetDebugRegisters(pid_t pid, DebugRegs *regs) const {
   assert(regs);
 
 #define GET_DR(name, num)\
@@ -259,18 +275,21 @@
   return true;
 }
 
-int LinuxThread::GetThreadStackDump(uintptr_t current_ebp,
-                                    uintptr_t current_esp,
+int LinuxThread::GetThreadStackDump(uintptr_t frame_pointer,
+                                    uintptr_t stack_pointer,
                                     void *buf,
-                                    int buf_size) const {
+                                    size_t buf_size) const {
   assert(buf);
   assert(buf_size > 0);
 
-  uintptr_t stack_bottom = GetThreadStackBottom(current_ebp);
-  int size = stack_bottom - current_esp;
+  uintptr_t stack_bottom = GetThreadStackBottom(frame_pointer);
+  // Stack bottom should be above the stack pointer.
+  if (stack_bottom < stack_pointer)
+    return 0;
+  size_t size = stack_bottom - stack_pointer;
   size = buf_size > size ? size : buf_size;
   if (size > 0)
-    memcpy(buf, reinterpret_cast<void*>(current_esp), size);
+    memcpy(buf, reinterpret_cast<void*>(stack_pointer), size);
   return size;
 }
 
@@ -281,14 +300,13 @@
 //
 // We will check each frame address by checking into module maps.
 // TODO(liuli): Improve it.
-uintptr_t LinuxThread::GetThreadStackBottom(uintptr_t current_ebp) const {
-  void **sp = reinterpret_cast<void **>(current_ebp);
-  void **previous_sp = sp;
-  while (sp && IsAddressMapped((uintptr_t)sp)) {
+uintptr_t LinuxThread::GetThreadStackBottom(uintptr_t frame_pointer) const {
+  uintptr_t sp = frame_pointer, previous_sp = 0;
+  while (sp && IsAddressMapped(sp)) {
     previous_sp = sp;
-    sp = reinterpret_cast<void **>(GetNextFrame(sp));
+    sp = GetNextFrame(reinterpret_cast<uintptr_t *>(sp));
   }
-  return (uintptr_t)previous_sp;
+  return previous_sp;
 }
 
 int LinuxThread::GetModuleCount() const {
@@ -305,10 +323,10 @@
   if (fp == NULL)
     return -1;
 
-  uintptr_t start_addr;
-  uintptr_t end_addr;
+  long start_addr;
+  long end_addr;
   while (fgets(line, sizeof(line), fp) != NULL) {
-    if (sscanf(line, "%x-%x", &start_addr, &end_addr) == 2) {
+    if (sscanf(line, "%lx-%lx", &start_addr, &end_addr) == 2) {
       ModuleInfo module;
       memset(&module, 0, sizeof(module));
       module.start_addr = start_addr;
@@ -336,8 +354,9 @@
 
 // Parse /proc/$pid/tasks to list all the threads of the process identified by
 // pid.
-int LinuxThread::IterateProcSelfTask(int pid,
-                          CallbackParam<PidCallback> *callback_param) const {
+int LinuxThread::IterateProcSelfTask(
+    pid_t pid,
+    CallbackParam<PidCallback> *callback_param) const {
   char task_path[80];
   FillProcPath(pid, task_path, sizeof(task_path));
   strcat(task_path, "task");
@@ -346,23 +365,24 @@
   if (dir == NULL)
     return -1;
 
-  int pid_number = 0;
+  pid_t pid_number = 0;
   // Record the last pid we've found. This is used for duplicated thread
   // removal. Duplicated thread information can be found in /proc/$pid/tasks.
-  int last_pid = -1;
+  pid_t last_pid = -1;
   struct dirent *entry = NULL;
   while ((entry = readdir(dir)) != NULL) {
     if (strcmp(entry->d_name, ".") &&
         strcmp(entry->d_name, "..")) {
-      int tpid = 0;
-      if (LocalAtoi(entry->d_name, &tpid) &&
+      long tpid = 0;
+      if (LocalAtol(entry->d_name, static_cast<long *>(&tpid)) &&
           last_pid != tpid) {
         last_pid = tpid;
         ++pid_number;
         // Invoke the callback.
         if (callback_param &&
-            !(callback_param->call_back)(tpid, callback_param->context))
+            !(callback_param->call_back)(tpid, callback_param->context)) {
           break;
+        }
       }
     }
   }
@@ -382,30 +402,47 @@
   return addr.is_mapped;
 }
 
-bool LinuxThread::FindSigContext(uintptr_t sighandler_ebp,
-                                 struct sigcontext **sig_ctx) {
-  uintptr_t previous_ebp;
+bool LinuxThread::FindSigContext(uintptr_t sighandler_frame,
+                                 SignalContext *sig_ctx) {
+#ifdef __x86_64__
+  // We have not way to find the signal context just by examining the
+  // stack, on X86_64, compiler agressively tries to use register to
+  // pass arguments instead of pushing them on stacks.
+  // This means our signal hander should be called with signal context,
+  // or breakpad won't work!
+  return true;
+#endif
+
+  uintptr_t previous_frame, current_frame = sighandler_frame;
+  uintptr_t sigctx_frame = 0;
   const int MAX_STACK_DEPTH = 10;
   int depth_counter = 0;
+  SignalContext tmp_ctx;
 
   do {
-    // We're looking for a |struct sigcontext| as the second parameter
+    // We're looking for a |struct ucontext_t| as the third parameter
     // to a signal handler function call.  Luckily, the sigcontext
     // has an ebp member which should match the ebp pointed to
     // by the ebp of the signal handler frame.
-    previous_ebp = reinterpret_cast<uintptr_t>(GetNextFrame(
-                                  reinterpret_cast<void**>(sighandler_ebp)));
+    previous_frame = GetNextFrame(reinterpret_cast<uintptr_t *>(current_frame));
     // The stack looks like this:
-    // | previous ebp | previous eip | first param | second param |,
-    // so we need to offset by 3 to get to the second parameter.
-    *sig_ctx = reinterpret_cast<struct sigcontext*>(sighandler_ebp +
-                                                    3 * sizeof(uintptr_t));
-    sighandler_ebp = previous_ebp;
+    // | previous ebp | previous eip | first param | second param | third param|
+    // so we need to offset by 4 to get to the second parameter.
+    ucontext_t *uc = *reinterpret_cast<ucontext_t**>(current_frame + 4 * sizeof(uintptr_t));
+
+    tmp_ctx.SetUContext(uc);
+    current_frame = previous_frame;
+    sigctx_frame = tmp_ctx.GetFramePointer();
     depth_counter++;
-  } while(previous_ebp != (*sig_ctx)->ebp && sighandler_ebp != 0 &&
-          IsAddressMapped(sighandler_ebp) && depth_counter < MAX_STACK_DEPTH);
 
-  return previous_ebp == (*sig_ctx)->ebp && previous_ebp != 0;
+  } while(previous_frame != sigctx_frame && current_frame != 0 &&
+          IsAddressMapped(current_frame) && depth_counter < MAX_STACK_DEPTH);
+
+  if (previous_frame == sigctx_frame && previous_frame != 0) {
+    sig_ctx->SetSignalContext(tmp_ctx.GetRawContext());
+    return true;
+  }
+  return false;
 }
 
 }  // namespace google_breakpad
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.h
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.h
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread.h
@@ -33,6 +33,7 @@
 #define CLIENT_LINUX_HANDLER_LINUX_THREAD_H__
 
 #include <stdint.h>
+#include <sys/types.h>
 #include <sys/user.h>
 
 namespace google_breakpad {
@@ -43,30 +44,30 @@
 // Holding information about a thread in the process.
 struct ThreadInfo {
   // Id of the thread group.
-  int tgid;
+  pid_t tgid;
   // Id of the thread.
-  int pid;
+  pid_t pid;
   // Id of the parent process.
-  int ppid;
+  pid_t ppid;
 };
 
 // Holding infomaton about a module in the process.
 struct ModuleInfo {
   char name[kMaxModuleNameLength];
-  uintptr_t start_addr;
-  int size;
+  unsigned long start_addr;
+  long size;
 };
 
 // Holding debug registers.
 struct DebugRegs {
-  int dr0;
-  int dr1;
-  int dr2;
-  int dr3;
-  int dr4;
-  int dr5;
-  int dr6;
-  int dr7;
+  long dr0;
+  long dr1;
+  long dr2;
+  long dr3;
+  long dr4;
+  long dr5;
+  long dr6;
+  long dr7;
 };
 
 // A callback to run when got a thread in the process.
@@ -95,6 +96,9 @@
   }
 };
 
+// Wrapper for the raw signal context.
+class SignalContext;
+
 ///////////////////////////////////////////////////////////////////////////////
 
 //
@@ -117,7 +121,7 @@
 class LinuxThread {
  public:
   // Create a LinuxThread instance to list all the threads in a process.
-  explicit LinuxThread(int pid);
+  explicit LinuxThread(pid_t pid);
   ~LinuxThread();
 
   // Stop all the threads in the process.
@@ -140,26 +144,32 @@
 
   // Get the general purpose registers of a thread.
   // The caller must get the thread pid by ListThreads.
-  bool GetRegisters(int pid, user_regs_struct *regs) const;
+  bool GetRegisters(pid_t pid, user_regs_struct *regs) const;
 
   // Get the floating-point registers of a thread.
   // The caller must get the thread pid by ListThreads.
-  bool GetFPRegisters(int pid, user_fpregs_struct *regs) const;
+  bool GetFPRegisters(pid_t pid, user_fpregs_struct *regs) const;
 
+#ifndef __x86_64__
   // Get all the extended floating-point registers. May not work on all
   // machines.
   // The caller must get the thread pid by ListThreads.
-  bool GetFPXRegisters(int pid, user_fpxregs_struct *regs) const;
+  bool GetFPXRegisters(pid_t pid, user_fpxregs_struct *regs) const;
+#endif
 
   // Get the debug registers.
   // The caller must get the thread pid by ListThreads.
-  bool GetDebugRegisters(int pid, DebugRegs *regs) const;
+  bool GetDebugRegisters(pid_t pid, DebugRegs *regs) const;
 
   // Get the stack memory dump.
-  int GetThreadStackDump(uintptr_t current_ebp,
-                         uintptr_t current_esp,
+  // |frame_pointer| points to the start of the frame, it is
+  // the value of ebp register in i386, and value of rbp in
+  // x86-64.
+  // |stack_pointer| points to the current stack top.
+  int GetThreadStackDump(uintptr_t frame_pointer,
+                         uintptr_t stack_pointer,
                          void *buf,
-                         int buf_size) const;
+                         size_t buf_size) const;
 
   // Get the module count of the current process.
   int GetModuleCount() const;
@@ -170,22 +180,23 @@
   // Return how may modules are found.
   int ListModules(CallbackParam<ModuleCallback> *callback_param) const;
 
-  // Get the bottom of the stack from ebp.
-  uintptr_t GetThreadStackBottom(uintptr_t current_ebp) const;
+  // Get the bottom of the stack from the frame_pointer.
+  uintptr_t GetThreadStackBottom(uintptr_t frame_pointer) const;
 
-  // Finds a sigcontext on the stack given the ebp of our signal handler.
-  bool FindSigContext(uintptr_t sighandler_ebp, struct sigcontext **sig_ctx);
+  // Finds a sigcontext on the stack given the frame pointer of our signal
+  // handler.
+  bool FindSigContext(uintptr_t sighandler_frame, SignalContext *sig_ctx);
 
  private:
   // This callback will run when a new thread has been found.
-  typedef bool (*PidCallback)(int pid, void *context);
+  typedef bool (*PidCallback)(pid_t pid, void *context);
 
   // Read thread information from /proc/$pid/task.
   // Whenever a thread has been found, and callback will be invoked with
   // the pid of the thread.
   // Return number of threads found.
   // Return -1 means the directory doesn't exist.
-  int IterateProcSelfTask(int pid,
+  int IterateProcSelfTask(pid_t pid,
                           CallbackParam<PidCallback> *callback_param) const;
 
   // Check if the address is a valid virtual address.
@@ -193,7 +204,7 @@
 
  private:
   // The pid of the process we are listing threads.
-  int pid_;
+  pid_t pid_;
 
   // Mark if we have suspended the threads.
   bool threads_suspened_;
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread_test.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread_test.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread_test.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/linux_thread_test.cc
@@ -63,6 +63,7 @@
   // Stack variable, used for debugging stack dumps.
   int b = 0xbbbbbbbb;
   b = b;
+  printf("Child thread id: %d\n", getpid());
   while (!should_exit) {
     foo();
   }
@@ -81,11 +82,11 @@
 
 static bool ProcessOneModule(const struct ModuleInfo &module_info,
                              void *context) {
-  printf("0x%x[%8d]         %s\n", module_info.start_addr, module_info.size,
-         module_info.name);
+  printf("0x%.16lx[%16ld]         %s\n", module_info.start_addr, module_info.size, module_info.name);
   return true;
 }
 
+#ifdef __i386__
 static bool ProcessOneThread(const struct ThreadInfo &thread_info,
                              void *context) {
   printf("\n\nPID: %d, TGID: %d, PPID: %d\n",
@@ -163,14 +164,14 @@
   }
   if (threads->GetDebugRegisters(thread_info.pid, &dbg_regs)) {
     printf("\n Debug registers:\n");
-    printf("  dr0                          = 0x%x\n", dbg_regs.dr0);
-    printf("  dr1                          = 0x%x\n", dbg_regs.dr1);
-    printf("  dr2                          = 0x%x\n", dbg_regs.dr2);
-    printf("  dr3                          = 0x%x\n", dbg_regs.dr3);
-    printf("  dr4                          = 0x%x\n", dbg_regs.dr4);
-    printf("  dr5                          = 0x%x\n", dbg_regs.dr5);
-    printf("  dr6                          = 0x%x\n", dbg_regs.dr6);
-    printf("  dr7                          = 0x%x\n", dbg_regs.dr7);
+    printf("  dr0                          = 0x%lx\n", dbg_regs.dr0);
+    printf("  dr1                          = 0x%lx\n", dbg_regs.dr1);
+    printf("  dr2                          = 0x%lx\n", dbg_regs.dr2);
+    printf("  dr3                          = 0x%lx\n", dbg_regs.dr3);
+    printf("  dr4                          = 0x%lx\n", dbg_regs.dr4);
+    printf("  dr5                          = 0x%lx\n", dbg_regs.dr5);
+    printf("  dr6                          = 0x%lx\n", dbg_regs.dr6);
+    printf("  dr7                          = 0x%lx\n", dbg_regs.dr7);
     printf("\n");
   }
   if (regs.esp != 0) {
@@ -190,15 +191,100 @@
   }
   return true;
 }
+#endif
+
+#ifdef __x86_64__
+static bool ProcessOneThread(const struct ThreadInfo &thread_info,
+                             void *context) {
+  printf("\n\nPID: %d, TGID: %d, PPID: %d\n",
+         thread_info.pid,
+         thread_info.tgid,
+         thread_info.ppid);
+
+  struct user_regs_struct regs;
+  struct user_fpregs_struct fp_regs;
+  struct DebugRegs dbg_regs;
+
+  LinuxThread *threads = reinterpret_cast<LinuxThread *>(context);
+  memset(&regs, 0, sizeof(regs));
+  if (threads->GetRegisters(thread_info.pid, &regs)) {
+    printf("  gs                           = 0x%lx\n", regs.gs);
+    printf("  fs                           = 0x%lx\n", regs.fs);
+    printf("  es                           = 0x%lx\n", regs.es);
+    printf("  ds                           = 0x%lx\n", regs.ds);
+    printf("  rdi                          = 0x%lx\n", regs.rdi);
+    printf("  rsi                          = 0x%lx\n", regs.rsi);
+    printf("  rbx                          = 0x%lx\n", regs.rbx);
+    printf("  rdx                          = 0x%lx\n", regs.rdx);
+    printf("  rcx                          = 0x%lx\n", regs.rcx);
+    printf("  rax                          = 0x%lx\n", regs.rax);
+    printf("  rbp                          = 0x%lx\n", regs.rbp);
+    printf("  rip                          = 0x%lx\n", regs.rip);
+    printf("  cs                           = 0x%lx\n", regs.cs);
+    printf("  eflags                       = 0x%lx\n", regs.eflags);
+    printf("  rsp                          = 0x%lx\n", regs.rsp);
+    printf("  ss                           = 0x%lx\n", regs.ss);
+  } else {
+    fprintf(stderr, "ERROR: Failed to get general purpose registers\n");
+  }
+  memset(&fp_regs, 0, sizeof(fp_regs));
+  if (threads->GetFPRegisters(thread_info.pid, &fp_regs)) {
+    printf("\n Floating point registers:\n");
+    printf("  cwd                         = 0x%x\n", fp_regs.cwd);
+    printf("  swd                         = 0x%x\n", fp_regs.swd);
+    printf("  ftw                         = 0x%x\n", fp_regs.ftw);
+    printf("  fop                         = 0x%x\n", fp_regs.fop);
+    printf("  rip                         = 0x%lx\n", fp_regs.rip);
+    printf("  rdp                         = 0x%lx\n", fp_regs.rdp);
+    printf("  mxcsr                       = 0x%x\n", fp_regs.mxcsr);
+    printf("  mxcr_mask                   = 0x%x\n", fp_regs.mxcr_mask);
+    int st_space_size = sizeof(fp_regs.st_space) / sizeof(fp_regs.st_space[0]);
+    printf("  st_space[%2d]                 = 0x", st_space_size);
+    for (int i = 0; i < st_space_size; ++i)
+      printf("%02x", fp_regs.st_space[i]);
+    printf("\n");
+  } else {
+    fprintf(stderr, "ERROR: Failed to get floating-point registers\n");
+  }
+  if (threads->GetDebugRegisters(thread_info.pid, &dbg_regs)) {
+    printf("\n Debug registers:\n");
+    printf("  dr0                          = 0x%lx\n", dbg_regs.dr0);
+    printf("  dr1                          = 0x%lx\n", dbg_regs.dr1);
+    printf("  dr2                          = 0x%lx\n", dbg_regs.dr2);
+    printf("  dr3                          = 0x%lx\n", dbg_regs.dr3);
+    printf("  dr4                          = 0x%lx\n", dbg_regs.dr4);
+    printf("  dr5                          = 0x%lx\n", dbg_regs.dr5);
+    printf("  dr6                          = 0x%lx\n", dbg_regs.dr6);
+    printf("  dr7                          = 0x%lx\n", dbg_regs.dr7);
+    printf("\n");
+  }
+  if (regs.rsp != 0) {
+    // Print the stack content.
+    int size = 1024 * 2;
+    char *buf = new char[size];
+    size = threads->GetThreadStackDump(regs.rbp,
+                                       regs.rsp,
+                                      (void*)buf, size);
+    printf(" Stack content:                 = 0x");
+    size /= sizeof(unsigned long);
+    unsigned long *p_buf = (unsigned long *)(buf);
+    for (int i = 0; i < size; i += 1)
+      printf("%.8lx ", p_buf[i]);
+    delete []buf;
+    printf("\n");
+  }
+  return true;
+}
+#endif
 
 static int PrintAllThreads(void *argument) {
-  int pid = (int)argument;
+  long pid = reinterpret_cast<long>(argument);
 
   LinuxThread threads(pid);
   int total_thread = threads.SuspendAllThreads();
-  printf("There are %d threads in the process: %d\n", total_thread, pid);
+  printf("There are %d threads in the process: %ld\n", total_thread, pid);
   int total_module = threads.GetModuleCount();
-  printf("There are %d modules in the process: %d\n", total_module, pid);
+  printf("There are %d modules in the process: %ld\n", total_module, pid);
   CallbackParam<ModuleCallback> module_callback(ProcessOneModule, &threads);
   threads.ListModules(&module_callback);
   CallbackParam<ThreadCallback> thread_callback(ProcessOneThread, &threads);
@@ -207,14 +293,19 @@
 }
 
 int main(int argc, char **argv) {
-  int pid = getpid();
+  pid_t pid = getpid();
   printf("Main thread is %d\n", pid);
   CreateThreads(1);
   // Create stack for the process.
   char *stack = new char[1024 * 100];
   int cloned_pid = clone(PrintAllThreads, stack + 1024 * 100,
-                           CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_UNTRACED,
-                           (void*)getpid());
+                         CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_UNTRACED,
+                         (void*)pid);
+#if defined(__x86_64__)
+  uintptr_t frame_pointer;
+  asm volatile ("mov %%rbp, %0"
+                :"=r"(frame_pointer));
+#endif
   waitpid(cloned_pid, NULL, __WALL);
   should_exit = true;
   printf("Test finished.\n");
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.cc
@@ -34,23 +34,36 @@
 #include <signal.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <string.h>
 #include <unistd.h>
 #include <sys/utsname.h>
 #include <sys/wait.h>
 
 #include <cstdlib>
 #include <ctime>
-#include <string.h>
 
 #include "common/linux/file_id.h"
+#include "client/linux/handler/gettid.h"
 #include "client/linux/handler/linux_thread.h"
 #include "client/minidump_file_writer.h"
 #include "client/minidump_file_writer-inl.h"
 #include "google_breakpad/common/minidump_format.h"
 #include "client/linux/handler/minidump_generator.h"
+#include "client/linux/handler/cpu_context.h"
+#include "client/linux/handler/sigcontext.h"
 
 #ifndef CLONE_UNTRACED
 #define CLONE_UNTRACED 0x00800000
+#endif
+
+#ifdef __x86_64__
+// For x86_64, there is a good chance the libs used are compiled without
+// frame pointer, and breakpad will failed to get the stack information
+// for those threads running in libs without frame pointer perserved. So
+// we just ignore those threads, and only reports the crashing thread. The
+// crashing thread mostly crashes in our code which should be compiled with
+// frame pointer, so we can get the stack information.
+#define ONLY_CRAHSING_THREAD
 #endif
 
 // This unnamed namespace contains helper functions.
@@ -66,96 +79,42 @@
   void *version_context;
 
   // Pid of the thread who called WriteMinidumpToFile
-  int requester_pid;
+  pid_t requester_pid;
 
-  // The stack bottom of the thread which caused the dump.
-  // Mainly used to find the thread id of the crashed thread since signal
-  // handler may not be called in the thread who caused it.
-  uintptr_t crashed_stack_bottom;
-
-  // Pid of the crashing thread.
-  int crashed_pid;
+  // Tid of the crashing thread.
+  pid_t crashed_tid;
 
   // Signal number when crash happed. Can be 0 if this is a requested dump.
   int signo;
 
-  // The ebp of the signal handler frame.  Can be zero if this
+  // The frame pointer of the signal handler frame.  Can be zero if this
   // is a requested dump.
-  uintptr_t sighandler_ebp;
+  uintptr_t sighandler_frame_pointer;
 
-  // Signal context when crash happed. Can be NULL if this is a requested dump.
+  // Signal context when crash happed. Can be empty if this is a requested dump.
   // This is actually an out parameter, but it will be filled in at the start
   // of the writer thread.
-  struct sigcontext *sig_ctx;
+  SignalContext sig_ctx;
 
   // Used to get information about the threads.
   LinuxThread *thread_lister;
 };
 
-// Holding context information for the callback of finding the crashing thread.
-struct FindCrashThreadContext {
-  const LinuxThread *thread_lister;
-  uintptr_t crashing_stack_bottom;
-  int crashing_thread_pid;
-
-  FindCrashThreadContext() :
-    thread_lister(NULL),
-    crashing_stack_bottom(0UL),
-    crashing_thread_pid(-1) {
-  }
-};
-
-// Callback for list threads.
-// It will compare the stack bottom of the provided thread with the stack
-// bottom of the crashed thread, it they are eqaul, this is thread is the one
-// who crashed.
-bool IsThreadCrashedCallback(const ThreadInfo &thread_info, void *context) {
-  FindCrashThreadContext *crashing_context =
-    static_cast<FindCrashThreadContext *>(context);
-  const LinuxThread *thread_lister = crashing_context->thread_lister;
-  struct user_regs_struct regs;
-  if (thread_lister->GetRegisters(thread_info.pid, &regs)) {
-    uintptr_t last_ebp = regs.ebp;
-    uintptr_t stack_bottom = thread_lister->GetThreadStackBottom(last_ebp);
-    if (stack_bottom > last_ebp &&
-        stack_bottom == crashing_context->crashing_stack_bottom) {
-      // Got it. Stop iteration.
-      crashing_context->crashing_thread_pid = thread_info.pid;
-      return false;
-    }
-  }
-  return true;
-}
-
-// Find the crashing thread id.
-// This is done based on stack bottom comparing.
-int FindCrashingThread(uintptr_t crashing_stack_bottom,
-                       int requester_pid,
-                       const LinuxThread *thread_lister) {
-  FindCrashThreadContext context;
-  context.thread_lister = thread_lister;
-  context.crashing_stack_bottom = crashing_stack_bottom;
-  CallbackParam<ThreadCallback> callback_param(IsThreadCrashedCallback,
-                                               &context);
-  thread_lister->ListThreads(&callback_param);
-  return context.crashing_thread_pid;
-}
-
 // Write the thread stack info minidump.
-bool WriteThreadStack(uintptr_t last_ebp,
-                      uintptr_t last_esp,
+bool WriteThreadStack(uintptr_t frame_pointer,
+                      uintptr_t stack_pointer,
                       const LinuxThread *thread_lister,
                       UntypedMDRVA *memory,
                       MDMemoryDescriptor *loc) {
   // Maximum stack size for a thread.
-  uintptr_t stack_bottom = thread_lister->GetThreadStackBottom(last_ebp);
-  if (stack_bottom > last_esp) {
-    int size = stack_bottom - last_esp;
+  uintptr_t stack_bottom = thread_lister->GetThreadStackBottom(frame_pointer);
+  if (stack_bottom > stack_pointer) {
+    size_t size = stack_bottom - stack_pointer;
     if (size > 0) {
       if (!memory->Allocate(size))
         return false;
-      memory->Copy(reinterpret_cast<void*>(last_esp), size);
-      loc->start_of_memory_range = 0 | last_esp;
+      memory->Copy(reinterpret_cast<void*>(stack_pointer), size);
+      loc->start_of_memory_range = stack_pointer;
       loc->memory = memory->location();
     }
     return true;
@@ -164,104 +123,27 @@
 }
 
 // Write CPU context based on signal context.
-bool WriteContext(MDRawContextX86 *context, const struct sigcontext *sig_ctx,
+bool WriteContext(RawContext *context,
+                  const SignalContext &sig_ctx,
                   const DebugRegs *debug_regs) {
-  assert(sig_ctx != NULL);
-  context->context_flags = MD_CONTEXT_X86_FULL;
-  context->gs = sig_ctx->gs;
-  context->fs = sig_ctx->fs;
-  context->es = sig_ctx->es;
-  context->ds = sig_ctx->ds;
-  context->cs = sig_ctx->cs;
-  context->ss = sig_ctx->ss;
-  context->edi = sig_ctx->edi;
-  context->esi = sig_ctx->esi;
-  context->ebp = sig_ctx->ebp;
-  context->esp = sig_ctx->esp;
-  context->ebx = sig_ctx->ebx;
-  context->edx = sig_ctx->edx;
-  context->ecx = sig_ctx->ecx;
-  context->eax = sig_ctx->eax;
-  context->eip = sig_ctx->eip;
-  context->eflags = sig_ctx->eflags;
-  if (sig_ctx->fpstate != NULL) {
-    context->context_flags = MD_CONTEXT_X86_FULL |
-      MD_CONTEXT_X86_FLOATING_POINT;
-    context->float_save.control_word = sig_ctx->fpstate->cw;
-    context->float_save.status_word = sig_ctx->fpstate->sw;
-    context->float_save.tag_word = sig_ctx->fpstate->tag;
-    context->float_save.error_offset = sig_ctx->fpstate->ipoff;
-    context->float_save.error_selector = sig_ctx->fpstate->cssel;
-    context->float_save.data_offset = sig_ctx->fpstate->dataoff;
-    context->float_save.data_selector = sig_ctx->fpstate->datasel;
-    memcpy(context->float_save.register_area, sig_ctx->fpstate->_st,
-           sizeof(context->float_save.register_area));
-  }
+  assert(!sig_ctx.IsEmpty());
+  if (!sig_ctx.CopyTo(context))
+    return false;
 
   if (debug_regs != NULL) {
-    context->context_flags |= MD_CONTEXT_X86_DEBUG_REGISTERS;
-    context->dr0 = debug_regs->dr0;
-    context->dr1 = debug_regs->dr1;
-    context->dr2 = debug_regs->dr2;
-    context->dr3 = debug_regs->dr3;
-    context->dr6 = debug_regs->dr6;
-    context->dr7 = debug_regs->dr7;
+    CPUContext reg(NULL, NULL, debug_regs);
+    return reg.CopyTo(context);
   }
   return true;
 }
 
 // Write CPU context based on provided registers.
-bool WriteContext(MDRawContextX86 *context,
-                  const struct user_regs_struct *regs,
-                  const struct user_fpregs_struct *fp_regs,
-                  const DebugRegs *dbg_regs) {
-  if (!context || !regs)
+bool WriteContext(RawContext *context,
+                  const CPUContext *cpu_context) {
+  if (!context || !cpu_context)
     return false;
 
-  context->context_flags = MD_CONTEXT_X86_FULL;
-
-  context->cs = regs->xcs;
-  context->ds = regs->xds;
-  context->es = regs->xes;
-  context->fs = regs->xfs;
-  context->gs = regs->xgs;
-  context->ss = regs->xss;
-  context->edi = regs->edi;
-  context->esi = regs->esi;
-  context->ebx = regs->ebx;
-  context->edx = regs->edx;
-  context->ecx = regs->ecx;
-  context->eax = regs->eax;
-  context->ebp = regs->ebp;
-  context->eip = regs->eip;
-  context->esp = regs->esp;
-  context->eflags = regs->eflags;
-
-  if (dbg_regs != NULL) {
-    context->context_flags |= MD_CONTEXT_X86_DEBUG_REGISTERS;
-    context->dr0 = dbg_regs->dr0;
-    context->dr1 = dbg_regs->dr1;
-    context->dr2 = dbg_regs->dr2;
-    context->dr3 = dbg_regs->dr3;
-    context->dr6 = dbg_regs->dr6;
-    context->dr7 = dbg_regs->dr7;
-  }
-
-  if (fp_regs != NULL) {
-    context->context_flags |= MD_CONTEXT_X86_FLOATING_POINT;
-    context->float_save.control_word = fp_regs->cwd;
-    context->float_save.status_word = fp_regs->swd;
-    context->float_save.tag_word = fp_regs->twd;
-    context->float_save.error_offset = fp_regs->fip;
-    context->float_save.error_selector = fp_regs->fcs;
-    context->float_save.data_offset = fp_regs->foo;
-    context->float_save.data_selector = fp_regs->fos;
-    context->float_save.data_selector = fp_regs->fos;
-
-    memcpy(context->float_save.register_area, fp_regs->st_space,
-           sizeof(context->float_save.register_area));
-  }
-  return true;
+  return cpu_context->CopyTo(context);
 }
 
 // Write information about a crashed thread.
@@ -270,26 +152,26 @@
 // won't figure out the whole call stack for this. So we write the stack at the
 // time of the crash into the minidump file, not the current stack.
 bool WriteCrashedThreadStream(MinidumpFileWriter *minidump_writer,
-                       const WriterArgument *writer_args,
-                       const ThreadInfo &thread_info,
-                       MDRawThread *thread) {
-  assert(writer_args->sig_ctx != NULL);
+                              const WriterArgument *writer_args,
+                              const ThreadInfo &thread_info,
+                              MDRawThread *thread) {
+  assert(!writer_args->sig_ctx.IsEmpty());
 
   thread->thread_id = thread_info.pid;
 
   UntypedMDRVA memory(minidump_writer);
-  if (!WriteThreadStack(writer_args->sig_ctx->ebp,
-                        writer_args->sig_ctx->esp,
+  if (!WriteThreadStack(writer_args->sig_ctx.GetFramePointer(),
+                        writer_args->sig_ctx.GetStackPointer(),
                         writer_args->thread_lister,
                         &memory,
                         &thread->stack))
     return false;
 
-  TypedMDRVA<MDRawContextX86> context(minidump_writer);
+  TypedMDRVA<RawContext> context(minidump_writer);
   if (!context.Allocate())
     return false;
   thread->thread_context = context.location();
-  memset(context.get(), 0, sizeof(MDRawContextX86));
+  memset(context.get(), 0, sizeof(RawContext));
   return WriteContext(context.get(), writer_args->sig_ctx, NULL);
 }
 
@@ -301,35 +183,35 @@
                        MDRawThread *thread) {
   thread->thread_id = thread_info.pid;
 
-  struct user_regs_struct regs;
-  memset(&regs, 0, sizeof(regs));
-  if (!thread_lister->GetRegisters(thread_info.pid, &regs)) {
-    perror(NULL);
+  struct user_regs_struct user_regs;
+  memset(&user_regs, 0, sizeof(user_regs));
+  if (!thread_lister->GetRegisters(thread_info.pid, &user_regs)) {
     return false;
   }
 
-  UntypedMDRVA memory(minidump_writer);
-  if (!WriteThreadStack(regs.ebp,
-                   regs.esp,
-                   thread_lister,
-                   &memory,
-                   &thread->stack))
-    return false;
-
   struct user_fpregs_struct fp_regs;
-  DebugRegs dbg_regs;
+  DebugRegs debug_regs;
   memset(&fp_regs, 0, sizeof(fp_regs));
   // Get all the registers.
   thread_lister->GetFPRegisters(thread_info.pid, &fp_regs);
-  thread_lister->GetDebugRegisters(thread_info.pid, &dbg_regs);
+  thread_lister->GetDebugRegisters(thread_info.pid, &debug_regs);
 
-  // Write context
-  TypedMDRVA<MDRawContextX86> context(minidump_writer);
+  CPUContext cpu_context(&user_regs, &fp_regs, &debug_regs);
+    // Write context
+  TypedMDRVA<RawContext> context(minidump_writer);
   if (!context.Allocate())
     return false;
   thread->thread_context = context.location();
-  memset(context.get(), 0, sizeof(MDRawContextX86));
-  return WriteContext(context.get(), &regs, &fp_regs, &dbg_regs);
+  memset(context.get(), 0, sizeof(RawContext));
+  if (!WriteContext(context.get(), &cpu_context))
+    return false;
+
+  UntypedMDRVA memory(minidump_writer);
+  return WriteThreadStack(cpu_context.GetFramePointer(),
+                          cpu_context.GetStackPointer(),
+                          thread_lister,
+                          &memory,
+                          &thread->stack);
 }
 
 bool WriteCPUInformation(MDRawSystemInfo *sys_info) {
@@ -400,12 +282,15 @@
   sys_info->processor_architecture = MD_CPU_ARCHITECTURE_UNKNOWN;
   struct utsname uts;
   if (uname(&uts) == 0) {
-    // Match i*86 and x86* as X86 architecture.
-    if ((strstr(uts.machine, "x86") == uts.machine) ||
-        (strlen(uts.machine) == 4 &&
-         uts.machine[0] == 'i' &&
-         uts.machine[2] == '8' &&
-         uts.machine[3] == '6')) {
+    // Match x86_64 architecture.
+    if (strstr(uts.machine, "x86_64") == uts.machine) {
+      sys_info->processor_architecture = MD_CPU_ARCHITECTURE_AMD64;
+    } else if ((strstr(uts.machine, "x86") == uts.machine) ||
+               (strlen(uts.machine) == 4 &&
+                uts.machine[0] == 'i' &&
+                uts.machine[2] == '8' &&
+                uts.machine[3] == '6')) {
+      // Match i*86 and x86* as X86 architecture.
       sys_info->processor_architecture = MD_CPU_ARCHITECTURE_X86;
       if (vendor_id[0] != '\0')
         memcpy(sys_info->cpu.x86_cpu_info.vendor_id, vendor_id,
@@ -465,17 +350,22 @@
 
 // Callback run for writing threads information in the process.
 bool ThreadInfomationCallback(const ThreadInfo &thread_info,
-                                 void *context) {
+                              void *context) {
   ThreadInfoCallbackCtx *callback_context =
     static_cast<ThreadInfoCallbackCtx *>(context);
   bool success = true;
   MDRawThread thread;
   memset(&thread, 0, sizeof(MDRawThread));
-  if (thread_info.pid != callback_context->writer_args->crashed_pid ||
-      callback_context->writer_args->sig_ctx == NULL) {
+  if (thread_info.pid != callback_context->writer_args->crashed_tid ||
+      callback_context->writer_args->sig_ctx.IsEmpty()) {
+#ifdef ONLY_CRAHSING_THREAD
+    // Ignore those threads that works normally.
+    return true;
+#else
     success = WriteThreadStream(callback_context->minidump_writer,
                            callback_context->writer_args->thread_lister,
                            thread_info, &thread);
+#endif
   } else {
     success = WriteCrashedThreadStream(callback_context->minidump_writer,
                                        callback_context->writer_args,
@@ -498,6 +388,12 @@
   int thread_count = thread_lister->GetThreadCount();
   if (thread_count < 0)
     return false;
+
+#ifdef ONLY_CRAHSING_THREAD
+  // Only count the crashing thread.
+  thread_count = 1;
+#endif
+
   TypedMDRVA<MDRawThreadList> list(minidump_writer);
   if (!list.AllocateObjectAndArray(thread_count, sizeof(MDRawThread)))
     return false;
@@ -512,8 +408,8 @@
   context.thread_index = 0;
   CallbackParam<ThreadCallback> callback_param(ThreadInfomationCallback,
                                                &context);
-  int written = thread_lister->ListThreads(&callback_param);
-  return written == thread_count;
+  thread_lister->ListThreads(&callback_param);
+  return true;
 }
 
 bool WriteCVRecord(MinidumpFileWriter *minidump_writer,
@@ -572,7 +468,7 @@
 };
 
 bool ModuleInfoCallback(const ModuleInfo &module_info,
-                           void *context) {
+                        void *context) {
   ModuleInfoCallbackCtx *callback_context =
     static_cast<ModuleInfoCallbackCtx *>(context);
   // Skip those modules without name, or those that are not modules.
@@ -632,10 +528,10 @@
 }
 
 bool WriteExceptionStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           MDRawDirectory *dir) {
+                          const WriterArgument *writer_args,
+                          MDRawDirectory *dir) {
   // This happenes when this is not a crash, but a requested dump.
-  if (writer_args->sig_ctx == NULL)
+  if (writer_args->sig_ctx.IsEmpty())
     return false;
 
   TypedMDRVA<MDRawExceptionStream> exception(minidump_writer);
@@ -644,28 +540,28 @@
 
   dir->stream_type = MD_EXCEPTION_STREAM;
   dir->location = exception.location();
-  exception.get()->thread_id = writer_args->crashed_pid;
+  exception.get()->thread_id = writer_args->crashed_tid;
   exception.get()->exception_record.exception_code = writer_args->signo;
   exception.get()->exception_record.exception_flags = 0;
-  if (writer_args->sig_ctx != NULL) {
+  if (!writer_args->sig_ctx.IsEmpty()) {
     exception.get()->exception_record.exception_address =
-      writer_args->sig_ctx->eip;
+      writer_args->sig_ctx.GetIP();
   } else {
     return true;
   }
 
   // Write context of the exception.
-  TypedMDRVA<MDRawContextX86> context(minidump_writer);
+  TypedMDRVA<RawContext> context(minidump_writer);
   if (!context.Allocate())
     return false;
   exception.get()->thread_context = context.location();
-  memset(context.get(), 0, sizeof(MDRawContextX86));
+  memset(context.get(), 0, sizeof(RawContext));
   return WriteContext(context.get(), writer_args->sig_ctx, NULL);
 }
 
 bool WriteMiscInfoStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           MDRawDirectory *dir) {
+                         const WriterArgument *writer_args,
+                         MDRawDirectory *dir) {
   TypedMDRVA<MDRawMiscInfo> info(minidump_writer);
   if (!info.Allocate())
     return false;
@@ -680,8 +576,8 @@
 }
 
 bool WriteBreakpadInfoStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           MDRawDirectory *dir) {
+                             const WriterArgument *writer_args,
+                             MDRawDirectory *dir) {
   TypedMDRVA<MDRawBreakpadInfo> info(minidump_writer);
   if (!info.Allocate())
     return false;
@@ -721,19 +617,11 @@
   if (!writer_args->thread_lister->SuspendAllThreads())
     return -1;
 
-  if (writer_args->sighandler_ebp != 0 &&
-      writer_args->thread_lister->FindSigContext(writer_args->sighandler_ebp,
-                                                 &writer_args->sig_ctx)) {
-    writer_args->crashed_stack_bottom =
-      writer_args->thread_lister->GetThreadStackBottom(
-                                             writer_args->sig_ctx->ebp);
-    int crashed_pid =  FindCrashingThread(writer_args->crashed_stack_bottom,
-                                          writer_args->requester_pid,
-                                          writer_args->thread_lister);
-    if (crashed_pid > 0)
-      writer_args->crashed_pid = crashed_pid;
-  }
-
+  if (writer_args->sighandler_frame_pointer != 0 &&
+      !writer_args->thread_lister->FindSigContext(
+          writer_args->sighandler_frame_pointer,
+          &writer_args->sig_ctx))
+    return -1;
 
   MinidumpFileWriter *minidump_writer = writer_args->minidump_writer;
   TypedMDRVA<MDRawHeader> header(minidump_writer);
@@ -777,14 +665,16 @@
   stack_.reset(new char[kStackSize]);
 }
 
-bool MinidumpGenerator::WriteMinidumpToFile(const char *file_pathname,
-                                   int signo,
-                                   uintptr_t sighandler_ebp,
-                                   struct sigcontext **sig_ctx) const {
+bool MinidumpGenerator::WriteMinidumpToFile(
+    const char *file_pathname,
+    int signo,
+    uintptr_t sighandler_frame_pointer,
+    SignalContext *raw_sig_ctx) const {
+
   assert(file_pathname != NULL);
-  assert(stack_ != NULL);
+  assert(stack_.get() != NULL);
 
-  if (stack_ == NULL || file_pathname == NULL)
+  if (file_pathname == NULL)
     return false;
 
   MinidumpFileWriter minidump_writer;
@@ -795,17 +685,22 @@
     argument.thread_lister = &thread_lister;
     argument.minidump_writer = &minidump_writer;
     argument.requester_pid = getpid();
-    argument.crashed_pid = getpid();
+    // Signal we are catching are synchronous signals, and the execution
+    // of signal handlers should be on the thread which is causing the signal.
+    argument.crashed_tid = gettid();
     argument.signo = signo;
-    argument.sighandler_ebp = sighandler_ebp;
-    argument.sig_ctx = NULL;
+    argument.sighandler_frame_pointer = sighandler_frame_pointer;
+#ifdef __x86_64__
+    if (raw_sig_ctx)
+      argument.sig_ctx.SetSignalContext(raw_sig_ctx->GetRawContext());
+#endif
 
-    int cloned_pid = clone(Write, stack_.get() + kStackSize,
+    pid_t cloned_pid = clone(Write, stack_.get() + kStackSize,
                            CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_UNTRACED,
                            (void*)&argument);
     waitpid(cloned_pid, NULL, __WALL);
-    if (sig_ctx != NULL)
-        *sig_ctx = argument.sig_ctx;
+    if (raw_sig_ctx != NULL)
+        raw_sig_ctx->SetSignalContext(argument.sig_ctx.GetRawContext());
     return true;
   }
 
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.h
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.h
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_generator.h
@@ -37,9 +37,9 @@
 #include "google_breakpad/common/breakpad_types.h"
 #include "processor/scoped_ptr.h"
 
-struct sigcontext;
+namespace google_breakpad {
 
-namespace google_breakpad {
+struct SignalContext;
 
 //
 // MinidumpGenerator
@@ -57,7 +57,7 @@
    bool WriteMinidumpToFile(const char *file_pathname,
                             int signo,
                             uintptr_t sighandler_ebp,
-                            struct sigcontext **sig_ctx) const;
+                            SignalContext *raw_sig_ctx) const;
   private:
    // Allocate memory for stack.
    void AllocateStack();
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_test.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_test.cc
--- a/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_test.cc
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/minidump_test.cc
@@ -77,7 +77,9 @@
 int main(int argc, char *argv[]) {
   CreateThread(10);
   google_breakpad::MinidumpGenerator mg;
-  if (mg.WriteMinidumpToFile("minidump_test.out", -1, 0, NULL))
+  const char *out = "minidump_test.out";
+  unlink(out);
+  if (mg.WriteMinidumpToFile(out, -1, 0, NULL))
     printf("Succeeded written minidump\n");
   else
     printf("Failed to write minidump\n");
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.cc b/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.cc
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.cc
@@ -0,0 +1,170 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+#include <cassert>
+#include <signal.h>
+#include <cstring>
+#include <sys/types.h>
+#include <sys/user.h>
+
+#include "client/linux/handler/sigcontext.h"
+
+namespace google_breakpad {
+
+SignalContext::SignalContext() : sig_ctx_(NULL) {
+}
+
+void SignalContext::SetSignalContext(const struct sigcontext *sig_ctx) {
+  assert(sig_ctx);
+  sig_ctx_ = sig_ctx;
+}
+
+void SignalContext::SetUContext(const ucontext_t *ucontext) {
+  assert(ucontext);
+  // mcontex_t and sigcontext has the same definition.
+  // We just do a convertion here.
+  sig_ctx_ = reinterpret_cast<const sigcontext*>(&ucontext->uc_mcontext);
+}
+
+const struct sigcontext *SignalContext::GetRawContext() const {
+  return sig_ctx_;
+}
+
+uintptr_t SignalContext::GetIP() const {
+  assert(sig_ctx_);
+#ifdef __i386__
+  return sig_ctx_->eip;
+#elif defined(__x86_64__)
+  return sig_ctx_->rip;
+#else
+  assert(!"only work on i386 and x86_64!");
+#endif
+}
+
+uintptr_t SignalContext::GetFramePointer() const {
+  assert(sig_ctx_);
+#ifdef __i386__
+  return sig_ctx_->ebp;
+#elif defined(__x86_64__)
+  return sig_ctx_->rbp;
+#else
+  assert(!"only work on i386 and x86_64!");
+#endif
+}
+
+uintptr_t SignalContext::GetStackPointer() const {
+  assert(sig_ctx_);
+#ifdef __i386__
+  return sig_ctx_->esp;
+#elif defined(__x86_64__)
+  return sig_ctx_->rsp;
+#else
+  assert(!"only work on i386 and x86_64!");
+#endif
+}
+
+bool SignalContext::IsEmpty() const {
+  return sig_ctx_ == NULL;
+}
+
+#ifdef __i386__
+bool SignalContext::CopyTo(RawContext *context) const {
+  context->context_flags = MD_CONTEXT_X86_FULL;
+  context->gs = sig_ctx_->gs;
+  context->fs = sig_ctx_->fs;
+  context->es = sig_ctx_->es;
+  context->ds = sig_ctx_->ds;
+  context->cs = sig_ctx_->cs;
+  context->ss = sig_ctx_->ss;
+  context->edi = sig_ctx_->edi;
+  context->esi = sig_ctx_->esi;
+  context->ebp = sig_ctx_->ebp;
+  context->esp = sig_ctx_->esp;
+  context->ebx = sig_ctx_->ebx;
+  context->edx = sig_ctx_->edx;
+  context->ecx = sig_ctx_->ecx;
+  context->eax = sig_ctx_->eax;
+  context->eip = sig_ctx_->eip;
+  context->eflags = sig_ctx_->eflags;
+  if (sig_ctx_->fpstate != NULL) {
+    context->context_flags = MD_CONTEXT_X86_FULL |
+      MD_CONTEXT_X86_FLOATING_POINT;
+    context->float_save.control_word = sig_ctx_->fpstate->cw;
+    context->float_save.status_word = sig_ctx_->fpstate->sw;
+    context->float_save.tag_word = sig_ctx_->fpstate->tag;
+    context->float_save.error_offset = sig_ctx_->fpstate->ipoff;
+    context->float_save.error_selector = sig_ctx_->fpstate->cssel;
+    context->float_save.data_offset = sig_ctx_->fpstate->dataoff;
+    context->float_save.data_selector = sig_ctx_->fpstate->datasel;
+    memcpy(context->float_save.register_area, sig_ctx_->fpstate->_st,
+           sizeof(context->float_save.register_area));
+  }
+  return true;
+}
+#endif
+
+#ifdef __x86_64__
+bool SignalContext::CopyTo(RawContext *context) const {
+  context->context_flags = MD_CONTEXT_AMD64_CONTROL |
+                           MD_CONTEXT_AMD64_INTEGER |
+                           MD_CONTEXT_AMD64_SEGMENTS;
+  context->cs = sig_ctx_->cs;
+    context->fs = sig_ctx_->fs;
+  context->gs = sig_ctx_->gs;
+  context->eflags = sig_ctx_->eflags;
+  context->rip = sig_ctx_->rip;
+  context->rax = sig_ctx_->rax;
+  context->rbx = sig_ctx_->rbx;
+  context->rcx = sig_ctx_->rcx;
+  context->rdx = sig_ctx_->rdx;
+  context->rsp = sig_ctx_->rsp;
+  context->rbp = sig_ctx_->rbp;
+  context->rsi = sig_ctx_->rsi;
+  context->rdi = sig_ctx_->rdi;
+  context->r8 = sig_ctx_->r8;
+  context->r9 = sig_ctx_->r9;
+  context->r10 = sig_ctx_->r10;
+  context->r11 = sig_ctx_->r11;
+  context->r12 = sig_ctx_->r12;
+  context->r13 = sig_ctx_->r13;
+  context->r14 = sig_ctx_->r14;
+  context->r15 = sig_ctx_->r15;
+
+  // The following registers are not set by kernel
+  // when setting up signal handler frame.
+  context->ds = 0;
+  context->es = 0;
+  context->ss = 0;
+  return true;
+}
+#endif
+
+}  // namespace google_breakpad
diff --git a/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.h b/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.h
new file mode 100644
--- /dev/null
+++ b/libs/3rdparty/googlebreakpad/src/client/linux/handler/sigcontext.h
@@ -0,0 +1,87 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_HANDLER_SIGCONTEXT_H__
+#define CLIENT_LINUX_HANDLER_SIGCONTEXT_H__
+
+#include <stdint.h>
+#include <sys/ucontext.h>
+
+#include "google_breakpad/common/minidump_format.h"
+#include "client/linux/handler/cpu_context.h"
+
+// Forward declaration of signal context.
+struct sigcontext;
+
+namespace google_breakpad {
+
+//
+// SignalContext
+//
+// Wrapper class around the raw signal context which depends on CPU type (i386
+// and x86_64).
+// It provides CPU independent way of accessing common fields in the signal
+// context.
+class SignalContext {
+  public:
+   SignalContext();
+
+   // Set the raw signal context.
+   void SetSignalContext(const struct sigcontext *sig_ctx);
+
+   // Set raw signal context from ucontext_t.
+   void SetUContext(const ucontext_t *ucontext);
+
+   // Get the raw signal context.
+   const struct sigcontext *GetRawContext() const;
+
+   // Get the current instruction address.
+   uintptr_t GetIP() const;
+
+   // Get the frame pointer.
+   uintptr_t GetFramePointer() const;
+
+   // Get the stack pointer.
+   uintptr_t GetStackPointer() const;
+
+   // Check if current signal context is empty or not.
+   bool IsEmpty() const;
+
+   // Fill the context section of minidump file.
+   bool CopyTo(RawContext *context) const;
+
+  private:
+   const struct sigcontext *sig_ctx_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_HANDLER_SIGCONTEXT_H__
diff --git a/libs/3rdparty/googlebreakpad/src/common/linux/dump_symbols.cc b/libs/3rdparty/googlebreakpad/src/common/linux/dump_symbols.cc
--- a/libs/3rdparty/googlebreakpad/src/common/linux/dump_symbols.cc
+++ b/libs/3rdparty/googlebreakpad/src/common/linux/dump_symbols.cc
@@ -138,7 +138,7 @@
 // Fix offset into virtual address by adding the mapped base into offsets.
 // Make life easier when want to find something by offset.
 static void FixAddress(void *obj_base) {
-  ElfW(Word) base = reinterpret_cast<ElfW(Word)>(obj_base);
+  ElfW(Xword) base = reinterpret_cast<ElfW(Xword)>(obj_base);
   ElfW(Ehdr) *elf_header = static_cast<ElfW(Ehdr) *>(obj_base);
   elf_header->e_phoff += base;
   elf_header->e_shoff += base;
