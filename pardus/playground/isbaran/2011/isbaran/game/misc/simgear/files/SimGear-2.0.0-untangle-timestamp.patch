diff -uNrp SimGear-2.0.0.orig/simgear/timing/timestamp.cxx SimGear-2.0.0/simgear/timing/timestamp.cxx
--- SimGear-2.0.0.orig/simgear/timing/timestamp.cxx	2010-02-17 16:39:22.000000000 +0100
+++ SimGear-2.0.0/simgear/timing/timestamp.cxx	2010-02-26 23:09:15.826492455 +0100
@@ -24,83 +24,6 @@
 // $Id$
 
 
-#ifdef HAVE_CONFIG_H
-#  include <simgear_config.h>
-#endif
-
-#include <simgear/compiler.h>
-
-#include <ctime>
-
-#ifdef HAVE_SYS_TIMEB_H
-#  include <sys/timeb.h> // for ftime() and struct timeb
-#endif
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>    // for gettimeofday() and the _POSIX_TIMERS define
-#endif
-#ifdef HAVE_SYS_TIME_H
-#  include <sys/time.h>  // for get/setitimer, gettimeofday, struct timeval
-#endif
-
-#if defined(_POSIX_TIMERS) && (0 < _POSIX_TIMERS)
-#  include <time.h>
-#  include <errno.h>
-#endif
-
-#ifdef WIN32
-#  include <windows.h>
-#  if defined( __CYGWIN__ ) || defined( __CYGWIN32__ )
-#    define NEAR /* */
-#    define FAR  /* */
-#  endif
-#  include <mmsystem.h>
-#endif
-
 #include "timestamp.hxx"
 
-void SGTimeStamp::stamp() {
-#ifdef _WIN32
-    unsigned int t;
-    t = timeGetTime();
-    _sec = t / 1000;
-    _nsec = ( t - ( _sec * 1000 ) ) * 1000 * 1000;
-#elif defined(_POSIX_TIMERS) && (0 < _POSIX_TIMERS)
-    struct timespec ts;
-#if defined(_POSIX_MONOTONIC_CLOCK)
-    static clockid_t clockid = CLOCK_MONOTONIC;
-    static bool firstTime = true;
-    if (firstTime) {
-        firstTime = false;
-        // For the first time test if the monotonic clock is available.
-        // If so use this if not use the realtime clock.
-        if (-1 == clock_gettime(clockid, &ts) && errno == EINVAL)
-            clockid = CLOCK_REALTIME;
-    }
-    clock_gettime(clockid, &ts);
-#else
-    clock_gettime(CLOCK_REALTIME, &ts);
-#endif
-    _sec = ts.tv_sec;
-    _nsec = ts.tv_nsec;
-#elif defined( HAVE_GETTIMEOFDAY )
-    struct timeval current;
-    struct timezone tz;
-    // sg_timestamp currtime;
-    gettimeofday(&current, &tz);
-    _sec = current.tv_sec;
-    _nsec = current.tv_usec * 1000;
-#elif defined( HAVE_GETLOCALTIME )
-    SYSTEMTIME current;
-    GetLocalTime(&current);
-    _sec = current.wSecond;
-    _nsec = current.wMilliseconds * 1000 * 1000;
-#elif defined( HAVE_FTIME )
-    struct timeb current;
-    ftime(&current);
-    _sec = current.time;
-    _nsec = current.millitm * 1000 * 1000;
-#else
-# error Port me
-#endif
-}
-
+// empty, all inline class now.
diff -uNrp SimGear-2.0.0.orig/simgear/timing/timestamp.hxx SimGear-2.0.0/simgear/timing/timestamp.hxx
--- SimGear-2.0.0.orig/simgear/timing/timestamp.hxx	2010-02-17 16:39:22.000000000 +0100
+++ SimGear-2.0.0/simgear/timing/timestamp.hxx	2010-02-26 23:09:23.070286905 +0100
@@ -32,12 +32,42 @@
 # error This library requires C++
 #endif
 
+#ifdef HAVE_CONFIG_H
+#  include <simgear_config.h>
+#endif
+
 #include <iosfwd>
 #include <iomanip>
 #include <sstream>
 #include <simgear/compiler.h>
 #include <simgear/math/SGCMath.hxx>
 
+#include <ctime>
+
+#ifdef HAVE_SYS_TIMEB_H
+#  include <sys/timeb.h> // for ftime() and struct timeb
+#endif
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>    // for gettimeofday() and the _POSIX_TIMERS define
+#endif
+#ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>  // for get/setitimer, gettimeofday, struct timeval
+#endif
+
+#if defined(_POSIX_TIMERS) && (0 < _POSIX_TIMERS)
+#  include <time.h>
+#  include <errno.h>
+#endif
+
+#ifdef WIN32
+#  include <windows.h>
+#  if defined( __CYGWIN__ ) || defined( __CYGWIN32__ )
+#    define NEAR /* */
+#    define FAR  /* */
+#  endif
+#  include <mmsystem.h>
+#endif
+
 /**
  * The SGTimeStamp class allows you to mark and compare time stamps
  * with nanosecond accuracy (if your system has support for this
@@ -76,7 +106,51 @@ public:
 //     { setTime(sec); }
 
     /** Update stored time to current time (seconds and nanoseconds) */
-    void stamp();
+    void stamp() {
+#ifdef _WIN32
+        unsigned int t;
+        t = timeGetTime();
+        _sec = t / 1000;
+        _nsec = ( t - ( _sec * 1000 ) ) * 1000 * 1000;
+#elif defined(_POSIX_TIMERS) && (0 < _POSIX_TIMERS)
+        struct timespec ts;
+#if defined(_POSIX_MONOTONIC_CLOCK)
+        static clockid_t clockid = CLOCK_MONOTONIC;
+        static bool firstTime = true;
+        if (firstTime) {
+            firstTime = false;
+            // For the first time test if the monotonic clock is available.
+            // If so use this if not use the realtime clock.
+            if (-1 == clock_gettime(clockid, &ts) && errno == EINVAL)
+                clockid = CLOCK_REALTIME;
+        }
+        clock_gettime(clockid, &ts);
+#else
+        clock_gettime(CLOCK_REALTIME, &ts);
+#endif
+        _sec = ts.tv_sec;
+        _nsec = ts.tv_nsec;
+#elif defined( HAVE_GETTIMEOFDAY )
+        struct timeval current;
+        struct timezone tz;
+        // sg_timestamp currtime;
+        gettimeofday(&current, &tz);
+        _sec = current.tv_sec;
+        _nsec = current.tv_usec * 1000;
+#elif defined( HAVE_GETLOCALTIME )
+        SYSTEMTIME current;
+        GetLocalTime(&current);
+        _sec = current.wSecond;
+        _nsec = current.wMilliseconds * 1000 * 1000;
+#elif defined( HAVE_FTIME )
+        struct timeb current;
+        ftime(&current);
+        _sec = current.time;
+        _nsec = current.millitm * 1000 * 1000;
+#else
+# error Port me
+#endif
+    }
 
     /** Set the time from a double value */
     void setTime(const double& seconds)
