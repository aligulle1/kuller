--- vdr-1.6.0.orig/debian/vdr-dev.docs
+++ vdr-1.6.0/debian/vdr-dev.docs
@@ -0,0 +1,4 @@
+README*
+CONTRIBUTORS
+PLUGINS.html
+debian/patchinfo
--- vdr-1.6.0.orig/debian/vdr.manpages
+++ vdr-1.6.0/debian/vdr.manpages
@@ -0,0 +1,5 @@
+vdr.1
+vdr.5
+
+debian/runvdr.8
+debian/svdrpsend.1
--- vdr-1.6.0.orig/debian/debugvdr
+++ vdr-1.6.0/debian/debugvdr
@@ -0,0 +1,79 @@
+#!/bin/bash
+
+# We need bash here, because of the *-loader.sh scripts containing bashisms!
+
+## NAME
+##   debugvdr - Runs the VDR debugging binary with the GDB debugger.
+##
+## SYNOPSIS
+##   debugvdr [-r]
+## 
+## DESCRIPTION
+##   debugvdr will start VDR with the GDB debugger with the same command line
+##   arguments as the VDR daemon. This means, all installed plugins will be
+##   loaded. If VDR is still running, it will be automatically stopped before
+##   starting the debugging version.
+## 
+## OPTIONS
+##   -r Start VDR with the GDB Server on port 1000 for remote debugging.
+## 
+## SEE ALSO
+##   vdr(1), gdb(1)
+## 
+## AUTHOR
+##   This manual page was written by Tobias Grimm <tg@e-tobi.net>
+## 
+### txt2man -s 1 -t DEBUGVDR -v "Start VDR with the GDB debugger"
+
+usage()
+{
+    local HELPCOMMENTPATTERN="^## "
+    cat "$0" | grep "$HELPCOMMENTPATTERN" | sed "s/$HELPCOMMENTPATTERN//"
+}
+
+
+while getopts hr opt
+do
+    case $opt in
+        r)
+            GDB_SERVER="yes"
+            [ -x $2 ] || GDB_SERVER_PORT="$2"
+            ;;
+        *)
+            usage
+            exit
+            ;;
+    esac
+done
+
+PLUGINS=""
+
+. /usr/lib/vdr/config-loader.sh
+. /usr/lib/vdr/commands-loader.sh
+. /usr/lib/vdr/plugin-loader.sh
+
+getplugins
+mergecommands "commands"
+mergecommands "reccmds"
+
+VDRCOMMANDLINE="-v $VIDEO_DIR -c $CFG_DIR -L $PLUGIN_DIR  -r $REC_CMD \
+  -E $EPG_FILE $PLUGINS $OPTIONS --lirc"
+
+/etc/init.d/vdr stop
+
+if [ "$GDB_SERVER" = "yes" ] ; then
+    gdbserver host:"$GDB_SERVER_PORT" /usr/bin/vdr-dbg \
+      `echo $VDRCOMMANDLINE | sed s/\"//g`
+
+else
+    GDB_COMMANDS_FILE=`mktemp`
+
+    echo "set args $VDRCOMMANDLINE"         >>$GDB_COMMANDS_FILE
+    echo "echo -----------------------\n"   >>$GDB_COMMANDS_FILE
+    echo "echo ---- VDR-Debugging ----\n"   >>$GDB_COMMANDS_FILE
+    echo "echo -----------------------\n\n" >>$GDB_COMMANDS_FILE
+    echo "echo type 'run' to start vdr\n\n" >>$GDB_COMMANDS_FILE
+
+    gdb -x $GDB_COMMANDS_FILE /usr/bin/vdr-dbg 
+    rm $GDB_COMMANDS_FILE
+fi
--- vdr-1.6.0.orig/debian/runvdr.8
+++ vdr-1.6.0/debian/runvdr.8
@@ -0,0 +1,27 @@
+.\" Man page for runvdr
+
+.TH runvdr 8
+.SH NAME
+runvdr \- starts VDR and reloads the DVB modules in case of errors
+.SH DESCRIPTION
+.B runvdr
+is called by the init-script of vdr. It acts as a watchdog for vdr and will 
+reload the dvb-modules and vdr, if vdr exits with an exitcode different from 0.
+
+.B runvdr
+will call /usr/bin/vdr and will pass all commandline-options directly to 
+/usr/bin/vdr.
+
+.B runvdr
+needs to be called by root in order to work correct, because it will try to 
+unload/load kernel-modules!
+
+.SH AUTHOR
+This man-page has been written by Thomas Schmidt <thomas@thsnet.de>
+.PP
+Permission is granted to copy, distribute and/or modify this document under
+the terms of the GNU General Public License, Version 2 any
+later version published by the Free Software Foundation.
+.PP
+On Debian systems, the complete text of the GNU General Public
+License can be found in /usr/share/common\-licenses/GPL.
--- vdr-1.6.0.orig/debian/runvdr
+++ vdr-1.6.0/debian/runvdr
@@ -0,0 +1,88 @@
+#!/bin/sh
+
+. /usr/lib/vdr/config-loader.sh
+
+VDR_ENV="LANG=$VDR_LANG LC_ALL=$VDR_LANG"
+if [ -n "$VDR_CHARSET_OVERRIDE" ] ; then
+   VDR_ENV="$VDR_ENV VDR_CHARSET_OVERRIDE=$VDR_CHARSET_OVERRIDE"
+fi
+
+VDRCMD="$VDR_ENV /usr/bin/vdr $*"
+
+get_modulenames()
+{
+    MODULES=`lsmod | awk '/^dvb/ {gsub(/,/,"\n", $4); print $4}' | uniq | tac | grep -v "^$"`
+    [ "$MODULES" ] && MODULES="$MODULES dvb_core"
+}
+
+# TODO: check if udev handles this on newer systems!?
+set_permissions()
+{
+    if [ "$USER" -o "$GROUP" ]; then
+        for FILE in av7110_ir budget_ci_ir; do
+            if [ -e "/proc/$FILE" ]; then
+                chown $USER.$GROUP /proc/$FILE
+            fi
+        done
+    fi
+    chmod o+r /dev/input/event*
+}
+
+load_dvb_modules()
+{
+    if modprobe dvb >/dev/null 2>&1 ; then
+        get_modulenames
+    else
+        if [ "$MODULES" ]; then
+            for MODULE in $MODULES; do
+                modprobe $MODULE >/dev/null 2>&1
+            done
+        else
+            modprobe dvb_ttpci >/dev/null 2>&1
+            get_modulenames
+        fi
+        wait `pidof udev`
+    fi
+    sleep 15
+}
+
+unload_dvb_modules()
+{
+    for MODULE in $MODULES; do
+        rmmod $MODULE >/dev/null 2>&1
+        wait `pidof rmmod`
+    done
+}
+
+
+VDR_ERR=`mktemp -p /tmp vdr-err.XXXXXX`
+
+get_modulenames
+
+[ -z "$MODULES" ] && load_dvb_modules
+
+while (true) do
+
+    set_permissions
+
+    eval $VDRCMD >/dev/null 2>"$VDR_ERR"
+
+    case $? in
+        0)
+            exit
+        ;;
+        2)
+            ERROR=`cat "$VDR_ERR"`
+            logger -t runvdr "stopping after fatal fail ($ERROR)"
+            exit
+        ;;
+    esac
+
+    logger -t runvdr "restarting VDR"
+    killall -q -TERM /usr/bin/vdr
+    wait `pidof vdr`
+    unload_dvb_modules
+    sleep 2
+    load_dvb_modules
+
+done
--- vdr-1.6.0.orig/debian/vdr.postrm
+++ vdr-1.6.0/debian/vdr.postrm
@@ -0,0 +1,45 @@
+#! /bin/sh
+# postrm script for vdr-plugin-#PACKAGE#
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postrm> `remove'
+#        * <postrm> `purge'
+#        * <old-postrm> `upgrade' <new-version>
+#        * <new-postrm> `failed-upgrade' <old-version>
+#        * <new-postrm> `abort-install'
+#        * <new-postrm> `abort-install' <old-version>
+#        * <new-postrm> `abort-upgrade' <old-version>
+#        * <disappearer's-postrm> `disappear' <r>overwrit>r> <new-version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    purge)
+        rm -f /var/cache/vdr/plugin_search_cache* > /dev/null 2>&1 || true
+        rm -f /var/cache/vdr/commands.conf > /dev/null 2>&1 || true
+        rm -f /var/cache/vdr/reccmds.conf > /dev/null 2>&1 || true
+        rm -f /var/cache/vdr/epg.data > /dev/null 2>&1 || true
+        rm -f /var/lib/vdr/channels.conf > /dev/null 2>&1 || true
+        rm -f /var/lib/vdr/remote.conf > /dev/null 2>&1 || true
+        rm -f /var/lib/vdr/setup.conf > /dev/null 2>&1 || true
+        rm -f /var/lib/vdr/timers.conf > /dev/null 2>&1 || true
+    ;;
+    remove|upgrade|failed-upgrade|abort-install|abort-upgrade|disappear)
+    ;;
+    *)
+        echo "postrm called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
--- vdr-1.6.0.orig/debian/vdr-dbg.install
+++ vdr-1.6.0/debian/vdr-dbg.install
@@ -0,0 +1,4 @@
+vdr-dbg               /usr/bin/
+debian/debugvdr       /usr/bin/
+debian/vdrleaktest    /usr/bin/
+debian/valgrind.supp  /usr/share/vdr/
--- vdr-1.6.0.orig/debian/dependencies.sh
+++ vdr-1.6.0/debian/dependencies.sh
@@ -0,0 +1,21 @@
+# dependencies.sh - vdr plugins depend on the current vdr version
+#
+# This script is called in debian/rules of vdr plugins:
+#    sh /usr/share/vdr-dev/dependencies.sh
+#
+# It sets a dependency to the current vdr version for all binary packages of the
+# plugin package. The current vdr version is the version of the vdr-dev package
+# used to compile the plugin package.
+#
+# This script sets the substitution variable "vdr:Depends" which is used in the
+# debian/control file of vdr plugins, e.g.:
+#    Depends: ${vdr:Depends}
+
+set -e
+
+ABI_VERSION=`cat /usr/share/vdr-dev/abi-version`
+
+# A plugin requires exactly the VDR ABI version it was compiled for
+for p in $(dh_listpackages); do
+    echo "vdr:Depends=$ABI_VERSION" >> debian/$p.substvars
+done
--- vdr-1.6.0.orig/debian/vdr.NEWS
+++ vdr-1.6.0/debian/vdr.NEWS
@@ -0,0 +1,77 @@
+vdr (1.4.7-1) experimental; urgency=low
+
+  The script /usr/lib/vdr/vdr-groups.sh may now be used by plugins to
+  manage the group memberships of the user 'vdr'. See README.Debian
+  for details on how to use this script.
+  
+  If you manually need to add the user 'vdr' to a group, you should
+  add the group name to /etc/vdr/vdr-groups. This way the vdr-groups.sh
+  script used by plugin installation/deinstallation procedures does
+  not try to remove vdr from this group.
+
+ -- Tobias Grimm <tg@e-tobi.net>  Sun,  6 May 2007 20:43:44 +0200
+
+vdr (1.2.6-9) experimental; urgency=low
+
+  This release adds a patch which allows us to have just one binary-
+  package for all four control-methods, so we do not need the 
+  packages vdr-daemon, vdr-kbd, vdr-lirc and vdr-rcu anymore. 
+  You can run vdr with the control-method you want by calling 
+  /usr/bin/vdr-{daemon,kbd,lirc,rcu} or by using 
+  
+  update-alternatives --config vdr
+
+  and setting it to the desired control-method. (lirc is default)
+  After this a call of /usr/bin/vdr will always use the control-
+  method you selected with update-alternatives.
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sun, 27 Feb 2005 00:44:05 +0100
+ 
+vdr (1.2.6-6) unstable; urgency=low
+
+  The most important change in this release is that vdr from now on
+  will run under the username vdr, not as root. This is due to some
+  security problems when vdr runs as root. The video-directory and 
+  configfiles will be changed at installation, so they are owned by 
+  the user and group vdr.
+
+  The second thing is that the automatic shutdown of vdr is now disabled
+  by default, you can enable it again by changing ENABLE_SHUTDOWN to 1 
+  in /etc/default/vdr.
+  
+  In this release we also changed the default VIDEO_DIR from 
+  /var/lib/video to /var/lib/video.00, to make adding extra harddisks 
+  for vdr very easy by just creating /var/lib/video.0{1,2,3,...} and 
+  mounting the drive(s) there. In existing installations we will simply 
+  create a symlink /var/lib/video.00 which points to /var/lib/video. In 
+  new installations /var/lib/video will be a symlink which points to 
+  /var/lib/video.00. (These changes will only be asked for when you 
+  selected yes in the debconf-question to create the video-directory!)
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Fri, 14 Jan 2005 12:17:51 +0100
+
+vdr (1.2.6-4) unstable; urgency=low
+
+  This is the first release from the VDR and DVB Packaging Team
+  <pkg-vdr-dvb-devel@lists.alioth.debian.org>
+  Many thanks to Tobias Grimm and Thomas Günther for the various improvements
+  of the package.
+
+  In this Release, we changed the path of the conf-files to /var/lib/vdr,
+  static conf-files will still be under /etc/vdr, and symlinked to
+  /var/lib/vdr. 
+  If you already have non-static files (channels.conf, remote.conf, 
+  setup.conf and timers.conf), these files will be moved by the 
+  postinst-script to /var/lib/vdr.
+
+  The most important change in this release is the new init-system of vdr,
+  which was taken from c't-vdr, a woody-based distribution, optimized for vdr.
+    - Plugins are no longer loaded via /etc/default/vdr. Instead of this,
+      every installed plugin will be loaded automatically. The order of the
+      plugins can be configured via /etc/vdr/plugins/order.conf.
+    - The commands.conf and the reccmds.conf files will be auto-generated 
+      by the init-script for better integration of vdr-addons.
+      If you already have a commands.conf or reccmds.conf, you should move it
+      to /etc/vdr/command-hooks/{commands|reccmds}.custom.conf .
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sat, 29 May 2004 19:43:49 +0200
--- vdr-1.6.0.orig/debian/copyright
+++ vdr-1.6.0/debian/copyright
@@ -0,0 +1,59 @@
+Upstream Homepage:
+    http://www.tvdr.de/
+
+Upstream Author: 
+    Klaus Schmidinger <Klaus.Schmidinger@tvdr.de> and others
+
+Patch Authors:
+    ttxtsubs  - Ragnar Sundblad <ragge@nada.kth.se>
+                http://www.nada.kth.se/~ragge/vdr/ttxtsubs/
+
+    jumpplay  -  Torsten Kunkel <vdr@tkunkel.de> (initial version)
+                 Thomas Günther <tom@toms-cafe.de> (current version)
+
+Theme Authors:
+    Blue LCARS - (debian/themes/sttng-blue.theme) from Sascha Volkenandt
+                 <sascha@akv-soft.de> was downloaded from 
+                 http://www.magoa.net/sttng-blue.theme
+
+    Cool       - (debian/themes/sttng-cool.theme) from 
+                 clocker@vdrportal.de, downloaded from 
+                 http://vdrportal.de/board/thread.php?postid=260715#post260715
+
+Debian Maintainers:
+    Tobias Grimm <etobi@debian.org>
+    Thomas Günther <tom@toms-cafe.de>
+    Thomas Schmidt <tschmidt@debian.org>
+
+Copyright:
+    (C) 2000 - 2008 Klaus Schmidinger
+    (C) 2001 - 2002 Andreas Schultz (SPU decoder for DVB devices)
+    (C) 2003        Marcel Wiesweg, Rolf Hakenes (libsi)
+
+Copyright (Debian packaging):
+    (C) 2001 - 2002 Eduard Bloch
+    (C) 2003 - 2004 Andreas Müller
+    (C) 2002 - 2010 Tobias Grimm, Thomas Günther, Thomas Schmidt
+
+License:
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 
+    02110-1301, USA.
+
+    The complete text of the GNU General Public License can be found
+    in /usr/share/common-licenses/GPL-2 on most Debian systems.
+
+License (Debian packaging):
+    The Debian packaging is licensed under the GPL, version 2 or any
+    later version, see /usr/share/common-licenses/GPL-2.
--- vdr-1.6.0.orig/debian/vdr-recordingaction
+++ vdr-1.6.0/debian/vdr-recordingaction
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# VDR Recording Action Script  - Tobias Grimm <tg@e-tobi.net>
+# ---------------------------
+#
+# This script gets executed by VDR before a recording starts, after a
+# recording ends and after a recording has been edited.
+# In order to allow other addons to hook into this process, this script will
+# search for any executables in /usr/share/vdr/recording-hooks. These
+# hooks are called in their alphabetical order and should follow this
+# naming scheme: 
+#
+# R<XX>.<identifier>
+#
+# Where <XX> is a two digit number, that mainly specifies the execution order 
+# and <identifier> is a unique descriptor.
+#
+# Two parameters are passed to each recording hook:
+#
+# Parameter 1 can have the values "before", "after" and "edited", depending
+# on whether the recording hook is called before the recording starts,
+# after the recording ends or after the recording has been edited.
+#
+# Parameter 2 is the directory of the recording. Be aware, that this directory 
+# doesn't exist before the recording starts.
+#
+
+REC_HOOKS_DIR=/usr/share/vdr/recording-hooks
+
+recordinghooks=`find $REC_HOOKS_DIR -maxdepth 1 -xtype f | sort`
+
+for recordinghook in $recordinghooks; do
+    case $1 in
+        before|after)
+            action="$1 recording $2" 
+            ;;
+        edited)
+            action="after editing recording $2" 
+            ;;
+    esac
+    if [ -x $recordinghook ]; then
+        logger -t recordingaction "executing $recordinghook $action"
+        $recordinghook $*
+    else
+        logger -t recordingaction "executing $recordinghook $action as shell script"
+        /bin/sh $recordinghook $*
+    fi
+    [ $? -ne 0 ] && logger -t recordingaction "error when executing $recordinghook"
+done 
--- vdr-1.6.0.orig/debian/vdr.templates
+++ vdr-1.6.0/debian/vdr.templates
@@ -0,0 +1,16 @@
+Template: vdr/select_dvb_card
+Type: select
+__Choices: Satellite, Terrestrial, Cable
+Default: Satellite
+_Description: DVB card type:
+ VDR needs to know your DVB card type to work correctly.
+ Using your selection, a channels.conf file will be installed to /var/lib/vdr. 
+ You may have to change this file depending on your setup.
+
+Template: vdr/create_video_dir
+Type: boolean
+Default: false
+_Description: Create /var/lib/video.00?
+ By default VDR is configured to use /var/lib/video.00 to store recordings.
+ You can either create this directory now, or change this behavior later 
+ by modifying the VIDEO_DIR variable in /etc/default/vdr.
--- vdr-1.6.0.orig/debian/TODO.Debian
+++ vdr-1.6.0/debian/TODO.Debian
@@ -0,0 +1,7 @@
+TODO: Make runvdr more equal to official Debian version
+TODO: When plugin could not be loaded, log stderr output somewhere
+TODO: Manpage for pic2mpg
+TODO: Remove | libcap-dev build dep, if Etch gets uninteresting
+TODO: Add option USE_LIRC=yes|no (see http://www.vdr-portal.de/board/thread.php?postid=829057#post829057)
+TODO: Get rid of bash in init script, debugvdr and vdrleaktest
+TODO: The runvdr module (re)loading stuff is weird - it was introduced to workaround driver bugs and can probably be removed
--- vdr-1.6.0.orig/debian/vdr.prerm
+++ vdr-1.6.0/debian/vdr.prerm
@@ -0,0 +1,19 @@
+#! /bin/sh
+# prerm script for vdr
+#
+# see: dh_installdeb(1)
+
+set -e
+
+case "$1" in
+  remove)
+        update-alternatives --remove vdr /usr/bin/vdr-daemon
+        update-alternatives --remove vdr /usr/bin/vdr-kbd
+        update-alternatives --remove vdr /usr/bin/vdr-lirc
+        update-alternatives --remove vdr /usr/bin/vdr-rcu
+        ;;
+esac
+
+#DEBHELPER#
+
+exit 0
--- vdr-1.6.0.orig/debian/README.Debian
+++ vdr-1.6.0/debian/README.Debian
@@ -0,0 +1,290 @@
+vdr for Debian
+--------------
+
+Comments to the Debian version:
+
+ - You need a DVB card and a driver using the "Linux DVB API"
+   (http://www.linuxtv.org/developer/dvbapi.xml). The standard VDR 
+   (without special plugins) requires a DVB-card with an integrated 
+   mpeg-decoder, a so called Full-Featured card. (For example the 
+   Hauppauge Nexus, or a TechnoTrend FullFeatured 1.x)
+ - all the small scripts and tools distributed with the package are located in
+   /usr/lib/vdr/. You may use and modify them for you own purposes.
+ - if you want to use the vdr-initscript, edit /etc/default/vdr and change
+   ENABLED=0 to ENABLED=1, and the other options in this file
+ - video-dir is moved to /var/lib/video see #234429
+ - cfg-dir was moved to /var/lib/vdr, to be FHS-compliant
+ - The selection of your favourite vdr-binary (vdr-daemon, vdr-kbd, vdr-lirc or 
+   vdr-rcu) is now handled via update-alternatives, so if you have more than 
+   one of these packages installed, and are not happy with the default 
+   priorities, you can select the binary via "update-alternatives --config vdr"
+
+ -- Thomas Schmidt <tschmidt@debian.org>,  Tue, 28 Dec 2004 14:22:21 +0100
+
+
+Additional configuration options
+-------------------------------
+
+The following options can be configured in /etc/default/vdr.
+
+KEYB_TTY="<CONSOLE>"
+
+    Default: "" (No console input)
+
+    Console for controlling VDR by keyboard (e.g. /dev/tty8). On startup VDR
+    will automatically switch to this console.
+
+KEYB_TTY_SWITCH=<0|1>
+
+    Default: 0
+
+    Set this to 1, to make VDR switch to the console specified in KEYB_TTY
+    on startup.
+
+PLUGIN_CHECK_STARTABLE="<yes|no>"
+
+    Default: "yes"
+
+    Before starting VDR with the plugins, the loadability of the plugin
+    libraries will be checked with "vdr -V -P plugin". This will catch
+    some binary incompatibilities and problems with the plugins
+    initialization code. Set this to "no" to load the plugins without
+    any testing.
+
+SHUTDOWNCMD="<COMMAND>"
+
+    Default: "/sbin/shutdown -h now"
+
+    VDR executes <COMMAND> when the power-off-key of the remote is pressed after
+    processing all shutdown hook scripts. Shutdown hooks may override this
+    command. See section "Shutdown-Hooks" below. SHUTDOWNCMD will be executed
+    detached in background.
+
+SVDRP_PORT=<PORT>
+
+    Default: 2001
+
+    Default port for SVDRP (Simple Video Disk Recorder Protocol), the telnet
+    like interface to control VDR.
+
+USER=<USERNAME>
+
+    Default: vdr
+
+    Username under which vdr will run. All plugins and commands invoked by VDR
+    will be executed with the rights of this user.
+
+VDR_CHARSET_OVERRIDE=<CHARSET>
+
+    Default: not set
+
+    Workaround for broadcasters not correctly implementing the standard.
+    According to "ETSI EN 300 468" the default character set is ISO-6937. But
+    unfortunately some broadcasters actually use ISO-8859-9, but fail to
+    correctly announce that. If you set VDR_CHARSET_OVERRIDE=ISO-8859-9, then VDR
+    uses ISO-8859-9 as default.
+
+VDR_LANG=<LANG>
+
+    Default: read from LANG or LC_ALL in /etc/default/locale or /etc/environment,
+             falling back to C, if no locale is specified
+
+    Locale which is used when running vdr.
+
+VFAT=<0|1>
+
+    Default: 1
+
+    This corresponds to VDR's --vfat option. If videos are stored on a VFAT file
+    system or a SAMBA share, VFAT should be set to 1. With VFAT=1, the encoding
+    and length of file names will be tweaked, so that it can be correctly stored
+    on VFAT file systems.
+
+VIDEO_DIR="<VIDEODIR>"
+
+    Default: "/var/lib/video.00"
+
+    The video directory where vdr recordings will be stored.  
+
+ -- Tobias Grimm <tg@e-tobi.net>,  Sat, 03 Jun 2006 19:00:00 +0100
+
+
+Automatic Loading of Plugins
+----------------------------
+
+When starting vdr with "/etc/init.d/vdr start", for each plugin found in 
+/usr/lib/vdr/plugins the appropriate command line argument -P<plugin_name>
+will be created automatically. 
+
+If a file /etc/vdr/plugins/plugin.<plugin_name>.conf exists, it will be
+parsed for command line arguments for the specified plugin. This file may
+contain comments prefixed by a "#" and the command line arguments may also be
+distributed across several lines.
+
+ -- Tobias Grimm <tg@e-tobi.net>,  Sun, 23 May 2004 18:00:00 +0100
+
+
+Command-Hooks
+-------------
+
+VDR has the ability, to start external commands using the OSD menu. There are
+two types of external commands - normal commands and recording commands. Normal
+commands are shown under VDR's main menu entry "commands" while, recording
+commands are accessible only in VDR's recordings menu. While normal commands are
+executed without any parameters, recording commands will receive the directory
+of the selected recording as the first command line argument.
+
+In order to allow other packages (Addons) to install their own commands, the
+command files passed to vdr in /etc/init.d/vdr are generated out of the files
+commands.<descriptor>.conf and reccmds.<descriptor>.conf found in
+/usr/share/vdr/command-hooks/. <descriptor> normally should be the name of
+the package, that wants to add these commands to VDR. The order of the 
+commands can be defined in the files order.commands.conf and order.reccmds.conf
+in /etc/vdr/command-hooks/.
+
+If the author of a package wants the user to be able to customize the commands
+added to vdr, the command file should be installed to /etc/vdr/command-hooks/
+and only symlinked to /usr/share/vdr/command-hooks/.
+
+For a description of the command file syntax, refer to commands.conf and
+reccmds.conf in the vdr documentation.
+
+Commands added by the user, should go to commands.custom.conf and
+reccmds.custom.conf in /etc/vdr/command-hooks/. These files contain also some
+examples.
+
+ -- Tobias Grimm <tg@e-tobi.net>,  Sun, 23 May 2004 18:00:00 +0100
+
+
+Recording-Hooks
+---------------
+
+VDR can execute an external command before a recording starts, after a
+recording ends and after a recording has been edited.
+In order to allow other packages to specify their own recording actions,
+all files in /usr/share/vdr/recording-hooks are executed one after another.
+If a file is not an executable or a link to an executable, it is executed as
+a shell script.
+
+Recording hooks are called in their alphabetical order and should follow this
+naming scheme: 
+
+R<XX>.<identifier>
+
+Where <XX> is a two digit number, that mainly specifies the execution order 
+and <identifier> is a unique descriptor.
+
+Two parameters are passed to each recording hook:
+
+Parameter 1 can have the values "before", "after" and "edited", depending
+on whether the recording hook is called before the recording starts,
+after the recording ends or after the recording has been edited.
+
+Parameter 2 is the directory of the recording. Be aware, that this directory 
+doesn't exist before the recording starts.
+
+If the author of a package wants the user to be able to customize a recording
+hook, it should be installed to /etc/vdr/recording-hooks/ and only symlinked
+to /usr/share/vdr/recording-hooks/.
+
+Custom user commands associated with the vdr package, can be added by the user
+to /etc/vdr/recording-hooks/R90.custom.
+
+ -- Tobias Grimm <tg@e-tobi.net>,  Sun, 23 May 2004 19:00:00 +0100
+
+
+Shutdown-Hooks
+---------------
+
+If you press the power key on your remote control, VDR executes a script 
+provided by the command line option -s. By default, this script will
+execute all files in /usr/share/vdr/shutdown-hooks/ in their alphabetical order. 
+If a file in there is not executable, it is treated as a shell script. These
+so called "shutdown hooks" should follow this naming scheme:
+
+S<XX>.<identifier>
+
+Where <XX> is a two digit number, that mainly specifies the execution order 
+and <identifier> is a unique descriptor.
+
+All shutdown hooks will be passed the same parameters as the main shutdown
+script. I.e. the first parameter is the start time of the next timer. Please
+refer to the vdr documentation for the other parameters.
+
+After all shutdown hooks have been processed, VDR will be terminated and the
+machine will be shut down.
+
+A shutdown hook may abort the shutdown process by exiting with an errorlevel
+unequal to 0. To provide the user with an OSD-message about the reason for
+aborting the shutdown, the shutdown hook may write an abort message to stdout
+like this:
+
+ABORT_MESSAGE=<message to display>
+
+If the shutdown should only be deferred (e.g. because some background process,
+is still active), the shutdown hook may write to stdout:
+
+TRY_AGAIN=<minutes to wait before next shutdown request>
+
+In this case, no further shutdown hooks will be processed and the shutdown will
+be invoked in TRY_AGAIN minutes again.
+
+To overwrite the command defined in /etc/default/vdr that will be executed to
+shutdown the machine after all shutdown hooks have been processed, a shutdown
+hook may write to stdout:
+
+SHUTDOWNCMD=<new shutdown command>
+
+
+Group memberships
+-----------------
+
+A few plugins require that the user vdr is member in additional system groups 
+like audio or cdrom. To be a little bit more flexible, we have designed a 
+mechanism which can be used by plugins to specify additional group memberships.
+Plugins can add a file /usr/share/vdr/groups.d/<plugin-name>.groups and call 
+/usr/lib/vdr/vdr-groups.sh in postinst and prerm. vdr-groups.sh will then take
+care of adding/removing vdr to/from the groups listed in the specified
+<plugin-name>.groups file. vdr will be removed from a group only, if no other
+plugin requires this group membership.
+
+In postinst a plugin should call:
+
+    /bin/sh /usr/lib/vdr/vdr-groups.sh --add vdr-plugin-foo
+    
+and in prerm:
+
+    /bin/sh /usr/lib/vdr/vdr-groups.sh --remove vdr-plugin-foo
+
+If you manually add vdr to a group, you must add the group to
+/etc/vdr/vdr.groups. If you don't do so, vdr may be removed from this group when
+uninstalling a plugin.
+
+ -- Thomas Schmidt <tschmidt@debian.org>,  Tue, 01 May 2007 14:12:15 +0200
+
+
+Optional Patches
+----------------
+
+A lot of VDR enthusiasts have improved VDR by creating patches that fix
+existing problems or add new functionality. Some of these patches may not work
+for everyone, so we decided to make them optional. This means, that these
+patches are only included as dpatch files in the vdr source package, NOT in
+the binary packages. They are named opt-<nn>_<patch name>, where <nn> is a
+two-digit-number and <patch name> a unique identifier. To enable a patch, just
+uncomment it in debian/patches/00list and recompile vdr.
+
+Most of these optional patches modify the interfaces used by the plugins. This
+means, that the plugins become binary incompatible. If you activate/deactivate
+patches in the vdr package, all plugins must be recompiled with the new vdr-dev
+package! There is only one exception from this rule - patches named 
+opt-<nn>-x_<patch name> do not affect the plugin interfaces and can therefore 
+be enabled or disabled without the need to recompile the plugins.
+
+Keep in mind, that if you enable any optional patches, you can't use apt-get
+anymore on the official Debian repositories to update existing vdr or plugin
+packages or install additional plugins. You always have to compile the plugins
+yourself! The optional patches are mainly intended for people who would like to
+create their own customized vdr distribution.
+
+ -- Tobias Grimm <tg@e-tobi.net>,  Thu, 3 Jun 2004 02:20:00 +0100
--- vdr-1.6.0.orig/debian/vdr.config
+++ vdr-1.6.0/debian/vdr.config
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+set -e
+
+# source debconf lib
+. /usr/share/debconf/confmodule
+
+# ask about creating /var/lib/video.00
+if [ ! -e /var/lib/video.00 ]; then
+    db_input high vdr/create_video_dir || true
+    db_go
+fi
+
+# ask about dvb card type
+db_input high vdr/select_dvb_card || true
+db_go
+
+exit 0
--- vdr-1.6.0.orig/debian/vdr.postinst
+++ vdr-1.6.0/debian/vdr.postinst
@@ -0,0 +1,151 @@
+#! /bin/sh
+# postinst script for vdr
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postinst> `configure' <most-recently-configured-version>
+#        * <old-postinst> `abort-upgrade' <new version>
+#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
+#          <new-version>
+#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
+#          <failed-install-package> <version> `removing'
+#          <conflicting-package> <version>
+# for details, see http://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+#
+# quoting from the policy:
+#     Any necessary prompting should almost always be confined to the
+#     post-installation script, and should be protected with a conditional
+#     so that unnecessary prompting doesn't happen if a package's
+#     installation fails and the `postinst' is called with `abort-upgrade',
+#     `abort-remove' or `abort-deconfigure'.
+
+# source debconf lib
+#. /usr/share/debconf/confmodule
+
+case "$1" in
+    configure)
+        
+        . /usr/share/debconf/confmodule
+    
+        # install/move channels.conf 
+        if [ ! -e /var/lib/vdr/channels.conf ]; then
+                if  [ -e /etc/vdr/channels.conf ]; then
+                        printf "Note: Moving /etc/vdr/channels.conf to /var/lib/vdr/channels.conf\n"
+                        mv /etc/vdr/channels.conf /var/lib/vdr/channels.conf
+                else
+                        db_get vdr/select_dvb_card
+        
+                        case "$RET" in
+                        Satellite)
+                                gzip -dc /usr/share/doc/vdr/examples/channels.conf.gz \
+                                > /var/lib/vdr/channels.conf
+                                chmod 644 /var/lib/vdr/channels.conf
+                        ;;
+                        Terrestrial)
+                                gzip -dc /usr/share/doc/vdr/examples/channels.conf.terr.gz \
+                                > /var/lib/vdr/channels.conf
+                                chmod 644 /var/lib/vdr/channels.conf
+                        ;;
+                        Cable)
+                                gzip -dc /usr/share/doc/vdr/examples/channels.conf.cable.gz \
+                                > /var/lib/vdr/channels.conf
+                                chmod 644 /var/lib/vdr/channels.conf
+                        ;;
+                        esac
+                fi
+        fi
+        
+        db_get vdr/create_video_dir
+        if $RET; then
+                # check if an old directory /var/lib/video exists, and 
+                # symlink it to /var/lib/video.00
+                if [ -d /var/lib/video ] && [ ! -e /var/lib/video.00 ]; then
+                        ln -s video /var/lib/video.00
+                fi
+
+                # create /var/lib/video.00 if it does not exist
+                if [ ! -e /var/lib/video.00 ]; then
+                        mkdir /var/lib/video.00
+                fi
+
+                # check if /var/lib/video.00 exists and /var/lib/video is 
+                # missing, then create the symlink /var/lib/video which
+                # points to /var/lib/video.00
+                if [ ! -e /var/lib/video ] && [ -e /var/lib/video.00 ]; then
+                        ln -s video.00 /var/lib/video
+                fi
+        fi
+
+        # ensure that user and group 'vdr' exist
+        USER=vdr
+        GROUP=vdr
+        if ! getent group | grep -q "^$GROUP:" ; then
+                echo -n "Adding group $GROUP.."
+                addgroup --quiet --system $GROUP
+                echo "..done"
+        fi
+        if ! getent passwd | grep -q "^$USER:"; then
+                echo -n "Adding user $USER.."
+                adduser --system --home /var/lib/vdr --shell /bin/false \
+                        --gecos "VDR user" --no-create-home \
+                        --disabled-login --disabled-password \
+                        --ingroup $GROUP \
+                        $USER
+                echo "...done"
+        fi
+        
+        # put vdr in group video so that it can access the DVB device nodes
+        adduser $USER video > /dev/null || true
+
+        # ensure that vdr's config and recording files are correctly owned
+        [ -e /var/lib/video ] && chown -R $USER:$GROUP /var/lib/video/
+        if [ -e /var/lib/vdr ] ; then 
+            chown $USER:$GROUP /var/lib/vdr
+            chown $USER:$GROUP /var/lib/vdr/* > /dev/null 2>&1 || true
+        fi
+        if [ -e /var/cache/vdr ] ; then
+            chown $USER:$GROUP /var/cache/vdr
+            chown $USER:$GROUP /var/cache/vdr/* > /dev/null 2>&1|| true
+        fi
+
+        # make /usr/lib/vdr/vdr-shutdown.wrapper setuid/setgid
+        # (owner root:vdr, mode 6750)
+        if [ -e /usr/lib/vdr/vdr-shutdown.wrapper ] ; then
+            chown root:$GROUP /usr/lib/vdr/vdr-shutdown.wrapper && \
+            chmod 6750 /usr/lib/vdr/vdr-shutdown.wrapper
+        fi
+
+        # Install alternatives for the different control methods
+        update-alternatives --install /usr/bin/vdr vdr /usr/bin/vdr-lirc   120
+        update-alternatives --install /usr/bin/vdr vdr /usr/bin/vdr-kbd    110
+        update-alternatives --install /usr/bin/vdr vdr /usr/bin/vdr-rcu    105
+        update-alternatives --install /usr/bin/vdr vdr /usr/bin/vdr-daemon 100
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+db_stop
+
+
+# FIXME
+# wait for vdr to properly shutdown before it is restarted again
+sleep 5 
+
+
+#DEBHELPER#
+
+exit 0
--- vdr-1.6.0.orig/debian/debianize-vdrplugin.1
+++ vdr-1.6.0/debian/debianize-vdrplugin.1
@@ -0,0 +1,33 @@
+.\" Man page for debianize-vdrplugin 
+
+.TH debianize-vdrplugin 1
+.SH NAME
+debianize-vdrplugin \- debianize a VDR plugin source archive
+.SH DESCRIPTION
+.B debianize-vdrplugin
+can be used to add a working debian-directory to the source-directory 
+of a vdr-plugin.
+
+.B debianize-vdrplugin
+should be called directly from a plugin-source-directory.
+
+After
+.B debianize-vdrplugin 
+was run, you should check the files inside the debian-directory if they 
+fit your needs, and modify them accordingly.
+
+The next step to get a debian-package for the vdr-plugin is to call
+.B dpkg-buildpackage
+(You need the package 
+.B dpkg-dev
+for this tool.)
+
+.SH AUTHOR
+This man-page has been written by Thomas Schmidt <thomas@thsnet.de>
+.PP
+Permission is granted to copy, distribute and/or modify this document under
+the terms of the GNU General Public License, Version 2 any
+later version published by the Free Software Foundation.
+.PP
+On Debian systems, the complete text of the GNU General Public
+License can be found in /usr/share/common\-licenses/GPL.
--- vdr-1.6.0.orig/debian/S90.custom
+++ vdr-1.6.0/debian/S90.custom
@@ -0,0 +1,29 @@
+#
+# Custom VDR Shutdown Hook
+# -------------------------
+#
+# Here you can place any commands, you want to be executed when VDR wants
+# to shutdown.
+#
+# * To abort the shutdown, exit with an errorlevel <> 0. 
+# 
+# * If you want a message to be displayed on the OSD when aborting a shutdown,
+#   then write to stdout:
+#
+#   ABORT_MESSAGE=<message to display>
+#
+# * If you want to defer the shutdown, write to stdout:
+#
+#   TRY_AGAIN=<minutes to wait before next shutdown request>
+#
+# * To overwrite the command that will be executed to shutdown the machine 
+#   after all shutdown hooks have been processed, write to stdout:
+#
+#   SHUTDOWNCMD=<new shutdown command>
+#
+# i.e.:
+#
+# echo "ABORT_MESSAGE=\"I do not want to shutdown now!\"" ; exit 1
+#
+
+
--- vdr-1.6.0.orig/debian/vdr-dev.install
+++ vdr-1.6.0/debian/vdr-dev.install
@@ -0,0 +1,15 @@
+*.h                             usr/include/vdr/
+
+libsi/*.h                       usr/include/libsi/
+
+debian/debianize-vdrplugin      usr/bin/
+debian/plugin-template/         usr/share/vdr-dev/
+
+vdr-newplugin                   usr/bin/
+
+debian/lintian/vdr-dev          usr/share/lintian/overrides/
+
+debian/dependencies.sh          usr/share/vdr-dev/
+
+debian/vdrdbg-buildpackage      usr/bin/
+Make.config                     usr/include/vdr/
--- vdr-1.6.0.orig/debian/vdr-shutdown
+++ vdr-1.6.0/debian/vdr-shutdown
@@ -0,0 +1,54 @@
+#!/bin/sh
+#
+# VDR Shutdown Script  - Tobias Grimm <tg@e-tobi.net>
+# -------------------
+#
+# see README.Debian
+#
+
+. /usr/lib/vdr/config-loader.sh
+
+SHUTDOWN_HOOKS_DIR=/usr/share/vdr/shutdown-hooks/
+
+log="logger -t vdr-shutdown"
+svdrpsend="/usr/lib/vdr/svdrpsend.pl"
+
+osdmsg()
+{
+    # OSD message must be deferred, to let VDR display it AFTER the
+    # shutdown script has been executed
+    sleep 2
+    $svdrpsend MESG "$1"
+}
+
+shutdownhooks=`find $SHUTDOWN_HOOKS_DIR -maxdepth 1 -xtype f | sort`
+
+for shutdownhook in $shutdownhooks; do
+    TRY_AGAIN=0
+
+    if [ -x $shutdownhook ]; then
+        $log "executing $shutdownhook"
+        result_data=`$shutdownhook "$@"`
+    else
+        $log "executing $shutdownhook as shell script"
+        result_data=`/bin/sh $shutdownhook "$@"`
+    fi
+    result=$?
+    eval $result_data
+    if [ $result -ne 0 ] ; then 
+        $log "Shutdown aborted by $shutdownhook with exitcode $result"
+        osdmsg "Shutdown abgebrochen / Shutdown aborted!" &
+        [ -z "$ABORT_MESSAGE" ] || osdmsg "$ABORT_MESSAGE" &
+        exit $result
+    fi
+
+    if [ $TRY_AGAIN -gt 0 ]
+    then
+        $log "$shutdownhook requests to try again in $TRY_AGAIN minutes" 
+        nohup sh -c "( sleep $(( $TRY_AGAIN * 60 )) && $svdrpsend \"HITK Power\" )" >/dev/null 2>&1 & 
+        osdmsg "Shutdown aborted. Retry in $TRY_AGAIN minutes." &
+        exit 0
+    fi
+done 
+
+eval $SHUTDOWNCMD &
--- vdr-1.6.0.orig/debian/.vdr-patches
+++ vdr-1.6.0/debian/.vdr-patches
@@ -0,0 +1,18 @@
+debian/patches/81_Make_config.dpatch:dcff6a00ef9474bca19d955d19574009
+debian/patches/99_ncursesw-include.dpatch:90810d58108ff8d9afd768fec67be904
+debian/patches/12_osdbase-maxitems.dpatch:e45d1b62f7d66c3e5d279e3561034107
+debian/patches/20_gcc44_ftbfs.dpatch:310f84b8c27541f3ecec0ce416c21a73
+debian/patches/10_dd-record-option.dpatch:58c3a3dbcd9a3ec4b0ee1814f71d1e88
+debian/patches/11_sortrecordings.dpatch:9ed4cd1e144ee59dab34d4df4aa9af51
+debian/patches/99_vdr-workaround-broken-sys-capability.dpatch:19d9edf94b745d972761cbcec9f442f2
+debian/patches/19_dvb-api-v5.dpatch:6714266c10537521d2440cfa4d50b3f0
+debian/patches/04_newplugin.dpatch:e99f8d21734a19b3eb93d9e3f11b680a
+debian/patches/14_cap-memsize.dpatch:7beb9bcecb1bdce4a03c1729acfbbdb3
+debian/patches/16_channels.conf.terr-fix.dpatch:72595733d0b46aa4093a640708d19226
+debian/patches/06_default_svdrp_port_0.dpatch:b49237a9ee246acfa01ee7ec92ad0a52
+debian/patches/17_vdr-maintenance-1.6.0-1.dpatch:386821878ee431af1b104a2f3a4f3746
+debian/patches/03_cmdsubmenu.dpatch:abff754a3d760764796f06cdf1cf5105
+debian/patches/09_sort_options.dpatch:3b561fcd7645b216b4dab989d7786fda
+debian/patches/18_vdr-maintenance-1.6.0-2.dpatch:703dc617afcbf87cde443ed0df4642da
+debian/patches/82_valgrind.dpatch:46960921b989f2f4dab829a51622ed85
+debian/patches/15_dvbplayer.dpatch:d1f31f0687c917dea48bc0ba26b7f3bb
--- vdr-1.6.0.orig/debian/vdr-plugin-sky.docs
+++ vdr-1.6.0/debian/vdr-plugin-sky.docs
@@ -0,0 +1 @@
+PLUGINS/src/sky/README
--- vdr-1.6.0.orig/debian/.vdr-patches.multipatch
+++ vdr-1.6.0/debian/.vdr-patches.multipatch
@@ -0,0 +1,43 @@
+debian/patches/opt-52_hard_link_cutter.dpatch:898b721991e948611ba0402af2f163a5
+debian/patches/opt-43-x_recordshowfree.dpatch:66152f345b03259d28e89135cda42310
+debian/patches/12_osdbase-maxitems.dpatch:e45d1b62f7d66c3e5d279e3561034107
+debian/patches/11_sortrecordings.dpatch:9ed4cd1e144ee59dab34d4df4aa9af51
+debian/patches/opt-53_dvbsetup.dpatch:dbb3417b0b33548728b43fd8613f7c73
+debian/patches/opt-50_graphtft.dpatch:aeba283cc500591fa0b6d112c063fadf
+debian/patches/16_channels.conf.terr-fix.dpatch:72595733d0b46aa4093a640708d19226
+debian/patches/06_default_svdrp_port_0.dpatch:b49237a9ee246acfa01ee7ec92ad0a52
+debian/patches/18_vdr-maintenance-1.6.0-2.dpatch:703dc617afcbf87cde443ed0df4642da
+debian/patches/82_valgrind.dpatch:46960921b989f2f4dab829a51622ed85
+debian/patches/opt-42-x_MainMenuHooks.dpatch:1c4c782b5c88c4f0408890a5f50b217b
+debian/patches/opt-44_rotor.dpatch:bbcc27512e0a0b610efadcde8fa67d02
+debian/patches/opt-41-x_timer-info.dpatch:92ee6cdf60b795d9fbcf4fdcafe401b4
+debian/patches/opt-20_liemikuutio.dpatch:b75777c886ae836a8d499a0628ae091f
+debian/patches/10_dd-record-option.dpatch:58c3a3dbcd9a3ec4b0ee1814f71d1e88
+debian/patches/opt-21_internal-cam-devices.dpatch:a883c0b09e67b679436b7df1e9807fc8
+debian/patches/09_sort_options.dpatch:3b561fcd7645b216b4dab989d7786fda
+debian/patches/99_vdr-workaround-broken-sys-capability.dpatch:19d9edf94b745d972761cbcec9f442f2
+debian/patches/opt-24_jumpplay.dpatch:1ff8f1a90e02b11a42218ffba18b5f26
+debian/patches/opt-30-x_analogtv.dpatch:3789ff68d9dc9a2482f78519634b27b6
+debian/patches/17_vdr-maintenance-1.6.0-1.dpatch:386821878ee431af1b104a2f3a4f3746
+debian/patches/03_cmdsubmenu.dpatch:abff754a3d760764796f06cdf1cf5105
+debian/patches/19_dvb-api-v5.dpatch:6714266c10537521d2440cfa4d50b3f0
+debian/patches/opt-28_audioindexer.dpatch:eab872310fd03a175b3b93a90d22d5db
+debian/patches/opt-31-x_reelchannelscan.dpatch:f8c06ac51888248f68badcab8533c2be
+debian/patches/81_Make_config.dpatch:dcff6a00ef9474bca19d955d19574009
+debian/patches/opt-51_cuttime.dpatch:cfbf0a7934f109148fef4e385c3eb465
+debian/patches/20_gcc44_ftbfs.dpatch:310f84b8c27541f3ecec0ce416c21a73
+debian/patches/opt-40_pluginparam.dpatch:9dc3baf2532c9df6e715f0d6c9f7df06
+debian/patches/14_cap-memsize.dpatch:7beb9bcecb1bdce4a03c1729acfbbdb3
+debian/patches/opt-48-x_pin.dpatch:77abed7c39fda93fbcdb7140d49f9566
+debian/patches/opt-47_sourcecaps.dpatch:626ed6d141802b9cae8c4b6cab97311e
+debian/patches/opt-37-x_menuorg.dpatch:9fb02cc8bd848add50b3866b6f476644
+debian/patches/opt-45_yaepg.dpatch:351c08a687755050e1140766b56dc27b
+debian/patches/opt-27_ttxtsubs.dpatch:c0b18cf05be89d87b0dff02ddeb14f05
+debian/patches/99_ncursesw-include.dpatch:90810d58108ff8d9afd768fec67be904
+debian/patches/opt-39_noepg.dpatch:424391fa1176800ec3a13ec608fafcd7
+debian/patches/opt-54_deltimeshiftrec.dpatch:5ed1505172adbdb45a583a69dfe19763
+debian/patches/opt-49-x_pvrinput.dpatch:213c07a003000b6b93f1a8d004787220
+debian/patches/04_newplugin.dpatch:e99f8d21734a19b3eb93d9e3f11b680a
+debian/patches/opt-38_disableDoubleEpgEntrys.dpatch:7a09fa581f95613497b718b5c4a4a875
+debian/patches/opt-29_syncearly-audioindexer.dpatch:4093d09329d441bd25703a4892633efb
+debian/patches/15_dvbplayer.dpatch:d1f31f0687c917dea48bc0ba26b7f3bb
--- vdr-1.6.0.orig/debian/vdr-shutdown-message
+++ vdr-1.6.0/debian/vdr-shutdown-message
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+svdrpsend="/usr/lib/vdr/svdrpsend.pl"
+log="logger -t vdr-shutdown"
+
+MESSAGE="Shutdown deactivated (see /etc/default/vdr)"
+
+osdmsg()
+{
+    # OSD message must be deferred, to let VDR display it AFTER the
+    # shutdown script has been executed
+    sleep 2
+    $svdrpsend MESG "$1"
+}
+
+osdmsg $MESSAGE &
+$log $MESSAGE &
+
+exit 1
--- vdr-1.6.0.orig/debian/vdr.links
+++ vdr-1.6.0/debian/vdr.links
@@ -0,0 +1,27 @@
+etc/vdr/command-hooks/commands.custom.conf   usr/share/vdr/command-hooks/commands.custom.conf
+etc/vdr/command-hooks/reccmds.custom.conf    usr/share/vdr/command-hooks/reccmds.custom.conf
+
+var/cache/vdr/commands.conf  var/lib/vdr/commands.conf
+var/cache/vdr/reccmds.conf   var/lib/vdr/reccmds.conf
+
+etc/vdr/recording-hooks/R90.custom        usr/share/vdr/recording-hooks/R90.custom
+etc/vdr/shutdown-hooks/S90.custom         usr/share/vdr/shutdown-hooks/S90.custom
+
+etc/vdr/diseqc.conf      var/lib/vdr/diseqc.conf
+etc/vdr/keymacros.conf   var/lib/vdr/keymacros.conf
+etc/vdr/sources.conf     var/lib/vdr/sources.conf
+etc/vdr/svdrphosts.conf  var/lib/vdr/svdrphosts.conf
+
+usr/share/man/man1/vdr.1.gz usr/share/man/man1/vdr-daemon.1.gz
+usr/share/man/man1/vdr.1.gz usr/share/man/man1/vdr-kbd.1.gz
+usr/share/man/man1/vdr.1.gz usr/share/man/man1/vdr-lirc.1.gz
+usr/share/man/man1/vdr.1.gz usr/share/man/man1/vdr-rcu.1.gz
+
+var/lib/vdr/setup.conf       etc/vdr/setup.conf
+var/lib/vdr/remote.conf      etc/vdr/remote.conf
+var/lib/vdr/channels.conf    etc/vdr/channels.conf
+etc/default/vdr              etc/vdr/vdr.default
+
+etc/vdr/vdr.groups    usr/share/vdr/groups.d/vdr.groups
+
+usr/lib/vdr/svdrpsend.pl    usr/bin/svdrpsend
--- vdr-1.6.0.orig/debian/R90.custom
+++ vdr-1.6.0/debian/R90.custom
@@ -0,0 +1,43 @@
+#
+# Custom VDR Recording Action Hook
+# ----------------------------------
+#
+# This is a custom Recording Action Hook. It gets called by vdr
+# before a recording starts, after a recording ended and after a
+# recording has been edited. It is maintained as a config file in the vdr
+# package. All other recording hooks get executed before this one! 
+#
+# If you want to create your own recording hook that may get executed
+# before any other hook, create it in /usr/share/vdr/recording-hooks or
+# link to this location. All hooks are called in their alphabetical
+# order and should follow this naming scheme: 
+#
+# R<XX>.<identifier>
+#
+# Where <XX> is a two digit number, that mainly specifies the execution order 
+# and <identifier> is a unique descriptor.
+#
+# Two parameters are passed:
+#
+# Parameter 1 can have the values "before", "after" and "edited", depending
+# on whether the recording hook is called before the recording starts,
+# after the recording ends or after the recording has been edited.
+#
+# Parameter 2 is the directory of the recording. Be aware, that this directory 
+# doesn't exist before the recording starts.
+#
+
+case $1 in
+    before)
+        # do here whatever you would like to do right BEFORE
+        # the recording $2 STARTS
+        ;;
+    after)
+        # do here whatever you would like to do right AFTER
+        # the recording $2 ENDED
+        ;;
+    edited)
+        # do here whatever you would like to do right AFTER
+        # the recording $2 has been EDITED
+        ;;
+esac
--- vdr-1.6.0.orig/debian/vdr-groups.sh
+++ vdr-1.6.0/debian/vdr-groups.sh
@@ -0,0 +1,112 @@
+#!/bin/sh
+#
+# This script checks which groups the vdr user should belong to and adds
+# it to the necessary groups or removes it from groups which are not needed
+# anymore
+#
+# (c) 2007, Thomas Schmidt <tschmidt@debian.org>
+# (c) 2007, Tobias Grimm <tg@e-tobi.net>
+#
+
+DIR="/usr/share/vdr/groups.d"
+VDR_USER=vdr
+
+ACTUAL_GROUPS=`groups $VDR_USER | cut -d' ' -f3-`
+
+is_group_in_list()
+{
+    local group=$1
+    shift
+    local group_list=$*
+    local current_group
+
+    for current_group in $group_list; do
+        [ "$current_group" = "$group" ] && return
+    done
+
+    false
+}
+
+read_groups()
+{
+    cat "$1" | grep -v "^#\|^$" | sed s/"\(.*\)#.*"/"\1"/ | xargs
+}
+
+add_to_groups()
+{
+    local groups_file="$1"
+    local groups=`read_groups "$groups_file"`
+    local group
+
+    for group in $groups; do
+        if ! is_group_in_list $group $ACTUAL_GROUPS; then
+            echo "Adding '$VDR_USER' to group '$group'"
+            adduser $VDR_USER $group > /dev/null 2>&1
+        fi
+    done
+}
+
+remove_from_groups()
+{
+    local groups_file="$1"
+    local groups=`read_groups "$groups_file"`
+    local needed_groups
+    local group
+    
+    needed_groups=`read_groups $DIR/*`
+
+    for group in $groups; do
+        if is_group_in_list $group $ACTUAL_GROUPS; then
+            if ! is_group_in_list $group $needed_groups; then
+                echo "Removing '$VDR_USER' from group '$group'"
+                deluser $VDR_USER $group > /dev/null 2>&1
+            fi
+        fi
+    done
+}
+
+show_help()
+{
+    echo
+    echo "vdr-groups.sh"
+    echo "-------------"
+    echo "Shell script to be used by vdr plugin packages to register/deregister"
+    echo "required vdr group memberships."
+    echo
+    echo "/bin/sh /usr/lib/vdr/vdr-groups.sh --add <GROUP-FILE>"
+    echo "/bin/sh /usr/lib/vdr/vdr-groups.sh --remove <GROUP-FILE>"
+    echo
+    echo "The <GROUP-FILE> is the file in $DIR containing the list of groups"
+    echo "vdr should be added to or removed from."
+    echo
+    exit 127
+}
+
+#
+# main()
+#
+
+
+if [ $# -ne 2 ]; then
+    show_help
+fi
+
+action="$1"
+groups_file="$DIR/$2.groups"
+
+if [ ! -e $groups_file ]; then
+    echo "WARNING: $groups_file does not exist. Can't adjust vdr group membership"
+    exit 0
+fi
+
+case "$action" in
+    --add)
+        add_to_groups "$groups_file"
+        ;;
+    --remove)
+        remove_from_groups "$groups_file"
+        ;;
+    *)
+        show_help
+        ;;
+esac
--- vdr-1.6.0.orig/debian/vdrdbg-buildpackage
+++ vdr-1.6.0/debian/vdrdbg-buildpackage
@@ -0,0 +1,45 @@
+#!/bin/sh
+
+## NAME
+##   vdrdbg-buildpackage - builds a VDR plugin for debugging
+## 
+## SYNOPSIS
+##   vdrdbg-buildpackage [dpkg-puildpackage-options]
+## 
+## DESCRIPTION
+##   vdrdbg-buildpackage is a small wrapper for dpkg-buildpackage, which
+##   sets all options needed to compile a VDR plugin for debugging.
+## 
+## OPTIONS
+##   -h This help
+## 
+##   All dpkg-buildpackage options are available for vdrdbg-buildpackage
+##   as well.
+## 
+## SEE ALSO
+##   dpkg-buildpackage (1)
+## 
+## AUTHOR
+##   This manual page was written by Tobias Grimm <tg@e-tobi.net>
+## 
+### txt2man -s 1 -t VDRDBG-BUILDPACKAGE -v "Create VDR dbeug plugin package"
+
+usage()
+{
+    local HELPCOMMENTPATTERN="^## "
+    cat "$0" | grep "$HELPCOMMENTPATTERN" | sed "s/$HELPCOMMENTPATTERN//"
+}
+
+while getopts :h opt
+do
+    case $opt in
+        h)
+            usage
+            exit
+            ;;
+    esac
+done
+
+export DEB_BUILD_OPTIONS="noopt nostrip $DEB_BUILD_OPTIONS"
+export VDRDEBUG=yes
+dpkg-buildpackage $*
--- vdr-1.6.0.orig/debian/commands-loader.sh
+++ vdr-1.6.0/debian/commands-loader.sh
@@ -0,0 +1,61 @@
+#
+# This file is called by /etc/init.d/vdr
+#
+
+writewarning ()
+{
+echo -e \
+"#\n"\
+"# This file is automatically generated by the vdr init-script. You can\n"\
+"# define custom commands in /etc/vdr/command-hooks/$1.custom.conf\n"\
+"# (see /usr/share/doc/vdr/README.Debian.gz).\n"\
+"#\n\n\n"
+}
+
+# merges single <cmdtype>.<name>.conf files into one <cmdtype>.conf using
+# the order defined in order.<cmdtype>.conf
+mergecommands ()
+{
+    local cmd
+    local cmds
+    local cmdsorder
+    local line
+    local cmdtype
+    local cmdfile
+    local ordered_cmds
+
+    cmdtype=$1
+    cmdfile="/var/cache/vdr/$cmdtype.conf"
+
+    writewarning $cmdtype > "$cmdfile"
+
+    cmdsorder=( `cat /etc/vdr/command-hooks/order.$cmdtype.conf | sed "s/#.*$//"` )
+    cmds=( `find $CMDHOOKSDIR -maxdepth 1 -name "$cmdtype.*.conf" -printf "%f \n" | sed "s/$cmdtype\.\(.\+\)\.conf/\1/g"` )
+
+    # first the ordered commands:
+    for cmd in ${cmdsorder[@]}; do
+        for (( line=0 ; line<${#cmds[@]} ; line++ )); do
+            if [ "$cmd" = "-${cmds[$line]}" ]; then
+                unset cmds[$line]
+                cmds=( "${cmds[@]}" )
+                break
+            fi
+            if [ "$cmd" = "${cmds[$line]}" ]; then
+                ordered_cmds=( "${ordered_cmds[@]}" "${cmds[$line]}" )
+                unset cmds[$line]
+                cmds=( "${cmds[@]}" )
+                break
+            fi
+        done
+    done
+    # then the remaining unordered commands:
+    ordered_cmds=( "${ordered_cmds[@]}" "${cmds[@]}" )
+
+    # concatenate all commands
+    for cmd in ${ordered_cmds[@]}; do
+        if [ "$cmd" != "" ]; then
+            cat "$CMDHOOKSDIR/$cmdtype.$cmd.conf" >> "$cmdfile" || true
+            echo "" >> "$cmdfile"
+        fi
+    done
+}
--- vdr-1.6.0.orig/debian/order.reccmds.conf
+++ vdr-1.6.0/debian/order.reccmds.conf
@@ -0,0 +1,10 @@
+#
+# If you like a fixed order in your recording commands menu, place the 
+# command base names (reccmds.<basename>.conf) here.
+#
+# If you want a certain command file not to be loaded automatically at 
+# vdr-startup, then you can simply write "-basename" in this file.
+
+firstcommand
+secondcommand
+-thirdcommand
--- vdr-1.6.0.orig/debian/vdr-plugin-examples.examples
+++ vdr-1.6.0/debian/vdr-plugin-examples.examples
@@ -0,0 +1 @@
+PLUGINS/src/pictures/pic2mpg
--- vdr-1.6.0.orig/debian/vdr-dbg.manpages
+++ vdr-1.6.0/debian/vdr-dbg.manpages
@@ -0,0 +1,3 @@
+debian/debugvdr.1
+debian/vdrleaktest.1
+debian/vdr-dbg.1
--- vdr-1.6.0.orig/debian/vdr-dbg.links
+++ vdr-1.6.0/debian/vdr-dbg.links
@@ -0,0 +1 @@
+usr/share/doc/vdr               usr/share/doc/vdr-dbg
--- vdr-1.6.0.orig/debian/abi-version.multipatch
+++ vdr-1.6.0/debian/abi-version.multipatch
@@ -0,0 +1 @@
+vdr-abi-1.6.0-multipatch-2009-05-03
--- vdr-1.6.0.orig/debian/abi-version
+++ vdr-1.6.0/debian/abi-version
@@ -0,0 +1 @@
+vdr-abi-1.6.0-debian
--- vdr-1.6.0.orig/debian/commands.update-recordings.conf
+++ vdr-1.6.0/debian/commands.update-recordings.conf
@@ -0,0 +1 @@
+Aufnahmen-Liste aktualisieren   : /usr/bin/touch /var/lib/video/.update
--- vdr-1.6.0.orig/debian/README.source
+++ vdr-1.6.0/debian/README.source
@@ -0,0 +1,7 @@
+This package uses the dpatch system to save and apply patches to the
+upstream source code of the software that is packaged. For details
+about how to use dpatch read
+
+   /usr/share/doc/dpatch/README.source.gz
+
+from the dpatch package.
--- vdr-1.6.0.orig/debian/changelog
+++ vdr-1.6.0/debian/changelog
@@ -0,0 +1,1360 @@
+vdr (1.6.0-19.1) unstable; urgency=low
+
+  * debian/vdrleaktest
+    - Remove extra colon from LD_LIBRARY_PATH to fix CVE-2010-3387.
+      (normal, security; Closes: #598308).
+
+ -- Jari Aalto <jari.aalto@cante.net>  Thu, 21 Oct 2010 09:18:54 +0300
+
+vdr (1.6.0-19) unstable; urgency=low
+
+  * Fixed DEB_BUILD_OPTIONS export in in vdrdbg-buildpackage
+    (Closes: #596593)
+
+ -- Tobias Grimm <etobi@debian.org>  Sun, 17 Oct 2010 11:27:55 +0200
+
+vdr (1.6.0-18.1) unstable; urgency=low
+
+  * debian/vdrleaktest
+    - Asjust LD_LIBRARY_PATH use according to CVE-2010-3387.
+      (normal, security; Closes: #598308).
+
+ -- Jari Aalto <jari.aalto@cante.net>  Sat, 16 Oct 2010 20:59:56 +0300
+
+vdr (1.6.0-18) unstable; urgency=low
+
+  * Added Danish translation of the debconf templates (Thx to Joe Hansen)
+    (Closes: #592260)
+  * Minor fix to options parsing in debug version start script
+  * Standards-Version: 3.9.1
+
+ -- Tobias Grimm <etobi@debian.org>  Thu, 19 Aug 2010 00:07:33 +0200
+
+vdr (1.6.0-17) unstable; urgency=low
+
+  * Modified runvdr to also (re)load dvb modules not depending on dvb_core*
+    (Closes: #576337)
+  * Added debian/source/format 1.0
+
+ -- Tobias Grimm <etobi@debian.org>  Fri, 30 Apr 2010 22:43:50 +0200
+
+vdr (1.6.0-16) unstable; urgency=low
+
+  [ Thomas Günther ]
+  * Added opt-22-x_edit_marks.dpatch
+  * Adapted opt-48-x_pin.dpatch to vdr-workaround-broken-sys-capability patch
+  * Updated opt-52_hard_link_cutter.dpatch to version 0.2.2
+    (fixes gcc 4.4 issue)
+  * Added -p to bash shebang line of init script, because this is needed,
+    if VDR calls the init script itself via a suid wrapper
+  * Added linux-libc-dev to Depends of package vdr-dev (linux/dvb/*.h included
+    in header files, e.g. device.h)
+
+  [ Tobias Grimm ]
+  * Moved /usr/include/vdr/libsi to /usr/include/libsi to make the include
+    structure compatible to vdr standards
+
+ -- Tobias Grimm <etobi@debian.org>  Sun, 28 Mar 2010 14:50:33 +0200
+
+vdr (1.6.0-15) unstable; urgency=low
+
+  * Standards-Version: 3.8.4
+  * Made init script require $remote_fs (/usr/...)
+  * Migrated debconf _Choices to __Choices
+
+ -- Tobias Grimm <etobi@debian.org>  Thu, 04 Mar 2010 23:28:37 +0100
+
+vdr (1.6.0-14) unstable; urgency=low
+
+  [ Thomas Günther ]
+  * Removed 99_dvb-header-fixes.dpatch
+  * Added 99_vdr-workaround-broken-sys-capability.dpatch
+
+  [ Tobias Grimm ]
+  * Added Japanese debconf translation (Closes: #555546)
+
+ -- Tobias Grimm <etobi@debian.org>  Fri, 15 Jan 2010 00:13:07 +0100
+
+vdr (1.6.0-13) unstable; urgency=low
+
+  * New upstream homepage http://www.tvdr.de/
+  * Removed make-special-vdr.sh (Closes: #552638)
+  * Added README.source
+
+ -- Tobias Grimm <etobi@debian.org>  Sun, 08 Nov 2009 22:14:13 +0100
+
+vdr (1.6.0-12) unstable; urgency=low
+
+  [ Thomas Günther ]
+  * Upgraded make-special-vdr.sh to version 1.3
+
+  [ Tobias Grimm ]
+  * Added Italian debconf translation (Closes: #548798)
+  * Fixed FTBFS with gcc 4.4 (Closes: #549380)
+  * Standards-Version: 3.8.3
+
+ -- Tobias Grimm <etobi@debian.org>  Fri, 09 Oct 2009 21:55:31 +0200
+
+vdr (1.6.0-11) unstable; urgency=low
+
+  * Fixed syntax error in runvdr and don't set "-p" anymore, which is only
+    supported by Bash (Closes: #536894)
+  * Added Russian debconf template provided by Yuri Kozlov (Closes: #536561)
+
+ -- Tobias Grimm <etobi@debian.org>  Tue, 14 Jul 2009 20:55:37 +0200
+
+vdr (1.6.0-10) unstable; urgency=low
+
+  * Upgraded opt-20_liemikuutio.dpatch to version 1.27
+  * Updated and renamed opt-40_iptv.dpatch to opt-40_pluginparam.dpatch
+  * Added 99_dvb-header-fixes.dpatch as a workaround for the header bugs in
+    Linux 2.6.29
+  * Fixed debianize-vdrplugin template (dropped patchlevel field in control)
+  * Changed section of plugin template to "video"
+  * Added Spanish debconf template translation (Closes: #528245)
+  * Build-Depend on linux-libc-dev
+  * Dropped Kernel 2.4 support in runvdr
+  * Updated make-special-vdr.sh
+  * New multipatch ABI version 2009-05-03
+  * Bumped standards version to 3.8.2
+
+ -- Tobias Grimm <etobi@debian.org>  Fri, 10 Jul 2009 20:24:50 +0200
+
+vdr (1.6.0-9) unstable; urgency=low
+
+  [ Tobias Grimm ]
+  * Removed debconf note "VDR needs DVB kernel modules" - DVB modules should
+    be part of the standard kernel (at least on i386 and amd64).
+  * Fixed debconf to not ask to create /var/lib/video.00 if it already exists
+  * Added 19_dvb-api-v5.dpatch for new DVB API version 5 in kernel 2.6.28
+    (Closes: #522011, #527664)
+  * Updated debian/copryright
+  * Added ${misc:Depends} to vdr-plugin-*
+  * Changed section of all packages to "video" except vdr-dbg which became
+    "debug"
+  * Bumped standards version to 3.8.1
+
+  [ Thomas Günther ]
+  * Added removal of vdr-dbg.1 to clean target in debian/rules
+  * Fixed substitution of 00list in debian/rules
+  * Added French language texts to 10_dd-record-option.dpatch (Thx to Michaël
+    Nival)
+  * Upgraded opt-24_jumpplay.dpatch to version 1.0
+  * Added French language texts to opt-38_disableDoubleEpgEntrys.dpatch (Thx to
+    Michaël Nival)
+
+ -- Tobias Grimm <etobi@debian.org>  Thu, 02 Apr 2009 14:55:20 +0200
+
+vdr (1.6.0-8) unstable; urgency=low
+
+  * Added 18_vdr-maintenance-1.6.0-2.dpatch (Closes: #485593)
+  * Added opt-21_internal-cam-devices.dpatch
+  * Added opt-53_dvbsetup.dpatch
+  * Added opt-54_deltimeshiftrec.dpatch
+  * Replaced libcap-dev build dependency by libcap2-dev | libcap-dev
+    (Closes: #492681)
+  * Fixed detection of default LANG setting to be used for VDR
+  * Updated README.Debian (Closes: #499047)
+  * Fixed reference to /usr/share/doc/vdr/README.Debian.gz in /etc/default/vdr
+  * Added missing dpatch descriptions
+  * Removed Lintian ovverride "shell-script-fails-syntax-check" for
+     ./usr/share/vdr-dev/plugin-template/rules
+
+ -- Tobias Grimm <etobi@debian.org>  Sat, 29 Nov 2008 14:21:04 +0100
+
+vdr (1.6.0-7) unstable; urgency=medium
+
+  [ Thomas Schmidt ]
+  * Fixed bashism in debian/rules (Closes: #491586)
+
+ -- Tobias Grimm <tg@e-tobi.net>  Wed, 27 Aug 2008 19:08:44 +0200
+
+vdr (1.6.0-6) unstable; urgency=medium
+
+  * Removed stdout output from vdrleaktest to /tmp/memleaktest.log,
+    create tempfile in debugvdr using mktemp now, to prevent
+    possible symlink attacks (Closes: #496421)
+
+ -- Tobias Grimm <tg@e-tobi.net>  Sun, 24 Aug 2008 23:13:44 +0200
+
+vdr (1.6.0-5) unstable; urgency=low
+
+  [ Thomas Schmidt ]
+  * Bumped Standards-Version to 3.8.0
+
+  [ Tobias Grimm ]
+  * Using "Provides: vdr-abi-1.6.0-debian" now, which plugin packages can depend
+    on. This way only plugins compiled for the specified ABI version can be
+    installed, allowing us to remove the runtime patch level test.
+    (Closes: #489914)
+  * Setting VDR_LANG now takes care of /etc/default/locale if available,
+    otherwise uses /etc/environment or falls back to "C" (Closes: #490651)
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sat, 19 Jul 2008 16:25:21 +0200
+
+vdr (1.6.0-4) unstable; urgency=high
+
+  [ Tobias Grimm ]
+  * Made valgrind a Suggests and check in vdrleaktest, if valgrind exists
+    (Closes: #489003)
+
+  [ Thomas Schmidt ]
+  * Set urgency to high, because it fixes an rc-bug
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Thu, 03 Jul 2008 10:21:17 +0200
+
+vdr (1.6.0-3) unstable; urgency=low
+
+  * Installing the pictures plugin now with vdr-plugin-examples
+  * Replaced usage of 'at' with 'nohupc -c "( command )" >/dev/null 2>&1 &'
+  * Removed debian/linda
+
+ -- Tobias Grimm <tg@e-tobi.net>  Wed, 18 Jun 2008 00:52:58 +0200
+
+vdr (1.6.0-2) unstable; urgency=low
+
+  [ Tobias Grimm ]
+  * Removed makedev dependency (not needed anymore since 1.4.7-2)
+    (closes: #477062)
+  * Added dependency to at (required by shutdown scripts)
+  * Modified 81_Make_config.dpatch to set the default CXXFLAGS and CFLAGS
+    required for building VDR and VDR plugins. This was necessary, because newer
+    versions of dpkg-buildpackage export CXXFLAGS. Because the upstream's
+    Makefile of VDR and VDR plugins usually define the compiler arguments
+    as "CXXFLAGS ?=...", these settings are ignored when an environment variable
+    CXXFLAGS exists. On non-i386 builds this causes a FTBFS for all plugins,
+    because of the missing -fPIC. Plugins, that require special compiler
+    arguments, should from now on pass CXXFLAGS as an argument to the make call
+    in debian/rules. (closes: #475710)
+  * Made Make.config handle DEB_BUILD_OPTIONS=noopt, so all plugins including
+    Make.config in their Makefile will inherently support noopt as well 
+    (see also Debian Policy 3.7.3.0 section 10.1)
+  * Added caching to plugin-loader.sh to speed up the initial startup of vdr
+    (Patch provided by Michael Burian <michael.burian@sbg.at>)
+  * Added 17_vdr-maintenance-1.6.0-1.dpatch
+  * Updated opt-20_liemikuutio.dpatch
+  * Updated opt-48-x_pin.dpatch
+  * Upgraded opt-37-x_menuorg.dpatch to version 0.4.2
+  * Upgraded opt-50_graphtft-0.1.dpatch to current version 0.1.7~alpha of the
+    GraphTFT plugin (taken from the Zulu Extensions Patch 56) and renamed it
+    to opt-50_graphtft.dpatch (deleted old opt-50_graphtft.dpatch)
+  * Applied a lot of spelling fixes (Thanks to Michael Nork!)
+  * Modified opt-49-x_pvrinput.dpatch: Added CA-Id's 0xA1 and 0xA2, required by
+    pvrusb2 as suggested by Christian Jarczyk
+  * Using txt2man for manpages that used docbook before
+  * Upgraded opt-21_liemikuutio.dpatch to version 1.21
+  * Updated opt-48_pin.dpatch
+  * Upgraded extensions patch to version 61
+  * Upgraded opt-39_noepg.dpatch to the patch taken from the vdr-noepgmenu
+    plugin 0.0.6.beta3
+  * Added opt-52_hard_link_cutter.dpatch
+
+
+  [ Thomas Günther ]
+  * Upgraded make-special-vdr.sh to version 0.9
+  * Upgraded opt-41-x_timer-info.dpatch to version 0.5
+  * Improved caching in plugin-loader.sh
+
+  [ Thomas Schmidt ]
+  * Added Galician debconf translation (gl.po) from Jacobo Tarrio
+    (closes: #482132)
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Wed, 21 May 2008 22:03:28 +0200
+
+vdr (1.6.0-1) experimental; urgency=low
+
+  [ Tobias Grimm]
+  * New upstream release (closes: #467512)
+  * Updated 03_cmdsubmenu.dpatch
+  * Updated 09_sort_options.dpatch
+  * Upgraded opt-20_liemikuutio.dpatch to version 1.19
+  * Updated opt-31-x_reelchannelscan
+  * Updated opt-37-x_menuorg.dpatch
+  * Updated opt-38_disableDoubleEpgEntrys.dpatch, to avoid sprintf buffer
+    overflows
+  * Updated opt-41-x_timer-info.dpatch
+  * Updated opt-43-x_recordshowfree.dpatch
+  * Updated opt-47_sourcecaps
+  * Updated opt-48-x_pin.dpatch
+  * Applied modification from Michaël Nival to opt-45_yaepg.dpatch that fixes a
+    small bug
+  * Removed opt-36_CutterQueue.dpatch
+  * Removed opt-36_CutterQueue-AutoDelete.dpatch
+  * Removed opt-46_dmh-dvd-archive.dpatch
+  * Removed opt-46_dvdarchive.dpatch
+  * Removed opt-46-x_dmh-dvd-archive-debian.dpatch
+  * Removed opt-49_sharelnb.dpatch
+  * Adapted 15_dvbplayer.dpatch
+  * Added 01_pic2mpg-debian.dpatch
+  * Added 99_ncursesw-include.dpatch
+  * Added opt-49-x_pvrinput.dpatch
+  * Added opt_40-iptv.dpatch
+  * Added latest version of pin patch opt-48_pin-0.1.7.dpatch
+  * Added installation of the pictures plug-in
+  * Line-wrapped dependencies in debian/control
+  * COMPAT=5, debhelper (>= 5)
+  * Made debianize-vdrplugin create cdbs based plugin packages
+  * Using empty directory /usr/lib/vdr/plugins again and adding lintian
+    override for "package-contains-empty-directory" warning - VDR
+    requires the plugin directory!
+  * Added short description to the NAME section of the manpages to fix the
+    Lintian manpage-has-bad-whatis-entry warning
+  * Removed upgrade code for VDR 1.2.6 from postinst
+  * Added some lines of documentation to README.Debian, explaining that
+    plug-ins manually copied to /usr/lib/vdr/plugins will only be loaded
+    when PLUGIN_CHECK_PATCHLEVEL=no (closes: #426921)
+  * Added manpages for vdr-dbg, debugvdr, vdrleaktest, vdrdbg-buildpackage
+    and pic2mpg
+  * Added support for VDR_CHARSET_OVERRIDE=<CHARSET> in /etc/default/vdr
+  * Made vdrleaktest and debugvdr explicitly using bash, because
+    commands-loader.sh and plugin-loader.sh contain bashisms
+  * Instead of setting VFAT=1 at compile time, introduced a new
+    configuration option in /etc/default/vdr (using VDR's 
+    --vfat option), so that the VFAT support can be disabled 
+
+  [ Thomas Günther ]
+  * Adapted 04_newplugin.dpatch
+  * Adapted 10_dd-record-option.dpatch
+  * Adapted opt-24_jumpplay.dpatch
+  * Adapted opt-28_audioindexer.dpatch
+  * Updated opt-39_noepg.dpatch
+  * Updated opt-44_rotor.dpatch
+  * Adapted opt-45_yaepg.dpatch
+  * Adapted opt-50_graphtft.dpatch
+  * Adapted opt-50_graphtft-0.1.dpatch
+  * Adapted opt-51_cuttime.dpatch
+  * Removed 02_Makefile-CFGDIR.dpatch
+  * Removed 17_epg-conv-iso6937.dpatch
+  * Removed opt-27-x_subtitles-ttxtsubs-volumebar-fix.dpatch (now
+    integrated in opt-27_subtitles-ttxtsubs.dpatch)
+  * Removed opt-40_wareagle-icons.dpatch
+  * Added opt-29_syncearly.dpatch and opt-29_syncearly-audioindexer.dpatch
+  * Added opt-48_pin-submenu.dpatch
+  * Added opt-50_graphtft-0.1.dpatch
+  * Replaced opt-27_subtitles-ttxtsubs.dpatch with opt-27_ttxtsubs.dpatch -
+    subtitles support now integrated in upstream (closes: #352442)
+  * Added gettext to Build-Depends
+  * Added libfreetype6-dev and libfontconfig-dev to Build-Depends
+  * Replaced libncurses5-dev with libncursesw5-dev in Build-Depends
+  * Added ttf-bitstream-vera | ttf-freefont to vdr Recommends
+  * Added URL for developer version to debian/watch
+  * Upgraded make-special-vdr.sh to version 0.7
+
+  [ Thomas Schmidt ]
+  * Added vdr-dbg-package + scripts vdrleaktest, debugvdr and
+    vdrdbg-buildpackage from Tobias repository
+  * Updated debian/copyright
+  * Changed config-loader.sh to get default $LANG from /etc/environment
+  * Updated years in debian/copyright
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Mon, 24 Mar 2008 18:58:22 +0100
+
+vdr (1.4.7-3) unstable; urgency=low
+
+  [ Tobias Grimm ]
+  * Synced optional patches with e-tobi.net version of the VDR package
+    - Added opt-50_graphtft-0.1.dpatch
+    - Added opt-51_cuttime.dpatch
+    - Added opt-39_noepg.dpatch
+    - Added opt-32_iptv.dpatch
+    - Added opt-43-x_recordshowfree.dpatch
+    - Added opt-37-x_menuorg.dpatch
+    - Added opt-31-x_reelchannelscan.dpatch
+    - Added opt-48-x_pin.dpatch
+    - Removed opt-37_submenu.dpatch
+    - Updated opt-48_pin.dpatch
+
+  [ Thomas Schmidt ]
+  * Do not ignore errors in clean-target
+  * Added Homepage field to debian/control
+  * Renamed XS-Vcs-* fields to Vcs-* in debian/control
+  * Bumped Standards-Version to 3.7.3
+  * Removed menu file, vdr should always be used as daemon
+  * Do not include empty directory /usr/lib/vdr/plugins
+  * Use ${binary:Version} instead of ${Source-Version} to make package
+    binNMUable
+  * Converted debian/copyright to UTF-8
+  * Removed override for lintian warning menu-command-not-in-package
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sat, 29 Dec 2007 18:06:09 +0100
+
+vdr (1.4.7-2) unstable; urgency=low
+
+  [ Thomas Schmidt ]
+  * Removed support for starting vdr without NPTL-support as glibc 2.5 does
+    not support this anymore
+  * removed creation of dvb-devices in postinst - should be created on every
+    system automatically (closes: #428695)
+
+  [ Thomas Günther ]
+  * Upgraded make-special-vdr.sh to version 0.6 (xineliboutput,
+    burnbackgrounds, debianize-vdrplugin, vompserver)
+
+  [ Tobias Grimm ]
+  * Changed copyright file in the new plug-in template to match
+    the new debian/copyright schema for VDR packages
+
+ -- Tobias Grimm <tg@e-tobi.net>  Fri, 07 Sep 2007 09:53:59 +0200
+
+vdr (1.4.7-1) unstable; urgency=low
+
+  [ Tobias Grimm ]
+  * Added opt-42-x_MainMenuHooks.dpatch
+  * Upgraded opt-48_pin.dpatch
+  * Updated opt-50_graphtft.dpatch
+  * Removed 92_MainMenuHooks.dpatch
+  * Removed opt-42-x_extrecmenu.dpatch
+  * Upgraded opt-27_subtitles-ttxtsubs to Rolf Ahrenberg's
+    vdr-1.4.5-subtitles-0.5.0-and-ttxtsubs-0.0.5.diff.gz (no functional changes,
+    just new version numbers)
+  * Added Portuguese debconf translations (closes: #415495)
+  * Modified 15_dvbplayer.dpatch
+  * vdr will no longer be added to the group cdrom by default. This has to be
+    done by the plugin, using the vdr-groups.sh script introduced in this
+    version
+  * Installing svdrpsend in /usr/bin for easier manual access
+
+  [ Thomas Günther ]
+  * Removed debug logs in 17_epg-conv-iso6937.dpatch
+
+  [ Thomas Schmidt ]
+  * Added vdr-groups.sh script which can be used by plugins which require the
+    user vdr to be a member in additional system groups, see README.Debian
+    for additional information
+  * New upstream release
+  * Added XS-Vcs-Svn and XS-Vcs-Browser fields to debian/control
+  * Removed version from build-dependency to dpatch - even Sarge has the
+    required version
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Mon, 28 May 2007 14:16:19 +0200
+
+vdr (1.4.6-1) experimental; urgency=low
+
+  [ Tobias Grimm ]
+  * Set NONPTL=0 by default - since version 1.3.27 VDR should work with the
+    Native Posix Threading Library without problems. NONPTL can now be
+    enabled for AMD64 systems again, even if this should not be necessary.
+  * Added KEYB_TTY_SWITCH option which, when set to "1", makes VDR switch to
+    the console specified in KEYB_TTY on startup. Before this version, this
+    was the default behaviour when KEYB_TTY was specified. Now it's optional
+    and disabled by default.
+  * Added opt-50_graphtft.dpatch, required by the graphtft plugin version 0.0.15
+  * Replaced "==" in shell scripts with "=" for compatibility reasons
+    (reported by Jörg (Kano) Schirottke)
+  * Updated debianize-vdrplugin for Debian Etch
+
+  [ Thomas Günther ]
+  * Upgraded make-special-vdr.sh to version 0.5 (fixed detection of *.vdr files
+    in burn plugin, updated for new vompserver release, updated for new graphtft
+    release)
+  * Added 17_epg-conv-iso6937.dpatch (convert EPG of UPC Direct / HBO
+    from iso6937 to iso8859-2) (closes: #384836)
+
+  [ Thomas Schmidt ]
+  * New upstream release
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sat, 10 Mar 2007 16:04:26 +0100
+
+vdr (1.4.5-1) experimental; urgency=low
+
+  [ Tobias Grimm ]
+  * Removed Conflicts line from plugin template
+  * Added Lintian override to vdr-dev regarding reports about
+    /usr/share/vdr-dev/plugin-template/rules not being a valid shell script
+  * Added lintian source override for "debian-rules-not-a-makefile"
+  * Removed lintian override for menu-command-not-in-package /usr/lib/menu/vdr:2
+  * Added the complete list of optional patches from the vdr package at e-tobi.net
+    (Ubuntu might want to use them)
+  * Fixed shutdown script to not cause at to generate mails when a shutdown is
+    scheduled for later retry - fix provided by
+    Wolfgang Miller-Reichling <wolfgang@miller-reichling.de>
+  * Added a linda override file to source package - at the moment it will not
+    be installed by any binary package
+
+  [ Thomas Günther ]
+  * Replaced VDRdevel adaptions in debian/rules and plugin-template/rules
+    with make-special-vdr.sh
+  * Install make-special-vdr.sh into vdr-dev package - plugins can use this to
+    build plugin packages for special vdr packages
+  * Changed installation directory of patchlevel.sh and dependencies.sh from
+    /usr/lib/vdr-dev to /usr/share/vdr-dev
+
+  [ Thomas Schmidt ]
+  * New upstream release
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sun, 14 Jan 2007 20:10:35 +0100
+
+vdr (1.4.4-1) unstable; urgency=low
+
+  [ Tobias Grimm ]
+  * New upstream release
+  * Renamed and updated optional subtitles-ttxtsubs example patch
+  * Created symlinks of setup.conf, channels.conf, remote.conf and
+    /etc/default/vdr in /etc/vdr/
+
+  [ Thomas Schmidt ]
+  * Removed linux-kernel-headers build-dependency, not needed anymore
+  * Removed vdr-dev dependency on dvb-dev | linux-kernel-headers
+    (Ubuntu Bug #65340)
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Sun,  5 Nov 2006 17:40:44 +0100
+
+vdr (1.4.3-1) unstable; urgency=low
+
+  * New upstream release
+    - Added LC_ALL=$VDR_LANG when calling vdr in debian/runvdr
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Tue, 26 Sep 2006 21:14:50 +0200
+
+vdr (1.4.2-1) unstable; urgency=low
+
+  * New upstream release
+    - Removed 01_IA64-FTBFS-fix.dpatch
+  * Added Tobias Grimm and Thomas Günther to Uploaders
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Tue, 29 Aug 2006 07:57:05 +0200
+
+vdr (1.4.1-1) unstable; urgency=low
+
+  [ Thomas Günther ]
+  * Upgraded opt-24_jumpplay-0.8.dpatch to opt-24_jumpplay.dpatch version 0.9
+
+  [ Tobias Grimm ]
+  * New upstream release
+  * Stripped default SHUTDOWNCMD to "shutdown -h now"
+  * SHUTDOWNCMD in vdr-shutdown is now executed detached, so that VDR does not
+    block and can cleanly shutdown when receiving SIGTERM
+    (Thanks to Hanno Müller for pointing this out!)
+  * Increased timeout for stopping the VDR daemon from 5 to 30 seconds, because
+    VDR may take pretty long to shut down gracefully
+  * Moved some of the default values in vdr.default to the config loader
+    and added description to README.Debian
+  * Added KEYB_TTY-option which may be overridden in /etc/default/vdr to make
+    VDR switch to and accept input from the specified console
+
+  [ Thomas Schmidt ]
+  * Using new changelog-format (closes: #343871)
+  * debian/runvdr: use LANG=C when starting vdr, to prevent vdr from exiting
+    on system which use UTF8 as default locale, this setting is also
+    configurable in /etc/default/vdr
+  * Added Tobias Grimm, Thomas Günther and myself to debian/copyright
+  * Added LSB-Headers and status action to debian/vdr.init
+  * Added 16_channels.conf.terr-fix.dpatch to fix the example
+    channels.conf.terr
+  * Bumped Standards-Version to 3.7.2
+  * Do not fail silently in postinst if invoke-rc.d vdr fails
+
+ -- Thomas Schmidt <tschmidt@debian.org>  Tue, 15 Aug 2006 07:49:08 +0200
+
+vdr (1.4.0-2) unstable; urgency=low
+
+  * Thomas Günther <tom@toms-cafe.de>
+    - Fixed i18n texts for replay in 10_dd-record-option.dpatch
+    - Upgraded 03_cmdsubmenu.dpatch to version 0.7 - fixes FTBFS with G++ 4.1:
+      extra qualification (closes: #367360)
+    - Upgraded opt-24_jumpplay-0.7.dpatch to opt-24_jumpplay-0.8.dpatch
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Fixed debian/watch
+  
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 27 May 2006 09:54:14 +0200
+
+vdr (1.4.0-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 30 Apr 2006 14:52:45 +0200
+
+vdr (1.3.48-1) unstable; urgency=low
+
+  * New upstream release
+  * Tobias Grimm <tg@e-tobi.net>
+    - Call target clean-plugins instead of plugins-clean in debian/rules
+  * Thomas Günther <tom@toms-cafe.de>
+    - Updated 10_dd-record-option.dpatch
+    - Changed dependencies.sh: don't create conflicts with next vdr version
+    - Changed plugin-loader.sh: detect api version, too
+    - Upgraded 03_cmdsubmenu.dpatch to version 0.6
+    - Removed 16_vdr-1.3.46_menuitems.c-fix.dpatch
+    - Upgraded opt-24_jumpplay-0.6.dpatch to opt-24_jumpplay-0.7.dpatch
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Conflict with vdradmin (<< 3.4.3) to force users to upgrade to
+      vdradmin-am, because the old vdradmin package which is partly 
+      incompatible with newer vdr versions
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue, 18 Apr 2006 00:53:07 +0200
+
+vdr (1.3.46-1) unstable; urgency=low
+
+  * New upstream release
+  * Thomas Günther <tom@toms-cafe.de>
+    - Removed 13_vdr_1.3.45_sources.conf-fix.dpatch
+    - Removed 16_vdr_1.3.45_diseqc.conf-fix.dpatch
+    - Removed 17_replay.dpatch
+    - Removed 99_epg-fix.dpatch
+    - Added 16_vdr-1.3.46_menuitems.c-fix.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun,  9 Apr 2006 17:46:02 +0200
+
+vdr (1.3.45-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Added 13_vdr_1.3.45_sources.conf-fix.dpatch
+      + Added 14_cap-memsize.dpatch
+      + Added 16_vdr_1.3.45_diseqc.conf-fix.dpatch
+      + Updated 11_sortrecordings.dpatch
+      + Updated 15_dvbplayer.dpatch
+      + Removed 18_vdr-1.3.39-menu-on-control.dpatch
+      + Removed 19_vdr-1.3.41-no-title-fix.dpatch
+    - Do not build-depend on dvb-dev anymore, this package is just a
+      dummy-package for easier woody -> sarge upgrades and will be 
+      removed from the archive soon
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 26 Mar 2006 18:08:29 +0200
+
+vdr (1.3.41-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 13_epgfix.dpatch
+      + Added 99_epg-fix.dpatch
+      + Added 19_vdr-1.3.41-no-title-fix.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue,  7 Feb 2006 22:50:56 +0100
+
+vdr (1.3.40-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 19_vdr-1.3.39-clre-crash-fix.dpatch
+      + Removed 20_vdr-1.3.39-schedule-crash-fix.dpatch
+      + Removed 21_vdr-1.3.39-keys-fix.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Thu, 26 Jan 2006 20:51:50 +0100
+
+vdr (1.3.39-2) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Added 01_IA64-FTBFS-fix - fixes FTBFS of vdr>=1.3.38 on ia64
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue, 14 Mar 2006 16:35:14 +0100
+
+vdr (1.3.39-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Updated 06_default_svdrp_port_0.dpatch
+      + Updated 09_sort_options.dpatch
+      + Removed 18_vdr-1.3.38-root-fix.dpatch
+      + Added 18_vdr-1.3.39-menu-on-control.dpatch
+      + Added 19_vdr-1.3.39-clre-crash-fix.dpatch
+      + Added 20_vdr-1.3.39-schedule-crash-fix.dpatch
+      + Added 21_vdr-1.3.39-keys-fix.dpatch
+    - Changed init-script to use almost the same start and stop 
+      functions like ctvdr
+  * Thomas Günther <tom@toms-cafe.de>
+    - Added option "-g /tmp" to vdr call in debian/vdr.init (necessary
+      for image grabbing from vdradmin)
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 22 Jan 2006 11:54:59 +0100
+
+vdr (1.3.38-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 05_set_system_time_as_user.dpatch
+      + Updated 06_default_svdrp_port_0.dpatch
+      + Removed 07_not_as_root.dpatch
+      + Removed 08_security_CAN-2005-0071.dpatch
+      + Added 18_vdr-1.3.38-root-fix.dpatch
+    - Do not try to install ca.conf, because it is not needed anymore
+    - Removed option to set group under which vdr should run from the
+      init-script
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun,  8 Jan 2006 20:13:57 +0100
+
+vdr (1.3.37-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 01_Makefile-fPIC-fix.dpatch
+      + Updated 03_cmdsubmenu.dpatch
+      + Updated 04_newplugin.dpatch
+      + Removed 16_recordings.c-fix.dpatch
+      + Removed 22_vdr-playerepg.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 10 Dec 2005 12:46:15 +0100
+
+vdr (1.3.35-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 16_avoidTrashing.dpatch
+      + Removed 18_vdr-1.3.33-recordingsmenu.dpatch
+      + Removed 19_vdr-1.3.33-recordingsupdate.dpatch
+      + Added 16_recordings.c-fix.dpatch
+    - Corrected FSF address in debian/copyright
+    - Call dh_installman in binary-indep target in debian/rules, to 
+      (re-)include 2 missing manpages
+    - Changed dependencies.sh to create Depends: like 
+      vdr (>= current>), vdr (<< current-9999) without using Conflicts: vdr
+      (>= current-9999) - many thanks to Adeodato Simó for suggesting this
+      (this will hopefully allow vdr+plugins to enter testing without manual
+      hinting)
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue,  1 Nov 2005 21:43:03 +0100
+
+vdr (1.3.33-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 14_update-resume.dpatch
+      + Removed 18_vdr-plugin-sky-fix
+    - Added initial Swedish translation (sv.po) of the debconf template
+      from Daniel Nylander (closes: #330988)
+  * Thomas Günther <tom@toms-cafe.de>
+    - Added 18_vdr-1.3.33-recordingsmenu.dpatch
+    - Added 19_vdr-1.3.33-recordingsupdate.dpatch
+    - Fixed make PLUGINS/lib in debian/rules
+  * Tobias Grimm <tg@e-tobi.net>
+    - Removed formatting spaces from substvars generated by 
+      dpendencies.sh, because dh_gencontrol does not like it
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Mon,  3 Oct 2005 13:26:46 +0200
+
+vdr (1.3.32-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Added 18_vdr-plugin-sky-fix.dpatch
+      + Updated 10_dd-record-option.dpatch
+      + Removed 18_vdr-1.3.31-remuxbraces.dpatch
+      + Removed 19_vdr-1.3.31-remux.dpatch
+      + Removed 20_vdr-1.3.31-sequence-end-code5.dpatch
+      + Removed 21_vdr-1.3.31-skipframes.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 11 Sep 2005 17:58:47 +0200
+
+vdr (1.3.31-3) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Updated 01_Makefile-fPIC-fix.dpatch again, added -fPIC to the Makefile 
+      of the skincurses plugin
+    - Build-Depend on libncurses5-dev, so the skincurses plugin gets compiled
+    - Install the plugins svccli, svcsvr, skincurses and svdrpdemo into the
+      vdr-plugin-examples package
+    - Modified the init-script to not exit silently if vdr is disabled in 
+      /etc/default/vdr (which is the default), instead of this showing a small
+      note how to enable the daemon
+    - Do not try to call vdr with LD_ASSUME_KERNEL=2.4.1 in plugins-loader.sh
+      on amd64 (many thanks to Sören Köpping for reporting the problem and
+      sending a patch) (closes: #326866)
+  * Thomas Günther <tom@toms-cafe.de>
+    - Fixed vdr call with LD_ASSUME_KERNEL=2.4.1 in plugins-loader.sh
+    - Adapted debian/plugin-loader.sh to example plugins
+    - Fixed patchlevel substitution for architecture-independent packages
+    - Removed unnecessary debian/vdr-dev.dirs and unnecessary entries from
+      debian/vdr.dirs
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue,  6 Sep 2005 14:19:43 +0200
+
+vdr (1.3.31-2) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Updated 01_Makefile-fPIC-fix.dpatch, added -fPIC to the Makefiles
+      of the new example plugins to fix the FTBFS on some architectures
+  
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Fri,  2 Sep 2005 23:26:47 +0200
+
+vdr (1.3.31-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+    - Use --background when calling start-stop-daemon in the init-script
+    - Added 16_avoidTrashing.dpatch, which prevents vdr from trashing the 
+      file system buffers when reading/writing recordings
+    - Added 18_vdr-1.3.31-remuxbraces - Fixes some gcc4 warning messages 
+    - Added 19_vdr-1.3.31-remux - Fixes a bug in cVideo/AudioRepacker::Repack()
+    - Added 20_vdr-1.3.31-sequence-end-code5 - Fixes a problem with appending 
+      a sequence end code when moving cutting marks in radio recordings
+    - Added 21_vdr-1.3.31-skipframes - Fixes a problem with skipping frames
+      when moving cutting marks in radio recordings
+    - Added dependencies.sh to vdr-dev to automatically fill in the right
+      Depends and Conflicts to vdr when building a plugin
+    - Cleaned up debian/rules and synced as far as possible with the version
+      from Tobias inofficial vdr package and changed a few things as suggested
+      by Thomas Günther
+  * Tobias Grimm <tg@e-tobi.net>
+    - Made debian/patchlevel.sh accept opt-entries in 00list with leading
+      spaces and removed leading space from vdr-patchlevel output
+  * Thomas Günther <tom@toms-cafe.de>
+    - Made debian/plugin-template/rules svn-buildpackage-save
+    - Updated 15_dvbplayer.dpatch
+    - Added 22_vdr-playerepg.dpatch - Fixes mp3 plugin problems
+    - Made debian/plugin-template/control and debian/plugin-template/rules
+      compatible with dependencies.sh and new patchlevel.sh
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Fri,  2 Sep 2005 17:14:02 +0200
+
+vdr (1.3.30-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Should fix the FTBFS on several arches (closes: #324082)
+    - Added 11_sortrecordings.dpatch, to allow changing the sort-order
+      of the recordings
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 27 Aug 2005 19:34:47 +0200
+
+vdr (1.3.29-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+  * Thomas Günther <tom@toms-cafe.de>
+    - Improved newplugin script
+    - Updated opt-24_jumpplay-0.6.dpatch
+    - Added 13_epgfix.dpatch to force saving of EPG data on exit
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Mon, 15 Aug 2005 17:31:44 +0200
+
+vdr (1.3.28-2) unstable; urgency=low
+
+  * Tobias Grimm <tg@e-tobi.net>
+    - Added osdbase-maxitems patch, which fixes a problem with the Enigma skin
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 14 Aug 2005 14:33:39 +0200
+
+vdr (1.3.28-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 13_remote.dpatch
+      + Removed 16_dvbspu.dpatch
+      + Updated 10_dd-record-option.dpatch
+      + Updated 15_dvbplayer.dpatch
+    - vdr-dev: depend on ${misc:Depends}, debhelper, 
+      dvb-dev (>= 1.0.0) | linux-kernel-headers (>=2.5.999-test7-bk-6) 
+    - vdr-dev: suggests dh-make
+  * Tobias Grimm <tg@e-tobi.net>
+    - Extract patch infos and install to /usr/share/doc/vdr/patchinfo
+    - Renamed 01_vdr_1.2.6-3.1.diff.gz to 01_Makefile-fPIC-fix
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue,  9 Aug 2005 20:45:37 +0200
+
+vdr (1.3.27-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 12_nptl.dpatch
+      + Removed 18_vdr-1.3.26-pagedown-fix.dpatch
+    - The new upstream version seems to compile fine with gcc-4.0 
+      (closes: #294041)
+    - Added 10_dd-record-option.dpatch - allows to choose if to record
+      or to replay Dolby Digital independently
+    - Updated 03_cmdsubmenu.dpatch and opt-24_jumpplay-0.6.dpatch to the
+      versions from vdrdevel
+    - Now using debian/watch from vdrdevel
+    - Bumped Standards-Version to 3.6.2
+  * Tobias Grimm <tg@e-tobi.net>
+    - Added installation of README.vps and README.developer
+    - Fixed parameter passing in vdr-shutdown
+    - Fixed package description
+    - Replaced some tabs with spaces and fixed indentation
+    - Took over commands-loader.sh from vdrdevel
+    - Added ${shlibs:Depends}
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Wed, 29 Jun 2005 15:49:58 +0200
+
+vdr (1.3.26-1) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Added 18_vdr-1.3.26-pagedown-fix.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 12 Jun 2005 16:52:15 +0200
+
+vdr (1.3.25-1) experimental; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Updated 05_set_system_time_as_user.dpatch
+    - Create device files silently
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Tue, 31 May 2005 14:06:49 +0200
+
+vdr (1.3.24-1) experimental; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 10_livelock.dpatch
+      + Removed 11_memleak.dpatch
+      + Updated 15_dvbplayer.dpatch
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Mon,  9 May 2005 15:47:50 +0200
+
+vdr (1.3.23-1) experimental; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - New upstream release
+      + Removed 01_gcc3.4-FTBFS-fix.dpatch
+      + Removed 09_amd64_epg.dpatch
+      + Removed opt-23_osdpip-0.0.3.dpatch
+      + Removed opt-20_elchiaio4d+1.dpatch
+      + Removed opt-22_8bitcolor.dpatch
+      + Updated jumpplay patch to version 0.6
+    - Use LD_ASSUME_KERNEL=2.4.1 when calling vdr in plugins-loader.sh
+    - Changes suggested by Thomas Günther <tom@toms-cafe.de>
+      + debian/watch: Updated to show the newest developer versions
+      + Install PLUGINS.html in vdr-dev only
+      + Install libsi header files in package vdr-dev
+      + Added XB-VDR-Patchlevel-field in debian/control to vdr-dev too
+      + Changed a few typos in README.Debian
+      + Added commands.update-recordings.conf from vdrdevel to have a 
+        command for updating the recordings list manually
+      + Added "Blue LCARS" and "Cool" themes from vdrdevel
+      + Added update-resume patch from vdrdevel (updates the resume
+        status of recordings after replaying them)
+  * Tobias Grimm <tg@e-tobi.net>
+    - Don't restrict root capabilities with --allow-root anymore
+    - Passing $OPTIONS to binary compatibility test in plugin loader now
+  * Darren Salt <linux@youmustbejoking.demon.co.uk>
+    - Added patches:
+      + 09_sort_options: extra channel sort options
+      + 10_livelock: don't hang when jumping between editing marks
+      + 11_memleak: fix two small memory leaks
+      + 12_nptl: don't abort if NPTL is in use
+      + 15_dvbplayer: send proper I-frames [Reinhard Nissl]
+      + 16_dvbspu: fix some SPU bugs [Reinhard Nissl]
+      + 17_replay: improve end-of-recording handling [Reinhard Nissl]
+    - Replaced the ttxtsubs patch with a combined subtitles+ttxtsubs patch.
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Wed, 04 May 2005 17:17:55 +0200
+
+vdr (1.2.6-13) unstable; urgency=medium
+
+  * Darren Salt <linux@youmustbejoking.demon.co.uk>
+    - Make the usage of NPTL configurable in /etc/default/vdr
+    - Disable the usage of NPTL on amd64 in runvdr (this always 
+      overrides  the setting in /etc/default/vdr) (closes: #305098)
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Added psmisc to the depends of the package vdr (thanks to Martin 
+      Langer <martin-langer@gmx.de> for the hint)
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Thu, 05 May 2005 21:47:56 +0200
+
+vdr (1.2.6-12) unstable; urgency=low
+
+  * Tobias Grimm <tg@e-tobi.net>
+    - Don't restrict root capabilities with --allow-root anymore
+    - Passing $OPTIONS to binary compatibility test in plugin loader now
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Add "Provides: vdr-daemon, vdr-kbd, vdr-lirc, vdr-rcu" to package 
+      vdr to ensure smooth upgrades
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 10 Apr 2005 17:00:24 +0200
+
+vdr (1.2.6-11) unstable; urgency=low
+
+  * Tobias Grimm <tg@e-tobi.net> 
+    - Modified not-as-root-patch to allow to start VDR as root anyway, if the
+      option --allow-root is given
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 09 Apr 2005 22:29:02 +0200
+
+vdr (1.2.6-10) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Added patch for the EPG handling under amd64 (closes: #300702)
+    - Check for existance of /usr/sbin/runvdr before sourcing the
+      config-loader.sh script (closes: #302826)
+    - Fixed small typos in the package descriptions of vdr and 
+      vdr-dev (closes: #300042, #300074)
+    - Add user vdr to group cdrom in postinst, so that vdr is able to
+      play DVDs with the dvd-plugin again
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 09 Apr 2005 18:32:59 +0200
+
+vdr (1.2.6-9) experimental; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Change owner of /proc/{av7110_ir,budget_ci_ir} to the uid and 
+      gid under which vdr will run in /usr/sbin/runvdr 
+      (closes: #297640)
+    - Added 13_remote.dpatch from Darren Salt, this allows to have
+      just 1 binary for all 4 possible control methods, and it should
+      reduce build-time by about 75%
+    - Removed packages vdr-daemon, vdr-kbd, vdr-lirc, vdr-rcu because 
+      they are not necessary anymore
+    - Added "Conflicts and Replaces: vdr-daemon, vdr-kbd, vdr-lirc, 
+      vdr-rcu" to debian/control
+    - Removed Andreas Müller from uploaders - he does not intend 
+      to do uploads anymore
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 12 Mar 2005 20:05:06 +0100
+
+vdr (1.2.6-8) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - Removed patch which fixes the compilation with gcc-4.0 on 
+      amd64 as it causes vdr to crash, will have to investigate 
+      this further, before the patch can be re-added 
+      (closes: #295838)
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sat, 19 Feb 2005 15:17:38 +0100
+
+vdr (1.2.6-7) unstable; urgency=low
+
+  * Thomas Schmidt <tschmidt@debian.org>
+    - This is the first upload of vdr, i can do by myself, i want 
+      to thank Andreas Müller (amu) and Christoph Martin (chrism) 
+      for their help with sponsoring previous uploads
+    - Only try to change capabilities when vdr is called by root 
+      (closes: #293042)
+    - Added patch from Andreas Jochens to fix the FTBFS on amd64
+      with gcc-4.0 (closes: #294041)
+    - Changed my email-address to the new debian one
+    - Make an entry in syslog when someone tries to shutdown vdr
+      while the automatic shutdown is disabled
+    
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Wed, 09 Feb 2005 12:41:49 +0100
+
+vdr (1.2.6-6) unstable; urgency=high
+
+  * Urgency high because it includes a fix for CAN-2005-0071
+  * Thomas Günther <tom@toms-cafe.de>
+    - new (optional) plugin check (with "vdr -V -P plugin")
+    - Extracted patchlevel code to patchlevel.sh 
+    - Installing patchlevel.sh into vdr-dev package
+  * Tobias Grimm <tg@e-tobi.net> 
+    - fixed small bug in vdr-recordingaction
+    - moved PLUGIN_DIR, PLUGIN_PREFIX, CFG_DIR, PLUGIN_CFG_DIR,
+      PLUGIN_ORDER_FILE, CMDHOOKSDIR, REC_CMD from the default file to 
+      the init script
+    - fixed bug in shutdown script (OSD messages have to be deferred until
+      the shutdown script is finished)
+    - removed PLUGIN_ORDER_FILE paramter, order.conf should always be in
+      PLUGIN_CFG_DIR
+    - set default location for epg.data to /var/cache/vdr (vdr -E)
+    - The default command to shutdown the system when the power-off-key of the
+      remote is pressed, can now be configured in /etc/default/vdr.
+    - When processing the shutdown hooks, no further hook scripts will be
+      processed, if one script requests to delay the shutdown.
+    - Extracted loading of VDR daemon config options to separate file for
+      later reuse by other start scripts
+    - Fixed warning message in generated commands.conf and reccmds.conf  
+  * Thomas Schmidt <thomas.schmidt@in.stud.tu-ilmenau.de>
+    - Do not run as user root anymore, the user vdr will be created
+      and the video-directory and config-files will be changed, so the
+      owner/group is vdr:vdr (closes: #287899)
+    - Added 07_not_as_root.dpatch - vdr exists when it should run as
+      user or with group-id root (adapted from Darren Salt's patch 
+      for vdr 1.3.x)
+    - Added 08_security_CAN-2005-0071.dpatch - do not overwrite 
+      existing files with the GRAB-Command anymore (CAN-2005-0071)
+    - Set default port for SVDRP to 0, users who run vdr from the 
+      commandline will have to enable it by using the --port option
+      (in the init-script SVDRP will still be enabled and on the default 
+      port 2001)
+    - Added vdr-shutdown.wrapper with owner/group root:vdr and mode 6750, 
+      which calls the normal vdr-shutdown-script so that the user vdr is 
+      able to run vdr's shutdown-hooks
+    - The automatic shutdown is now disabled by default, to enable it 
+      again you have to change ENABLE_SHUTDOWN=0 to 1 in /etc/default/vdr
+    - Changed package vdr to Architecture: any, because it now contains
+      a binary file
+    - Added patch from Ludwig Nussel to be able to synchronize the system-
+      time via DVB, even when vdr runs as user
+    - Build-depend on libcap-dev
+    - Package vdr: depend on adduser
+    - Remove some files under /var/lib/vdr and /var/cache/vdr in postrm 
+      on purge (closes: #287914)
+    - Added german (de.po) debconf-translation from Jens Nachtigall 
+      <nachtigall@web.de> (closes: #273643)
+    - Added a note to the package description and README.Debian that vdr
+      (without special plugins) requires a DVB-Card with an mpeg-decoder
+      (Closes: #287428)
+    - Improved runvdr-script: when no loaded dvb-modules were found, 
+      try to load the module dvb (could be an alias for the real 
+      dvb-module)
+    - Added XB-VDR-Patchlevel-field in debian/control to vdr-plugin-sky 
+      and vdr-plugin-examples
+    - Build-depend on dpatch (>= 2.0.9)
+    - Converted existing dpatch-files to the new short format
+    - Added newplugin-script as vdr-newplugin to vdr-dev, so 
+      plugin-developers can initialize a new plugin-directory without a 
+      normal vdr-source-tree
+    - Added debianize-vdrplugin-script and the plugin-template-dir from 
+      c't-vdr
+    - Added lintian-override to avoid the lintian-warnings for the
+      plugin-template-scripts
+    - Default VIDEO_DIR is now /var/lib/video.00, so new harddisks can
+      be added very easy by mounting them to /var/lib/video.0{1,2,...}
+      (if the old directory /var/lib/video exists, create 
+      /var/lib/video.00 as symlink to the old directory, if it does
+      not exist, /var/lib/video will be a symlink to /var/lib/video.00)
+    - Removed unnecessary debconf-question about creating the dvb 
+      devices, they will now be created without any question when they
+      are not existing already
+    - Removed libncurses5-dev from Build-Depends
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Wed, 19 Jan 2005 00:12:03 +0100
+
+vdr (1.2.6-5) unstable; urgency=low
+
+  * Tobias Grimm <tg@e-tobi.net> 
+    - fixed Bug in vdr-shutdown script - osd messages have to be send detached
+    - added patchlevel check in vdr.init - only plugins that have been compiled
+      with the same patch levels will be loaded, to avoid conflicts due to
+      binary incompatibility.
+    - removed dh_shlibdeps and $shlibs:Depends from binary independent target
+    - extracted common patch code from dpatch files
+    - added patchlevel generation
+    - added patchlevel checking when loading plugins - it's enabled in
+      /etc/default by setting PLUGIN_CHECK_PATCHLEVEL="yes"
+    - added ElchiAio4d as optional patch (see README.Debian)
+    - added ttxtsubs-patch as optional patch
+    - added 8-bit-color-patch as optional patch
+    - added osdpip-patch as optional patch
+    - added jumpplay-patch as optional patch
+    - an entry in the (commands|reccmds).order.conf can now be disabled by
+      prepending a "-", just like this is done in the plugins.order.conf too
+  * Thomas Schmidt <thomas.schmidt@in.stud.tu-ilmenau.de>
+    - It is not possible anymore to start more than one instance of vdr
+      with the init-script
+    - Changed runvdr-script as suggested by Nikolaus Regnat (Closes: #258412)
+    - Fix spelling error in vdr.postinst (Closes: #258615)
+    - Changed Maintainer to Debian VDR and DVB Packaging team
+      <pkg-vdr-dvb-devel@lists.alioth.debian.org>
+    - List Andreas Mueller <amu@tr.debian.net> as Uploader
+    - Added patch from Andreas Jochens <aj@andaco.de> to fix FTBFS with
+      gcc 3.4 (Closes: #262744)
+    - Changed $PLUGIN_CFG_DIR in /etc/default/vdr, to /etc/vdr/plugins 
+      (Closes: #264071)
+    - Changed package-description of vdr-plugin-examples a little bit
+
+ -- Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>  Sun, 08 Aug 2004 19:48:33 +0200 
+
+vdr (1.2.6-4) unstable; urgency=low
+
+  * First release from the VDR and DVB Packaging team
+    (pkg-vdr-dvb-devel@lists.alioth.debian.org)
+
+  * Thomas Schmidt
+    - Acknowledge NMU (Closes: #238395)
+    - Use dpatch, so build-depend on dpatch
+    - Build-Depend on: dvb-dev | linux-kernel-headers
+    - Separate plugins from the vdr-package (new packages: 
+      vdr-plugin-examples and vdr-plugin-sky)
+    - Change architecture of package vdr to all - it does not 
+      contain any architecture-dependent files anymore
+    - Cleaned up some parts to avoid lintian warnings and errors
+    - Use makedev for device-generation in postinst, therefore 
+      depend on makedev
+    - Removed build-dep to g++
+    - Added LD_ASSUME_KERNEL=2.4 in runvdr, to be able to run vdr 
+      under 2.6 without problems
+    - New cfg-dir /var/lib/vdr, link static cfg-files from /etc/vdr to
+      /var/lib/vdr, install channels.conf in postinst to /var/lib/vdr,
+      move non-static cfg-files to /var/lib/vdr in postinst
+    - Add an option to vdr, to specify the cfg-dir at build-time,
+      and set this to /var/lib/vdr (Closes: Bug#233647)
+    - Selection of vdr-binary now handled by update-alternatives
+    - Changed runvdr, to quote plugin-options correct (Closes: Bug#239619)
+    - Applied patch from Emmanuel le Chevoir (Closes: Bug#238713)
+    - Updated debconf-translations:
+      + French (fr.po) by Emmanuel le Chevoir
+      + Czech (cs.po) by Miroslav Kure
+      + Dutch (nl.po) by Luk Claes
+    - Added myself as uploader
+    - Added correct watch-file
+    - Added manpage for runvdr
+
+  * Tobias Grimm <vdr@e-tobi.net>
+    - added automatic loading of plugins in init script from c't vdr
+      (see README.Debian)
+    - added dynamic generation of reccmds.conf and commands.conf from c't vdr
+      (see README.Debian)
+    - added recording hooks as used in c't vdr (see README.Debian)
+    - added cmd_submenus patch with improvements by Thomas Günther
+    - added shutdown hooks as used in c't vdr (see README.Debian)
+
+ -- Thomas Schmidt <thomas.schmidt@in.stud.tu-ilmenau.de>  Sat, 24 Apr 2004 12:04:41 +0200
+
+vdr (1.2.6-3.1) unstable; urgency=low
+
+  * Non-Maintainer-Upload during Bug-Squashing-Party.
+  * Applied patch by Lamont Jones to build all shared libraries
+    with -fPIC. (Closes: #238395)
+
+ -- Michael Banck <mbanck@debian.org>  Sun, 18 Apr 2004 13:49:48 +0200
+
+vdr (1.2.6-3) unstable; urgency=low
+
+  * Moved /video to /var/lib/video now we should FHS conform
+    Thx to Noel Koethe. (Closes: #234429)
+  * changed control to arch any/all for buildd.d.o 
+
+ -- Andreas Mueller <amu@tr.debian.net>  Sat, 13 Mar 2004 02:27:00 +0100
+    
+vdr (1.2.6-2) unstable; urgency=low
+
+  * Thx to Nikolaus Regnat
+  * Corrected runvdr script dvb module detection. (Closes: #233520)
+  * Switched to gettext-based debconf templates (Thx to Martin Quinson). (Closes: #233107)  
+  * Improved debconf question texts.
+  * Fixed vdr.postinst script so that channels.conf is no longer overwritten.
+    (Closes: #233646)
+  * Fixed bug in vdr.postinst script which prevented package upgrade.
+  * Adapted debian/rules to use upstream make plugin/plugin-clean targets. (Closes: #233630)
+
+ -- Andreas Mueller <amu@tr.debian.net>  Wed, 18 Feb 2004 17:08:34 +0100
+
+vdr (1.2.6-1) unstable; urgency=low
+
+  * Thx to Nikolaus Regnat
+  * New upstream release.
+  * Corrected plugin installation. Plugin libs do now reside in
+    /usr/lib/vdr/plugins. (Closes: #227074)
+  * Install needed configuration files in /etc/vdr.
+  * Changed (in /etc/default/vdr) CFG_DIR="/etc/vdr". (Closes: #227084)
+  * Added debconf info about needed kernel-modules.
+  * Added debconf question to select dvb card type.
+  * Added debconf question to create /video filesystem.
+  * Added debconf question to create dvb device nodes.
+  * Declared ca.conf, diseqc.conf, keymacros.conf, sources.conf and
+    svdrphosts.conf as conffiles.
+  * Added lirc dependency to vdr-lirc.
+  * Removed loading of hello plugin (in /etc/default/vdr) as it is useless.
+  * Modified runvdr script to accept lsmod output of module-init-tools (kernel
+    2.6). (Closes: #227059)
+  * Used the --port=0 option (in /etc/default/vdr) to disable SVDRP port.
+  * Accepted various suggestion on packaging improvement (Closes: #227084)
+    
+ -- Andreas Mueller <amu@tr.debian.net>  Sat, 10 Jan 2004 15:25:27 +0100
+
+vdr (1.2.5-3) unstable; urgency=low
+
+  * moved plugins-dir to /usr/lib/vdr
+
+ -- Andreas Mueller <amu@tr.debian.net>  Mon,  21 Sep 2003 19:23:12 +0200
+
+vdr (1.2.5-2) unstable; urgency=low
+
+  * vdr_1.2.5-1.dsc: invalid 'Build-Depends' field produced by a broken
+    version of dpkg-dev (1.10.11). Now build with 1.10.13
+
+ -- Andreas Mueller <amu@tr.debian.net>  Tue,  18 Sep 2003 01:10:47 +0200
+
+
+vdr (1.2.5-1) unstable; urgency=low
+
+  * new upstream build
+  * Moved to Standards-Version: 3.6.1
+
+ -- Andreas Mueller <amu@tr.debian.net>  Tue,  17 Sep 2003 22:12:38 +0200
+
+
+vdr (1.2.2-1) unstable; urgency=low
+
+  * new upstream build
+    (closes: Bug#195951)
+
+ -- Andreas Mueller <amu@tr.debian.net>  Tue,  9 Sep 2003 11:27:00 +0200
+
+vdr (1.0.4-3) unstable; urgency=low
+
+  * some cosmetic things ( ex. autobuilder )
+  * added autobuilder support
+
+ -- Andreas Mueller <amu@tr.debian.net>  Mon,  10 Mar 2003 11:27:00 +0100
+
+vdr (1.0.4-2) unstable; urgency=low
+
+  * took package from Eduard/QA
+    (closes: Bug#134645)
+    (closes: Bug#158158)
+
+ -- Andreas Mueller <amu@tr.debian.net>  Sat,  4 Jan 2003 16:27:00 +0100
+
+vdr (1.0.4-1) unstable; urgency=low
+
+  * New upstream release
+
+ -- Eduard Bloch <blade@debian.org>  Sat,  3 Aug 2002 12:22:20 +0200
+
+vdr (1.0.0-1) unstable; urgency=medium
+
+  * New upstream (stable) release
+  * removed manpages hocus-pocus and forced to use new version to avoid
+    trashing of vdr.1. Closes: #142809
+  * removed kvdr references, it is broken anyways
+
+ -- Eduard Bloch <blade@debian.org>  Sun,  7 Apr 2002 23:43:41 +0200
+
+vdr (0.98+1.0.0pre5-1) unstable; urgency=high
+
+  * New upstream (pre)release, closes: #141035
+  * Urgency high, since the Woody version is already broken since the new
+    drivers entered it recently
+  * incompatible with kvdr, set Conflicts:
+  * Changed the build-system to DBS like
+  * Added the tools pack from Upstream's web location and the FORMATS file
+  * Not including the DVD patch, too unstable.
+
+ -- Eduard Bloch <blade@debian.org>  Wed,  3 Apr 2002 12:10:31 +0200
+
+vdr (0.98-2) unstable; urgency=medium
+
+  * Disabled SVDRP port as-default and noted in README.Debian.
+    Better secure than warned and less secure. Closes: #117193
+  * added more Build-Depends, closes: #123701
+  * now conflicting with previous kvdr version and recommending the new since
+    kvdr would break starting vdr-daemon without port specification.
+
+ -- Eduard Bloch <blade@debian.org>  Thu, 13 Dec 2001 00:58:01 +0100
+
+vdr (0.98-1) unstable; urgency=low
+
+  * New upstream release
+  * fixed spelling errors
+
+ -- Eduard Bloch <blade@debian.org>  Wed, 14 Nov 2001 09:56:49 +0100
+
+vdr (0.96-4) unstable; urgency=low
+
+  * improved Description, thanks to Joey and Alfie
+  * included README and other scripts, maybe useful
+
+ -- Eduard Bloch <blade@debian.org>  Thu, 11 Oct 2001 12:56:42 +0200
+
+vdr (0.96-3) unstable; urgency=high
+
+  * all versions except of -daemon disable the control port by default
+    (possible security hole). Debconf warning for -daemon.
+  * package splitted
+  * building additional vdr-daemon binary, needed for kvdr
+  * fixed postinst files, there were too much copy&paste work :(
+
+ -- Eduard Bloch <blade@debian.org>  Mon,  8 Oct 2001 13:21:31 +0200
+
+vdr (0.96-2) unstable; urgency=low
+
+  * enabled DVD support after helping Brian to fix libdvdread packages
+
+ -- Eduard Bloch <blade@debian.org>  Sun,  7 Oct 2001 16:27:53 +0200
+
+vdr (0.96-1) unstable; urgency=low
+
+  * New upstream release
+  * removed upx stuff
+  * no DVD support until the libdvdread2 package is ready
+
+ -- Eduard Bloch <blade@debian.org>  Tue,  2 Oct 2001 02:24:51 +0200
+
+vdr (0.95-1) unstable; urgency=low
+
+  * Initial Release, closes: #113106
+  * Made a little hack to create the channel.conf template from Debian examples
+
+ -- Eduard Bloch <blade@debian.org>  Sat, 22 Sep 2001 03:16:11 +0200
--- vdr-1.6.0.orig/debian/vdr.install
+++ vdr-1.6.0/debian/vdr.install
@@ -0,0 +1,44 @@
+vdr-kbd                   usr/bin/
+debian/scripts/vdr-daemon usr/bin/
+debian/scripts/vdr-lirc   usr/bin/
+debian/scripts/vdr-rcu    usr/bin/
+
+debian/runvdr usr/sbin/
+
+debian/config-loader.sh   usr/lib/vdr/
+debian/plugin-loader.sh   usr/lib/vdr/
+debian/commands-loader.sh usr/lib/vdr/
+debian/vdr-groups.sh      usr/lib/vdr/
+
+epg2html.pl  usr/lib/vdr/
+svdrpsend.pl usr/lib/vdr/
+
+
+debian/order.conf etc/vdr/plugins/
+
+debian/order.commands.conf etc/vdr/command-hooks/
+debian/order.reccmds.conf  etc/vdr/command-hooks/
+
+debian/commands.custom.conf             etc/vdr/command-hooks/
+debian/reccmds.custom.conf              etc/vdr/command-hooks/
+debian/commands.update-recordings.conf  usr/share/vdr/command-hooks/
+
+diseqc.conf       etc/vdr/
+keymacros.conf    etc/vdr/
+sources.conf      etc/vdr/
+svdrphosts.conf   etc/vdr/
+debian/vdr.groups etc/vdr/
+
+debian/vdr-recordingaction usr/lib/vdr/
+debian/R90.custom          etc/vdr/recording-hooks/
+
+debian/themes/*.theme       var/lib/vdr/themes/
+
+debian/vdr-shutdown         usr/lib/vdr/
+debian/vdr-shutdown-message usr/lib/vdr/
+debian/vdr-shutdown.wrapper usr/lib/vdr/
+debian/S90.custom           etc/vdr/shutdown-hooks/
+
+debian/lintian/vdr usr/share/lintian/overrides/
+
+locale                                  usr/share/
--- vdr-1.6.0.orig/debian/vdr-plugin-sky.examples
+++ vdr-1.6.0/debian/vdr-plugin-sky.examples
@@ -0,0 +1 @@
+PLUGINS/src/sky/*.sky
--- vdr-1.6.0.orig/debian/vdr-plugin-sky.install
+++ vdr-1.6.0/debian/vdr-plugin-sky.install
@@ -0,0 +1 @@
+PLUGINS/lib/libvdr-sky.so.* usr/lib/vdr/plugins/
--- vdr-1.6.0.orig/debian/commands.custom.conf
+++ vdr-1.6.0/debian/commands.custom.conf
@@ -0,0 +1,30 @@
+#
+# This is an example file for defining external commands, that will be 
+# accessible via VDR's OSD menu.
+# The commands will be executed under the same user id that vdr is running 
+# with, so take care if your are running vdr as root!
+# 
+# The format of a command entry is:  <title> : <command>
+# <title> is the menu text shown on the OSD and <command> is the command to
+# be executed. Everything that <command> writes to stdout will be displayed
+# on the OSD. i.e.:
+#
+# Open fortune cookie: /usr/games/fortune
+#
+# If you uncomment the line above and restart vdr, you will have a new 
+# command menu entry, called "Open fortune cookie", that will show you a 
+# random epigram. ( you may need an "apt-get install fortune" first! )
+#
+# If you are using the reccmd-patch, you can even divide your commands into
+# submenus. To do so, prefix all sub menu items with a "-". i.e.:
+# 
+# Fortune Cookies ... : echo "sub menu, no command"
+# -Long Dictum        : /usr/games/fortune -l
+# -Short Apothegms    : /usr/games/fortune -s
+# -Special Topics ... : echo "sub-sub menu, no command"
+# --Literature        : /usr/games/fortune literature
+# --Riddles           : /usr/games/fortune riddles
+#
+# Again, just uncomment the above lines and restart vdr to see for your self,
+# how this looks like on the OSD.
+#
--- vdr-1.6.0.orig/debian/watch
+++ vdr-1.6.0/debian/watch
@@ -0,0 +1,3 @@
+version=2
+ftp://ftp.tvdr.de/vdr/vdr-([\d\.]+)\.tar\.bz2
+#ftp://ftp.tvdr.de/vdr/Developer/vdr-([\d\.]+)\.tar\.bz2
--- vdr-1.6.0.orig/debian/config-loader.sh
+++ vdr-1.6.0/debian/config-loader.sh
@@ -0,0 +1,77 @@
+#
+# This file is called by /etc/init.d/vdr
+#
+
+#
+# Defaults - don't touch, edit options for the VDR daemon in
+# /etc/default/vdr !!!
+#
+
+# Config-Directory
+CFG_DIR="/var/lib/vdr"
+
+# Plugin-Directory
+PLUGIN_DIR="/usr/lib/vdr/plugins"
+
+# Plugin Config-Directory
+PLUGIN_CFG_DIR="/etc/vdr/plugins"
+
+# Plugin prefix
+PLUGIN_PREFIX="libvdr-"
+
+# Command-Hooks Directory
+CMDHOOKSDIR="/usr/share/vdr/command-hooks"
+
+# Commmand executed on start, stop and editing of a recording
+REC_CMD=/usr/lib/vdr/vdr-recordingaction
+
+# Commmand executed by vdr to shutdown the system
+SHUTDOWNCMD="/sbin/shutdown -h now"
+
+# EPG data file
+EPG_FILE=/var/cache/vdr/epg.data
+
+# Username under which vdr will run (Note: the user root is not 
+# allowed to run vdr, vdr will abort when you try to start it as 
+# root or with "-u root")
+USER=vdr
+
+# Default port for SVDRP
+SVDRP_PORT=2001
+
+# Enable / Disable vdr daemon
+ENABLED=0
+
+# Enable / Disable automatic shutdown
+ENABLE_SHUTDOWN=0
+
+# Video-Directory
+VIDEO_DIR="/var/lib/video.00"
+
+# Set this to load only startable plugins (check with "vdr -V -P plugin")
+PLUGIN_CHECK_STARTABLE="yes"
+
+# Default Console for controlling VDR by keyboard. Empty means no console
+# input.
+KEYB_TTY=""
+
+# Set this to 1 to make VDR switch to the console specified in KEYB_TTY
+# on startup
+KEYB_TTY_SWITCH=0
+
+# get locale which is used for running vdr from /etc/default/locale or
+# /etc/environment or fall back to "C"
+ENV_FILE="none"
+[ -r /etc/environment ] && ENV_FILE="/etc/environment"
+[ -r /etc/default/locale ] && ENV_FILE="/etc/default/locale"
+[ $ENV_FILE = none ] || \
+  for var in LANG LC_ALL; do
+    eval VDR_LANG=$(egrep "^[^#]*${var}=" $ENV_FILE | tail -n1 | cut -d= -f2)
+    [ -z "$VDR_LANG" ] || break
+  done
+[ -z "$VDR_LANG" ] && VDR_LANG="C"
+
+# Enable VFAT file system support by default
+VFAT=1
+
+test -f /etc/default/vdr && . /etc/default/vdr
--- vdr-1.6.0.orig/debian/patchcheck.py
+++ vdr-1.6.0/debian/patchcheck.py
@@ -0,0 +1,90 @@
+#!/usr/bin/python
+
+import re
+import md5
+import os
+from optparse import OptionParser
+
+PATCHES_FILE = 'debian/.vdr-patches'
+
+def file_name_for_patch_variant(baseFileName):
+    if options.patchVariant:
+        return baseFileName + "." + options.patchVariant
+    else:
+        return baseFileName
+
+def get_active_patches():
+    active_patches = {}
+    for line in open(file_name_for_patch_variant("debian/patches/00list"), "r"):
+        match = re.match('^(?!00_)([^#]+)', line.rstrip())
+        if match:
+            patchFileName = "debian/patches/" + match.group(1)
+            if not os.path.exists(patchFileName):
+                patchFileName += ".dpatch"
+            if os.path.exists(patchFileName):
+                active_patches[patchFileName] = md5.new(open(patchFileName).read()).hexdigest()
+    return active_patches
+
+def get_last_patches():
+    lastPatches = {}
+    for line in open(file_name_for_patch_variant(PATCHES_FILE), "r"):
+        match = re.match('(.+):(.+)', line.rstrip())
+        if match:
+            lastPatches[match.group(1)] = match.group(2)
+    return lastPatches
+        
+def update_patchlist():
+    patchListFile = open(file_name_for_patch_variant(PATCHES_FILE), "w")
+    patches = get_active_patches()
+    for fileName in patches:
+        patchListFile.write(fileName + ":" + patches[fileName] + "\n")
+                    
+def report_patches(patches, reportText):
+    if len(patches) > 0:
+        print reportText
+        for p in patches:
+            print "    " + p
+        print
+
+def check_patches():
+    active_patches = get_active_patches()
+    last_patches = get_last_patches()    
+
+    new_patches = [p for p in active_patches if last_patches.keys().count(p) == 0]
+    removed_patches = [p for p in last_patches if active_patches.keys().count(p) == 0]
+    changed_patches = [p for p in last_patches if p in active_patches and active_patches[p] != last_patches[p]]
+        
+    report_patches(new_patches, "The following patches are new:")
+    report_patches(removed_patches, "The following patches have been disabled:") 
+    report_patches(changed_patches, "The following patches have been modified:")
+    
+    if len(new_patches) + len(removed_patches) + len(changed_patches) > 0:
+        commandLine = "debian/rules accept-patches"
+        abiVersion = "abi-version"
+        if options.patchVariant:
+            commandLine = "PATCHVARIANT=" + options.patchVariant + " " + commandLine
+            abiVersion += "." + options.patchVariant
+        print "Please check, if any of the above changes affects VDR's ABI!"
+        print "If this is the case, then update %s and run" % abiVersion
+        print "'%s' to update the snapshot of" % commandLine
+        print "the current patch level."
+        exit(1)
+
+#
+# main()
+#
+
+parser = OptionParser()
+
+parser.add_option("-u", "--update", action="store_true", dest="doUpdate", help="updated the list of accepted patches")
+parser.add_option("-c", "--check", action="store_true", dest="doCheck", help="check patches")
+parser.add_option("-p", "--patchvariant", dest="patchVariant", help="use a patch variant")
+
+(options, args) = parser.parse_args()
+
+if options.doCheck:
+    check_patches()
+elif options.doUpdate:
+    update_patchlist()
+else:
+    parser.print_help()
--- vdr-1.6.0.orig/debian/vdrleaktest
+++ vdr-1.6.0/debian/vdrleaktest
@@ -0,0 +1,75 @@
+#!/bin/bash
+
+# We need bash here, because of the *-loader.sh scripts containing bashisms!
+
+## NAME
+##   vdrleaktest - Runs the VDR debugging binary with Valgrind.
+## 
+## SYNOPSIS
+##   vdrleaktest [-h] [vdr-options]
+## 
+## DESCRIPTION
+##   vdrleaktest will stop any running VDR daemon and start the debugging
+##   version of VDR with Valgrind. No plugins will be loaded automatically.
+##   In order to test VDR plugins with vdrleaktest, you need to pass the
+##   appropriate VDR arguments (e.g. -P plugin-name).
+## 
+## OPTIONS
+##   -h This help
+## 
+##   All other options will be passed down to VDR
+## 
+## SEE ALSO
+##   vdr(1), valgrind(1)
+## 
+## AUTHOR
+##   This manual page was written by Tobias Grimm <tg@e-tobi.net>
+## 
+### txt2man -s 1 -t VDRLEAKTEST -v "Start VDR with Valgrind"
+
+usage()
+{
+    local HELPCOMMENTPATTERN="^## "
+    cat "$0" | grep "$HELPCOMMENTPATTERN" | sed "s/$HELPCOMMENTPATTERN//"
+}
+
+
+while getopts h opt
+do
+    case $opt in
+        h)
+            usage
+            exit
+            ;;
+    esac
+done
+
+#
+# Check for Valgrind
+#
+
+if [ ! -x /usr/bin/valgrind ] ; then
+    echo "ERROR: Please install valgrind first!" >&2
+    exit 1
+fi
+
+#
+# c't-VDR Memory Leak Tester
+#
+
+. /usr/lib/vdr/config-loader.sh
+. /usr/lib/vdr/commands-loader.sh
+
+mergecommands "commands"
+mergecommands "reccmds"
+
+/etc/init.d/vdr stop
+
+LANG=C LD_LIBRARY_PATH="/usr/lib/debug${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}" \
+   valgrind --tool=memcheck --leak-check=yes --num-callers=20 \
+   --suppressions=/usr/share/vdr/valgrind.supp \
+   /usr/bin/vdr-dbg -v $VIDEO_DIR -c $CFG_DIR -L $PLUGIN_DIR  -r $REC_CMD \
+   -E $EPG_FILE -g /tmp $OPTIONS --port $SVDRP_PORT --lirc \
+   "$@"
+
+/etc/init.d/vdr restart
--- vdr-1.6.0.orig/debian/debianize-vdrplugin
+++ vdr-1.6.0/debian/debianize-vdrplugin
@@ -0,0 +1,82 @@
+#!/bin/sh
+
+detect_plugin_name()
+{
+    local PATTERN='.*\/\(.*\)-\([0-9][0-9a-zA-Z+.~-]*\)$'
+    if pwd | grep -q -E ".*\/.*-[0-9][0-9a-zA-Z+.~-]*$" ; then
+        PLUGIN=`pwd | sed "s/$PATTERN/\1/"`
+        VERSION=`pwd | sed "s/$PATTERN/\2/"`
+    else
+        echo "debianize-vdrplugin expects the upstream sources to be extracted in a"
+        echo "directory named:  <PLUGIN-NAME>-<VERSION>"
+        echo 
+        echo "e.g.: coolplugin-0.0.1"
+        echo 
+        echo "The upsteam tarball should be named: vdr-<PLUGIN-NAME>-<VERSION>.tar.gz"
+        echo 
+        echo "e.g.: vdr-coolplugin-0.0.1.tar.gz"
+        echo 
+        exit 1
+    fi
+}
+
+create_orig_tarball()
+{
+    local tarball
+
+    ORIGTARBALL="../vdr-plugin-$PLUGIN"_"$VERSION.orig.tar.gz"
+    
+    if [ -e $ORIGTARBALL ] ; then
+        return
+    fi
+    
+    for tarball in `find ../ -name "*$PLUGIN-$VERSION.t*gz"`; do
+        ln -sf `basename $tarball` $ORIGTARBALL
+        return
+    done
+      
+    for tarball in `find ../ -name "*$PLUGIN-$VERSION.t*bz2"`; do
+        /bin/bzip2 -cd $tarball | /bin/gzip --best > $ORIGTARBALL
+        return
+    done
+}
+
+check_dh_make()
+{
+    if [ ! -x /usr/bin/dh_make ] ; then
+        echo "If you want to use this script, please install the package dh-make!"
+        exit 1
+    fi
+}
+
+replace_vdr_version()
+{
+    VDRVERSION=`dpkg -s vdr-dev | awk '/Version/ { print $2 }'`
+    perl -pi -e "s/#VDRVERSION#/$VDRVERSION/g" debian/control
+}
+
+replace_plugin_name()
+{
+    perl -pi -e "s/#PLUGIN#/$PLUGIN/g" debian/install
+    perl -pi -e "s/#PLUGIN#/$PLUGIN/g" debian/links.ex
+}
+
+#
+# main()
+#
+
+check_dh_make
+detect_plugin_name
+create_orig_tarball
+
+dh_make="/usr/bin/dh_make -t /usr/share/vdr-dev/plugin-template -b -p vdr-plugin-$PLUGIN"
+if [ ! -e $ORIGTARBALL ] ; then
+    dh_make="$dh_make -r"
+fi
+
+$dh_make
+
+if [ "$?" -eq "0" ]; then
+    replace_vdr_version
+    replace_plugin_name
+fi
--- vdr-1.6.0.orig/debian/vdr-plugin-examples.install
+++ vdr-1.6.0/debian/vdr-plugin-examples.install
@@ -0,0 +1,8 @@
+PLUGINS/lib/libvdr-hello.so.*           usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-osddemo.so.*         usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-svccli.so.*          usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-svcsvr.so.*          usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-skincurses.so.*      usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-status.so.*          usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-svdrpdemo.so.*       usr/lib/vdr/plugins/
+PLUGINS/lib/libvdr-pictures.so.*        usr/lib/vdr/plugins/
--- vdr-1.6.0.orig/debian/rules
+++ vdr-1.6.0/debian/rules
@@ -0,0 +1,195 @@
+#!/usr/bin/make -f
+# Sample debian/rules that uses debhelper.
+# GNU copyright 1997 to 1999 by Joey Hess.
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+ifneq (,$(findstring debug,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -g
+endif
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+	INSTALL_PROGRAM += -s
+endif
+
+# To use dpatch uncomment the following line and set Build-Depends to dpatch
+DPATCH=yes
+
+ifdef DPATCH
+include /usr/share/dpatch/dpatch.make
+else
+patch:
+patch-stamp:
+unpatch:
+endif
+
+TXT2MANPAGES = debian/vdr-dbg.1
+MANPAGES = debian/vdrdbg-buildpackage.1 debian/debugvdr.1 debian/vdrleaktest.1
+
+MAKE_OPTIONS = REMOTE=LIRC CONFDIR=/var/lib/vdr LOCDIR=/usr/share/locale \
+               VIDEODIR=/var/lib/video.00 PLUGINLIBDIR=/usr/lib/vdr/plugins
+
+$(MANPAGES): %.1: %
+	sh $< -h | \
+	  eval "`cat $< | grep "^### txt2man" | sed "s/### //"`" >$@
+
+$(TXT2MANPAGES): %.1: %.1.txt
+	cat $< | grep -v "^###" | \
+	  eval "`cat $< | grep "^### txt2man" | sed "s/### //"`" >$@
+
+OOLIST := debian/patches/00list
+ABIVERSION := debian/abi-version
+ifdef PATCHVARIANT
+    OOLIST := $(OOLIST).$(PATCHVARIANT)
+    ABIVERSION := $(ABIVERSION).$(PATCHVARIANT)
+    PATCHCHECKOPTION := -p $(PATCHVARIANT)
+endif
+
+prepare-00list:
+	python debian/patchcheck.py -c $(PATCHCHECKOPTION)
+	cmp -s $(OOLIST) debian/patches/00list || \
+	  cp -b --suffix=.save $(OOLIST) debian/patches/00list
+
+restore-00list:
+	[ ! -e debian/patches/00list.save ] || \
+	  mv debian/patches/00list.save debian/patches/00list
+
+accept-patches:
+	python debian/patchcheck.py -u $(PATCHCHECKOPTION)
+
+configure: configure-stamp
+configure-stamp: prepare-00list patch-stamp
+	dh_testdir
+	touch configure-stamp
+
+build: build-stamp $(MANPAGES) $(TXT2MANPAGES)
+build-stamp: configure-stamp
+	dh_testdir
+
+	# build unoptimized vdr with debugging symbols
+	touch po/vdr.pot po/*.po
+	$(MAKE) all $(MAKE_OPTIONS) BUILDVDR=yes VDRDEBUG=yes DEB_BUILD_OPTIONS=nostrip,noopt
+	cp vdr vdr-dbg
+	$(MAKE) -o .dependencies clean $(MAKE_OPTIONS)
+
+	# build "productive" vdr
+	touch po/vdr.pot po/*.po
+	$(MAKE) all $(MAKE_OPTIONS) BUILDVDR=yes
+	ln -f vdr vdr-kbd
+
+	# plugins
+	mkdir -p PLUGINS/lib
+	$(MAKE) plugins $(MAKE_OPTIONS)
+
+	cp newplugin vdr-newplugin
+
+	gcc -o debian/vdr-shutdown.wrapper debian/vdr-shutdown-wrapper.c
+
+	touch build-stamp
+
+patchinfo:
+	sh debian/extract-patchinfo >debian/patchinfo
+
+clean: clean-patched unpatch restore-00list
+clean-patched:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+	$(MAKE) -o .dependencies clean-plugins $(MAKE_OPTIONS)
+	$(MAKE) -o .dependencies clean $(MAKE_OPTIONS)
+	rm -f vdr-dbg
+	rm -f vdr-kbd
+	rm -rf PLUGINS/lib
+	rm -f vdr-newplugin
+	rm -f debian/vdr-shutdown.wrapper
+	rm -f debian/patchinfo
+	rm -f $(MANPAGES) $(TXT2MANPAGES)
+	dh_clean
+
+install: patchinfo build
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+	dh_install
+	chmod +x $(CURDIR)/debian/vdr/usr/lib/vdr/vdr-*
+	for example in hello osddemo pictures servicedemo skincurses status svdrpdemo; do \
+	    install -D PLUGINS/src/$$example/README $(CURDIR)/debian/vdr-plugin-examples/usr/share/doc/vdr-plugin-examples/README.$$example; \
+	done
+	echo -n "vdr:Provides=" >> debian/vdr.substvars
+	cat $(ABIVERSION) >> debian/vdr.substvars
+	install -m644 $(ABIVERSION) $(CURDIR)/debian/vdr-dev/usr/share/vdr-dev/abi-version
+ifdef PATCHVARIANT
+	mkdir -p $(CURDIR)/debian/vdr/usr/share/doc/vdr
+	mkdir -p $(CURDIR)/debian/vdr-dev/usr/share/doc/vdr-dev
+	grep ^opt- $(OOLIST) >$(CURDIR)/debian/vdr/usr/share/doc/vdr/optional-patches.txt
+	cp $(CURDIR)/debian/vdr/usr/share/doc/vdr/optional-patches.txt \
+	  $(CURDIR)/debian/vdr-dev/usr/share/doc/vdr-dev/optional-patches.txt
+endif
+
+
+# Build architecture-independent files here.
+binary-indep: build install
+	dh_testdir -i
+	dh_testroot -i
+#	dh_installdebconf -i
+	dh_installdocs -i
+	dh_installexamples -i
+#	dh_installmenu -i
+#	dh_installlogrotate -i
+#	dh_installemacsen -i
+#	dh_installpam -i
+#	dh_installmime -i
+#	dh_installinit -i
+#	dh_installcron -i
+	dh_installman -i
+#	dh_installinfo -i
+#	dh_undocumented -i
+	dh_installchangelogs -i HISTORY
+	dh_link -i
+	dh_strip -i
+	dh_compress -i
+	dh_fixperms -i
+#	dh_makeshlibs -i
+	dh_installdeb -i
+	dh_perl -i
+	dh_shlibdeps -i
+	dh_gencontrol -i
+	dh_md5sums -i
+	dh_builddeb -i
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir -a
+	dh_testroot -a
+	dh_installdebconf -a
+	dh_installdocs -a -Nvdr-dbg
+	dh_installexamples -a
+	dh_installmenu -a
+#	dh_installlogrotate -a
+#	dh_installemacsen -a
+#	dh_installpam -a
+#	dh_installmime -a
+	dh_installinit -a
+#	dh_installcron -a
+	dh_installman -a
+#	dh_installinfo -a
+#	dh_undocumented -a
+	dh_installchangelogs -pvdr HISTORY
+	dh_installchangelogs -pvdr-plugin-sky PLUGINS/src/sky/HISTORY
+	dh_installchangelogs -pvdr-plugin-examples
+	dh_link -a
+	dh_strip -a -Xvdr-dbg
+	dh_compress -a
+	dh_fixperms -a
+#	dh_makeshlibs -a
+	dh_installdeb -a
+	dh_perl -a
+	dh_shlibdeps -a
+	dh_gencontrol -a
+	dh_md5sums -a
+	dh_builddeb -a
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure \
+        clean-patched patch unpatch
--- vdr-1.6.0.orig/debian/valgrind.supp
+++ vdr-1.6.0/debian/valgrind.supp
@@ -0,0 +1,22 @@
+#
+# This is a valgrind suppression file for VDR
+#
+
+{
+   cThread::Start
+   Memcheck:Param
+   write(buf)
+   fun:write
+   fun:_ZN7cThread5StartEv
+}
+
+{
+   cThread::Start/pthread_create
+   Memcheck:Param
+   write(buf)
+   fun:write
+   fun:pthread_create@@GLIBC_2.1
+   fun:_ZN7cThread5StartEv
+   fun:_ZN11cRecordings6UpdateEb
+   fun:main
+}
--- vdr-1.6.0.orig/debian/vdr.docs
+++ vdr-1.6.0/debian/vdr.docs
@@ -0,0 +1,6 @@
+README*
+CONTRIBUTORS
+MANUAL
+INSTALL
+UPDATE*
+debian/patchinfo
--- vdr-1.6.0.orig/debian/vdr.dirs
+++ vdr-1.6.0/debian/vdr.dirs
@@ -0,0 +1,3 @@
+usr/lib/vdr/plugins
+var/cache/vdr
+var/lib/vdr/plugins
--- vdr-1.6.0.orig/debian/vdr-newplugin.1
+++ vdr-1.6.0/debian/vdr-newplugin.1
@@ -0,0 +1,26 @@
+.\" Man page for vdr-newplugin
+
+.TH vdr-newplugin 1
+.SH NAME
+vdr-newplugin \- create a new VDR plugin source tree
+.SH SYNOPSIS
+
+.B vdr-newplugin
+.I <pluginname>
+
+.SH DESCRIPTION
+.B vdr-newplugin
+creates a new plugin source directory from which to start implementing
+a plugin for VDR.
+
+The source directory will be created in the active working-directory.
+
+.SH AUTHOR
+This man-page has been written by Thomas Schmidt <thomas@thsnet.de>
+.PP
+Permission is granted to copy, distribute and/or modify this document under
+the terms of the GNU General Public License, Version 2 any
+later version published by the Free Software Foundation.
+.PP
+On Debian systems, the complete text of the GNU General Public
+License can be found in /usr/share/common\-licenses/GPL.
--- vdr-1.6.0.orig/debian/vdr-dbg.1.txt
+++ vdr-1.6.0/debian/vdr-dbg.1.txt
@@ -0,0 +1,21 @@
+### txt2man -s 1 -t VDR-DBG -v "Debug version of VDR"
+
+NAME
+  vdr-dbg - Starts the debugging version of vdr
+
+SYNOPSIS
+  vdr-dbg [vdr-options]
+
+DESCRIPTION
+  vdr-dbg is a debugging version of vdr, containing all debugging
+  symbols. vdr-dbg will not unload plugins, to be able to track memory
+  leaks in VDR plugins with valgrind.
+
+OPTIONS
+  All vdr options are available for vdr-dbg as well.
+
+SEE ALSO
+       vdr(1), debugvdr(1), vdrleaktest(1)
+
+AUTHOR
+       This manual page was written by Tobias Grimm <tg@e-tobi.net>.
--- vdr-1.6.0.orig/debian/order.commands.conf
+++ vdr-1.6.0/debian/order.commands.conf
@@ -0,0 +1,10 @@
+#
+# If you like a fixed order in your commands menu, place the command base names
+# (commands.<basename>.conf) here.
+#
+# If you want a certain command file not to be loaded automatically at 
+# vdr-startup, then you can simply write "-basename" in this file.
+
+firstcommand
+secondcommand
+-thirdcommand
--- vdr-1.6.0.orig/debian/control
+++ vdr-1.6.0/debian/control
@@ -0,0 +1,82 @@
+Source: vdr
+Section: video
+Priority: extra
+Maintainer: Debian VDR Team <pkg-vdr-dvb-devel@lists.alioth.debian.org>
+Uploaders: Thomas Schmidt <tschmidt@debian.org>, Tobias Grimm <etobi@debian.org>, Thomas Günther <tom@toms-cafe.de>
+Build-Depends: debhelper (>= 5), dpatch, libjpeg62-dev, libcap2-dev | libcap-dev,
+  libncursesw5-dev, libfreetype6-dev, libfontconfig-dev, gettext,
+  txt2man, python, linux-libc-dev
+Standards-Version: 3.9.1
+Vcs-Svn: svn://svn.debian.org/pkg-vdr-dvb/vdr/vdr/trunk/
+Vcs-Browser: http://svn.debian.org/wsvn/pkg-vdr-dvb/vdr/vdr/trunk/
+Homepage: http://www.tvdr.de/
+
+Package: vdr
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}, adduser, psmisc
+Recommends: lirc, ttf-bitstream-vera | ttf-freefont
+Provides: vdr-daemon, vdr-kbd, vdr-lirc, vdr-rcu, ${vdr:Provides}
+Conflicts: vdr-daemon, vdr-kbd, vdr-lirc, vdr-rcu, vdradmin (<< 3.4.3)
+Replaces: vdr-daemon, vdr-kbd, vdr-lirc, vdr-rcu
+Description: Video Disk Recorder for DVB cards
+ Video Disk Recorder (VDR) is a digital sat-receiver program using
+ Linux and DVB technologies. It allows one to record MPEG2 streams,
+ as well as output the stream to TV. It is also possible to watch DVDs
+ (hardware accelerated) with some comfort and use an IR remote control.
+ .
+ This package contains the vdr main program which is controlled via the
+ PC keyboard or a IR remote control.
+ .
+ NOTE: You should install compatible DVB drivers before using these
+ programs. Also the standard VDR (without special plugins) requires 
+ a DVB-Card with an integrated mpeg-decoder, a so called 
+ Full-Featured Card.
+
+Package: vdr-dev
+Architecture: all
+Depends: ${misc:Depends}, debhelper, linux-libc-dev
+Suggests: dh-make
+Description: Video Disk Recorder for DVB cards
+ Video Disk Recorder (VDR) is a digital sat-receiver program using
+ Linux and DVB technologies. It allows one to record MPEG2 streams,
+ as well as output the stream to TV. It is also possible to watch DVDs
+ (hardware accelerated) with some comfort and use an IR remote control.
+ .
+ This package contains the header files of VDR.
+ You need this package to be able to build vdr-plugins!
+
+Package: vdr-dbg
+Section: debug
+Priority: extra
+Architecture: any 
+Depends: ${shlibs:Depends}, ${misc:Depends}, vdr (= ${binary:Version}), gdb
+Suggests: valgrind
+Description: Debuggable version of the VDR Video Disk Recorder
+ This package installs an unoptimized vdr binary with debugging symbols as well
+ as some helper scripts to debug VDR and its plugins.
+
+Package: vdr-plugin-sky
+Architecture: any 
+Depends: ${shlibs:Depends}, ${misc:Depends}, vdr (= ${binary:Version})
+Description: Plugin for using a Sky Digibox with vdr
+ Video Disk Recorder (VDR) is a digital sat-receiver program using
+ Linux and DVB technologies. It allows one to record MPEG2 streams,
+ as well as output the stream to TV.
+ .
+ This package contains the sky-plugin, which allows you to connect 
+ the analog a/v output of a Sky Digibox to VDR, so that you can 
+ enjoy the full recording flexibility of VDR with your Sky 
+ subscription. 
+
+Package: vdr-plugin-examples
+Architecture: any 
+Depends: ${shlibs:Depends}, ${misc:Depends}, vdr (= ${binary:Version})
+Description: Plugins for vdr to show some possible features
+ Video Disk Recorder (VDR) is a digital sat-receiver program using
+ Linux and DVB technologies. It allows one to record MPEG2 streams,
+ as well as output the stream to TV.
+ .
+ This package contains the example-plugins hello, osddemo, svccli, 
+ svcsvr, skincurses, status and svdrpdemo from the vdr-source. 
+ These plugins do not have useful features, they only demonstrate 
+ how vdr-plugins work and what is possible to do with them.
--- vdr-1.6.0.orig/debian/plugin-loader.sh
+++ vdr-1.6.0/debian/plugin-loader.sh
@@ -0,0 +1,122 @@
+#
+# This file is called by /etc/init.d/vdr
+#
+
+getplugins ()
+{
+    local plugin_order
+    local installed_plugins
+    local ordered_plugins
+    local plugin
+    local i
+    local arguments
+    local plugins
+    local packages
+    local leftout
+    local leftout2
+    local vdrcmd
+    local version
+
+    vdrcmd="/usr/bin/vdr -u $USER $OPTIONS"
+
+    CACHE_DIR="/var/cache/vdr"
+    CACHE_FILE="${CACHE_DIR}/plugin_search_cache"
+    CACHE_MD5="${CACHE_FILE}.md5"
+
+    version=`eval "$vdrcmd -V -L/usr/bin/vdr 2>/dev/null | sed 's/.*(\(.*\)).*/\1/'"`
+    test "$version" || version="unknown version"
+
+    PLUGINS=""
+
+    echo -ne "\nSearching for plugins (VDR $version) "
+
+    # find installed plugins
+    version=`echo "$version" | sed 's:.*/::'`
+    # cached plugin index up to date ?
+    if [ -e ${CACHE_MD5} ] && \
+       [ -e ${CACHE_FILE} ] && \
+       md5sum ${PLUGIN_DIR}/${PLUGIN_PREFIX}*.so.${version} ${CACHE_FILE} 2>&1 | cmp -s - ${CACHE_MD5}
+    then
+        plugins=`cat ${CACHE_FILE}`
+        echo -ne "(cache hit):"
+    else
+        echo -ne "(cache miss):"
+        # clear stale cache files
+        rm -f ${CACHE_FILE} ${CACHE_MD5}
+        plugins=(`find ${PLUGIN_DIR} -maxdepth 1 \
+                       -name "${PLUGIN_PREFIX}*.so.${version}" | \
+                   xargs -r dpkg -S 2>&1 | \
+                   sed "s/^dpkg:/'':/" | \
+                   sed "s/:.*${PLUGIN_PREFIX}\([^\.]\+\)\.so\.${version}.*$/:\1/"`)
+        # write results into cache
+        echo ${plugins[@]} > ${CACHE_FILE}
+        md5sum ${PLUGIN_DIR}/${PLUGIN_PREFIX}*.so.${version} ${CACHE_FILE} > ${CACHE_MD5} 2>&1
+    fi
+    installed_plugins=(`echo ${plugins[@]} | sed 's/[^ ]*://g'`)
+    packages=(   vdr   `echo ${plugins[@]} | sed 's/:[^ ]*//g'`)
+
+    if [ "$PLUGIN_CHECK_STARTABLE" = "yes" ]; then
+
+        # move not startable plugins to $leftout2
+        for (( i=${#installed_plugins[@]}, i-- ; i >= 0 ; i-- )); do
+            if ! eval "$vdrcmd -V -L $PLUGIN_DIR -P ${installed_plugins[$i]}" \
+                2>/dev/null | grep -q "^${installed_plugins[$i]} "; then
+                leftout2="${leftout2} ${installed_plugins[$i]}"
+                unset installed_plugins[$i]
+            fi
+        done
+
+        # cleanup the installed_plugins array
+        installed_plugins=( "${installed_plugins[@]}" )
+    fi
+
+    if [ -r "$PLUGIN_CFG_DIR/order.conf" ]; then
+        # load plugin order
+        plugin_order=( `cat $PLUGIN_CFG_DIR/order.conf | sed "s/#.*$//"` )
+
+        # move ordered plugins to list of ordered plugins
+        for plugin in ${plugin_order[@]}; do
+            for (( i=0 ; i<${#installed_plugins[@]} ; i++ )); do
+                if [ "$plugin" = "-${installed_plugins[$i]}" ]; then
+                    unset installed_plugins[$i]
+                    installed_plugins=( "${installed_plugins[@]}" )
+                    break
+                fi
+                if [ "$plugin" = "${installed_plugins[$i]}" ]; then
+                    ordered_plugins=( "${ordered_plugins[@]}" "$plugin" )
+                    unset installed_plugins[$i]
+                    installed_plugins=( "${installed_plugins[@]}" )
+                    break
+                fi
+            done
+        done
+    fi
+
+    # append unordered to ordered plugins
+    ordered_plugins=( "${ordered_plugins[@]}" "${installed_plugins[@]}" )
+
+    # add the command line arguments for each plugin
+    for plugin in ${ordered_plugins[@]}; do
+        echo -n " $plugin"
+        if [ -r "$PLUGIN_CFG_DIR/plugin.$plugin.conf" ] ; then
+            arguments=( `cat $PLUGIN_CFG_DIR/plugin.$plugin.conf | sed "s/#.*$//"` )
+            PLUGINS="$PLUGINS -P \"$plugin ${arguments[*]}\""
+        else
+            PLUGINS="$PLUGINS -P $plugin"
+        fi
+    done
+
+    # warn about incompatible plugins
+    if [ ! -z "$leftout" ]; then
+        echo -ne "\nWARNING: The following plugins have been left out due to"\
+             "possible binary incompatibility: "
+        echo -n $leftout
+    fi
+
+    # warn about not startable plugins
+    if [ ! -z "$leftout2" ]; then
+        echo -ne "\nWARNING: The following plugins have been left out due to"\
+             "really binary incompatibility: "
+        echo -n $leftout2
+    fi
+}
--- vdr-1.6.0.orig/debian/vdr.default
+++ vdr-1.6.0/debian/vdr.default
@@ -0,0 +1,15 @@
+# /etc/default/vdr
+#
+# See also /usr/share/doc/vdr/README.Debian.gz
+#
+
+# Change to 1 to enable vdr's init-script
+ENABLED=0
+
+# Change this to 1 if you want vdr to be able to shutdown the
+# computer
+ENABLE_SHUTDOWN=0
+
+# Options that will be passed to vdr's commandline
+# for example: OPTIONS="-w 15"
+OPTIONS="-w 60"
--- vdr-1.6.0.orig/debian/vdr-dev.manpages
+++ vdr-1.6.0/debian/vdr-dev.manpages
@@ -0,0 +1,3 @@
+debian/vdr-newplugin.1
+debian/debianize-vdrplugin.1
+debian/vdrdbg-buildpackage.1
--- vdr-1.6.0.orig/debian/order.conf
+++ vdr-1.6.0/debian/order.conf
@@ -0,0 +1,16 @@
+#
+# If you like a fixed plugin order in your menu place the plugin base names
+# here. Remember that the first entry a plugin may get, starts at five in 
+# VDR's OSD.
+#
+# If you want a certain Plugin not to be loaded automatically at 
+# vdr-startup, then you can simply write "-pluginname" in this file.
+# 
+# If you want to add commandline-options for a certain plugin, this file is 
+# not the right place - you can add them in the file(s) 
+# /etc/vdr/plugins/plugin.<pluginname>.conf - each option in one line
+
+firstplugin
+secondplugin
+-thirdplugin
+-fourthplugin
--- vdr-1.6.0.orig/debian/vdr.init
+++ vdr-1.6.0/debian/vdr.init
@@ -0,0 +1,141 @@
+#! /bin/bash -p
+#
+# vdr start-stop script
+#
+### BEGIN INIT INFO
+# Provides:          vdr
+# Required-Start:    $remote_fs $network $syslog
+# Required-Stop:     $remote_fs $network $syslog
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: Starts the Linux Video Disk Recorder (VDR)
+# Description:       Starts the Linux Video Disk Recorder (VDR),
+#                    if it is enabled in /etc/default/vdr.
+### END INIT INFO
+
+PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
+NAME=vdr
+DESC="Linux Video Disk Recorder"
+
+DAEMON=/usr/sbin/runvdr
+PIDFILE=/var/run/runvdr.pid
+VDRPRG=/usr/bin/vdr
+
+test -x $DAEMON || exit 0
+test -x $VDRPRG || exit 0
+
+. /usr/lib/vdr/config-loader.sh
+
+# Set shutdown command
+test "$ENABLE_SHUTDOWN" = "1" && VDRSHUTDOWN="/usr/lib/vdr/vdr-shutdown.wrapper" \
+                              || VDRSHUTDOWN="/usr/lib/vdr/vdr-shutdown-message"
+
+. /usr/lib/vdr/plugin-loader.sh
+. /usr/lib/vdr/commands-loader.sh
+
+
+clean_console()
+{
+    if [ "$KEYB_TTY" != "" ]; then
+        tput -Tlinux clear > $KEYB_TTY
+    fi
+}
+
+configure_console_input()
+{
+    if [ "$KEYB_TTY" != "" ]; then
+        clean_console
+        echo -e "This tty is currently mapped to VDR, keypresses aren't echoed.\r" > $KEYB_TTY
+        echo -n "For a login prompt switch to another console." > $KEYB_TTY
+        REDIRECT="< $KEYB_TTY"
+        if [ "$KEYB_TTY_SWITCH" = "1" ]; then
+            chvt `echo "$KEYB_TTY" | sed "s/\/dev\/tty//"`
+        fi
+    fi
+}
+
+get_status()
+{
+    if start-stop-daemon --start --startas $DAEMON --test \
+        --name $(basename $DAEMON) --pidfile $PIDFILE >/dev/null
+    then
+        echo " - is not running."
+        exit 3
+    else
+        echo " - is running."
+        exit 0
+    fi
+}
+
+startvdr()
+{
+    if [ "$ENABLED" != "0" ] ; then
+        # only start vdr if there is no other instance running
+        if start-stop-daemon --start --startas $DAEMON --test \
+            --name $(basename $DAEMON) --pidfile $PIDFILE >/dev/null
+        then
+            getplugins
+            mergecommands "commands"
+            mergecommands "reccmds"
+            configure_console_input
+
+            if [ "$VFAT" == "1" ]; then
+                OPTIONS="--vfat $OPTIONS"
+            fi
+
+            start-stop-daemon --start --quiet --startas $DAEMON --background \
+                --name $(basename $DAEMON) --pidfile $PIDFILE --make-pidfile -- \
+                -v $VIDEO_DIR -c $CFG_DIR -L $PLUGIN_DIR -r $REC_CMD \
+                -s $VDRSHUTDOWN -E $EPG_FILE -u $USER -g /tmp \
+                --port $SVDRP_PORT $OPTIONS $PLUGINS $REDIRECT
+        else
+            echo -n " - seems to be running already"
+        fi
+    else
+        echo -n " - aborted (to enable the daemon, edit /etc/default/vdr)"
+    fi
+}
+
+stopvdr()
+{
+    if start-stop-daemon --stop --retry 30 \
+        --name $(basename $DAEMON) --pidfile $PIDFILE >/dev/null
+    then
+        start-stop-daemon --stop --retry 30 --oknodo --exec $VDRPRG-kbd >/dev/null
+        rm -f $PIDFILE
+        clean_console
+    else
+        echo -n " - seems not to be running"
+    fi
+}
+
+case "$1" in
+    start)
+        echo -n "Starting $DESC: $NAME"
+        startvdr
+        echo "."
+        ;;
+    stop)
+        echo -n "Stopping $DESC: $NAME"
+        stopvdr
+        echo "."
+        ;;
+    restart|force-reload)
+        echo -n "Restarting $DESC: $NAME"
+        stopvdr
+        sleep 4
+        startvdr
+        echo "."
+        ;;
+    status)
+        echo -n "Getting status of $DESC: $NAME"
+        get_status
+        ;;
+    *)
+        N=/etc/init.d/$NAME
+        echo "Usage: $N {start|stop|restart|force-reload}" >&2
+        exit 1
+        ;;
+esac
+
+exit 0
--- vdr-1.6.0.orig/debian/vdr-shutdown-wrapper.c
+++ vdr-1.6.0/debian/vdr-shutdown-wrapper.c
@@ -0,0 +1,3 @@
+int main (int argc, char *argv[]) {
+   return execv("/usr/lib/vdr/vdr-shutdown", argv);
+}
--- vdr-1.6.0.orig/debian/extract-patchinfo
+++ vdr-1.6.0/debian/extract-patchinfo
@@ -0,0 +1,47 @@
+#!/bin/sh
+
+print_patch()
+{
+    author=`dpatch cat --author-only $1`
+    patch_name=`echo $1 | sed 's/[^_]*_\(.*\)/\1/'`
+    patch_description=`dpatch cat --no-meta $patch` 
+    echo $patch_name:
+    if [ ! -z "$author" ] ; then
+       echo "    $author"
+       echo
+    fi
+    if [ ! -z "$patch_description" ] ; then
+        echo $patch_description | fmt | sed 's/\(.*\)/    \1/'
+    fi
+    echo
+}
+
+echo "Patches applied to vanilla vdr sources"
+echo "--------------------------------------"
+echo
+
+patches_applied=`dpatch list-all`
+for patch in $patches_applied ; do
+    print_patch $patch
+done
+
+echo
+echo "Patches available in source package, but not active"
+echo "---------------------------------------------------"
+echo
+
+patches_available=`find debian/patches -name *.dpatch -printf "%f\n" | sed 's/\(.*\)\.dpatch/\1/'`
+for patch in $patches_available ; do
+    is_applied="no"
+
+    for applied_patch in $patches_applied ; do
+        if [ $applied_patch = $patch ] ; then
+            is_applied="yes"
+            break
+        fi
+    done
+    
+    if [ $is_applied = "no" ] ; then
+        print_patch $patch
+    fi
+done
--- vdr-1.6.0.orig/debian/vdr.groups
+++ vdr-1.6.0/debian/vdr.groups
@@ -0,0 +1,9 @@
+#
+# If you add the user vdr manually to a group, you should list this
+# group here. The plugin installation / deinstallation procedures may
+# automatically remove vdr from a group, that isn't listed here.
+#
+
+# vdr should be in the groups vdr and video. You shouldn't change this!
+vdr
+video
--- vdr-1.6.0.orig/debian/vdr.examples
+++ vdr-1.6.0/debian/vdr.examples
@@ -0,0 +1,2 @@
+*.conf
+channels.conf.*
--- vdr-1.6.0.orig/debian/compat
+++ vdr-1.6.0/debian/compat
@@ -0,0 +1 @@
+5
--- vdr-1.6.0.orig/debian/reccmds.custom.conf
+++ vdr-1.6.0/debian/reccmds.custom.conf
@@ -0,0 +1,27 @@
+#
+# This is an example file for defining external commands, that will be 
+# accessible as commands at the recordings list.
+# The commands will be executed under the same user id that vdr is running 
+# with, so take care if your are running vdr as root!
+# 
+# The format of a command entry is:  <title> : <command>
+# <title> is the menu text shown on the OSD and <command> is the command to
+# be executed. Everything that <command> writes to stdout will be displayed
+# on the OSD. Also the name of the selected recording will be passed 
+# in single quotes as the first parameter to the command. i.e.:
+#
+# Show me the recording name: echo 
+#
+# If you uncomment the line above and restart vdr, you will have a new 
+# recordings command menu entry, called "Show me the recording name", that 
+# will simply show you the recording name :-)
+#
+# If you are using the reccmd-patch, you can even divide your commands into
+# submenus. To do so, prefix all sub menu items with a "-". i.e.:
+# 
+# main menu node ...   : echo "sub menu, no command"
+# -sub menu entry 1    : do_something.sh
+# -sub menu entry 2    : do_something_else.sh
+# -sub menu node ...   : echo "sub sub menu, no command"
+# --sub-sub menu entry : do_whatever_you_want.sh
+#
--- vdr-1.6.0.orig/debian/svdrpsend.1
+++ vdr-1.6.0/debian/svdrpsend.1
@@ -0,0 +1,39 @@
+.TH "svdrpsend" "1" "" "Tobias Grimm" ""
+.SH "NAME"
+.LP 
+svdrpsend \- Sends commands to VDR
+.SH "DESCRIPTION"
+.LP 
+This program sends commands to VDR and displays the result. A list of available commands can be shown by sending the HELP command.
+.SH "SYNTAX"
+.LP 
+svdrpsend [\fIoptions\fP] \fIcommand\fP
+.SH "OPTIONS"
+.LP 
+.TP 
+\fB\-d\fR <\fIhostname\fP>
+Accesses the VDR at the specified <\fIhostname\fP> (default is localhost).
+.TP 
+\fB\-p\fR <\fIport\fP>
+Uses the SVDRP port number <\fIport\fP> (default is 2001).
+.SH "EXAMPLES"
+.LP 
+To request the available commands from the VDR running on the local host:
+.LP 
+svdrpsend HELP
+.SH "FILES"
+.LP 
+\fI/etc/vdr/svdrphosts.conf\fP 
+.SH "AUTHORS"
+.LP 
+This man-page has been written by Tobias Grimm <tg@e\-tobi.net>
+.PP
+Permission is granted to copy, distribute and/or modify this document under
+the terms of the GNU General Public License, Version 2 any
+later version published by the Free Software Foundation.
+.PP
+On Debian systems, the complete text of the GNU General Public
+License can be found in /usr/share/common\-licenses/GPL.
+.SH "SEE ALSO"
+.LP 
+vdr(1) vdr(5)
--- vdr-1.6.0.orig/debian/plugin-template/copyright
+++ vdr-1.6.0/debian/plugin-template/copyright
@@ -0,0 +1,46 @@
+Upstream Homepage:
+    <fill in http/ftp site>
+
+Upstream Author(s):
+    <put author(s) name and email here>
+
+Debian Maintainer(s):
+    #USERNAME# <#EMAIL#>
+
+Copyright:
+    <put the year(s) of the copyright, and the names of the copyright
+     holder(s) here>
+
+Copyright (Debian packaging):
+    (C) #YEAR# #USERNAME#
+
+License:
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+    The complete text of the GNU General Public License can be found
+    in /usr/share/common-licenses/GPL-2 on most Debian systems.
+
+License (Debian packaging):
+    The Debian packaging is licensed under the GPL, version 2 or any
+    later version, see /usr/share/common-licenses/GPL-2.
+
+# Please also look if there are files or directories which have a
+# different copyright/license attached and list them in this file.
+#
+# Check if the upstream sources explicitly state which licenses apply to
+# which action. If this is not the case, ask the upstream author to add such a
+# license disclaimer to all source files or at least to the README. For the
+# GPL2 or GPL3 the small license disclaimer mentioned at the end of the full license
+# text in "How to Apply These Terms to Your New Programs" should be sufficient.
--- vdr-1.6.0.orig/debian/plugin-template/links.ex
+++ vdr-1.6.0/debian/plugin-template/links.ex
@@ -0,0 +1 @@
+usr/share/#PACKAGE#/#PLUGIN#    var/lib/vdr/plugins/#PLUGIN#
--- vdr-1.6.0.orig/debian/plugin-template/install
+++ vdr-1.6.0/debian/plugin-template/install
@@ -0,0 +1,2 @@
+libvdr-#PLUGIN#.so.*    usr/lib/vdr/plugins/
+debian/tmp/usr/share/locale
--- vdr-1.6.0.orig/debian/plugin-template/changelog
+++ vdr-1.6.0/debian/plugin-template/changelog
@@ -0,0 +1,12 @@
+#PACKAGE# (#VERSION#-1) unstable; urgency=low
+
+  * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
+  
+  Important:
+  
+  If you intend to make this plugin available to others, please create an
+  ITP-bug (see http://www.debian.org/devel/wnpp ) and contact the
+  Debian VDR packaging team: pkg-vdr-dvb-devel@lists.alioth.debian.org
+
+ -- #USERNAME# <#EMAIL#>  #DATE#
+
--- vdr-1.6.0.orig/debian/plugin-template/rules
+++ vdr-1.6.0/debian/plugin-template/rules
@@ -0,0 +1,19 @@
+#!/usr/bin/make -f
+
+include /usr/share/cdbs/1/rules/debhelper.mk
+# include /usr/share/cdbs/1/rules/dpatch.mk
+
+DEB_INSTALL_CHANGELOGS_ALL = HISTORY
+
+MAKE_OPTIONS = DVBDIR=/usr VDRDIR=/usr/include/vdr LIBDIR=. \
+               LOCALEDIR=debian/tmp/usr/share/locale
+
+common-build-arch::
+	$(MAKE) all $(MAKE_OPTIONS)
+
+cleanbuilddir::
+	$(MAKE) -o .dependencies clean $(MAKE_OPTIONS)
+	rm -f libvdr-*.so.*
+
+common-binary-predeb-arch::
+	sh /usr/share/vdr-dev/dependencies.sh
--- vdr-1.6.0.orig/debian/plugin-template/control
+++ vdr-1.6.0/debian/plugin-template/control
@@ -0,0 +1,15 @@
+Source: #PACKAGE#
+Section: video
+Priority: extra
+Maintainer: #USERNAME# <#EMAIL#>
+Build-Depends: #BUILD_DEPS#, vdr-dev (>= #VDRVERSION#), gettext
+Standards-Version: #POLICY#
+Vcs-Svn: svn://svn.debian.org/pkg-vdr-dvb/vdr/#PACKAGE#/trunk/
+Vcs-Browser: http://svn.debian.org/wsvn/pkg-vdr-dvb/vdr/#PACKAGE#/trunk/
+Homepage: <url://example.com>
+
+Package: #PACKAGE#
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}, ${vdr:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
--- vdr-1.6.0.orig/debian/po/templates.pot
+++ vdr-1.6.0/debian/po/templates.pot
@@ -0,0 +1,65 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr ""
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr ""
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr ""
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr ""
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr ""
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
--- vdr-1.6.0.orig/debian/po/cs.po
+++ vdr-1.6.0/debian/po/cs.po
@@ -0,0 +1,78 @@
+#
+#    Translators, if you are not familiar with the PO format, gettext
+#    documentation is worth reading, especially sections dedicated to
+#    this format, e.g. by running:
+#         info -n '(gettext)PO Files'
+#         info -n '(gettext)Header Entry'
+#
+#    Some information specific to po-debconf are available at
+#            /usr/share/doc/po-debconf/README-trans
+#         or http://www.debian.org/intl/l10n/po-debconf/README-trans
+#
+#    Developers do not need to manually edit POT or PO files.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2004-05-15 11:10+0200\n"
+"Last-Translator: Miroslav Kure <kurem@debian.cz>\n"
+"Language-Team: Czech <provoz@debian.cz>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satelitn"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Pozemn"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Kabelov"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Typ DVB karty:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR mus znt typ va DVB karty. Na zklad va odpovdi se do /var/lib/"
+"vdr nainstaluje soubor channels.conf. Tento soubor mete pozdji upravit "
+"dle svch poteb."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Vytvoit /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Implicitn je VDR nastaveno pro ukldn nahrvek do /var/lib/video.00. "
+"Tento adres se nyn me vytvoit automaticky. Jeho umstn mete "
+"pozdji upravit zmnou promnn VIDEO_DIR v souboru /etc/default/vdr."
--- vdr-1.6.0.orig/debian/po/fr.po
+++ vdr-1.6.0/debian/po/fr.po
@@ -0,0 +1,82 @@
+# translation of fr.po to French
+#
+#    Translators, if you are not familiar with the PO format, gettext
+#    documentation is worth reading, especially sections dedicated to
+#    this format, e.g. by running:
+#         info -n '(gettext)PO Files'
+#         info -n '(gettext)Header Entry'
+#    Some information specific to po-debconf are available at
+#            /usr/share/doc/po-debconf/README-trans
+#         or http://www.debian.org/intl/l10n/po-debconf/README-trans#
+#    Developers do not need to manually edit POT or PO files.
+# Emmanuel le Chevoir <mms@debian.org>, 2004.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr_1.2.6-3\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2004-03-18 10:42+0100\n"
+"Last-Translator: Emmanuel le Chevoir <mms@debian.org>\n"
+"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.3.1\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satellite"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestre"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Cble"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Type de carte DVB:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR a besoin de connatre le type de votre carte DVB pour fonctionner "
+"correctement. Un fichier channels.conf correspondant au type que vous "
+"choisirez sera install dans le rpertoire /var/lib/vdr. En fonction de "
+"votre configuration, il est possible que vous ayez besoin de modifier ce "
+"fichier par la suite."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Crer le rpertoire /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Par dfaut, VDR sauvegarde les enregistrements dans le rpertoire /var/lib/"
+"video.00. Vous pouvez changer ce rpertoire en modifiant la variable "
+"VIDEO_DIR dans le fichier /etc/default/vdr, ou crer ce rpertoire "
+"maintenant."
--- vdr-1.6.0.orig/debian/po/nl.po
+++ vdr-1.6.0/debian/po/nl.po
@@ -0,0 +1,77 @@
+#    Translators, if you are not familiar with the PO format, gettext
+#    documentation is worth reading, especially sections dedicated to
+#    this format, e.g. by running:
+#         info -n '(gettext)PO Files'
+#         info -n '(gettext)Header Entry'
+#
+#    Some information specific to po-debconf are available at
+#            /usr/share/doc/po-debconf/README-trans
+#         or http://www.debian.org/intl/l10n/po-debconf/README-trans
+#
+#    Developers do not need to manually edit POT or PO files.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.2.6-4\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2004-05-18 08:40+0100\n"
+"Last-Translator: Luk Claes <luk.claes@ugent.be>\n"
+"Language-Team: Debian l10n Dutch <debian-l10n-dutch@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=iso-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satelliet"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Aards"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Kabel"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "DVB-kaarttype:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR moet uw DVB-kaarttype weten om correct te werken. Gebruikmakend van uw "
+"selectie, zal een channels.conf-bestand worden genstalleerd in /var/lib/"
+"vdr. U moet dit bestand misschien aanpassen afhankelijk van uw configuratie."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "/var/lib/video.00 aanmaken?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Standaard is VDR geconfigureerd om /var/lib/video.00 te gebruiken om opnames "
+"te bewaren. U kunt deze map nu aanmaken of dit gedrag later wijzigen door de "
+"VIDEO_DIR-variabele aan te passen in /etc/default/vdr."
--- vdr-1.6.0.orig/debian/po/gl.po
+++ vdr-1.6.0/debian/po/gl.po
@@ -0,0 +1,71 @@
+# Galician translation of vdr's debconf templates
+# This file is distributed under the same license as the vdr package.
+# Jacobo Tarrio <jtarrio@debian.org>, 2008.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2008-05-20 23:07+0100\n"
+"Last-Translator: Jacobo Tarrio <jtarrio@debian.org>\n"
+"Language-Team: Galician <proxecto@trasno.net>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satélite"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestre"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Cable"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Tipo de tarxeta de TV dixital:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR precisa de coñecer o tipo de tarxeta de TV dixital para funcionar "
+"correctamente. Segundo o que escolla, hase instalar un ficheiro channels."
+"conf en /var/lib/vdr. Pode ter que modificar este ficheiro dependendo da súa "
+"configuración."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "¿Crear /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Por defecto, VDR está configurado para empregar /var/lib/video.00 para "
+"armacenar as gravacións. Pode crear este directorio agora, ou cambiar este "
+"comportamento máis adiante modificando a variable VIDEO_DIR en /etc/default/"
+"vdr."
--- vdr-1.6.0.orig/debian/po/sv.po
+++ vdr-1.6.0/debian/po/sv.po
@@ -0,0 +1,77 @@
+# Translators, if you are not familiar with the PO format, gettext
+# documentation is worth reading, especially sections dedicated to
+# this format, e.g. by running:
+# info -n '(gettext)PO Files'
+# info -n '(gettext)Header Entry'
+# Some information specific to po-debconf are available at
+# /usr/share/doc/po-debconf/README-trans
+# or http://www.debian.org/intl/l10n/po-debconf/README-trans
+# Developers do not need to manually edit POT or PO files.
+# , fuzzy
+#
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.3.31-2\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2005-09-30 23:31-0700\n"
+"Last-Translator: Daniel Nylander <po@danielnylander.se>\n"
+"Language-Team: Swedish <sv@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=iso-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satellit"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Marksnd"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Kabel"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "DVB-korttyp:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR behver veta om din DVB-korttyp fr att fungera korrekt. Baserat p ditt "
+"val kommer en channels.conf fil att installeras i /var/lib/vdr.  Du kanske "
+"mste ndra i denna fil beroende p din konfiguration."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Skapa /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Som standard r VDR konfigurerad att anvnda /var/lib/video.00 fr att lagra "
+"inspelningar. Du kan antingen skapa denna mapp nu eller ndra detta senare  "
+"genom att modifiera variabeln VIDEO_DIR i /etc/default/vdr."
--- vdr-1.6.0.orig/debian/po/ru.po
+++ vdr-1.6.0/debian/po/ru.po
@@ -0,0 +1,73 @@
+# translation of ru.po to Russian
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Yuri Kozlov <yuray@komyakino.ru>, 2009.
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.6.0-8\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2009-07-02 21:17+0400\n"
+"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
+"Language-Team: Russian <debian-l10n-russian@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+"Plural-Forms:  nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%"
+"10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Спутниковая"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Эфирная"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Кабельная"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Тип карты DVB:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"Для корректной работы VDR требуется указать тип карты DVB. На основе вашего "
+"выбора в каталог /var/lib/vdr будет помещён подходящий файл channels.conf. В "
+"зависимости от установки вам может потребоваться изменить этот файл."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Создать /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"По умолчанию для хранения записей VDR использует /var/lib/video.00. Вы "
+"можете создать этот каталог сейчас, или изменить эту настройку позже, "
+"отредактировав значение переменной VIDEO_DIR в /etc/default/vdr."
--- vdr-1.6.0.orig/debian/po/da.po
+++ vdr-1.6.0/debian/po/da.po
@@ -0,0 +1,71 @@
+# Danish translation vdr.
+# Copyright (C) 2010 vdr & nedenstående oversættere.
+# This file is distributed under the same license as the vdr package.
+# Joe Hansen (joedalton2@yahoo.dk), 2010.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2010-08-08 17:30+01:00\n"
+"Last-Translator: Joe Hansen <joedalton2@yahoo.dk>\n"
+"Language-Team: Danish <debian-l10n-danish@lists.debian.org> \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satellit"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestrisk"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Kabel"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "DVB-korttype:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR skal kende din DVB-korttype for at fungere korrekt. Filen channels.conf "
+"vil med dine valg blive installeret i /var/lib/vdr. Du skal måske ændre denne "
+"fil afhængig af din opsætning."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Opret /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Som standard er VDR konfigureret til at bruge /var/lib/video.00 til at gemme "
+"optagelser. Du kan enten oprette denne mappe nu, eller ændre denne opførsel "
+"senere ved at ændre variablen VIDEO_DIR i /etc/default/vdr."
+
--- vdr-1.6.0.orig/debian/po/es.po
+++ vdr-1.6.0/debian/po/es.po
@@ -0,0 +1,98 @@
+# vdr po-debconf translation to Spanish.
+# Copyright (C) 2009 Software in the Public Interest.
+# This file is distributed under the same license as the vdrpackage.
+#
+#  Changes:
+# - Initial translation
+#       Fernando González de Requena <fgrequena@gmail.com>, 2009.
+#
+#
+#  Traductores, si no conoce el formato PO, merece la pena leer la
+#  documentación de gettext, especialmente las secciones dedicadas a este
+#  formato, por ejemplo ejecutando:
+#         info -n '(gettext)PO Files'
+#         info -n '(gettext)Header Entry'
+#
+# Equipo de traducción al español, por favor lean antes de traducir
+# los siguientes documentos:
+#
+# - El proyecto de traducción de Debian al español
+#   http://www.debian.org/intl/spanish/
+#   especialmente las notas y normas de traducción en
+#   http://www.debian.org/intl/spanish/notas
+#
+# - La guía de traducción de po's de debconf:
+#   /usr/share/doc/po-debconf/README-trans
+#   o http://www.debian.org/intl/l10n/po-debconf/README-trans
+#
+# Si tiene dudas o consultas sobre esta traducción consulte con el último
+# traductor (campo Last-Translator) y ponga en copia a la lista de
+# traducción de Debian al español (<debian-l10n-spanish@lists.debian.org>)
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.6.0-8\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2009-04-26 19:29+0200\n"
+"Last-Translator: Fernando González de Requena <fgrequena@gmail.com>\n"
+"Language-Team: Spanish <debian-l10n-spanish@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satélite"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestre"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Cable"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Tipo de tarjeta DVB:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR necesita saber el tipo de la tarjeta DVB para funcionar correctamente. "
+"Utilizando su selección, se instalará un archivo «channels.conf» en «/var/lib/"
+"vdr». Puede que necesite cambiar este archivo dependiendo de su "
+"configuración."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "¿Desea crear «/var/lib/video.00»?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"VDR se configura por omisión para utilizar «/var/lib/video.00» para almacenar "
+"las grabaciones. Puede crear ahora este directorio, o cambiar más tarde este "
+"comportamiento modificando la variable VIDEO_DIR en «/etc/default/vdr»."
--- vdr-1.6.0.orig/debian/po/de.po
+++ vdr-1.6.0/debian/po/de.po
@@ -0,0 +1,82 @@
+# translation of de.po to German
+#
+#    Translators, if you are not familiar with the PO format, gettext
+#    documentation is worth reading, especially sections dedicated to
+#    this format, e.g. by running:
+#         info -n '(gettext)PO Files'
+#         info -n '(gettext)Header Entry'
+#    Some information specific to po-debconf are available at
+#            /usr/share/doc/po-debconf/README-trans
+#         or http://www.debian.org/intl/l10n/po-debconf/README-trans#
+#    Developers do not need to manually edit POT or PO files.
+# Jens Nachtigall <nachtigall@web.de>, 2004.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: de\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2004-09-27 16:00+0200\n"
+"Last-Translator: Jens Nachtigall <nachtigall@web.de>\n"
+"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.3.1\n"
+"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satellit"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestrisch"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Kabel"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "DVB-Karten-Typ:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR muss den Typ Ihrer DVB-Karte kennen, um korrekt zu funktionieren. Mit "
+"Hilfe ihrer Auswahl wird eine channels.conf-Datei in /var/lib/vdr "
+"installiert.  Eventuell werden Sie diese Datei an Ihre Umgebung anpassen "
+"müssen. "
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Soll /var/lib/video.00 erstellt werden?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Standardmäßig ist VDR so konfiguriert, dass Aufnahmen in /var/lib/video.00 "
+"gespeichert werden. Sie können dieses Verzeichnis entweder jetzt erstellen, "
+"oder diese Konfiguration später ändern, indem Sie die Variable VIDEO_DIR in /"
+"etc/default/vdr anpassen."
--- vdr-1.6.0.orig/debian/po/it.po
+++ vdr-1.6.0/debian/po/it.po
@@ -0,0 +1,71 @@
+# Italian translation of vdr.
+# COPYRIGHT (C) 2009 THE VDR'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the vdr package.
+# Luca Monducci <luca.mo@tiscali.it>, 2009.
+# 
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.6.0 italian debconf templates\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2009-09-28 22:36+0200\n"
+"Last-Translator: Luca Monducci <luca.mo@tiscali.it>\n"
+"Language-Team: Italian <debian-l10n-italian@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satellite"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestre"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Cavo"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Tipo di scheda DVB:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"Per funzionare correttamente è necessario indicare a VDR il tipo di scheda "
+"DVB. In base a questa scelta verrà creato un file channels.conf che verrà "
+"installato in /var/lib/vdr. Potrebbe essere necessario adattare questo file "
+"al sistema in uso."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Creare /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Con la configurazione predefinita, VDR usa /var/lib/video.00 per memorizzare "
+"le registrazioni. È possibile creare questa directory adesso oppure cambiare "
+"questo comportamento modificando la variabile VIDEO_DIR in /etc/default/vdr."
--- vdr-1.6.0.orig/debian/po/pt.po
+++ vdr-1.6.0/debian/po/pt.po
@@ -0,0 +1,72 @@
+# Portuguese translation of vdr's debconf messages.
+# Copyright (C) 2007
+# This file is distributed under the same license as the vdr package.
+# Luísa Lourenço <kikentai@gmail.com>, YEAR.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.4.4-1\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2007-03-19 12:24+0000\n"
+"Last-Translator: Luísa Lourenço <kikentai@gmail.com>\n"
+"Language-Team: Portuguese <traduz@debianpt.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "Satélite"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "Terrestre"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "Cabo"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "Tipo de placa DVB:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"O VDR precisa de saber qual o tipo da sua placa DVB para funcionar "
+"correctamente. Usando a sua escolha, o ficheiro channels.conf irá ser "
+"instalado para /var/lib/vdr. Poderá ter que modificar este ficheiro "
+"dependendo da sua configuração."
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "Criar /var/lib/video.00?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"Por omissão o VDR é configurado para usar o /var/lib/video.00 para guardar "
+"as gravações. Poderá tanto criar agora este directório, ou modificar este "
+"comportamento mais tarde modificando a variável VIDEO_DIR em /etc/default/"
+"vdr."
--- vdr-1.6.0.orig/debian/po/POTFILES.in
+++ vdr-1.6.0/debian/po/POTFILES.in
@@ -0,0 +1 @@
+[type: gettext/rfc822deb] vdr.templates
--- vdr-1.6.0.orig/debian/po/ja.po
+++ vdr-1.6.0/debian/po/ja.po
@@ -0,0 +1,69 @@
+# Japanese translation of vdr debconf templates.
+# Copyright (C) 2009 Hideki Yamane <henrich@debian.or.jp>
+# This file is distributed under the same license as vdr package.
+# 
+msgid ""
+msgstr ""
+"Project-Id-Version: vdr 1.6.0-12\n"
+"Report-Msgid-Bugs-To: vdr@packages.debian.org\n"
+"POT-Creation-Date: 2010-03-04 22:58+0100\n"
+"PO-Revision-Date: 2009-10-29 06:26+0900\n"
+"Last-Translator: Hideki Yamane (Debian-JP) <henrich@debian.or.jp>\n"
+"Language-Team: Japanese <debian-japanese@lists.debian.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Satellite"
+msgstr "衛星放送"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Terrestrial"
+msgstr "地上デジタル放送"
+
+#. Type: select
+#. Choices
+#: ../vdr.templates:1001
+msgid "Cable"
+msgstr "ケーブル放送"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid "DVB card type:"
+msgstr "DVB カードの種類:"
+
+#. Type: select
+#. Description
+#: ../vdr.templates:1002
+msgid ""
+"VDR needs to know your DVB card type to work correctly. Using your "
+"selection, a channels.conf file will be installed to /var/lib/vdr.  You may "
+"have to change this file depending on your setup."
+msgstr ""
+"VDR は正常に動作するために DVB カードの種類を知っている必要があります。ここで"
+"の選択を元にして、/var/lib/vdr に channels.conf ファイルがインストールされま"
+"す。設定によってはこのファイルを変更する必要があるかもしれません。"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid "Create /var/lib/video.00?"
+msgstr "/var/lib/video.00 を作成しますか?"
+
+#. Type: boolean
+#. Description
+#: ../vdr.templates:2001
+msgid ""
+"By default VDR is configured to use /var/lib/video.00 to store recordings. "
+"You can either create this directory now, or change this behavior later  by "
+"modifying the VIDEO_DIR variable in /etc/default/vdr."
+msgstr ""
+"デフォルトでは VDR は録画を保存するのに /var/lib/video.00 を使うように設定さ"
+"れています。このディレクトリをすぐに作成する、あるいは後ほど /etc/default/"
+"vdr 内の VIDEO_DIR 変数の設定にて、保存するディレクトリの指定を変更できます。"
--- vdr-1.6.0.orig/debian/themes/sttng-cool.theme
+++ vdr-1.6.0/debian/themes/sttng-cool.theme
@@ -0,0 +1,62 @@
+Description = Cool
+clrBackground = 80000000
+clrButtonRedFg = FFFFFFFF
+clrButtonRedBg = C0C00000
+clrButtonGreenFg = FFFFFFFF
+clrButtonGreenBg = C000C000
+clrButtonYellowFg = FF000000
+clrButtonYellowBg = C0C0C000
+clrButtonBlueFg = FFFFFFFF
+clrButtonBlueBg = C00000C0
+clrMessageFrame = C0004080
+clrMessageStatusFg = FFFFFFFF
+clrMessageStatusBg = C000C000
+clrMessageInfoFg = FFFFFFFF
+clrMessageInfoBg = C00080FF
+clrMessageWarningFg = FF000000
+clrMessageWarningBg = C0C0C000
+clrMessageErrorFg = FFFFFFFF
+clrMessageErrorBg = C0C00000
+clrVolumeFrame = C0004080
+clrVolumeSymbol = FFFFFFFF
+clrVolumeBarUpper = C00080FF
+clrVolumeBarLower = C0C0C000
+clrChannelFrame = C0004080
+clrChannelName = FFFFFFFF
+clrChannelDate = FFFFFFFF
+clrChannelSymbolOn = FFE0E000
+clrChannelSymbolOff = FFB0B0B0
+clrChannelSymbolRecFg = FFFFFFFF
+clrChannelSymbolRecBg = C0C00000
+clrChannelEpgTime = FFFFFFFF
+clrChannelEpgTitle = FFE0E000
+clrChannelEpgShortText = FFB0B0B0
+clrChannelTimebarSeen = FFE0E000
+clrChannelTimebarRest = FFB0B0B0
+clrMenuFrame = C0004080
+clrMenuTitle = FFFFFFFF
+clrMenuDate = FFFFFFFF
+clrMenuItemCurrentFg = FFFFFFFF
+clrMenuItemCurrentBg = C00080FF
+clrMenuItemSelectable = FFFFFFFF
+clrMenuItemNonSelectable = FFB0B0B0
+clrMenuEventTime = FFE0E000
+clrMenuEventVps = FFFFFFFF
+clrMenuEventTitle = FFE0E000
+clrMenuEventShortText = FFE0E000
+clrMenuEventDescription = FFFFFFFF
+clrMenuScrollbarTotal = C00080FF
+clrMenuScrollbarShown = C0C0C000
+clrMenuScrollbarArrow = FFFFFFFF
+clrMenuText = FFFFFFFF
+clrReplayFrame = C0004080
+clrReplayTitle = FFE0E000
+clrReplayMode = FFFFFFFF
+clrReplayCurrent = FFFFFFFF
+clrReplayTotal = FFE0E000
+clrReplayJump = FFE0E000
+clrReplayProgressSeen = C00080FF
+clrReplayProgressRest = 80000000
+clrReplayProgressSelected = C0C00000
+clrReplayProgressMark = FFFFFFFF
+clrReplayProgressCurrent = FFFFFFFF
--- vdr-1.6.0.orig/debian/themes/sttng-blue.theme
+++ vdr-1.6.0/debian/themes/sttng-blue.theme
@@ -0,0 +1,62 @@
+Description = Blue LCARS
+clrBackground = 7F000000
+clrButtonRedFg = FFFCFCFC
+clrButtonRedBg = FFFC1414
+clrButtonGreenFg = FF000000
+clrButtonGreenBg = FF24FC24
+clrButtonYellowFg = FF000000
+clrButtonYellowBg = FFFCC024
+clrButtonBlueFg = FFFCFCFC
+clrButtonBlueBg = FF0000FC
+clrMessageFrame = FF598ACD
+clrMessageStatusFg = FF000000
+clrMessageStatusBg = FF00FCFC
+clrMessageInfoFg = FF000000
+clrMessageInfoBg = FF9C9CFF
+clrMessageWarningFg = FF000000
+clrMessageWarningBg = FFFCC024
+clrMessageErrorFg = FFFCFCFC
+clrMessageErrorBg = FFFC1414
+clrVolumeFrame = FF598ACD
+clrVolumeSymbol = FF000000
+clrVolumeBarUpper = FF38359E
+clrVolumeBarLower = FF9FCEFF
+clrChannelFrame = FF598ACD
+clrChannelName = FF000000
+clrChannelDate = FF000000
+clrChannelSymbolOn = FF000000
+clrChannelSymbolOff = FF5A7CA2
+clrChannelSymbolRecFg = FFFCFCFC
+clrChannelSymbolRecBg = FFFC1414
+clrChannelEpgTime = FF000000
+clrChannelEpgTitle = FF00FCFC
+clrChannelEpgShortText = FFFCC024
+clrChannelTimebarSeen = FF38359E
+clrChannelTimebarRest = FF9FCEFF
+clrMenuFrame = FF598ACD
+clrMenuTitle = FF000000
+clrMenuDate = FF000000
+clrMenuItemCurrentFg = FF000000
+clrMenuItemCurrentBg = FF9C9CFF
+clrMenuItemSelectable = FF9C9CFF
+clrMenuItemNonSelectable = FF00FCFC
+clrMenuEventTime = FFFCC024
+clrMenuEventVps = FF000000
+clrMenuEventTitle = FF00FCFC
+clrMenuEventShortText = FFFCC024
+clrMenuEventDescription = FF00FCFC
+clrMenuScrollbarTotal = FF38359E
+clrMenuScrollbarShown = FF00FCFC
+clrMenuScrollbarArrow = FF000000
+clrMenuText = FF00FCFC
+clrReplayFrame = FF598ACD
+clrReplayTitle = FF000000
+clrReplayMode = FF000000
+clrReplayCurrent = FF000000
+clrReplayTotal = FF000000
+clrReplayJump = FF000000
+clrReplayProgressSeen = FF9FCEFF
+clrReplayProgressRest = FF38359E
+clrReplayProgressSelected = FFFC1414
+clrReplayProgressMark = FF000000
+clrReplayProgressCurrent = FFFC1414
--- vdr-1.6.0.orig/debian/scripts/vdr-daemon
+++ vdr-1.6.0/debian/scripts/vdr-daemon
@@ -0,0 +1,2 @@
+#! /bin/sh
+exec /usr/bin/vdr-kbd "$@" --no-kbd
--- vdr-1.6.0.orig/debian/scripts/vdr-lirc
+++ vdr-1.6.0/debian/scripts/vdr-lirc
@@ -0,0 +1,2 @@
+#! /bin/sh
+exec /usr/bin/vdr-kbd "$@" --lirc
--- vdr-1.6.0.orig/debian/scripts/vdr-rcu
+++ vdr-1.6.0/debian/scripts/vdr-rcu
@@ -0,0 +1,2 @@
+#! /bin/sh
+exec /usr/bin/vdr-kbd "$@" --rcu
--- vdr-1.6.0.orig/debian/source/format
+++ vdr-1.6.0/debian/source/format
@@ -0,0 +1 @@
+1.0
--- vdr-1.6.0.orig/debian/patches/opt-44_rotor.dpatch
+++ vdr-1.6.0/debian/patches/opt-44_rotor.dpatch
@@ -0,0 +1,118 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-44_rotor.dpatch by Thomas Bergwinkl <Bergwinkl.Thomas@vr-web.de>
+## extracted from the rotor plugin 0.1.4-vdr1.5
+## original filename: vdr-1.5.5-rotor.diff
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - made compatible to VDR-1.4.7
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is needed for the rotor plugin.
+
+@DPATCH@
+diff -ubw vdr-1.5.5/device.h vdr-1.5.5-Rotor/device.h
+--- vdr-1.5.5/device.h	2007-01-13 12:33:57.000000000 +0100
++++ vdr-1.5.5-Rotor/device.h	2007-06-30 21:27:45.000000000 +0200
+@@ -22,6 +22,7 @@
+ #include "spu.h"
+ #include "thread.h"
+ #include "tools.h"
++#include <linux/dvb/frontend.h>
+ 
+ #define MAXDEVICES         16 // the maximum number of devices in the system
+ #define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
+@@ -256,6 +257,7 @@
+   virtual bool HasProgramme(void);
+          ///< Returns true if the device is currently showing any programme to
+          ///< the user, either through replaying or live.
++  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd) {return false;}
+ 
+ // PID handle facilities
+ 
+diff -ubw vdr-1.5.5/dvbdevice.c vdr-1.5.5-Rotor/dvbdevice.c
+--- vdr-1.5.5/dvbdevice.c	2007-02-25 12:46:52.000000000 +0100
++++ vdr-1.5.5-Rotor/dvbdevice.c	2007-06-30 21:28:47.000000000 +0200
+@@ -71,6 +71,7 @@
+ class cDvbTuner : public cThread {
+ private:
+   enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
++  bool SendDiseqc;
+   int fd_frontend;
+   int cardIndex;
+   int tuneTimeout;
+@@ -83,6 +84,7 @@
+   cMutex mutex;
+   cCondVar locked;
+   cCondVar newSet;
++  dvb_diseqc_master_cmd diseqc_cmd;
+   bool GetFrontendStatus(fe_status_t &Status, int TimeoutMs = 0);
+   bool SetFrontend(void);
+   virtual void Action(void);
+@@ -91,6 +93,7 @@
+   virtual ~cDvbTuner();
+   bool IsTunedTo(const cChannel *Channel) const;
+   void Set(const cChannel *Channel, bool Tune);
++  bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+   bool Locked(int TimeoutMs = 0);
+   };
+ 
+@@ -97,6 +100,7 @@
+ cDvbTuner::cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType)
+ {
+   fd_frontend = Fd_Frontend;
++  SendDiseqc=false;
+   cardIndex = CardIndex;
+   frontendType = FrontendType;
+   tuneTimeout = 0;
+@@ -145,6 +149,17 @@
+   return tunerStatus >= tsLocked;
+ }
+ 
++bool cDvbTuner::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
++{
++  cMutexLock MutexLock(&mutex);
++  if (frontendType!=FE_QPSK || SendDiseqc)
++    return false;
++  diseqc_cmd=cmd;
++  SendDiseqc=true;
++  newSet.Broadcast();
++  return true;
++}
++
+ bool cDvbTuner::GetFrontendStatus(fe_status_t &Status, int TimeoutMs)
+ {
+   if (TimeoutMs) {
+@@ -297,6 +312,10 @@
+         if (GetFrontendStatus(NewStatus, 10))
+            Status = NewStatus;
+         cMutexLock MutexLock(&mutex);
++        if (SendDiseqc) {
++           CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &diseqc_cmd));
++           SendDiseqc=false;
++           }
+         switch (tunerStatus) {
+           case tsIdle:
+                break;
+@@ -858,6 +877,11 @@
+   return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
+ }
+ 
++bool cDvbDevice::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
++{
++  return dvbTuner->SendDiseqcCmd(cmd);
++}
++
+ int cDvbDevice::GetAudioChannelDevice(void)
+ {
+   if (HasDecoder()) {
+diff -ubw vdr-1.5.5/dvbdevice.h vdr-1.5.5-Rotor/dvbdevice.h
+--- vdr-1.5.5/dvbdevice.h	2007-02-25 13:23:57.000000000 +0100
++++ vdr-1.5.5-Rotor/dvbdevice.h	2007-06-30 21:27:45.000000000 +0200
+@@ -71,6 +71,7 @@
+   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
+ public:
+   virtual bool HasLock(int TimeoutMs = 0);
++  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+ 
+ // PID handle facilities
+ 
--- vdr-1.6.0.orig/debian/patches/opt-43-x_recordshowfree.dpatch
+++ vdr-1.6.0/debian/patches/opt-43-x_recordshowfree.dpatch
@@ -0,0 +1,31 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-32-x_recordshowfree.dpatch by Walter Koch <koch@u32.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Shows remaining recording capacity in recordings menu.
+## DP: (Requires timer-info patch)
+
+@DPATCH@
+diff -urNad vdr-1.5.15~/menu.c vdr-1.5.15/menu.c
+--- vdr-1.5.15~/menu.c	2008-02-17 22:09:26.000000000 +0100
++++ vdr-1.5.15/menu.c	2008-02-17 22:10:29.000000000 +0100
+@@ -2317,6 +2317,19 @@
+          }
+       }
+   free(LastItemText);
++  
++//kw
++  char *buffer = NULL;
++  int FreeMB;
++  int Percent = VideoDiskSpace(&FreeMB);
++  int Minutes = int(double(FreeMB) / MB_PER_MINUTE);
++  int Hours = Minutes / 60;
++  Minutes %= 60;
++  asprintf(&buffer, "%s   %d%%  %2d:%02d %s  (%.1f GB)", tr("Disk"), Percent, Hours, Minutes, tr("free"), FreeMB / 1024.0 );
++  SetTitle(buffer);
++  free(buffer);
++//kw
++  
+   Refresh |= SetFreeDiskDisplay(Refresh);
+   if (Refresh)
+      Display();
--- vdr-1.6.0.orig/debian/patches/opt-41-x_timer-info.dpatch
+++ vdr-1.6.0/debian/patches/opt-41-x_timer-info.dpatch
@@ -0,0 +1,302 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-41-x_timer-info.dpatch by Andreas Brugger <brougs78@gmx.net>, Thomas Gnther <tom@toms-cafe.de>
+## http://toms-cafe.de/vdr/download/vdr-timer-info-0.5-1.5.15.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Shows info, if it is possible to record an event in the timer-info of
+## DP: vdr - see README.timer-info for details.
+
+@DPATCH@
+diff -Naurp vdr-1.5.15/README.timer-info vdr-1.5.15-timer-info-0.5/README.timer-info
+--- vdr-1.5.15/README.timer-info	1970-01-01 00:00:00.000000000 +0000
++++ vdr-1.5.15-timer-info-0.5/README.timer-info	2008-04-12 11:54:16.000000000 +0000
+@@ -0,0 +1,65 @@
+++------------------------------------------------------------------------------+
++|               Info about the timer-info-patch by Brougs78                    |
++|                brougs78@gmx.net / home.pages.at/brougs78                     |
+++------------------------------------------------------------------------------+
++
++
++README timer-info:
++------------------
++
++Features:
++ - Shows info, if it is possible to record an event in the timer menu of vdr.
++   For calculations the free space incl. the deleted recordings is used,
++   considering an average consumtion of 25.75 MB/min (also used by vdr itself).
++   The first column in the timer-list shows:
++      ( + ) recording will be most probably possible (enough space)
++      (+/-) recording may be possible
++      ( - ) recording will most probably fail (to less space)
++   The calculations also consider repeating timers.
++ - It is possible to deactivate the patch in the OSD-menu of VDR.
++
++
++HISTORY timer-info:
++-------------------
++
++25.11.2004: v0.1
++ - Initial release
++
++11.01.2005: v0.1b
++ - Bugfixes for vdr-1.3.18
++ - In the menu the free recording-time no longer includes the space of the
++   deleted recordings, because this slowed the vdr down to much.
++
++08.07.2005: v0.1c
++ - Made the patch configurable
++
++29.01.2006: v0.2 - Thomas Gnther <tom@toms-cafe.de>
++ - Rewritten great parts for vdr-1.3.38+
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.2-1.3.38+.diff
++
++05.02.2006: v0.3 - Thomas Gnther <tom@toms-cafe.de>
++ - Fixed refresh of timer menu in cMenuTimers::OnOff
++ - Fixed check of repeating timers
++ - Syslog debug messages can be enabled with Define DEBUG_TIMER_INFO
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.3-1.3.38+.diff
++
++03.03.2006: v0.4 - Thomas Gnther <tom@toms-cafe.de>
++ - Adapted to vdr-1.3.44
++ - Removed setup parameter "Show timer-info"
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.4-1.3.44.diff
++
++26.03.2006:      - Tobias Grimm <tg@e-tobi.net>
++ - Adapted to vdr-1.3.45
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.4-1.3.45.diff
++
++14.01.2008:      - Thomas Gnther <tom@toms-cafe.de>
++ - Adapted to vdr-1.5.13
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.4-1.5.13.diff
++
++17.02.2008:      - Tobias Grimm <tg@e-tobi.net>
++ - Adapted to vdr-1.5.15
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.4-1.5.15.diff
++
++12.04.2008: v0.5 - Thomas Gnther <tom@toms-cafe.de>
++ - Fixed display of +/- sign with UTF-8
++   http://toms-cafe.de/vdr/download/vdr-timer-info-0.5-1.5.15.diff
+diff -Naurp vdr-1.5.15/menu.c vdr-1.5.15-timer-info-0.5/menu.c
+--- vdr-1.5.15/menu.c	2008-02-16 13:53:26.000000000 +0000
++++ vdr-1.5.15-timer-info-0.5/menu.c	2008-04-12 11:49:23.000000000 +0000
+@@ -777,8 +777,10 @@ eOSState cMenuEditTimer::ProcessKey(eKey
+ class cMenuTimerItem : public cOsdItem {
+ private:
+   cTimer *timer;
++  char diskStatus;
+ public:
+   cMenuTimerItem(cTimer *Timer);
++  void SetDiskStatus(char DiskStatus);
+   virtual int Compare(const cListObject &ListObject) const;
+   virtual void Set(void);
+   cTimer *Timer(void) { return timer; }
+@@ -787,6 +789,7 @@ public:
+ cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
+ {
+   timer = Timer;
++  diskStatus = ' ';
+   Set();
+ }
+ 
+@@ -812,7 +815,10 @@ void cMenuTimerItem::Set(void)
+      strftime(buffer, sizeof(buffer), "%Y%m%d", &tm_r);
+      day = buffer;
+      }
+-  SetText(cString::sprintf("%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
++  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
++  char diskStatusString[2] = { diskStatus, 0 };
++  SetText(cString::sprintf("%s%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
++                    csc.Convert(diskStatusString),
+                     !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? '!' : timer->Recording() ? '#' : '>',
+                     timer->Channel()->Number(),
+                     *name,
+@@ -825,6 +831,57 @@ void cMenuTimerItem::Set(void)
+                     timer->File()));
+ }
+ 
++void cMenuTimerItem::SetDiskStatus(char DiskStatus)
++{
++  diskStatus = DiskStatus;
++  Set();
++}
++
++// --- cTimerEntry -----------------------------------------------------------
++
++class cTimerEntry : public cListObject {
++private:
++  cMenuTimerItem *item;
++  const cTimer *timer;
++  time_t start;
++public:
++  cTimerEntry(cMenuTimerItem *item) : item(item), timer(item->Timer()), start(timer->StartTime()) {}
++  cTimerEntry(const cTimer *timer, time_t start) : item(NULL), timer(timer), start(start) {}
++  virtual int Compare(const cListObject &ListObject) const;
++  bool active(void) const { return timer->HasFlags(tfActive); }
++  time_t startTime(void) const { return start; }
++  int priority(void) const { return timer->Priority(); }
++  int duration(void) const;
++  bool repTimer(void) const { return !timer->IsSingleEvent(); }
++  bool isDummy(void) const { return item == NULL; }
++  const cTimer *Timer(void) const { return timer; }
++  void SetDiskStatus(char DiskStatus);
++  };
++
++int cTimerEntry::Compare(const cListObject &ListObject) const
++{
++  cTimerEntry *entry = (cTimerEntry *)&ListObject;
++  int r = startTime() - entry->startTime();
++  if (r == 0)
++     r = entry->priority() - priority();
++  return r;
++}
++
++int cTimerEntry::duration(void) const
++{
++  int dur = (timer->Stop()  / 100 * 60 + timer->Stop()  % 100) -
++            (timer->Start() / 100 * 60 + timer->Start() % 100);
++  if (dur < 0)
++     dur += 24 * 60;
++  return dur;
++}
++
++void cTimerEntry::SetDiskStatus(char DiskStatus)
++{
++  if (item)
++     item->SetDiskStatus(DiskStatus);
++}
++
+ // --- cMenuTimers -----------------------------------------------------------
+ 
+ class cMenuTimers : public cOsdMenu {
+@@ -837,14 +894,17 @@ private:
+   eOSState Info(void);
+   cTimer *CurrentTimer(void);
+   void SetHelpKeys(void);
++  void ActualiseDiskStatus(void);
++  bool actualiseDiskStatus;
+ public:
+   cMenuTimers(void);
+   virtual ~cMenuTimers();
++  virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
+   };
+ 
+ cMenuTimers::cMenuTimers(void)
+-:cOsdMenu(tr("Timers"), 2, CHNUMWIDTH, 10, 6, 6)
++:cOsdMenu(tr("Timers"), 3, CHNUMWIDTH, 10, 6, 6)
+ {
+   helpKeys = -1;
+   for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
+@@ -855,6 +915,7 @@ cMenuTimers::cMenuTimers(void)
+   SetCurrent(First());
+   SetHelpKeys();
+   Timers.IncBeingEdited();
++  actualiseDiskStatus = true;
+ }
+ 
+ cMenuTimers::~cMenuTimers()
+@@ -893,7 +954,7 @@ eOSState cMenuTimers::OnOff(void)
+      timer->OnOff();
+      timer->SetEventFromSchedule();
+      RefreshCurrent();
+-     DisplayCurrent(true);
++     Display();
+      if (timer->FirstDay())
+         isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
+      else
+@@ -952,6 +1013,67 @@ eOSState cMenuTimers::Info(void)
+   return osContinue;
+ }
+ 
++void cMenuTimers::ActualiseDiskStatus(void)
++{
++  if (!actualiseDiskStatus || !Count())
++     return;
++
++  // compute free disk space
++  int freeMB, freeMinutes, runshortMinutes;
++  VideoDiskSpace(&freeMB);
++  freeMinutes = int(double(freeMB) * 1.1 / MB_PER_MINUTE); // overestimate by 10 percent
++  runshortMinutes = freeMinutes / 5; // 20 Percent
++
++  // fill entries list
++  cTimerEntry *entry;
++  cList<cTimerEntry> entries;
++  for (cOsdItem *item = First(); item; item = Next(item))
++     entries.Add(new cTimerEntry((cMenuTimerItem *)item));
++
++  // search last start time
++  time_t last = 0;
++  for (entry = entries.First(); entry; entry = entries.Next(entry))
++     last = max(entry->startTime(), last);
++
++  // add entries for repeating timers
++  for (entry = entries.First(); entry; entry = entries.Next(entry))
++     if (entry->repTimer() && !entry->isDummy())
++        for (time_t start = cTimer::IncDay(entry->startTime(), 1);
++             start <= last;
++             start = cTimer::IncDay(start, 1))
++           if (entry->Timer()->DayMatches(start))
++              entries.Add(new cTimerEntry(entry->Timer(), start));
++
++  // set the disk-status
++  entries.Sort();
++  for (entry = entries.First(); entry; entry = entries.Next(entry)) {
++     char status = ' ';
++     if (entry->active()) {
++        freeMinutes -= entry->duration();
++        status = freeMinutes > runshortMinutes ? '+' : freeMinutes > 0 ? 177 /* +/- */ : '-';
++        }
++     entry->SetDiskStatus(status);
++#ifdef DEBUG_TIMER_INFO
++     dsyslog("timer-info: %c | %d | %s | %s | %3d | %+5d -> %+5d",
++             status,
++             entry->startTime(),
++             entry->active() ? "aktiv " : "n.akt.",
++             entry->repTimer() ? entry->isDummy() ? "  dummy  " : "mehrmalig" : "einmalig ",
++             entry->duration(),
++             entry->active() ? freeMinutes + entry->duration() : freeMinutes,
++             freeMinutes);
++#endif
++     }
++
++  actualiseDiskStatus = false;
++}
++
++void cMenuTimers::Display(void)
++{
++  ActualiseDiskStatus();
++  cOsdMenu::Display();
++}
++
+ eOSState cMenuTimers::ProcessKey(eKeys Key)
+ {
+   int TimerNumber = HasSubMenu() ? Count() : -1;
+@@ -960,18 +1082,22 @@ eOSState cMenuTimers::ProcessKey(eKeys K
+   if (state == osUnknown) {
+      switch (Key) {
+        case kOk:     return Edit();
+-       case kRed:    state = OnOff(); break; // must go through SetHelpKeys()!
++       case kRed:    actualiseDiskStatus = true;
++                     state = OnOff(); break; // must go through SetHelpKeys()!
+        case kGreen:  return New();
+-       case kYellow: state = Delete(); break;
++       case kYellow: actualiseDiskStatus = true;
++                     state = Delete(); break;
+        case kInfo:
+        case kBlue:   return Info();
+                      break;
+        default: break;
+        }
+      }
+-  if (TimerNumber >= 0 && !HasSubMenu() && Timers.Get(TimerNumber)) {
+-     // a newly created timer was confirmed with Ok
+-     Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
++  if (TimerNumber >= 0 && !HasSubMenu()) {
++     if (Timers.Get(TimerNumber)) // a newly created timer was confirmed with Ok
++        Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
++     Sort();
++     actualiseDiskStatus = true;
+      Display();
+      }
+   if (Key != kNone)
--- vdr-1.6.0.orig/debian/patches/opt-31-x_reelchannelscan.dpatch
+++ vdr-1.6.0/debian/patches/opt-31-x_reelchannelscan.dpatch
@@ -0,0 +1,32 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-31_reelchannelscan.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.8
+## Tobias Grimm <tg@e-tobi.net>:
+##   - adapted to VDR-1.5.16
+##   - adapted to VDR-1.5.18
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Makes VDR aware of the reelchannelscan plugin.
+
+@DPATCH@
+diff -urNad vdr-1.5.18~/vdr.c vdr-1.5.18/vdr.c
+--- vdr-1.5.18~/vdr.c	2008-03-14 14:22:39.000000000 +0100
++++ vdr-1.5.18/vdr.c	2008-03-16 15:59:55.000000000 +0100
+@@ -731,7 +731,14 @@
+         // Make sure we have a visible programme in case device usage has changed:
+         if (!EITScanner.Active() && cDevice::PrimaryDevice()->HasDecoder() && !cDevice::PrimaryDevice()->HasProgramme()) {
+            static time_t lastTime = 0;
+-           if ((!Menu || CheckHasProgramme) && Now - lastTime > MINCHANNELWAIT) { // !Menu to avoid interfering with the CAM if a CAM menu is open
++
++           bool reelChannelscanIsScanningOnReceivingDevice;
++           if (!cPluginManager::CallFirstService("ReelChannelscan::IsScanningOnReceivingDevice", &reelChannelscanIsScanningOnReceivingDevice))
++           {
++             reelChannelscanIsScanningOnReceivingDevice = false;
++           }
++
++           if (!reelChannelscanIsScanningOnReceivingDevice && (!Menu || CheckHasProgramme) && Now - lastTime > MINCHANNELWAIT) { // !Menu to avoid interfering with the CAM if a CAM menu is open
+               cChannel *Channel = Channels.GetByNumber(cDevice::CurrentChannel());
+               if (Channel && (Channel->Vpid() || Channel->Apid(0))) {
+                  if (!Channels.SwitchTo(cDevice::CurrentChannel()) // try to switch to the original channel...
--- vdr-1.6.0.orig/debian/patches/opt-22-x_edit_marks.dpatch
+++ vdr-1.6.0/debian/patches/opt-22-x_edit_marks.dpatch
@@ -0,0 +1,72 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-22-x_edit_marks.dpatch by FrankJepsen at vdrportal.de
+## http://www.jepsennet.de/vdr/download/opt-22-x_edit_marks.dpatch
+##
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch adds keys '1', '3' in replay mode to move marks by +/-5secs.
+## DP: When in replay mode key '0' sets a mark and stops there.
+## DP: 'Green' and 'Yellow' act as 'Prev' and 'Next'.
+@DPATCH@
+diff -u vdr-1.6.0p/menu.c vdr-1.6.0n/menu.c
+--- vdr-1.6.0p/menu.c   2010-01-15 12:55:13.000000000 +0100
++++ vdr-1.6.0n/menu.c   2010-01-15 13:17:01.000000000 +0100
+@@ -5078,10 +5078,6 @@
+     case kGreen:   SkipSeconds(-60); break;
+     case kYellow|k_Repeat:
+     case kYellow:  SkipSeconds( 60); break;
+-    case k1|k_Repeat:
+-    case k1:       SkipSeconds(-20); break;
+-    case k3|k_Repeat:
+-    case k3:       SkipSeconds( 20); break;
+     case kPrev|k_Repeat:
+     case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                       lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+@@ -5109,10 +5105,46 @@
+                    Stop();
+                    return osEnd;
+     default: {
++      bool play, forward;
++      int speed;
++      int Current, Total;
++      cMark *m;
++
+       DoShowMode = false;
+       switch (Key) {
+         // Editing:
+-        case kMarkToggle:      MarkToggle(); break;
++        case k1|k_Repeat:
++        case k1:            if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
++                             displayFrames = true;
++                             int p = SkipFrames(-5 * FRAMESPERSEC);
++                             cMark *m2;
++                             if ((m2 = marks.Prev(m)) != NULL && m2->position >= p)
++                               break;
++                             Goto(m->position = p, true);
++                             marks.Save();
++                           }
++                           else
++                               SkipSeconds(-20);
++                           break;
++        case k3|k_Repeat:
++        case k3:            if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
++                             displayFrames = true;
++                             int p = SkipFrames(5 * FRAMESPERSEC);
++                             cMark *m2;
++                             if ((m2 = marks.Next(m)) != NULL && m2->position <= p)
++                               break;
++                             Goto(m->position = p, true);
++                             marks.Save();
++                           }
++                           else
++                               SkipSeconds(20);
++                           break;
++        case kMarkToggle:   if (GetReplayMode(play, forward, speed) && play) {
++                              displayFrames = true;
++                              Pause();
++                           }
++                            MarkToggle();
++                            break;
+         case kMarkJumpBack|k_Repeat:
+         case kMarkJumpBack:    MarkJump(false); break;
+         case kMarkJumpForward|k_Repeat:
--- vdr-1.6.0.orig/debian/patches/opt-21_internal-cam-devices.dpatch
+++ vdr-1.6.0/debian/patches/opt-21_internal-cam-devices.dpatch
@@ -0,0 +1,86 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-21_internal-cam-devices.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch allows tuning to encrypted channels which are
+## DP: provided by a stremdev client device and therefore already are
+## DP: decrypted on the streamdev server side.
+## DP: See also: http://www.vdr-developer.org/mantisbt/view.php?id=429
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/device.c vdr-1.6.0/device.c
+--- vdr-1.6.0~/device.c	2008-03-09 11:03:34.000000000 +0100
++++ vdr-1.6.0/device.c	2008-07-24 16:34:52.000000000 +0200
+@@ -363,6 +363,7 @@
+   int NumCamSlots = CamSlots.Count();
+   int SlotPriority[NumCamSlots];
+   int NumUsableSlots = 0;
++  bool InternalCamNeeded = false;
+   if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
+      for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
+          SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
+@@ -376,7 +377,7 @@
+             }
+          }
+      if (!NumUsableSlots)
+-        return NULL; // no CAM is able to decrypt this channel
++        InternalCamNeeded = true; // no CAM is able to decrypt this channel
+      }
+ 
+   bool NeedsDetachReceivers = false;
+@@ -392,11 +393,13 @@
+              continue; // this device shall be temporarily avoided
+           if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
+              continue; // a specific card was requested, but not this one
+-          if (NumUsableSlots && !CamSlots.Get(j)->Assign(device[i], true))
++          if (InternalCamNeeded && !device[i]->HasInternalCam())
++             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
++          if (NumUsableSlots && !device[i]->HasInternalCam() && !CamSlots.Get(j)->Assign(device[i], true))
+              continue; // CAM slot can't be used with this device
+           bool ndr;
+           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basicly able to do the job
+-             if (NumUsableSlots && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
++             if (NumUsableSlots && !device[i]->HasInternalCam() && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+                 ndr = true; // using a different CAM slot requires detaching receivers
+              // Put together an integer number that reflects the "impact" using
+              // this device would have on the overall system. Each condition is represented
+@@ -410,18 +413,18 @@
+              imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
+              imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
+              imp <<= 8; imp |= min(max(device[i]->Priority() + MAXPRIORITY, 0), 0xFF);                               // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+-             imp <<= 8; imp |= min(max((NumUsableSlots ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
++             imp <<= 8; imp |= min(max(((NumUsableSlots && !device[i]->HasInternalCam()) ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+              imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
+              imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
+-             imp <<= 1; imp |= NumUsableSlots ? 0 : device[i]->HasCi();                                              // avoid cards with Common Interface for FTA channels
++             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+              imp <<= 1; imp |= device[i]->HasDecoder();                                                              // avoid full featured cards
+-             imp <<= 1; imp |= NumUsableSlots ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
++             imp <<= 1; imp |= (NumUsableSlots && !device[i]->HasInternalCam()) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+              if (imp < Impact) {
+                 // This device has less impact than any previous one, so we take it.
+                 Impact = imp;
+                 d = device[i];
+                 NeedsDetachReceivers = ndr;
+-                if (NumUsableSlots)
++                if (NumUsableSlots && !device[i]->HasInternalCam())
+                    s = CamSlots.Get(j);
+                 }
+              }
+diff -urNad vdr-1.6.0~/device.h vdr-1.6.0/device.h
+--- vdr-1.6.0~/device.h	2008-02-23 14:13:04.000000000 +0100
++++ vdr-1.6.0/device.h	2008-07-24 16:36:12.000000000 +0200
+@@ -335,6 +335,13 @@
+ public:
+   virtual bool HasCi(void);
+          ///< Returns true if this device has a Common Interface.
++#define INTERNAL_CAM_DEVICES_PATCH 1
++  virtual bool HasInternalCam(void) { return false; }
++         ///< Returns true if this device handles encrypted channels itself
++         ///< without VDR assistance. This can be e.g. when the device is a
++         ///< client that gets the stream from another VDR instance that has
++         ///< already decrypted the stream. In this case ProvidesChannel()
++         ///< shall check whether the channel can be decrypted.
+   void SetCamSlot(cCamSlot *CamSlot);
+          ///< Sets the given CamSlot to be used with this device.
+   cCamSlot *CamSlot(void) const { return camSlot; }
--- vdr-1.6.0.orig/debian/patches/20_gcc44_ftbfs.dpatch
+++ vdr-1.6.0/debian/patches/20_gcc44_ftbfs.dpatch
@@ -0,0 +1,74 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 20_gcc44_ftbfs.dpatch copied from Fedora
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fix FTBFS with gcc 4.4
+## DP: http://cvs.fedoraproject.org/viewvc/rpms/vdr/devel/vdr-1.6.0-const.diff?revision=1.1&view=markup
+
+@DPATCH@
+--- vdr-1.6.0.orig/recording.c
++++ vdr-1.6.0/recording.c
+@@ -509,8 +509,8 @@ cRecording::cRecording(cTimer *Timer, co
+      Utf8Strn0Cpy(SubtitleBuffer, Subtitle, MAX_SUBTITLE_LENGTH);
+      Subtitle = SubtitleBuffer;
+      }
+-  char *macroTITLE   = strstr(Timer->File(), TIMERMACRO_TITLE);
+-  char *macroEPISODE = strstr(Timer->File(), TIMERMACRO_EPISODE);
++  const char *macroTITLE   = strstr(Timer->File(), TIMERMACRO_TITLE);
++  const char *macroEPISODE = strstr(Timer->File(), TIMERMACRO_EPISODE);
+   if (macroTITLE || macroEPISODE) {
+      name = strdup(Timer->File());
+      name = strreplace(name, TIMERMACRO_TITLE, Title);
+@@ -551,7 +551,7 @@ cRecording::cRecording(const char *FileN
+   sortBuffer = NULL;
+   fileName = strdup(FileName);
+   FileName += strlen(VideoDirectory) + 1;
+-  char *p = strrchr(FileName, '/');
++  const char *p = strrchr(FileName, '/');
+ 
+   name = NULL;
+   info = new cRecordingInfo;
+@@ -1022,7 +1022,8 @@ void cRecordings::DelByName(const char *
+   if (recording) {
+      cThreadLock DeletedRecordingsLock(&DeletedRecordings);
+      Del(recording, false);
+-     char *ext = strrchr(recording->FileName(), '.');
++     // wtf?
++     char *ext = strrchr(const_cast<char*>(recording->FileName()), '.');
+      if (ext) {
+         strncpy(ext, DELEXT, strlen(ext));
+         recording->fileSizeMB = DirSizeMB(recording->FileName());
+--- vdr-1.6.0.orig/svdrp.c
++++ vdr-1.6.0/svdrp.c
+@@ -736,7 +736,7 @@ void cSVDRP::CmdGRAB(const char *Option)
+      char *strtok_next;
+      FileName = strtok_r(p, delim, &strtok_next);
+      // image type:
+-     char *Extension = strrchr(FileName, '.');
++     const char *Extension = strrchr(FileName, '.');
+      if (Extension) {
+         if (strcasecmp(Extension, ".jpg") == 0 || strcasecmp(Extension, ".jpeg") == 0)
+            Jpeg = true;
+@@ -795,16 +795,17 @@ void cSVDRP::CmdGRAB(const char *Option)
+      char RealFileName[PATH_MAX];
+      if (FileName) {
+         if (grabImageDir) {
+-           cString s;
+-           char *slash = strrchr(FileName, '/');
++           cString s(FileName);
++           FileName = s;
++           const char *slash = strrchr(FileName, '/');
+            if (!slash) {
+               s = AddDirectory(grabImageDir, FileName);
+               FileName = s;
+               }
+            slash = strrchr(FileName, '/'); // there definitely is one
+-           *slash = 0;
+-           char *r = realpath(FileName, RealFileName);
+-           *slash = '/';
++           cString t(s);
++           t.Truncate(slash - FileName);
++           char *r = realpath(t, RealFileName);
+            if (!r) {
+               LOG_ERROR_STR(FileName);
+               Reply(501, "Invalid file name \"%s\"", FileName);
--- vdr-1.6.0.orig/debian/patches/opt-45_yaepg.dpatch
+++ vdr-1.6.0/debian/patches/opt-45_yaepg.dpatch
@@ -0,0 +1,90 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-45_yaepg.dpatch by bball950@yahoo.com
+## http://www.hoochvdr.info/yaepg/vdr-1.3.19-core-yaepg.diff
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.3.25
+##   - adapted to VDR-1.3.42
+##   - adapted to VDR-1.5.2
+##   - adapted to VDR-1.5.3 (removed special yaepg font)
+##   - adapted to VDR-1.5.9
+## Tobias Grimm <tg@e-tobi.net>:
+##   - applied modification from Michal Nival that fixes a small bug
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is needed for the yaepg plugin.
+
+@DPATCH@
+--- vdr-1.5.10/device.h
++++ vdr-1.5.10/device.h
+@@ -238,12 +238,12 @@
+          ///< Direction (only the sign of Direction is evaluated, positive values
+          ///< switch to higher channel numbers).
+ private:
+-  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
+-         ///< Sets the device to the given channel (general setup).
+ protected:
+   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
+          ///< Sets the device to the given channel (actual physical setup).
+ public:
++  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
++         ///< Sets the device to the given channel (general setup).
+   static int CurrentChannel(void) { return primaryDevice ? currentChannel : 0; }
+          ///< Returns the number of the current channel on the primary device.
+   static void SetCurrentChannel(const cChannel *Channel) { currentChannel = Channel ? Channel->Number() : 0; }
+--- vdr-1.5.10/dvbosd.c
++++ vdr-1.5.10/dvbosd.c
+@@ -80,6 +80,10 @@ void cDvbOsd::SetActive(bool On)
+             Cmd(OSD_SetWindow, 0, i + 1);
+             Cmd(OSD_Close);
+             }
++        if (vidWin.bpp != 0) {
++           Cmd(OSD_SetWindow, 0, MAXNUMWINDOWS);
++           Cmd(OSD_Close);
++           }
+         shown = false;
+         }
+      }
+@@ -115,6 +119,10 @@ eOsdError cDvbOsd::SetAreas(const tArea 
+          Cmd(OSD_SetWindow, 0, i + 1);
+          Cmd(OSD_Close);
+          }
++     if (vidWin.bpp != 0) {
++        Cmd(OSD_SetWindow, 0, MAXNUMWINDOWS);
++        Cmd(OSD_Close);
++        }
+      shown = false;
+      }
+   return cOsd::SetAreas(Areas, NumAreas);
+@@ -198,6 +206,11 @@ void cDvbOsd::Flush(void)
+          Cmd(OSD_SetWindow, 0, i + 1);
+          Cmd(OSD_MoveWindow, 0, Left() + Bitmap->X0(), Top() + Bitmap->Y0());
+          }
++     if (vidWin.bpp != 0) {
++        Cmd(OSD_SetWindow, 0, MAXNUMWINDOWS);
++        Cmd(OSD_OpenRaw, vidWin.bpp, vidWin.x1, vidWin.y1,
++            vidWin.x2, vidWin.y2, (void *)0);
++        }
+      shown = true;
+      }
+ }
+--- vdr-1.5.10/osd.c
++++ vdr-1.5.10/osd.c
+@@ -737,6 +737,7 @@ cOsd::cOsd(int Left, int Top, uint Level
+          }
+       }
+   Osds.Append(this);
++  vidWin.bpp = 0;
+ }
+ 
+ cOsd::~cOsd()
+--- vdr-1.5.10/osd.h
++++ vdr-1.5.10/osd.h
+@@ -400,6 +400,7 @@
+        ///< 7: vertical,   falling, upper
+   virtual void Flush(void);
+        ///< Actually commits all data to the OSD hardware.
++  tArea vidWin;
+   };
+ 
+ class cOsdProvider {
--- vdr-1.6.0.orig/debian/patches/12_osdbase-maxitems.dpatch
+++ vdr-1.6.0/debian/patches/12_osdbase-maxitems.dpatch
@@ -0,0 +1,46 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## 12_osdbase-maxitems.dpatch by Andreas Brugger <brougs78@gmx.net>
+##
+## downloaded from http://vdrportal.de/board/thread.php?postid=343665#post343665
+## original filename: vdr-1.3.28-osdbase-maxitems.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fixes problems with text2skin skin enigma.
+
+@DPATCH@
+diff -Nru vdr_plain/osdbase.c vdr_patched/osdbase.c
+--- vdr_plain/osdbase.c	2005-06-18 12:30:51.000000000 +0200
++++ vdr_patched/osdbase.c	2005-08-07 20:26:55.000000000 +0200
+@@ -261,6 +261,7 @@
+ 
+ void cOsdMenu::CursorUp(void)
+ {
++  displayMenuItems = displayMenu->MaxItems();
+   int tmpCurrent = current;
+   int lastOnScreen = first + displayMenuItems - 1;
+   int last = Count() - 1;
+@@ -291,6 +292,7 @@
+ 
+ void cOsdMenu::CursorDown(void)
+ {
++  displayMenuItems = displayMenu->MaxItems();
+   int tmpCurrent = current;
+   int lastOnScreen = first + displayMenuItems - 1;
+   int last = Count() - 1;
+@@ -323,6 +325,7 @@
+ 
+ void cOsdMenu::PageUp(void)
+ {
++  displayMenuItems = displayMenu->MaxItems();
+   int oldCurrent = current;
+   int oldFirst = first;
+   current -= displayMenuItems;
+@@ -357,6 +360,7 @@
+ 
+ void cOsdMenu::PageDown(void) 
+ {
++  displayMenuItems = displayMenu->MaxItems();
+   int oldCurrent = current;
+   int oldFirst = first;
+   current += displayMenuItems;
--- vdr-1.6.0.orig/debian/patches/10_dd-record-option.dpatch
+++ vdr-1.6.0/debian/patches/10_dd-record-option.dpatch
@@ -0,0 +1,117 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10_dd-record-option.dpatch by Thomas Schmidt <tschmidt@debian.org>
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.0
+##   - fixed i18n texts for replay
+##   - adapted to VDR-1.5.7
+##     http://toms-cafe.de/vdr/download/vdr-dd-record-option-1.5.7.diff
+##   - added French language texts (thanks to Michal Nival)
+##     http://toms-cafe.de/vdr/download/vdr-dd-record-option-1.6.0.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Allows to choose if to record and to replay Dolby Digital
+## DP: independently (to work around some audio issues with the
+## DP: dvd-plugin)
+
+@DPATCH@
+--- vdr-1.6.0/config.c
++++ vdr-1.6.0/config.c
+@@ -259,6 +259,7 @@ cSetup::cSetup(void)
+   VideoDisplayFormat = 1;
+   VideoFormat = 0;
+   UpdateChannels = 5;
++  RecordDolbyDigital = 1;
+   UseDolbyDigital = 1;
+   ChannelInfoPos = 0;
+   ChannelInfoTime = 5;
+@@ -432,6 +433,7 @@ bool cSetup::Parse(const char *Name, con
+   else if (!strcasecmp(Name, "VideoDisplayFormat"))  VideoDisplayFormat = atoi(Value);
+   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
+   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
++  else if (!strcasecmp(Name, "RecordDolbyDigital"))  RecordDolbyDigital = atoi(Value);
+   else if (!strcasecmp(Name, "UseDolbyDigital"))     UseDolbyDigital    = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoTime"))     ChannelInfoTime    = atoi(Value);
+@@ -515,6 +517,7 @@ bool cSetup::Save(void)
+   Store("VideoDisplayFormat", VideoDisplayFormat);
+   Store("VideoFormat",        VideoFormat);
+   Store("UpdateChannels",     UpdateChannels);
++  Store("RecordDolbyDigital", RecordDolbyDigital);
+   Store("UseDolbyDigital",    UseDolbyDigital);
+   Store("ChannelInfoPos",     ChannelInfoPos);
+   Store("ChannelInfoTime",    ChannelInfoTime);
+--- vdr-1.6.0/config.h
++++ vdr-1.6.0/config.h
+@@ -241,6 +241,7 @@ public:
+   int VideoDisplayFormat;
+   int VideoFormat;
+   int UpdateChannels;
++  int RecordDolbyDigital;
+   int UseDolbyDigital;
+   int ChannelInfoPos;
+   int ChannelInfoTime;
+--- vdr-1.6.0/menu.c
++++ vdr-1.6.0/menu.c
+@@ -2488,7 +2488,8 @@ void cMenuSetupDVB::Setup(void)
+   Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
+   if (data.VideoFormat == 0)
+      Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
+-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Record Dolby Digital"),  &data.RecordDolbyDigital));
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Replay Dolby Digital"),  &data.UseDolbyDigital));
+   Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
+   Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
+   for (int i = 0; i < numAudioLanguages; i++)
+--- vdr-1.6.0/po/de_DE.po
++++ vdr-1.6.0/po/de_DE.po
+@@ -620,8 +620,11 @@ msgstr "Videoformat"
+ msgid "Setup.DVB$Video display format"
+ msgstr "Video-Anzeigeformat"
+ 
+-msgid "Setup.DVB$Use Dolby Digital"
+-msgstr "Dolby-Digital-Ton benutzen"
++msgid "Setup.DVB$Record Dolby Digital"
++msgstr "Dolby-Digital-Ton aufzeichnen"
++
++msgid "Setup.DVB$Replay Dolby Digital"
++msgstr "Dolby-Digital-Ton wiedergeben"
+ 
+ msgid "Setup.DVB$Update channels"
+ msgstr "Kanle aktualisieren"
+--- vdr-1.6.0/po/fr_FR.po
++++ vdr-1.6.0/po/fr_FR.po
+@@ -626,8 +626,11 @@ msgstr "Format vido"
+ msgid "Setup.DVB$Video display format"
+ msgstr "Format d'affichage"
+ 
+-msgid "Setup.DVB$Use Dolby Digital"
+-msgstr "Utiliser le Dolby Digital"
++msgid "Setup.DVB$Record Dolby Digital"
++msgstr "Enregistrer le Dolby Digital"
++
++msgid "Setup.DVB$Replay Dolby Digital"
++msgstr "Lire le Dolby Digital"
+ 
+ msgid "Setup.DVB$Update channels"
+ msgstr "Mettre  jour les chanes"
+--- vdr-1.6.0/recorder.c
++++ vdr-1.6.0/recorder.c
+@@ -127,7 +127,7 @@ void cFileWriter::Action(void)
+ // --- cRecorder -------------------------------------------------------------
+ 
+ cRecorder::cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids)
+-:cReceiver(ChannelID, Priority, VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids)
++:cReceiver(ChannelID, Priority, VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids)
+ ,cThread("recording")
+ {
+   // Make sure the disk is up and running:
+@@ -136,7 +136,7 @@ cRecorder::cRecorder(const char *FileNam
+ 
+   ringBuffer = new cRingBufferLinear(RECORDERBUFSIZE, TS_SIZE * 2, true, "Recorder");
+   ringBuffer->SetTimeouts(0, 100);
+-  remux = new cRemux(VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids, true);
++  remux = new cRemux(VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids, true);
+   writer = new cFileWriter(FileName, remux);
+ }
+ 
--- vdr-1.6.0.orig/debian/patches/18_vdr-maintenance-1.6.0-2.dpatch
+++ vdr-1.6.0/debian/patches/18_vdr-maintenance-1.6.0-2.dpatch
@@ -0,0 +1,594 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 18_vdr-maintenance-1.6.0-2.dpatch by Klaus Schmidinger <Klaus.Schmidinger@tvdr.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: VDR 1.6.0 maintenance patch #2
+
+@DPATCH@
+diff -ruN vdr-1.6.0-1/CONTRIBUTORS vdr-1.6.0-2/CONTRIBUTORS
+--- vdr-1.6.0-1/CONTRIBUTORS	2008-04-13 15:34:03.000000000 +0200
++++ vdr-1.6.0-2/CONTRIBUTORS	2008-09-06 16:46:56.000000000 +0200
+@@ -1053,6 +1053,7 @@
+  language
+  for fixing displaying the free disk space when entering the recordings menu where
+  the last replayed recording was in a subdirectory, and pressing Back
++ for replacing the Finnish language code "smi" with "suo"
+ 
+ Ralf Klueber <ralf.klueber@vodafone.com>
+  for reporting a bug in cutting a recording if there is only a single editing mark
+@@ -1579,6 +1580,7 @@
+  for making housekeeping wait for a while after a replay has ended
+  for fixing error handling in cCuttingThread::Action()
+  for suppressing the automatic shutdown if the remote control is currently disabled
++ for fixing a problem with calling isyslog() from within the SignalHandler()
+ 
+ Sven Kreiensen <svenk@kammer.uni-hannover.de>
+  for his help in keeping 'channels.conf.terr' up to date
+@@ -1895,6 +1897,7 @@
+  for fixing cTimer::operator=() in case a cTimer variable is assigned to itself
+  for making the list of tracks given in cStatus::SetAudioTrack() NULL terminated
+  for fixing handling kLeft in the calls to cStatus::MsgOsdTextItem()
++ for fixing a possible integer overflow in GetAbsTime()
+ 
+ Philip Prindeville <philipp_subx@redfish-solutions.com>
+  for updates to 'sources.conf'
+@@ -2116,6 +2119,7 @@
+  for making the non-breaking space symbol be rendered as a blank
+  for fixing a signed character used as index in cBase64Encoder::NextLine()
+  for fixing formatting the name section in the VDR man pages
++ for reporting unneeded include files <linux/dvb/dmx.h> und <time.h> in remux.h
+ 
+ Helge Lenz <h.lenz@gmx.de>
+  for reporting a bug in setting the 'Delta' parameter when calling the shutdown
+@@ -2352,3 +2356,10 @@
+ 
+ Nan Feng <nfgx@21cn.com>
+  for translating OSD texts to the Chinese language
++
++Edgar Toernig <froese@gmx.de>
++ for suggesting to not call FcFini() to avoid problems with older (broken) versions
++ of fontconfig
++
++Winfried Khler <w_koehl@gmx.de>
++ for fixing wrong value for TableIdBAT in libsi/si.h
+diff -ruN vdr-1.6.0-1/HISTORY vdr-1.6.0-2/HISTORY
+--- vdr-1.6.0-1/HISTORY	2008-04-13 15:33:46.000000000 +0200
++++ vdr-1.6.0-2/HISTORY	2008-09-06 16:36:51.000000000 +0200
+@@ -5740,3 +5740,21 @@
+   Andreas Mair).
+ - Increased the time between checking the CAM status to 500ms to avoid problems
+   with some CAMs (reported by Arthur Konovalov).
++
++2008-09-06: Version 1.6.0-2
++
++- Updated the Italian OSD texts (thanks to Diego Pierotto).
++- The SVDRP signon message now indicates the character encoding in use, as in
++  "220 video SVDRP VideoDiskRecorder 1.7.1; Fri May  2 16:17:10 2008; ISO-8859-1".
++  This may be useful for instance for external tools that provide EPG data, so that
++  they can correctly encode the strings.
++- No longer calling FcFini() to avoid problems with older (broken) versions of
++  fontconfig (suggested by Edgar Toernig).
++- Updated the sources.conf file (thanks to Oleg Roitburd).
++- Fixed a possible integer overflow in GetAbsTime() (thanks to Alexander Rieger).
++- Fixed a problem with calling isyslog() from within the SignalHandler() (thanks
++  to Udo Richter).
++- Replaced the Finnish language code "smi" with "suo" (thanks to Rolf Ahrenberg).
++- Fixed wrong value for TableIdBAT in libsi/si.h (thanks to Winfried Khler).
++- Removed unneeded include files <linux/dvb/dmx.h> und <time.h> from remux.h
++  (reported by Tobias Grimm).
+diff -ruN vdr-1.6.0-1/config.h vdr-1.6.0-2/config.h
+--- vdr-1.6.0-1/config.h	2008-04-13 13:09:42.000000000 +0200
++++ vdr-1.6.0-2/config.h	2008-09-07 11:33:03.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: config.h 1.310.1.1 2008/04/13 11:09:42 kls Exp $
++ * $Id: config.h 1.310.1.2 2008/09/07 09:33:03 kls Exp $
+  */
+ 
+ #ifndef __CONFIG_H
+@@ -22,7 +22,7 @@
+ 
+ // VDR's own version number:
+ 
+-#define VDRVERSION  "1.6.0-1"
++#define VDRVERSION  "1.6.0-2"
+ #define VDRVERSNUM   10600  // Version * 10000 + Major * 100 + Minor
+ 
+ // The plugin API's version number:
+diff -ruN vdr-1.6.0-1/font.c vdr-1.6.0-2/font.c
+--- vdr-1.6.0-1/font.c	2008-03-01 11:19:41.000000000 +0100
++++ vdr-1.6.0-2/font.c	2008-05-03 11:59:24.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: font.c 1.25 2008/03/01 10:19:41 kls Exp $
++ * $Id: font.c 1.25.1.1 2008/05/03 09:59:24 kls Exp $
+  */
+ 
+ #include "font.h"
+@@ -395,7 +395,7 @@
+      FcFontSetDestroy(fontset);
+      FcPatternDestroy(pat);
+      FcObjectSetDestroy(os);
+-     FcFini();
++     //FcFini(); // older versions of fontconfig are broken - and FcInit() can be called more than once
+      FontNames->Sort();
+      }
+   return FontNames->Size() > 0;
+@@ -431,7 +431,7 @@
+         esyslog("ERROR: no usable font found for '%s'", FontName);
+      FcPatternDestroy(pat);
+      free(fn);
+-     FcFini();
++     //FcFini(); // older versions of fontconfig are broken - and FcInit() can be called more than once
+      }
+   return FontFileName;
+ }
+diff -ruN vdr-1.6.0-1/i18n.c vdr-1.6.0-2/i18n.c
+--- vdr-1.6.0-1/i18n.c	2008-01-19 13:07:11.000000000 +0100
++++ vdr-1.6.0-2/i18n.c	2008-09-06 14:21:17.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: i18n.c 1.319 2008/01/19 12:07:11 kls Exp $
++ * $Id: i18n.c 1.319.1.1 2008/09/06 12:21:17 kls Exp $
+  *
+  *
+  */
+@@ -45,7 +45,7 @@
+   "por",
+   "fra,fre",
+   "nor",
+-  "fin,smi",
++  "fin,suo",
+   "pol",
+   "esl,spa",
+   "ell,gre",
+diff -ruN vdr-1.6.0-1/libsi/si.h vdr-1.6.0-2/libsi/si.h
+--- vdr-1.6.0-1/libsi/si.h	2007-04-22 15:32:09.000000000 +0200
++++ vdr-1.6.0-2/libsi/si.h	2008-09-06 14:40:49.000000000 +0200
+@@ -6,7 +6,7 @@
+  *   the Free Software Foundation; either version 2 of the License, or     *
+  *   (at your option) any later version.                                   *
+  *                                                                         *
+- *   $Id: si.h 1.17 2007/04/22 13:32:09 kls Exp $
++ *   $Id: si.h 1.17.1.1 2008/09/06 12:40:49 kls Exp $
+  *                                                                         *
+  ***************************************************************************/
+ 
+@@ -28,7 +28,7 @@
+                TableIdNIT_other  = 0x41, //network information section, other network
+                TableIdSDT = 0x42, //service description section
+                TableIdSDT_other  = 0x46,
+-               TableIdBAT = 0x46, //bouquet association section
++               TableIdBAT = 0x4A, //bouquet association section
+                TableIdEIT_presentFollowing = 0x4E, //event information section
+                TableIdEIT_presentFollowing_other = 0x4F,
+                //range from 0x50 to 0x5F
+diff -ruN vdr-1.6.0-1/po/it_IT.po vdr-1.6.0-2/po/it_IT.po
+--- vdr-1.6.0-1/po/it_IT.po	2008-03-09 11:33:04.000000000 +0100
++++ vdr-1.6.0-2/po/it_IT.po	2008-04-19 12:03:16.000000000 +0200
+@@ -12,9 +12,9 @@
+ "Project-Id-Version: VDR 1.6.0\n"
+ "Report-Msgid-Bugs-To: <vdr-bugs@cadsoft.de>\n"
+ "POT-Creation-Date: 2008-02-10 12:22+0100\n"
+-"PO-Revision-Date: 2008-03-08 21:06+0100\n"
++"PO-Revision-Date: 2008-04-17 01:07+0100\n"
+ "Last-Translator: Diego Pierotto <vdr-italian@tiscali.it>\n"
+-"Language-Team:  Italian\n"
++"Language-Team: Italian\n"
+ "MIME-Version: 1.0\n"
+ "Content-Type: text/plain; charset=ISO-8859-15\n"
+ "Content-Transfer-Encoding: 8bit\n"
+@@ -221,7 +221,7 @@
+ msgstr "Disco"
+ 
+ msgid "free"
+-msgstr "liberi"
++msgstr "disponibile"
+ 
+ msgid "Free To Air"
+ msgstr "in chiaro"
+@@ -230,7 +230,7 @@
+ msgstr "codificato"
+ 
+ msgid "auto"
+-msgstr "automatico"
++msgstr "automatica"
+ 
+ msgid "Edit channel"
+ msgstr "Modifica canale"
+@@ -293,7 +293,7 @@
+ msgstr "CoderateH"
+ 
+ msgid "none"
+-msgstr "nessuno"
++msgstr "nessuna"
+ 
+ msgid "CoderateL"
+ msgstr "CoderateL"
+@@ -404,20 +404,20 @@
+ msgstr "Prossimi programmi"
+ 
+ msgid "Button$Next"
+-msgstr "Prossimo"
++msgstr "Prossimi"
+ 
+ msgid "Button$Now"
+ msgstr "Adesso"
+ 
+ msgid "Button$Schedule"
+-msgstr "Programma"
++msgstr "Programmi"
+ 
+ msgid "Can't switch channel!"
+ msgstr "Impossibile cambiare canale!"
+ 
+ #, c-format
+ msgid "Schedule - %s"
+-msgstr "Programma - %s"
++msgstr "Programmi - %s"
+ 
+ #, c-format
+ msgid "This event - %s"
+@@ -500,7 +500,7 @@
+ msgstr "Altezza OSD"
+ 
+ msgid "Setup.OSD$Message time (s)"
+-msgstr "Tempo del messaggio (s)"
++msgstr "Durata del messaggio (s)"
+ 
+ msgid "Setup.OSD$Use small font"
+ msgstr "Utilizza caratteri piccoli"
+@@ -572,7 +572,7 @@
+ msgstr "Mostra vecchi dati EPG (min)"
+ 
+ msgid "Setup.EPG$Set system time"
+-msgstr "Imposta orario automatico"
++msgstr "Imposta orario di sistema"
+ 
+ msgid "Setup.EPG$Use time from transponder"
+ msgstr "Utilizza orario da transponder"
+@@ -628,7 +628,7 @@
+ msgstr "Dolby Digital"
+ 
+ msgid "Setup.DVB$Update channels"
+-msgstr "Aggiorna i canali"
++msgstr "Aggiornamento canali"
+ 
+ msgid "Setup.DVB$Audio languages"
+ msgstr "Lingue audio"
+@@ -739,7 +739,7 @@
+ msgstr "Nome reg. immediata"
+ 
+ msgid "Setup.Recording$Instant rec. time (min)"
+-msgstr "Tempo reg. immediata (min)"
++msgstr "Durata reg. immediata (min)"
+ 
+ msgid "Setup.Recording$Max. video file size (MB)"
+ msgstr "Dim. massima file video (MB)"
+@@ -899,7 +899,7 @@
+ msgstr "Plugin"
+ 
+ msgid "Up/Dn for new location - OK to move"
+-msgstr "Su/Gi per nuova posizione - OK per muovere"
++msgstr "Su/Gi per nuova posizione - OK per spostare"
+ 
+ msgid "Channel locked (recording)!"
+ msgstr "Canale bloccato (in registrazione)!"
+diff -ruN vdr-1.6.0-1/remux.h vdr-1.6.0-2/remux.h
+--- vdr-1.6.0-1/remux.h	2007-09-02 12:19:06.000000000 +0200
++++ vdr-1.6.0-2/remux.h	2008-09-06 16:34:42.000000000 +0200
+@@ -4,14 +4,12 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: remux.h 1.17 2007/09/02 10:19:06 kls Exp $
++ * $Id: remux.h 1.17.1.1 2008/09/06 14:34:42 kls Exp $
+  */
+ 
+ #ifndef __REMUX_H
+ #define __REMUX_H
+ 
+-#include <time.h> //XXX FIXME: DVB/linux/dvb/dmx.h should include <time.h> itself!!!
+-#include <linux/dvb/dmx.h>
+ #include "ringbuffer.h"
+ #include "tools.h"
+ 
+diff -ruN vdr-1.6.0-1/sources.conf vdr-1.6.0-2/sources.conf
+--- vdr-1.6.0-1/sources.conf	2007-02-17 17:15:13.000000000 +0100
++++ vdr-1.6.0-2/sources.conf	2008-08-16 12:06:30.000000000 +0200
+@@ -19,29 +19,34 @@
+ 
+ # Europe
+ 
+-S5E     Sirius 2/3
++S3E     Telecom 2C
++S4E     Eurobird 4
++S5E     Sirius 4
+ S7E     Eutelsat W3A
++S9E     Eurobird 9
+ S10E    Eutelsat W1
+-S13E    Hotbird 1-3/6/7A
++S13E    Hotbird 6/7A/8
+ S16E    Eutelsat W2
+-S19.2E  Astra 1B/C/E/F/G/H/2C
++S19.2E  Astra F/G/H/KR/L
+ S21.0E  Afristar 1
+ S21.6E  Eutelsat W6
+-S23.5E  Astra 1D 3A
+-S26E    Arabsat 2D/2C/3A
++S23.5E  Astra 1E/3A
++S25.5E  Eurobird 2
++S26E    Badr 3/4/6
+ S28.2E  Astra 2D/A/B
+-S28.5E  Eurobird 1 & Astra 2A/B/D
++S28.5E  Eurobird 1 & Astra 2A/B/C/D
+ S30.5E  Arabsat 2B
++S31.5E  Astra 1D/5A
+ S33E    Eurobird 3 & Intelsat 802
+ S36E    Eutelsat W4 & Sesat
+ S38E    Paksat 1
+ S39E    Hellas Sat 2
+ S40E    Express AM1
+-S42E    Turksat 1C/2A
++S42E    Turksat 2A/3A
+ S45E    Intelsat 12
+ S49E    Yamal 202
+ S53E    Express AM 22
+-S55E    Insat 3E & Intelsat 702
++S55E    Insat 3E 
+ S56E    Bonum 1
+ S57E    NSS 703
+ S60E    Intelsat 904
+@@ -54,10 +59,10 @@
+ 
+ # Asia
+ 
+-S74E    Insat 3C & Edusat
+-S75E    LMI 1
++S74E    Insat 3C/4CR & Edusat
++S75E    ABS 1
+ S76.5E  Telstar 10
+-S78.5E  Thaicom 2/3
++S78.5E  Thaicom 2/5
+ S80E    Express AM2
+ S83E    Insat 2E/3B/4A
+ S85.2E  Intelsat 709
+@@ -65,14 +70,17 @@
+ S88E    ST 1
+ S90E    Yamal 201
+ S91.5E  Measat 1
+-S93.5E  Insat 3A
++S92.2E  Chinasat 9
++S93.5E  Insat 3A/4B
+ S95E    NSS 6
+-S96.5E  Express AM 11
++S96.5E  Express AM 33
++S98.5E  Protostar 1
+ S100.5E Asiasat 2
+ S103E   Express A2
++S105E   Asiastar
+ S105.5E Asiasat 3S
+ S107.7E Cakrawarta 1
+-S108E   Telkom 1 & AAP 1
++S108E   Telkom 1 & NSS 11
+ S110E   N-Sat 110 & BSAT 1A/2A
+ S110.5E Sinosat 1
+ S113E   Palapa C2 & Koreasat 2
+@@ -81,38 +89,38 @@
+ S120E   Thaicom 1A
+ S122.2E Asiasat 4
+ S124E   JCSAT 4a
++S125E   Sinosat 3
+ S128E   JCSAT 3
+-S132E   N-Star A
++S132E   Vinasat 1 & JCSAT5a
+ S134E   Apstar 6
+-S136E   N-Star B
+ S138E   Telstar 18
+ S140E   Express AM 3
+ S144E   Superbird C
+ S146E   Agila 2
+ S148E   Measat 2
+ S150E   JCSAT R
+-S152E   Optus B3
++S152E   Optus D2
+ S154E   JCSAT 2A
+ S156E   Optus C1
+ S158E   Superbird A
+-S160E   Optus B1
++S160E   Optus D1
+ S162E   Superbird B2
+-S164E   Optus A3
++S164E   Optus B3
+ S166E   Intelsat 8
+ S169E   Intelsat 2
+-S172E   AMC 23
++S172E   GE 23
+ S180E   Intelsat 701
+ S177W   NSS 5
+ 
+ # Atlantic
+ 
+-S1W     Thor 2/3 & Intelsat 10-02
+-S4W     Amos 1/2
++S1W     Thor 3/5 & Intelsat 10-02
++S4W     Amos 1/2/3
+ S5W     Atlantic Bird 3
+-S7W     Nilesat 101 & 102
++S7W     Nilesat 101/102 & Atlantic Bird 4
+ S8W     Telecom 2D & Atlantic Bird 2
+ S11W    Express A3
+-S12.5W  Atlantic Bird 2
++S12.5W  Atlantic Bird 1
+ S14W    Express A4
+ S15W    Telstar 12
+ S18W    Intelsat 901
+@@ -123,9 +131,9 @@
+ S30W    Hispasat 1C/1D
+ S31.5W  Intelsat 801
+ S34.5W  Intelsat 903
+-S37.5W  Telstar 11 & AMC 12
++S37.5W  NSS 10
+ S40.5W  NSS 806
+-S43W    Intelsat 3R/6B
++S43W    Intelsat 3R/11
+ S45W    Intelsat 1R
+ S50W    Intelsat 705
+ S53W    Intelsat 707
+@@ -137,47 +145,45 @@
+ 
+ S61.5W  Echostar 3 & Rainbow 1
+ S63W    Estrelo de Sul 1
+-S65W    Brasilsat B2
+-S70W    Brasilsat B1
++S65W    Star One C1
++S70W    Star One C2
+ S72W    Nahuel 1 & AMC 6
+-S72.5W  DirecTV 1
+-S74W    SBS 6
+-S77W    Echostar 4
++S72.5W  DirecTV 1R & Echostar 6
++S74W    Horizons 2
++S77W    Echostar 4 & Galaxy 4R
+ S79W    AMC5
+-S79.5W  Nimiq 3
+ S82W    Nimiq 2
+ S83W    AMC 9
+-S84W    Brasilsat B3
+-S85W    AMC 2
++S84W    Brasilsat B3/4
++S85W    AMC 16
+ S85.1W  XM 3
+ S87W    AMC3
+ S89W    Galaxy 28
+-S91W    Galaxy 11 & Nimiq 1
+-S91.5W  DirecTV 2
+-S92W    Brasilsat B4
++S91W    Galaxy 11/17 & Nimiq 1
++S92W    Brasilsat B2
+ S93W    Galaxy 26
+ S95W    Galaxy 3C
+ S97W    Galaxy 25
+-S99W    Galaxy 4R
+-S99.2W  Spaceway 2
+-S101W   DirecTV 1R/4S/8 & AMC4
++S99W    Galaxy 16
++S99.2W  Spaceway 2 & DirecTV 11
++S101W   DirecTV 4S/8 & AMC 2/4
+ S103W   AMC1
+-S105W   AMC15
++S105W   AMC15/18
+ S107.3W Anik F1/F1R
+-S110W   DirecTV 5 & Echostar 6/8/10
++S110W   DirecTV 5 & Echostar 8/10
+ S111.1W Anik F2
+-S113W   Solidaridad 2
+-S119W   Echostar 7 & DirecTV 7S
++S113W   SatMex 6
++S116.8W SatMex 5
++S119W   Anik F3 & Echostar 7 & DirecTV 7S
+ S121W   Echostar 9 & Galaxy 23
+-S123W   Galaxy 10R
++S123W   Galaxy 18
+ S125W   Galaxy 14
+ S127W   Galaxy 13/Horizons 1
+ S129W   Echostar 5 & Galaxy 27
+ S131W   AMC 11
+-S133W   Galaxy15/1R
++S133W   Galaxy15
+ S135W   AMC 10
+ S137W   AMC 7
+-S138.5W Echostar 10
+ S139W   AMC 8
+ S148W   Echostar 1/2
+ 
+diff -ruN vdr-1.6.0-1/svdrp.c vdr-1.6.0-2/svdrp.c
+--- vdr-1.6.0-1/svdrp.c	2008-02-17 14:36:01.000000000 +0100
++++ vdr-1.6.0-2/svdrp.c	2008-05-02 16:29:16.000000000 +0200
+@@ -10,7 +10,7 @@
+  * and interact with the Video Disk Recorder - or write a full featured
+  * graphical interface that sits on top of an SVDRP connection.
+  *
+- * $Id: svdrp.c 1.109 2008/02/17 13:36:01 kls Exp $
++ * $Id: svdrp.c 1.109.1.1 2008/05/02 14:29:16 kls Exp $
+  */
+ 
+ #include "svdrp.h"
+@@ -1606,7 +1606,7 @@
+         char buffer[BUFSIZ];
+         gethostname(buffer, sizeof(buffer));
+         time_t now = time(NULL);
+-        Reply(220, "%s SVDRP VideoDiskRecorder %s; %s", buffer, VDRVERSION, *TimeToString(now));
++        Reply(220, "%s SVDRP VideoDiskRecorder %s; %s; %s", buffer, VDRVERSION, *TimeToString(now), cCharSetConv::SystemCharacterTable() ? cCharSetConv::SystemCharacterTable() : "UTF-8");
+         }
+      if (NewConnection)
+         lastActivity = time(NULL);
+diff -ruN vdr-1.6.0-1/thread.c vdr-1.6.0-2/thread.c
+--- vdr-1.6.0-1/thread.c	2008-02-15 15:17:42.000000000 +0100
++++ vdr-1.6.0-2/thread.c	2008-08-16 13:00:40.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: thread.c 1.64 2008/02/15 14:17:42 kls Exp $
++ * $Id: thread.c 1.64.1.1 2008/08/16 11:00:40 kls Exp $
+  */
+ 
+ #include "thread.h"
+@@ -24,11 +24,12 @@
+ {
+   struct timeval now;
+   if (gettimeofday(&now, NULL) == 0) {           // get current time
+-     now.tv_usec += MillisecondsFromNow * 1000;  // add the timeout
+-     while (now.tv_usec >= 1000000) {            // take care of an overflow
+-           now.tv_sec++;
+-           now.tv_usec -= 1000000;
+-           }
++     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
++     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
++     if (now.tv_usec >= 1000000) {               // take care of an overflow
++        now.tv_sec++;
++        now.tv_usec -= 1000000;
++        }
+      Abstime->tv_sec = now.tv_sec;          // seconds
+      Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+      return true;
+diff -ruN vdr-1.6.0-1/vdr.c vdr-1.6.0-2/vdr.c
+--- vdr-1.6.0-1/vdr.c	2008-03-14 14:22:39.000000000 +0100
++++ vdr-1.6.0-2/vdr.c	2008-09-06 13:07:52.000000000 +0200
+@@ -22,7 +22,7 @@
+  *
+  * The project's page is at http://www.cadsoft.de/vdr
+  *
+- * $Id: vdr.c 1.313 2008/03/14 13:22:39 kls Exp $
++ * $Id: vdr.c 1.313.1.1 2008/09/06 11:07:52 kls Exp $
+  */
+ 
+ #include <getopt.h>
+@@ -141,7 +141,6 @@
+ 
+ static void SignalHandler(int signum)
+ {
+-  isyslog("caught signal %d", signum);
+   switch (signum) {
+     case SIGPIPE:
+          break;
+@@ -1288,9 +1287,11 @@
+   ReportEpgBugFixStats();
+   if (WatchdogTimeout > 0)
+      dsyslog("max. latency time %d seconds", MaxLatencyTime);
+-  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
++  if (LastSignal)
++     isyslog("caught signal %d", LastSignal);
+   if (ShutdownHandler.EmergencyExitRequested())
+      esyslog("emergency exit!");
++  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
+   if (SysLogLevel > 0)
+      closelog();
+   if (HasStdin)
--- vdr-1.6.0.orig/debian/patches/opt-38_disableDoubleEpgEntrys.dpatch
+++ vdr-1.6.0/debian/patches/opt-38_disableDoubleEpgEntrys.dpatch
@@ -0,0 +1,349 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-38_disableDoubleEpgEntrys.dpatch by Emanuel Wontorra <hoerzu2vdr@wontorra.net>
+## http://vdrportal.de/board/thread.php?postid=317214#post317214
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.1
+##   - adapted to VDR-1.5.7
+##     http://toms-cafe.de/vdr/download/vdr-disableDoubleEpgEntrys_0.7.3b-1.5.7.diff
+## Tobias Grimm <tg@e-tobi.net>:
+##   - added buffer overflow fix from:
+##     http://vdrportal.de/board/thread.php?postid=683477#post683477
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - added French language texts (thanks to Michal Nival)
+##     http://toms-cafe.de/vdr/download/vdr-disableDoubleEpgEntrys_0.7.3b-1.6.0.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch suppresses double EPG entries.
+
+@DPATCH@
+diff -Naurp vdr-1.6.0/config.c vdr-1.6.0-disableDoubleEpgEntrys/config.c
+--- vdr-1.6.0/config.c	2008-02-17 13:39:00.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/config.c	2009-03-29 23:25:00.000000000 +0000
+@@ -241,6 +241,10 @@ cSetup::cSetup(void)
+   SubtitleFgTransparency = 0;
+   SubtitleBgTransparency = 0;
+   EPGLanguages[0] = -1;
++  DoubleEpgTimeDelta = 15;
++  DoubleEpgAction = 0;
++  MixEpgAction = 0;
++  DisableVPS = 0;
+   EPGScanTimeout = 5;
+   EPGBugfixLevel = 3;
+   EPGLinger = 0;
+@@ -414,6 +418,10 @@ bool cSetup::Parse(const char *Name, con
+   else if (!strcasecmp(Name, "SubtitleFgTransparency")) SubtitleFgTransparency = atoi(Value);
+   else if (!strcasecmp(Name, "SubtitleBgTransparency")) SubtitleBgTransparency = atoi(Value);
+   else if (!strcasecmp(Name, "EPGLanguages"))        return ParseLanguages(Value, EPGLanguages);
++  else if (!strcasecmp(Name, "DoubleEpgTimeDelta"))  DoubleEpgTimeDelta = atoi(Value);
++  else if (!strcasecmp(Name, "DoubleEpgAction"))     DoubleEpgAction    = atoi(Value);
++  else if (!strcasecmp(Name, "MixEpgAction"))        MixEpgAction       = atoi(Value);
++  else if (!strcasecmp(Name, "DisableVPS"))          DisableVPS         = atoi(Value);
+   else if (!strcasecmp(Name, "EPGScanTimeout"))      EPGScanTimeout     = atoi(Value);
+   else if (!strcasecmp(Name, "EPGBugfixLevel"))      EPGBugfixLevel     = atoi(Value);
+   else if (!strcasecmp(Name, "EPGLinger"))           EPGLinger          = atoi(Value);
+@@ -497,6 +505,10 @@ bool cSetup::Save(void)
+   Store("SubtitleFgTransparency", SubtitleFgTransparency);
+   Store("SubtitleBgTransparency", SubtitleBgTransparency);
+   StoreLanguages("EPGLanguages", EPGLanguages);
++  Store("DoubleEpgTimeDelta", DoubleEpgTimeDelta);
++  Store("DoubleEpgAction",    DoubleEpgAction);
++  Store("MixEpgAction",       MixEpgAction);
++  Store("DisableVPS",         DisableVPS);
+   Store("EPGScanTimeout",     EPGScanTimeout);
+   Store("EPGBugfixLevel",     EPGBugfixLevel);
+   Store("EPGLinger",          EPGLinger);
+diff -Naurp vdr-1.6.0/config.h vdr-1.6.0-disableDoubleEpgEntrys/config.h
+--- vdr-1.6.0/config.h	2008-03-23 10:26:10.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/config.h	2009-03-29 23:25:00.000000000 +0000
+@@ -225,6 +225,10 @@ public:
+   int SubtitleOffset;
+   int SubtitleFgTransparency, SubtitleBgTransparency;
+   int EPGLanguages[I18N_MAX_LANGUAGES + 1];
++  int DoubleEpgTimeDelta;
++  int DoubleEpgAction;
++  int MixEpgAction;
++  int DisableVPS;
+   int EPGScanTimeout;
+   int EPGBugfixLevel;
+   int EPGLinger;
+diff -Naurp vdr-1.6.0/eit.c vdr-1.6.0-disableDoubleEpgEntrys/eit.c
+--- vdr-1.6.0/eit.c	2007-08-26 10:56:33.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/eit.c	2009-03-29 23:25:00.000000000 +0000
+@@ -72,7 +72,83 @@ cEIT::cEIT(cSchedules *Schedules, int So
+          // not be overwritten.
+          if (pEvent->TableID() == 0x00) {
+             if (pEvent->Version() == getVersionNumber())
+-               continue;
++          {
++          	if(Setup.MixEpgAction == 0)
++          		continue;
++          		
++          	//printf("in");
++          	//printf("%s", pEvent->GetTimeString());
++          	// to use the info of the original epg, update the extern one,
++          	// if it has less info
++          	SI::Descriptor *d;
++          	SI::ExtendedEventDescriptors *ExtendedEventDescriptors = NULL;
++          	//SI::ExtendedEventDescriptor *eed = NULL;
++          	SI::ShortEventDescriptor *ShortEventDescriptor = NULL;
++          	//SI::ShortEventDescriptor *sed = NULL;
++          	//SI::TimeShiftedEventDescriptor *tsed = NULL;
++          	//cLinkChannels *LinkChannels = NULL;
++          	for (SI::Loop::Iterator it2; (d = SiEitEvent.eventDescriptors.getNext(it2));)
++          	{
++          		if(d->getDescriptorTag() == SI::ShortEventDescriptorTag)
++          		{
++          			int LanguagePreferenceShort = -1;
++          			SI::ShortEventDescriptor *sed = (SI::ShortEventDescriptor *)d;
++          			if (I18nIsPreferredLanguage(Setup.EPGLanguages, sed->languageCode, LanguagePreferenceShort) || !ShortEventDescriptor)
++          			{
++          				delete ShortEventDescriptor;
++          				ShortEventDescriptor = sed;
++          				d = NULL; // so that it is not deleted
++          			}
++          		}
++          		else if(d->getDescriptorTag() == SI::ExtendedEventDescriptorTag)
++          		{
++          			int LanguagePreferenceExt = -1;
++          			bool UseExtendedEventDescriptor = false;
++          			SI::ExtendedEventDescriptor *eed = (SI::ExtendedEventDescriptor *)d;
++          			if (I18nIsPreferredLanguage(Setup.EPGLanguages, eed->languageCode, LanguagePreferenceExt) || !ExtendedEventDescriptors) 
++          			{
++          				delete ExtendedEventDescriptors;
++          				ExtendedEventDescriptors = new SI::ExtendedEventDescriptors;
++          				UseExtendedEventDescriptor = true;
++          			}
++          			if (UseExtendedEventDescriptor) 
++          			{
++          				ExtendedEventDescriptors->Add(eed);
++          				d = NULL; // so that it is not deleted
++          			}
++          			if (eed->getDescriptorNumber() == eed->getLastDescriptorNumber())
++          				UseExtendedEventDescriptor = false;
++          		}         		                 
++          		delete d;
++          	}
++          	if(pEvent)
++          	{
++          		
++             		if(ShortEventDescriptor)
++ 	             	{
++ 	             		char buffer[256];    		
++ 	             		if(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)) && pEvent->ShortText() && (strlen(ShortEventDescriptor->text.getText(buffer, sizeof(buffer))) > strlen(pEvent->ShortText())))
++ 	             		{
++ 	             			pEvent->SetShortText(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)));
++ 	             			pEvent->FixEpgBugs();
++ 				}
++ 			}
++ 			if(ExtendedEventDescriptors)
++ 			{
++ 				char buffer[ExtendedEventDescriptors->getMaximumTextLength(": ") + 1];
++ 				//pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
++             
++ 				if(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ") && pEvent->Description() && (strlen(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ")) > strlen(pEvent->Description())))
++ 				{
++ 		  			pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
++ 		  			pEvent->FixEpgBugs();
++ 		  		}
++ 		  	}
++ 		}
++ 	  	delete ExtendedEventDescriptors;
++ 	  	delete ShortEventDescriptor;
++          	continue;
++          }
+             HasExternalData = ExternalData = true;
+             }
+          // If the new event has a higher table ID, let's skip it.
+@@ -97,7 +173,7 @@ cEIT::cEIT(cSchedules *Schedules, int So
+       if (newEvent)
+          pSchedule->AddEvent(newEvent);
+       if (Tid == 0x4E) { // we trust only the present/following info on the actual TS
+-         if (SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
++         if (Setup.DisableVPS == 0 && SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
+             pSchedule->SetRunningStatus(pEvent, SiEitEvent.getRunningStatus(), channel);
+          }
+       if (OnlyRunningStatus)
+@@ -259,6 +335,80 @@ cEIT::cEIT(cSchedules *Schedules, int So
+       if (LinkChannels)
+          channel->SetLinkChannels(LinkChannels);
+       Modified = true;
++       
++      //to avoid double epg-entrys from ext and int epg sources :EW
++      if (pEvent && pEvent->TableID() != 0x00)
++      {
++      	cEvent *pPreviousEvent = (cEvent *)pSchedule->GetPreviousEvent(pEvent);
++      	
++      	if (pPreviousEvent)
++       	{
++       		if(Setup.DoubleEpgAction == 0)
++       		{
++       			pPreviousEvent->SetStartTime(pEvent->StartTime());
++       			pPreviousEvent->SetDuration(pEvent->Duration());
++       			
++       			if(Setup.DisableVPS == 0)
++       			{
++       				if(channel)
++       					pPreviousEvent->SetRunningStatus(pEvent->RunningStatus(), channel);
++       				else
++       					pPreviousEvent->SetRunningStatus(pEvent->RunningStatus());
++       			}
++       			
++       			// to use the info of the original epg, update the extern one,
++       			// if it has less info
++       			char buffer_short_intern[256];
++       			char buffer_short_extern[256];
++       			int len_short_intern = 0;
++       			int len_short_extern = 0;
++       			
++       			if (pEvent->ShortText())
++       				len_short_intern = snprintf (buffer_short_intern, sizeof(buffer_short_intern), "%s", pEvent->ShortText());
++       				
++       			if (pPreviousEvent->ShortText())
++       				len_short_extern = snprintf (buffer_short_extern, sizeof(buffer_short_extern), "%s",pPreviousEvent->ShortText());
++ 			
++       			if(len_short_intern > 0)
++       			{
++       				if(len_short_extern < 1)
++       					pPreviousEvent->SetShortText(buffer_short_intern);
++       				else if (len_short_intern > len_short_extern)
++       						pPreviousEvent->SetShortText(buffer_short_intern);
++       			}
++       			
++       			if(pEvent->Description())
++       			{
++       				char buffer_title_intern[4096];
++       				char buffer_title_extern[4096];
++       				int len_title_intern = 0;
++       				int len_title_extern = 0;
++       				
++       				if (pEvent->Description())
++       					len_title_intern = snprintf (buffer_title_intern, sizeof(buffer_title_intern), "%s", pEvent->Description());
++       					
++       				if (pPreviousEvent->Description())
++       					len_title_extern = snprintf (buffer_title_extern, sizeof(buffer_title_extern), "%s", pPreviousEvent->Description());
++       				
++       				if(len_title_intern > 0)
++ 	      			{
++ 	      				if(len_title_extern < 1)
++ 	      					pPreviousEvent->SetDescription(buffer_title_intern);
++ 	      				else if (len_title_intern > len_title_extern)
++ 	      					pPreviousEvent->SetDescription(buffer_title_intern);
++ 	      			}
++ 	      		}
++ 	      		
++ 	      		if(pPreviousEvent->Vps() == 0 && pEvent->Vps() != 0)
++ 	      			pPreviousEvent->SetVps(pEvent->Vps());
++ 	      			
++ 	      		pSchedule->DelEvent(pEvent);
++ 	      		pPreviousEvent->FixEpgBugs();
++       		}
++       		else
++       			pSchedule->DelEvent(pPreviousEvent);
++       	}
++       }
+       }
+   if (Empty && Tid == 0x4E && getSectionNumber() == 0)
+      // ETR 211: an empty entry in section 0 of table 0x4E means there is currently no event running
+diff -Naurp vdr-1.6.0/epg.c vdr-1.6.0-disableDoubleEpgEntrys/epg.c
+--- vdr-1.6.0/epg.c	2008-02-16 16:09:12.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/epg.c	2009-03-29 23:25:00.000000000 +0000
+@@ -742,6 +742,29 @@ const cEvent *cSchedule::GetEventAround(
+   return pe;
+ }
+ 
++const cEvent *cSchedule::GetPreviousEvent(cEvent *Event) const
++{
++	
++	if(!Event || Event->Duration() == 0 || Event->StartTime() == 0)
++		return NULL;
++	// Returns either the event info to the previous/following event to the given EventID or, if that one can't be found NULL :EW
++	cEvent *pt = NULL;
++	int epgTimeDelta = Setup.DoubleEpgTimeDelta * 60 + 1;
++	for (pt = events.First(); pt; pt = events.Next(pt))
++		if(pt && pt->TableID() == 0x00)
++			if ((Event->StartTime() - pt->StartTime()) > -  epgTimeDelta && (Event->StartTime() - pt->StartTime()) < epgTimeDelta)
++			{
++				if((pt->Duration() + (pt->Duration()/ 5) + 1) > Event->Duration() && (pt->Duration() - (pt->Duration()/ 5) - 1) < Event->Duration())
++					return pt;
++				else if (pt->Title() && Event->Title() && (strcmp(pt->Title(), ".") != 0 && strcmp(Event->Title(), ".") != 0))
++				{
++					if (strstr(pt->Title(), Event->Title()) != NULL || strstr(Event->Title(), pt->Title()) != NULL)
++						return pt;
++				}
++			}
++	return NULL;
++}
++
+ void cSchedule::SetRunningStatus(cEvent *Event, int RunningStatus, cChannel *Channel)
+ {
+   hasRunning = false;
+diff -Naurp vdr-1.6.0/epg.h vdr-1.6.0-disableDoubleEpgEntrys/epg.h
+--- vdr-1.6.0/epg.h	2006-10-07 13:47:19.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/epg.h	2009-03-29 23:25:00.000000000 +0000
+@@ -137,6 +137,7 @@ public:
+   void DropOutdated(time_t SegmentStart, time_t SegmentEnd, uchar TableID, uchar Version);
+   void Cleanup(time_t Time);
+   void Cleanup(void);
++  const cEvent *GetPreviousEvent(cEvent *Event) const; //:EW
+   cEvent *AddEvent(cEvent *Event);
+   void DelEvent(cEvent *Event);
+   void HashEvent(cEvent *Event);
+diff -Naurp vdr-1.6.0/menu.c vdr-1.6.0-disableDoubleEpgEntrys/menu.c
+--- vdr-1.6.0/menu.c	2008-03-16 11:15:28.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/menu.c	2009-03-29 23:25:00.000000000 +0000
+@@ -2388,6 +2388,10 @@ void cMenuSetupEPG::Setup(void)
+   for (int i = 0; i < numLanguages; i++)
+       // TRANSLATORS: note the singular!
+       Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
++  Add(new cMenuEditIntItem(tr("Setup.EPG$Period for double EPG search(min)"), &data.DoubleEpgTimeDelta));
++  Add(new cMenuEditBoolItem(tr("Setup.EPG$extern double Epg entry"),   &data.DoubleEpgAction, "adjust", "delete"));
++  Add(new cMenuEditBoolItem(tr("Setup.EPG$Mix intern and extern EPG"), &data.MixEpgAction));
++  Add(new cMenuEditBoolItem(tr("Setup.EPG$Disable running VPS event"), &data.DisableVPS));
+ 
+   SetCurrent(Get(current));
+   Display();
+diff -Naurp vdr-1.6.0/po/de_DE.po vdr-1.6.0-disableDoubleEpgEntrys/po/de_DE.po
+--- vdr-1.6.0/po/de_DE.po	2008-03-23 10:31:29.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/po/de_DE.po	2009-03-29 23:25:00.000000000 +0000
+@@ -558,6 +558,18 @@ msgstr "EPG"
+ msgid "Button$Scan"
+ msgstr "Scan"
+ 
++msgid "Setup.EPG$Period for double EPG search(min)"
++msgstr "Zeitspanne fr dop. EPG-Suche(min)"
++
++msgid "Setup.EPG$extern double Epg entry"
++msgstr "Doppelten externen EPG-Eintrag"
++
++msgid "Setup.EPG$Mix intern and extern EPG"
++msgstr "Internen und externen EPG mischen"
++
++msgid "Setup.EPG$Disable running VPS event"
++msgstr "Erk. des lauf. VPS-Events abschalten"
++
+ msgid "Setup.EPG$EPG scan timeout (h)"
+ msgstr "Zeit bis zur EPG-Aktualisierung (h)"
+ 
+diff -Naurp vdr-1.6.0/po/fr_FR.po vdr-1.6.0-disableDoubleEpgEntrys/po/fr_FR.po
+--- vdr-1.6.0/po/fr_FR.po	2008-03-23 10:31:29.000000000 +0000
++++ vdr-1.6.0-disableDoubleEpgEntrys/po/fr_FR.po	2009-03-29 23:25:58.000000000 +0000
+@@ -564,6 +564,18 @@ msgstr "Guide des programmes"
+ msgid "Button$Scan"
+ msgstr "Scan"
+ 
++msgid "Setup.EPG$Period for double EPG search(min)"
++msgstr "Intervalle de recherche du double EPG(min)"
++
++msgid "Setup.EPG$extern double Epg entry"
++msgstr "Entre EPG externe en double"
++
++msgid "Setup.EPG$Mix intern and extern EPG"
++msgstr "Mixer EPG interne et externe"
++
++msgid "Setup.EPG$Disable running VPS event"
++msgstr "Dsactiver vnement VPS"
++
+ msgid "Setup.EPG$EPG scan timeout (h)"
+ msgstr "Inactivit avant rech. EPG (h)"
+ 
--- vdr-1.6.0.orig/debian/patches/opt-47_sourcecaps.dpatch
+++ vdr-1.6.0/debian/patches/opt-47_sourcecaps.dpatch
@@ -0,0 +1,220 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-21_sourcecaps.dpatch by Christian Schuld <chris@sonnengesicht.de>
+## http://linvdr.org/mailinglists/vdr/2004/08/msg00521.html
+## http://article.gmane.org/gmane.linux.vdr/27260/
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.0
+## Tobias Grimm <tg@e-tobi.net>:
+##   - adapted to VDR-1.5.16
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch for assigning special satellites to one dvb card.
+
+@DPATCH@
+diff -urNad vdr-1.5.16~/config.c vdr-1.5.16/config.c
+--- vdr-1.5.16~/config.c	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/config.c	2008-02-25 21:00:06.000000000 +0100
+@@ -15,6 +15,7 @@
+ #include "interface.h"
+ #include "plugin.h"
+ #include "recording.h"
++#include "sources.h"
+ 
+ // IMPORTANT NOTE: in the 'sscanf()' calls there is a blank after the '%d'
+ // format characters in order to allow any number of blanks after a numeric
+@@ -264,6 +265,8 @@
+   LnbFrequLo =  9750;
+   LnbFrequHi = 10600;
+   DiSEqC = 0;
++  memset(SourceCaps, 0, sizeof SourceCaps);
++  SourceCapsSet = false;
+   SetSystemTime = 0;
+   TimeSource = 0;
+   TimeTransponder = 0;
+@@ -436,6 +439,49 @@
+   return true;
+ }
+ 
++void cSetup::StoreSourceCaps(const char *Name)
++{
++  cSetupLine *l;
++  while ((l = Get(Name)) != NULL)
++        Del(l);
++
++  for (int i = 0; i < MAXDEVICES; i++) {
++      char buffer[MAXSOURCECAPS*8]={0,}, *q = buffer;
++      int j = 0;
++      while (SourceCaps[i][j] && j < MAXSOURCECAPS) {
++            if (j==0) 
++               q += snprintf(buffer, sizeof(buffer), "%i ", i+1);
++            q += snprintf(q, sizeof(buffer) - (q-buffer), "%s ", *cSource::ToString(SourceCaps[i][j++]));
++      }
++      if (*buffer)
++         Store(Name, buffer, NULL, true);
++      }
++}
++
++bool cSetup::ParseSourceCaps(const char *Value)
++{
++  char *p;
++  int d = strtol(Value, &p, 10)-1, i = 0;
++  while (p < Value+strlen(Value)) {
++        if (*p==0) return true;
++        if (isblank(*p)) ++p;
++        if (isalpha(*p)) {
++           int source = cSource::FromString(p);
++           if (source != cSource::stNone) {
++              SourceCaps[d][i++] = source;
++              SourceCapsSet = true;
++              }
++           else
++              return false;
++           while (!isblank(*p) && *p)
++                 ++p;
++           if (i>MAXSOURCECAPS)
++              return false;
++           }
++        }
++  return true;
++}
++
+ bool cSetup::Parse(const char *Name, const char *Value)
+ {
+   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+@@ -454,6 +500,7 @@
+   else if (!strcasecmp(Name, "LnbFrequLo"))          LnbFrequLo         = atoi(Value);
+   else if (!strcasecmp(Name, "LnbFrequHi"))          LnbFrequHi         = atoi(Value);
+   else if (!strcasecmp(Name, "DiSEqC"))              DiSEqC             = atoi(Value);
++  else if (!strcasecmp(Name, "SourceCaps"))          return ParseSourceCaps(Value);
+   else if (!strcasecmp(Name, "SetSystemTime"))       SetSystemTime      = atoi(Value);
+   else if (!strcasecmp(Name, "TimeSource"))          TimeSource         = cSource::FromString(Value);
+   else if (!strcasecmp(Name, "TimeTransponder"))     TimeTransponder    = atoi(Value);
+@@ -557,6 +604,7 @@
+   Store("LnbFrequLo",         LnbFrequLo);
+   Store("LnbFrequHi",         LnbFrequHi);
+   Store("DiSEqC",             DiSEqC);
++  if (SourceCapsSet) StoreSourceCaps("SourceCaps");
+   Store("SetSystemTime",      SetSystemTime);
+   Store("TimeSource",         cSource::ToString(TimeSource));
+   Store("TimeTransponder",    TimeTransponder);
+diff -urNad vdr-1.5.16~/config.h vdr-1.5.16/config.h
+--- vdr-1.5.16~/config.h	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/config.h	2008-02-25 21:00:06.000000000 +0100
+@@ -54,6 +54,9 @@
+ #define MINOSDHEIGHT 324
+ #define MAXOSDHEIGHT 567
+ 
++#define MAXDEVICES         16 // the maximum number of devices in the system
++#define MAXSOURCECAPS     128 // the maximum number of different sources per device
++
+ #define MaxFileName 256
+ #define MaxSkinName 16
+ #define MaxThemeName 16
+@@ -217,6 +220,8 @@
+   void StoreLanguages(const char *Name, int *Values);
+   bool ParseLanguages(const char *Value, int *Values);
+   bool Parse(const char *Name, const char *Value);
++  void StoreSourceCaps(const char *Name);
++  bool ParseSourceCaps(const char *Value);
+   cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+   void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
+   void Store(const char *Name, int Value, const char *Plugin = NULL);
+@@ -239,6 +244,8 @@
+   int LnbFrequLo;
+   int LnbFrequHi;
+   int DiSEqC;
++  int SourceCaps[MAXDEVICES][MAXSOURCECAPS];
++  bool SourceCapsSet;
+   int SetSystemTime;
+   int TimeSource;
+   int TimeTransponder;
+diff -urNad vdr-1.5.16~/device.c vdr-1.5.16/device.c
+--- vdr-1.5.16~/device.c	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/device.c	2008-02-25 21:00:06.000000000 +0100
+@@ -253,8 +253,10 @@
+   for (int i = 0; i < MAXRECEIVERS; i++)
+       receiver[i] = NULL;
+ 
+-  if (numDevices < MAXDEVICES)
++  if (numDevices < MAXDEVICES) {
+      device[numDevices++] = this;
++     SetSourceCaps(cardIndex);
++     }
+   else
+      esyslog("ERROR: too many devices!");
+ }
+@@ -457,6 +459,17 @@
+   camSlot = CamSlot;
+ }
+ 
++void cDevice::SetSourceCaps(int Index)
++{
++  for (int d = 0; d < numDevices; d++) {
++      if (Index < 0 || Index == device[d]->CardIndex()) {
++         for (int i = 0; i < MAXSOURCECAPS; i++)
++             device[d]->sourceCaps[i] = Setup.SourceCaps[device[d]->CardIndex()][i];
++         }
++      }
++}
++
++
+ void cDevice::Shutdown(void)
+ {
+   primaryDevice = NULL;
+diff -urNad vdr-1.5.16~/device.h vdr-1.5.16/device.h
+--- vdr-1.5.16~/device.h	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/device.h	2008-02-25 21:00:50.000000000 +0100
+@@ -25,7 +25,6 @@
+ #include "tools.h"
+ #include <linux/dvb/frontend.h>
+ 
+-#define MAXDEVICES         16 // the maximum number of devices in the system
+ #define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
+ #define MAXRECEIVERS       16 // the maximum number of receivers per device
+ #define MAXVOLUME         255
+@@ -150,6 +149,8 @@
+   static void SetAvoidDevice(cDevice *Device) { avoidDevice = Device; }
+          ///< Sets the given Device to be temporarily avoided in the next call to
+          ///< GetDevice(const cChannel, int, bool).
++  static void SetSourceCaps(int Index = -1);
++         ///< Sets the SourceCaps of the given device according to the Setup data.
+   static void Shutdown(void);
+          ///< Closes down all devices.
+          ///< Must be called at the end of the program.
+@@ -157,6 +158,7 @@
+   static int nextCardIndex;
+   int cardIndex;
+ protected:
++  int sourceCaps[MAXSOURCECAPS];
+   cDevice(void);
+   virtual ~cDevice();
+   virtual bool Ready(void);
+diff -urNad vdr-1.5.16~/dvbdevice.c vdr-1.5.16/dvbdevice.c
+--- vdr-1.5.16~/dvbdevice.c	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/dvbdevice.c	2008-02-25 21:00:06.000000000 +0100
+@@ -762,6 +762,12 @@
+ bool cDvbDevice::ProvidesSource(int Source) const
+ {
+   int type = Source & cSource::st_Mask;
++  if (Setup.SourceCapsSet && type == cSource::stSat && frontendType == FE_QPSK) {
++     for (int i = 0; i < MAXSOURCECAPS; i++)
++         if (sourceCaps[i] == Source)
++            return true;
++     return false;
++     }
+   return type == cSource::stNone
+       || type == cSource::stCable && frontendType == FE_QAM
+       || type == cSource::stSat   && frontendType == FE_QPSK
+diff -urNad vdr-1.5.16~/sources.c vdr-1.5.16/sources.c
+--- vdr-1.5.16~/sources.c	2008-02-25 21:00:06.000000000 +0100
++++ vdr-1.5.16/sources.c	2008-02-25 21:00:06.000000000 +0100
+@@ -70,7 +70,7 @@
+      int pos = 0;
+      bool dot = false;
+      bool neg = false;
+-     while (*++s) {
++     while (*++s && !isblank(*s)) {
+            switch (toupper(*s)) {
+              case '0' ... '9': pos *= 10;
+                                pos += *s - '0';
--- vdr-1.6.0.orig/debian/patches/15_dvbplayer.dpatch
+++ vdr-1.6.0/debian/patches/15_dvbplayer.dpatch
@@ -0,0 +1,253 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 15_dvbplayer.dpatch by Reinhard Nissl <rnissl@gmx.de>
+## http://home.vr-web.de/~rnissl/vdr-1.3.31-dvbplayer5.patch
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.3.43
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fixes VDR's recording replayer to send proper I-frames to a device.
+## DP: Without this patch it is very likely that incomplete I-frames are sent
+## DP: and therefore many I-frames will not be displayed by devices like
+## DP: vdr-xine or dxr3. This patch has a very positive effect on moving
+## DP: cutting marks and all fast trickspeed modes as well as slow motion
+## DP: rewind.
+## DP: NOTE: without this patch it is likely that xine disconnects from
+## DP: vdr-xine while moving cut marks.
+
+@DPATCH@
+diff -urNad vdr-1.4.6~/dvbplayer.c vdr-1.4.6/dvbplayer.c
+--- vdr-1.4.6~/dvbplayer.c	2007-05-01 21:22:11.000000000 +0200
++++ vdr-1.4.6/dvbplayer.c	2007-05-01 21:29:43.000000000 +0200
+@@ -363,6 +363,202 @@
+      Cancel(9);
+ }
+ 
++// --- BEGIN fix for I frames  -------------------------------------------
++// 
++//  Prior to the introduction of cVideoRepacker, VDR didn't start a new
++//  PES packet when a new frame started. So, it was likely that the tail
++//  of an I frame was at the beginning of the packet which started the
++//  following B frame. Due to the organisation of VDR's index file, VDR
++//  typically didn't read the tail of the I frame and therefore caused
++//  softdevice plugins to not render such a frame as it was incomplete,
++//  e. g. when moving cutting marks.
++//
++//  The following code tries to fix incomplete I frames for recordings
++//  made prior to the introdcution of cVideoRepacker, to be able to
++//  edit cutting marks for example with softdevice plugins like vdr-xine.
++//
++
++#if VDRVERSNUM < 10331
++
++enum ePesHeader {
++  phNeedMoreData = -1,
++  phInvalid = 0,
++  phMPEG1 = 1,
++  phMPEG2 = 2
++  };
++
++static ePesHeader AnalyzePesHeader(const uchar *Data, int Count, int &PesPayloadOffset, bool *ContinuationHeader = NULL)
++{
++  if (Count < 7)
++     return phNeedMoreData; // too short
++
++  if ((Data[6] & 0xC0) == 0x80) { // MPEG 2
++     if (Count < 9)
++        return phNeedMoreData; // too short
++
++     PesPayloadOffset = 6 + 3 + Data[8];
++     if (Count < PesPayloadOffset)
++        return phNeedMoreData; // too short
++
++     if (ContinuationHeader)
++        *ContinuationHeader = ((Data[6] == 0x80) && !Data[7] && !Data[8]);
++
++     return phMPEG2; // MPEG 2
++     }
++
++  // check for MPEG 1 ...
++  PesPayloadOffset = 6;
++
++  // skip up to 16 stuffing bytes
++  for (int i = 0; i < 16; i++) {
++      if (Data[PesPayloadOffset] != 0xFF)
++         break;
++
++      if (Count <= ++PesPayloadOffset)
++         return phNeedMoreData; // too short
++      }
++
++  // skip STD_buffer_scale/size
++  if ((Data[PesPayloadOffset] & 0xC0) == 0x40) {
++     PesPayloadOffset += 2;
++
++     if (Count <= PesPayloadOffset)
++        return phNeedMoreData; // too short
++     }
++
++  if (ContinuationHeader)
++     *ContinuationHeader = false;
++
++  if ((Data[PesPayloadOffset] & 0xF0) == 0x20) {
++     // skip PTS only
++     PesPayloadOffset += 5;
++     }
++  else if ((Data[PesPayloadOffset] & 0xF0) == 0x30) {
++     // skip PTS and DTS
++     PesPayloadOffset += 10;
++     }
++  else if (Data[PesPayloadOffset] == 0x0F) {
++     // continuation header
++     PesPayloadOffset++;
++
++     if (ContinuationHeader)
++        *ContinuationHeader = true;
++     }
++  else
++     return phInvalid; // unknown
++
++  if (Count < PesPayloadOffset)
++     return phNeedMoreData; // too short
++
++  return phMPEG1; // MPEG 1
++}
++
++#endif
++
++static uchar *findStartCode(uchar *Data, int Length, int &PesPayloadOffset)
++{
++  uchar *limit = Data + Length;
++  if (AnalyzePesHeader(Data, Length, PesPayloadOffset) <= phInvalid)
++     return 0; // neither MPEG1 nor MPEG2
++
++  Data += PesPayloadOffset + 3; // move to video payload and skip 00 00 01
++  while (Data < limit) {
++        // possible start codes that appear before/after picture data
++        // 00 00 01 B3: sequence header code
++        // 00 00 01 B8: group start code
++        // 00 00 01 00: picture start code
++        // 00 00 01 B7: sequence end code
++        if (0x01 == Data[-1] && (0xB3 == Data[0] || 0xB8 == Data[0] || 0x00 == Data[0] || 0xB7 == Data[0]) && 0x00 == Data[-2] && 0x00 == Data[-3])
++            return Data - 3;
++        Data++;
++        }
++
++  return 0;
++}
++
++static void fixIFrameHead(uchar *Data, int Length)
++{
++  int pesPayloadOffset = 0;
++  uchar *p = findStartCode(Data, Length, pesPayloadOffset);
++  if (!p) {
++     esyslog("fixIframeHead: start code not found!\n");
++     return;
++     }
++
++  Data += pesPayloadOffset; // move to video payload
++  if (Data < p)
++     memset(Data, 0, p - Data); // zero preceeding bytes
++}
++
++static int fixIFrameTail(uchar *Data, int Length)
++{
++  int pesPayloadOffset = 0;
++  uchar *p = findStartCode(Data, Length, pesPayloadOffset);
++  if (!p) {
++     esyslog("fixIframeTail: start code not found!\n");
++     return Length;
++     }
++
++  // is this PES packet required?
++  uchar *videoPayload = Data + pesPayloadOffset;
++  if (videoPayload >= p)
++     return 0; // no
++  
++  // adjust PES length
++  int lenPES = (p - Data);
++  Data[4] = (lenPES - 6) >> 8;
++  Data[5] = (lenPES - 6) & 0xFF;
++
++  return lenPES;
++}
++
++#define IPACKS 2048 // originally defined in remux.c
++
++static void fixIFrame(uchar *Data, int &Length, const int OriginalLength)
++{
++  int done = 0;
++
++  while (done < Length) {
++        if (0x00 != Data[0] || 0x00 != Data[1] || 0x01 != Data[2]) {
++           esyslog("fixIFrame: PES start code not found at offset %d (data length: %d, original length: %d)!", done, Length, OriginalLength);
++           if (Length > OriginalLength) // roll back additional data
++              Length = OriginalLength;
++           return;
++           }
++
++        int lenPES = 6 + Data[4] * 256 + Data[5];
++        if (0xBA == Data[3]) { // pack header has fixed length
++           if (0x00 == (0xC0 & Data[4]))
++              lenPES = 12; // MPEG1
++           else
++              lenPES = 14 + (Data[13] & 0x07); // MPEG2
++           }
++        else if (0xB9 == Data[3]) // stream end has fixed length
++           lenPES = 4;
++        else if (0xE0 == (0xF0 & Data[3])) { // video packet
++           int todo = Length - done;
++           int bite = (lenPES < todo) ? lenPES : todo;
++           if (0 == done) // first packet
++              fixIFrameHead(Data, bite);
++           else if (done >= OriginalLength) { // last packet
++              Length = done + fixIFrameTail(Data, bite);
++              return;
++              }
++           }
++        else if (0 == done && 0xC0 == (0xE0 & Data[3])) {
++           // if the first I frame packet is an audio packet then this is a radio recording: don't touch it!
++           if (Length > OriginalLength) // roll back additional data
++              Length = OriginalLength;
++           return;
++           }
++
++        done += lenPES;
++        Data += lenPES;
++        }
++}
++
++// --- END fix for I frames  ---------------------------------------------
++
+ void cDvbPlayer::Action(void)
+ {
+   uchar *b = NULL;
+@@ -406,6 +602,7 @@
+                              readIndex = Index;
+                              continue;
+                              }
++                          Length += IPACKS; // fixIFrame needs next video packet
+                           }
+                        else {
+                           if (!TimeShiftMode && playDir == pdForward) {
+@@ -450,6 +647,8 @@
+                     }
+                  int r = nonBlockingFileReader->Read(replayFile, b, Length);
+                  if (r > 0) {
++                    if (playMode == pmFast || (playMode == pmSlow && playDir == pdBackward))
++                       fixIFrame(b, r, Length - IPACKS);
+                     WaitingForData = false;
+                     readFrame = new cFrame(b, -r, ftUnknown, readIndex); // hands over b to the ringBuffer
+                     b = NULL;
+@@ -688,9 +887,11 @@
+      int FileOffset, Length;
+      Index = index->GetNextIFrame(Index, false, &FileNumber, &FileOffset, &Length);
+      if (Index >= 0 && NextFile(FileNumber, FileOffset) && Still) {
++        Length += IPACKS; // fixIFrame needs next video packet
+         uchar b[MAXFRAMESIZE + 4 + 5 + 4];
+         int r = ReadFrame(replayFile, b, Length, sizeof(b));
+         if (r > 0) {
++           fixIFrame(b, r, Length - IPACKS);
+            if (playMode == pmPause)
+               DevicePlay();
+            // append sequence end code to get the image shown immediately with softdevices
--- vdr-1.6.0.orig/debian/patches/09_sort_options.dpatch
+++ vdr-1.6.0/debian/patches/09_sort_options.dpatch
@@ -0,0 +1,104 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+
+## 11_sort_options.dpatch by Darren Salt and Luca Olivetti <luca@ventoso.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: [LO] Add sort-by-source options.
+## DP: [DS] Add sort-by-provider-then-channel-number options.
+
+@DPATCH@
+diff -urNad vdr-1.5.15~/menu.c vdr-1.5.15/menu.c
+--- vdr-1.5.15~/menu.c	2008-02-17 21:05:46.000000000 +0100
++++ vdr-1.5.15/menu.c	2008-02-17 21:09:06.000000000 +0100
+@@ -359,14 +359,18 @@
+ 
+ class cMenuChannelItem : public cOsdItem {
+ public:
+-  enum eChannelSortMode { csmNumber, csmName, csmProvider };
++  enum eChannelSortMode {
++    csmNumber, csmName, csmProvider, csmProviderNumber,
++    csmSourceNumber, csmSourceName, csmSourceProvider, csmSourceProviderNumber,
++    csmLAST
++  };
+ private:
+   static eChannelSortMode sortMode;
+   cChannel *channel;
+ public:
+   cMenuChannelItem(cChannel *Channel);
+   static void SetSortMode(eChannelSortMode SortMode) { sortMode = SortMode; }
+-  static void IncSortMode(void) { sortMode = eChannelSortMode((sortMode == csmProvider) ? csmNumber : sortMode + 1); }
++  static void IncSortMode(void) { sortMode = eChannelSortMode(sortMode + 1); if (sortMode == csmLAST) sortMode = csmNumber; }
+   static eChannelSortMode SortMode(void) { return sortMode; }
+   virtual int Compare(const cListObject &ListObject) const;
+   virtual void Set(void);
+@@ -383,13 +387,46 @@
+   Set();
+ }
+ 
++static int snum(int source)
++{
++  int stype = (source & cSource::st_Mask);
++  // arbitrary order: sat, cable, terrestrial, none
++  int r;
++  switch(stype) {
++    case cSource::stCable:
++      r=0x7FF0;
++      break;
++    case cSource::stTerr:
++      r=0x7FF2;
++      break;
++    case cSource::stSat: 
++      r=source & cSource::st_Pos;
++      if (source & cSource::st_Neg) r*=-1;
++      break;
++    default:  //stNone or unknown
++      r=0x7FFF;
++  }
++  return r;
++}
++
+ int cMenuChannelItem::Compare(const cListObject &ListObject) const
+ {
+   cMenuChannelItem *p = (cMenuChannelItem *)&ListObject;
+   int r = -1;
+-  if (sortMode == csmProvider)
++  if (sortMode >= csmSourceNumber) {
++     int rsource = snum(channel->Source()) - snum(p->channel->Source());
++     if (sortMode == csmSourceProvider && rsource  == 0)
++        r = strcoll(channel->Provider(), p->channel->Provider());
++     if ((sortMode == csmSourceName ||
++          (r == 0 && sortMode != csmSourceProviderNumber)) && rsource == 0)
++        r = strcoll(channel->Name(), p->channel->Name());
++     if ((sortMode == csmSourceNumber || r == 0) && rsource == 0)
++        r = channel->Number() - p->channel->Number();
++     return ((rsource == 0) ? r : rsource);
++  }
++  if (sortMode == csmProvider || sortMode == csmProviderNumber)
+      r = strcoll(channel->Provider(), p->channel->Provider());
+-  if (sortMode == csmName || r == 0)
++  if (sortMode == csmName || (r == 0 && sortMode != csmProviderNumber))
+      r = strcoll(channel->Name(), p->channel->Name());
+   if (sortMode == csmNumber || r == 0)
+      r = channel->Number() - p->channel->Number();
+@@ -400,10 +437,17 @@
+ {
+   cString buffer;
+   if (!channel->GroupSep()) {
+-     if (sortMode == csmProvider)
+-        buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
+-     else
+-        buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
++     if (sortMode >= csmSourceNumber) {
++        if (sortMode == csmSourceProvider || sortMode == csmSourceProviderNumber)
++           buffer = cString::sprintf("%d\t%s - %s - %s", channel->Number(), *cSource::ToString(channel->Source()), channel->Provider(), channel->Name());
++        else
++           buffer = cString::sprintf("%d\t%s - %s", channel->Number(), *cSource::ToString(channel->Source()), channel->Name());
++       } else {
++        if (sortMode == csmProvider || sortMode == csmProviderNumber)
++           buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
++        else
++           buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
++       }   
+      }
+   else
+      buffer = cString::sprintf("---\t%s ----------------------------------------------------------------", channel->Name());
--- vdr-1.6.0.orig/debian/patches/opt-28_audioindexer.dpatch
+++ vdr-1.6.0/debian/patches/opt-28_audioindexer.dpatch
@@ -0,0 +1,319 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-28_audioindexer.dpatch by Reinhard Nissl <rnissl@gmx.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fixes cRemux to only generate an index entry whenever
+## DP: the recorded amount of music crosses a 40 ms boundary.
+## DP: This should fix problems with the length of radio recordings.
+
+@DPATCH@
+diff -urNad vdr-1.5.10~/remux.c vdr-1.5.10/remux.c
+--- vdr-1.5.10~/remux.c	2007-09-22 14:08:22.000000000 +0200
++++ vdr-1.5.10/remux.c	2007-11-04 00:09:33.000000000 +0100
+@@ -19,6 +19,7 @@
+ #include "channels.h"
+ #include "shutdown.h"
+ #include "tools.h"
++#include "recording.h"
+ 
+ ePesHeader AnalyzePesHeader(const uchar *Data, int Count, int &PesPayloadOffset, bool *ContinuationHeader)
+ {
+@@ -690,12 +691,13 @@
+   int frameTodo;
+   int frameSize;
+   int cid;
+-  static bool IsValidAudioHeader(uint32_t Header, bool Mpeg2, int *FrameSize = NULL);
++  static bool IsValidAudioHeader(uint32_t Header, bool Mpeg2, int *FrameSize = NULL, int *FrameDuration = NULL);
+ public:
+   cAudioRepacker(int Cid);
+   virtual void Reset(void);
+   virtual void Repack(cRingBufferLinear *ResultBuffer, const uchar *Data, int Count);
+   virtual int BreakAt(const uchar *Data, int Count);
++  static int GetFrameDuration(const uchar *Data, int Count, int *TrackIndex = NULL);
+   };
+ 
+ int cAudioRepacker::bitRates[2][3][16] = { // all values are specified as kbits/s
+@@ -711,6 +713,25 @@
+   }
+   };
+ 
++int cAudioRepacker::GetFrameDuration(const uchar *Data, int Count, int *TrackIndex)
++{
++  int PesPayloadOffset = 0;
++  ePesHeader PH = AnalyzePesHeader(Data, Count, PesPayloadOffset);
++  if (PH < phMPEG1)
++     return -1;
++
++  const uchar *Payload = Data + PesPayloadOffset;
++  const int PayloadCount = Count - PesPayloadOffset;
++
++  int FrameDuration = -1;
++  if ((Data[3] & 0xE0) == 0xC0 && PayloadCount >= 4) {
++     if (IsValidAudioHeader(((Payload[0] << 8 | Payload[1]) << 8 | Payload[2]) << 8 | Payload[3], PH == phMPEG2, NULL, &FrameDuration) && TrackIndex)
++        *TrackIndex = Data[3] - 0xC0;
++     }
++
++  return FrameDuration;
++}
++
+ cAudioRepacker::cAudioRepacker(int Cid)
+ {
+   cid = Cid;
+@@ -726,7 +747,7 @@
+   frameSize = 0;
+ }
+ 
+-bool cAudioRepacker::IsValidAudioHeader(uint32_t Header, bool Mpeg2, int *FrameSize)
++bool cAudioRepacker::IsValidAudioHeader(uint32_t Header, bool Mpeg2, int *FrameSize, int *FrameDuration)
+ {
+   int syncword           = (Header & 0xFFF00000) >> 20;
+   int id                 = (Header & 0x00080000) >> 19;
+@@ -760,32 +781,36 @@
+   if (emphasis == 2) // reserved
+      return false;
+ 
+-  if (FrameSize) {
+-     if (bitrate_index == 0)
+-        *FrameSize = 0;
+-     else {
+-        static int samplingFrequencies[2][4] = { // all values are specified in Hz
+-          { 44100, 48000, 32000, -1 }, // MPEG 1
+-          { 22050, 24000, 16000, -1 }  // MPEG 2
+-          };
++  if (FrameSize || FrameDuration) {
++     static int samplingFrequencies[2][4] = { // all values are specified in Hz
++       { 44100, 48000, 32000, -1 }, // MPEG 1
++       { 22050, 24000, 16000, -1 }  // MPEG 2
++       };
+ 
+-        static int slots_per_frame[2][3] = {
+-          { 12, 144, 144 }, // MPEG 1, Layer I, II, III
+-          { 12, 144,  72 }  // MPEG 2, Layer I, II, III
+-          };
++     static int slots_per_frame[2][3] = {
++       { 12, 144, 144 }, // MPEG 1, Layer I, II, III
++       { 12, 144,  72 }  // MPEG 2, Layer I, II, III
++       };
+ 
+-        int mpegIndex = 1 - id;
+-        int layerIndex = 3 - layer;
++     int mpegIndex = 1 - id;
++     int layerIndex = 3 - layer;
+ 
+-        // Layer I (i. e., layerIndex == 0) has a larger slot size
+-        int slotSize = (layerIndex == 0) ? 4 : 1; // bytes
++     // Layer I (i. e., layerIndex == 0) has a larger slot size
++     int slotSize = (layerIndex == 0) ? 4 : 1; // bytes
++     int sf = samplingFrequencies[mpegIndex][sampling_frequency];
+ 
+-        int br = 1000 * bitRates[mpegIndex][layerIndex][bitrate_index]; // bits/s
+-        int sf = samplingFrequencies[mpegIndex][sampling_frequency];
++     if (FrameDuration)
++        *FrameDuration = 90000 * 8 * slotSize * slots_per_frame[mpegIndex][layerIndex] / sf;
+ 
+-        int N = slots_per_frame[mpegIndex][layerIndex] * br / sf; // slots
++     if (FrameSize) {
++        if (bitrate_index == 0)
++           *FrameSize = 0;
++        else {
++           int br = 1000 * bitRates[mpegIndex][layerIndex][bitrate_index]; // bits/s
++           int N = slots_per_frame[mpegIndex][layerIndex] * br / sf; // slots
+ 
+-        *FrameSize = (N + padding_bit) * slotSize; // bytes
++           *FrameSize = (N + padding_bit) * slotSize; // bytes
++           }
+         }
+      }
+ 
+@@ -1086,6 +1111,7 @@
+   virtual void Reset(void);
+   virtual void Repack(cRingBufferLinear *ResultBuffer, const uchar *Data, int Count);
+   virtual int BreakAt(const uchar *Data, int Count);
++  static int GetFrameDuration(const uchar *Data, int Count, int *TrackIndex = NULL);
+   };
+ 
+ // frameSizes are in words, i. e. multiply them by 2 to get bytes
+@@ -1112,6 +1138,30 @@
+      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   };
+ 
++int cDolbyRepacker::GetFrameDuration(const uchar *Data, int Count, int *TrackIndex)
++{
++  int PesPayloadOffset = 0;
++  ePesHeader PH = AnalyzePesHeader(Data, Count, PesPayloadOffset);
++  if (PH < phMPEG1)
++     return -1;
++
++  const uchar *Payload = Data + PesPayloadOffset;
++  const int PayloadCount = Count - PesPayloadOffset;
++
++  if (Data[3] == 0xBD && PayloadCount >= 9 && ((Payload[0] & 0xF0) == 0x80) && Payload[4] == 0x0B && Payload[5] == 0x77 && frameSizes[Payload[8]] > 0) {
++     if (TrackIndex)
++        *TrackIndex = Payload[0] - 0x80;
++
++     static int samplingFrequencies[4] = { // all values are specified in Hz
++       48000, 44100, 32000, -1
++       };
++
++     return 90000 * 1536 / samplingFrequencies[Payload[8] >> 6];
++     }
++
++  return -1;
++}
++
+ cDolbyRepacker::cDolbyRepacker(void)
+ {
+   pesHeader[0] = 0x00;
+@@ -1869,6 +1919,58 @@
+      instant_repack(Buf + 4 + off, TS_SIZE - 4 - off);
+ }
+ 
++// --- cAudioIndexer ---------------------------------------------------------
++
++class cAudioIndexer {
++private:
++  int frameTrack;
++  int frameDuration;
++  int64_t trackTime[MAXAPIDS + MAXDPIDS];
++  int64_t nextIndexTime;
++  
++public:
++  cAudioIndexer(void);
++  void Clear(void);
++  void PrepareFrame(const uchar *Data, int Count, int Offset, uchar &PictureType);
++  void ProcessFrame(void);
++  };
++
++cAudioIndexer::cAudioIndexer(void)
++{
++  Clear();
++}
++
++void cAudioIndexer::Clear(void)
++{
++  memset(trackTime, 0, sizeof (trackTime));
++  nextIndexTime = 0;
++  frameTrack = -1;
++}
++
++void cAudioIndexer::PrepareFrame(const uchar *Data, int Count, int Offset, uchar &PictureType)
++{
++  frameDuration = cRemux::GetAudioFrameDuration(Data + Offset, Count - Offset, &frameTrack);
++  if (frameDuration <= 0)
++     return;
++
++  if (Data[Offset + 3] == 0xBD)
++     frameTrack += MAXAPIDS;
++
++  PictureType = (trackTime[frameTrack] >= nextIndexTime) ? I_FRAME : NO_PICTURE;
++}
++
++void cAudioIndexer::ProcessFrame(void)
++{
++  if (frameTrack < 0)
++     return;
++
++  if (trackTime[frameTrack] >= nextIndexTime)
++     nextIndexTime += 90000 / FRAMESPERSEC;
++
++  trackTime[frameTrack] += frameDuration;
++  frameTrack = -1;
++}
++
+ // --- cRemux ----------------------------------------------------------------
+ 
+ #define RESULTBUFFERSIZE KILOBYTE(256)
+@@ -1877,6 +1979,7 @@
+ {
+   exitOnFailure = ExitOnFailure;
+   noVideo = VPid == 0 || VPid == 1 || VPid == 0x1FFF;
++  audioIndexer = (noVideo ? new cAudioIndexer : NULL);
+   numUPTerrors = 0;
+   synced = false;
+   skipped = 0;
+@@ -1920,6 +2023,18 @@
+   for (int t = 0; t < numTracks; t++)
+       delete ts2pes[t];
+   delete resultBuffer;
++  delete audioIndexer;
++}
++
++int cRemux::GetAudioFrameDuration(const uchar *Data, int Count, int *TrackIndex)
++{
++  if (Count <= 4)
++     return -1;
++
++  if (Data[3] == 0xBD)
++     return cDolbyRepacker::GetFrameDuration(Data, Count, TrackIndex);
++
++  return cAudioRepacker::GetFrameDuration(Data, Count, TrackIndex);
+ }
+ 
+ int cRemux::GetPid(const uchar *Data)
+@@ -2099,16 +2214,19 @@
+                if (l < 0)
+                   return resultData;
+                if (noVideo) {
++                  uchar pt = NO_PICTURE;
++                  if (audioIndexer && !Count)
++                     audioIndexer->PrepareFrame(data, resultCount, i, pt); 
+                   if (!synced) {
+                      if (PictureType)
+-                        *PictureType = I_FRAME;
++                        *PictureType = pt;
+                      resultSkipped = i; // will drop everything before this position
+                      synced = true;
+                      }
+                   else if (Count)
+                      return resultData;
+                   else if (PictureType)
+-                     *PictureType = I_FRAME;
++                     *PictureType = pt;
+                   }
+                }
+             if (synced) {
+@@ -2129,6 +2247,8 @@
+ void cRemux::Del(int Count)
+ {
+   resultBuffer->Del(Count);
++  if (audioIndexer && Count > 0)
++     audioIndexer->ProcessFrame();
+ }
+ 
+ void cRemux::Clear(void)
+@@ -2136,6 +2256,8 @@
+   for (int t = 0; t < numTracks; t++)
+       ts2pes[t]->Clear();
+   resultBuffer->Clear();
++  if (audioIndexer)
++     audioIndexer->Clear();
+   synced = false;
+   skipped = 0;
+   resultSkipped = 0;
+diff -urNad vdr-1.5.10~/remux.h vdr-1.5.10/remux.h
+--- vdr-1.5.10~/remux.h	2007-09-02 12:19:06.000000000 +0200
++++ vdr-1.5.10/remux.h	2007-11-04 00:08:43.000000000 +0100
+@@ -33,6 +33,7 @@
+ #define MAXTRACKS 64
+ 
+ class cTS2PES;
++class cAudioIndexer;
+ 
+ class cRemux {
+ private:
+@@ -45,6 +46,7 @@
+   int numTracks;
+   cRingBufferLinear *resultBuffer;
+   int resultSkipped;
++  cAudioIndexer *audioIndexer;
+   int GetPid(const uchar *Data);
+ public:
+   cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure = false);
+@@ -79,6 +81,7 @@
+   static void SetBrokenLink(uchar *Data, int Length);
+   static int GetPacketLength(const uchar *Data, int Count, int Offset);
+   static int ScanVideoPacket(const uchar *Data, int Count, int Offset, uchar &PictureType);
++  static int GetAudioFrameDuration(const uchar *Data, int Count, int *TrackIndex = NULL);
+   };
+ 
+ #endif // __REMUX_H
--- vdr-1.6.0.orig/debian/patches/opt-53_dvbsetup.dpatch
+++ vdr-1.6.0/debian/patches/opt-53_dvbsetup.dpatch
@@ -0,0 +1,150 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-53_dvbsetup.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Setup for AC3 transfer, QAM_256, disable primary tuner
+## DP: Taken from the Zulu extensions patch
+## DP: See http://www.zulu-entertainment.de/download.php?group=VDR
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/config.c vdr-1.6.0/config.c
+--- vdr-1.6.0~/config.c	2008-07-25 23:53:03.000000000 +0200
++++ vdr-1.6.0/config.c	2008-07-25 23:53:52.000000000 +0200
+@@ -253,6 +253,9 @@
+   strcpy(OSDLanguage, ""); // default is taken from environment
+   strcpy(OSDSkin, "sttng");
+   strcpy(OSDTheme, "default");
++  DolbyTransferFix = 1;
++  NoQamOnDecoder = 0;
++  TurnOffPrimary = 0;
+   PrimaryDVB = 1;
+   ShowInfoOnChSwitch = 1;
+   TimeoutRequChInfo = 1;
+@@ -497,6 +500,9 @@
+   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
+   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
++  else if (!strcasecmp(Name, "DolbyTransferFix"))    DolbyTransferFix   = atoi(Value);
++  else if (!strcasecmp(Name, "NoQamOnDecoder"))      NoQamOnDecoder     = atoi(Value);
++  else if (!strcasecmp(Name, "TurnOffPrimary"))      TurnOffPrimary     = atoi(Value);
+   else if (!strcasecmp(Name, "PrimaryDVB"))          PrimaryDVB         = atoi(Value);
+   else if (!strcasecmp(Name, "ShowInfoOnChSwitch"))  ShowInfoOnChSwitch = atoi(Value);
+   else if (!strcasecmp(Name, "TimeoutRequChInfo"))   TimeoutRequChInfo  = atoi(Value);
+@@ -601,6 +607,9 @@
+ 
+ bool cSetup::Save(void)
+ {
++  Store("DolbyTransferFix",   DolbyTransferFix);
++  Store("NoQamOnDecoder",     NoQamOnDecoder);
++  Store("TurnOffPrimary",     TurnOffPrimary);
+   Store("OSDLanguage",        OSDLanguage);
+   Store("OSDSkin",            OSDSkin);
+   Store("OSDTheme",           OSDTheme);
+diff -urNad vdr-1.6.0~/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0~/config.h	2008-07-25 23:53:03.000000000 +0200
++++ vdr-1.6.0/config.h	2008-07-25 23:53:03.000000000 +0200
+@@ -228,6 +228,9 @@
+ public:
+   // Also adjust cMenuSetup (menu.c) when adding parameters here!
+   int __BeginData__;
++  int DolbyTransferFix;
++  int NoQamOnDecoder;
++  int TurnOffPrimary;
+   char OSDLanguage[I18N_MAX_LOCALE_LEN];
+   char OSDSkin[MaxSkinName];
+   char OSDTheme[MaxThemeName];
+diff -urNad vdr-1.6.0~/dvbdevice.c vdr-1.6.0/dvbdevice.c
+--- vdr-1.6.0~/dvbdevice.c	2008-07-25 23:53:03.000000000 +0200
++++ vdr-1.6.0/dvbdevice.c	2008-07-25 23:53:03.000000000 +0200
+@@ -438,7 +438,10 @@
+   if (fd_frontend >= 0) {
+      dvb_frontend_info feinfo;
+      if (ioctl(fd_frontend, FE_GET_INFO, &feinfo) >= 0) {
+-        frontendType = feinfo.type;
++        if (Setup.TurnOffPrimary)
++           frontendType = n == Setup.PrimaryDVB - 1 ? frontendType : feinfo.type;
++        else
++           frontendType = feinfo.type;
+         dvbTuner = new cDvbTuner(fd_frontend, CardIndex(), frontendType);
+         }
+      else
+@@ -657,6 +660,11 @@
+ 
+ bool cDvbDevice::SetAudioBypass(bool On)
+ {
++ if (Setup.DolbyTransferFix && On) {
++    cChannel *c=Channels.GetByNumber(cDevice::CurrentChannel());
++    if (c->Ca(0) != 0)
++       return false;
++    }
+   if (setTransferModeForDolbyDigital != 1)
+      return false;
+   return ioctl(fd_audio, AUDIO_SET_BYPASS_MODE, On) == 0;
+@@ -776,11 +784,21 @@
+ 
+ bool cDvbDevice::ProvidesTransponder(const cChannel *Channel) const
+ {
++  if (Setup.NoQamOnDecoder) {
++     if (HasDecoder() && (cSource::IsCable(Channel->Source())) && (fe_modulation_t(Channel->Modulation()) == QAM_256))
++        return false;
++     }
++
+   return ProvidesSource(Channel->Source()) && (!cSource::IsSat(Channel->Source()) || !Setup.DiSEqC || Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization()));
+ }
+ 
+ bool cDvbDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
+ {
++  if (Setup.NoQamOnDecoder) {
++     if (HasDecoder() && (cSource::IsCable(Channel->Source())) && (fe_modulation_t(Channel->Modulation()) == QAM_256))
++        return false;
++     }
++
+   bool result = false;
+   bool hasPriority = Priority < 0 || Priority > this->Priority();
+   bool needsDetachReceivers = false;
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2008-07-25 23:53:03.000000000 +0200
++++ vdr-1.6.0/menu.c	2008-07-25 23:53:03.000000000 +0200
+@@ -3033,6 +3033,10 @@
+      Add(new cMenuEditIntItem( tr("Setup.LNB$High LNB frequency (MHz)"), &data.LnbFrequHi));
+      }
+ 
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use AC3-Transfer Fix"),          &data.DolbyTransferFix));
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$No Qam256 on Cards with Decoder"),   &data.NoQamOnDecoder));
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Turn off Primary Tuner"),        &data.TurnOffPrimary));
++
+   SetCurrent(Get(current));
+   Display();
+ }
+diff -urNad vdr-1.6.0~/remux.c vdr-1.6.0/remux.c
+--- vdr-1.6.0~/remux.c	2008-07-25 23:53:03.000000000 +0200
++++ vdr-1.6.0/remux.c	2008-07-25 23:53:03.000000000 +0200
+@@ -1879,8 +1879,10 @@
+   if (Buf[1] & TS_ERROR)
+      tsErrors++;
+ 
+-  if (!(Buf[3] & (ADAPT_FIELD | PAY_LOAD)))
++  if (!(Buf[3] & (ADAPT_FIELD | PAY_LOAD))) {
++     dsyslog("TS packet discarded due to invalid adaption_field_control");
+      return; // discard TS packet with adaption_field_control set to '00'.
++     }
+ 
+   if ((Buf[3] & PAY_LOAD) && ((Buf[3] ^ ccCounter) & CONT_CNT_MASK)) {
+      // This should check duplicates and packets which do not increase the counter.
+@@ -1892,6 +1894,7 @@
+         // These are the errors I used to get with Nova-T when antenna
+         // was not positioned correcly (not transport errors). //tvr
+         //dsyslog("TS continuity error (%d)", ccCounter);
++        dsyslog("TS continuity error (%d)", ccCounter);
+         }
+      ccCounter = Buf[3] & CONT_CNT_MASK;
+      }
+@@ -1917,6 +1920,8 @@
+ 
+   if (Buf[3] & PAY_LOAD)
+      instant_repack(Buf + 4 + off, TS_SIZE - 4 - off);
++  else if (off + 4 < 188)
++     dsyslog("adaption_field zu short or PAY_LOAD not set");
+ }
+ 
+ // --- cRingBufferLinearPes --------------------------------------------------
--- vdr-1.6.0.orig/debian/patches/opt-24_jumpplay.dpatch
+++ vdr-1.6.0/debian/patches/opt-24_jumpplay.dpatch
@@ -0,0 +1,548 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-24_jumpplay.dpatch by Torsten Kunkel <vdr@tkunkel.de>, Thomas Gnther <tom@toms-cafe.de>
+## http://toms-cafe.de/vdr/download/vdr-jumpplay-1.0-1.6.0.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Play after jump to next mark. Automatically jump over commercial breaks.
+## DP: See README.jumpplay and MANUAL for details.
+
+@DPATCH@
+diff -Naurp vdr-1.6.0/MANUAL vdr-1.6.0-jumpplay-1.0/MANUAL
+--- vdr-1.6.0/MANUAL	2008-02-24 10:09:17.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/MANUAL	2009-03-31 00:11:13.000000000 +0000
+@@ -813,6 +813,30 @@ Version 1.6
+                          0 resulting in a file named 'resume.vdr', and any other
+                          value resulting in 'resume.n.vdr'.
+ 
++  Jump&Play = no         Turns playing on or off after jumping forward to the
++                         next editing mark with the '9' key.
++
++  Play&Jump = no         Turns automatic jumping over commercial breaks on or
++                         off. This includes jumping to the first mark, if the
++                         replay starts at the beginning of a recording - and
++                         stopping the replay at the last mark.
++                         With this setting enabled, the behaviour of the '8'
++                         key during replay is changed too. It moves the actual
++                         replay position not only three seconds before the
++                         next "start" mark, but also before the next "end"
++                         mark. This can be used to test, if the editing marks
++                         are correctly positioned for a "smooth" jump over a
++                         commercial break.
++
++  Pause at last mark = no
++                         Turns pausing of replay at the last editing mark on or
++                         off.
++
++  Reload marks = no      Turns reloading of editing marks on or off. This can
++                         be used if an external programme adjusts the editing
++                         marks, e.g. noad in online mode. The marks are reloaded
++                         in 10 seconds intervals.
++
+   Miscellaneous:
+ 
+   Min. event timeout = 30
+diff -Naurp vdr-1.6.0/README.jumpplay vdr-1.6.0-jumpplay-1.0/README.jumpplay
+--- vdr-1.6.0/README.jumpplay	1970-01-01 00:00:00.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/README.jumpplay	2009-03-31 00:24:59.000000000 +0000
+@@ -0,0 +1,92 @@
++JumpPlay patch for VDR
++----------------------
++
++This patch changes the replay behaviour for recordings that contain editing
++marks. It allows to immediately continue the replay after jumping forward to
++the next mark, and to automatically jump over the commercial break to the next
++"start" mark, if an "end" mark is reached.
++
++The features of this patch can be turned on or off with parameters in the replay
++setup. See MANUAL for description of this parameters: "Jump&Play", "Play&Jump",
++"Pause at last mark" and "Reload marks".
++
++
++* History
++
++  2003-07-04: jumpandrun.diff - the Noad <theNoad@SoftHome.net>
++    Jump&Play
++
++  2003-12-06: Version 0.0 - Torsten Kunkel <vdr@tkunkel.de>
++    Play&Jump (only if progressbar is visible)
++    Setup parameters Jump&Play and Play&Jump in the replay setup
++
++  2004-01-20: Version 0.1 - Thomas Gnther <tom@toms-cafe.de>
++    Jump&Play:
++      - fixed speed after jump
++      - fixed removing of marks
++    Play&Jump:
++      - jump only on "end" marks
++
++  2004-01-27: Version 0.2 - Thomas Gnther <tom@toms-cafe.de>
++    Jump&Play:
++      - fixed double jump
++    Play&Jump:
++      - fixed mark detection: fuzzy detection (until 3 seconds after mark)
++      - jump without progressbar
++      - mode "progressbar only" for old behaviour
++
++  2004-01-31: Version 0.3 - Thomas Gnther <tom@toms-cafe.de>
++    Jump&Play:
++      - fixed display frames
++    Play&Jump:
++      - fixed end of playing at last mark
++
++  2004-07-11: Version 0.4 - Thomas Gnther <tom@toms-cafe.de>
++    Jump&Play:
++      - don't play after jump to end
++    Play&Jump:
++      - don't prevent jumping after hide or show
++    Less conflicts with other patches (Elchi/AutoPID)
++
++  2004-08-21: Version 0.5 - Thomas Gnther <tom@toms-cafe.de>
++    Play&Jump:
++      - exact jumps, replay like edited recording (no fuzzy mark detection)
++      - jump to first mark if replay starts at the beginning
++      - check jump marks with '8' key
++      - mode "progressbar only" removed
++    Description in README.jumpplay
++
++  2004-12-28: Version 0.6 - Thomas Gnther <tom@toms-cafe.de>
++    Adapted noad extensions (from the Noad <theNoad@SoftHome.net>) to
++    jumpplay-0.5:
++      - cyclic reloading of marks found by noad online-scan
++      - don't stop after the last mark in case of live-recordings
++    New setup parameter "Load marks interval (s)"
++    Updated description in README.jumpplay
++
++  2006-04-14: Version 0.7 - Thomas Gnther <tom@toms-cafe.de>
++    Fixed jump to first mark (crashed with plugin extrecmenu-0.9)
++    Added version define JUMPPLAYVERSNUM
++    Added placeholders for Czech language texts
++    Cleaned up i18n entries (support only VDR >= 1.3.29)
++    Improved description of i18n placeholders - hoping for real language texts
++
++  2006-05-12: Version 0.8 - Thomas Gnther <tom@toms-cafe.de>
++    Fixed segfault in dvbplayer thread while the replaycontrol thread is
++    reloading the marks (thanks to horchi at vdrportal.de for reporting this -
++    see http://vdrportal.de/board/thread.php?postid=450463#post450463):
++    New class cMarksReload checks the timestamp of marks.vdr in 10 seconds
++    intervals, so the marks in the threads dvbplayer and replaycontrol can be
++    reloaded independently
++    Changed setup parameter "Load marks interval (s)" to "Reload marks"
++    Updated description in README.jumpplay
++
++  2006-05-28: Version 0.9 - Thomas Gnther <tom@toms-cafe.de>
++    New setup parameter "Pause at last mark"
++    Updated description in README.jumpplay
++    Moved parameters description to MANUAL
++
++  2009-03-31: Version 1.0 - Thomas Gnther <tom@toms-cafe.de>
++    Play&Jump:
++      - set resume position to 0 if replay stops at the first mark
++    Added French language texts (thanks to Michal Nival)
+diff -Naurp vdr-1.6.0/config.c vdr-1.6.0-jumpplay-1.0/config.c
+--- vdr-1.6.0/config.c	2008-02-17 13:39:00.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/config.c	2009-03-31 00:11:13.000000000 +0000
+@@ -283,6 +283,10 @@ cSetup::cSetup(void)
+   MultiSpeedMode = 0;
+   ShowReplayMode = 0;
+   ResumeID = 0;
++  JumpPlay = 0;
++  PlayJump = 0;
++  PauseLastMark = 0;
++  ReloadMarks = 0;
+   CurrentChannel = -1;
+   CurrentVolume = MAXVOLUME;
+   CurrentDolby = 0;
+@@ -456,6 +460,10 @@ bool cSetup::Parse(const char *Name, con
+   else if (!strcasecmp(Name, "MultiSpeedMode"))      MultiSpeedMode     = atoi(Value);
+   else if (!strcasecmp(Name, "ShowReplayMode"))      ShowReplayMode     = atoi(Value);
+   else if (!strcasecmp(Name, "ResumeID"))            ResumeID           = atoi(Value);
++  else if (!strcasecmp(Name, "JumpPlay"))            JumpPlay           = atoi(Value);
++  else if (!strcasecmp(Name, "PlayJump"))            PlayJump           = atoi(Value);
++  else if (!strcasecmp(Name, "PauseLastMark"))       PauseLastMark      = atoi(Value);
++  else if (!strcasecmp(Name, "ReloadMarks"))         ReloadMarks        = atoi(Value);
+   else if (!strcasecmp(Name, "CurrentChannel"))      CurrentChannel     = atoi(Value);
+   else if (!strcasecmp(Name, "CurrentVolume"))       CurrentVolume      = atoi(Value);
+   else if (!strcasecmp(Name, "CurrentDolby"))        CurrentDolby       = atoi(Value);
+@@ -539,6 +547,10 @@ bool cSetup::Save(void)
+   Store("MultiSpeedMode",     MultiSpeedMode);
+   Store("ShowReplayMode",     ShowReplayMode);
+   Store("ResumeID",           ResumeID);
++  Store("JumpPlay",           JumpPlay);
++  Store("PlayJump",           PlayJump);
++  Store("PauseLastMark",      PauseLastMark);
++  Store("ReloadMarks",        ReloadMarks);
+   Store("CurrentChannel",     CurrentChannel);
+   Store("CurrentVolume",      CurrentVolume);
+   Store("CurrentDolby",       CurrentDolby);
+diff -Naurp vdr-1.6.0/config.h vdr-1.6.0-jumpplay-1.0/config.h
+--- vdr-1.6.0/config.h	2008-03-23 10:26:10.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/config.h	2009-03-31 00:11:13.000000000 +0000
+@@ -36,6 +36,8 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++#define JUMPPLAYVERSNUM 100
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
+@@ -261,6 +263,10 @@ public:
+   int MultiSpeedMode;
+   int ShowReplayMode;
+   int ResumeID;
++  int JumpPlay;
++  int PlayJump;
++  int PauseLastMark;
++  int ReloadMarks;
+   int CurrentChannel;
+   int CurrentVolume;
+   int CurrentDolby;
+diff -Naurp vdr-1.6.0/dvbplayer.c vdr-1.6.0-jumpplay-1.0/dvbplayer.c
+--- vdr-1.6.0/dvbplayer.c	2008-02-09 15:10:54.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/dvbplayer.c	2009-03-31 00:17:08.000000000 +0000
+@@ -193,6 +193,7 @@ private:
+   cNonBlockingFileReader *nonBlockingFileReader;
+   cRingBufferFrame *ringBuffer;
+   cBackTrace *backTrace;
++  cMarksReload marks;
+   cFileName *fileName;
+   cIndexFile *index;
+   cUnbufferedFile *replayFile;
+@@ -234,7 +235,7 @@ public:
+ int cDvbPlayer::Speeds[] = { 0, -2, -4, -8, 1, 2, 4, 12, 0 };
+ 
+ cDvbPlayer::cDvbPlayer(const char *FileName)
+-:cThread("dvbplayer")
++:cThread("dvbplayer"), marks(FileName)
+ {
+   nonBlockingFileReader = NULL;
+   ringBuffer = NULL;
+@@ -341,6 +342,10 @@ bool cDvbPlayer::Save(void)
+   if (index) {
+      int Index = writeIndex;
+      if (Index >= 0) {
++        // set resume position to 0 if replay stops at the first mark
++        if (Setup.PlayJump && marks.First() &&
++            abs(Index - marks.First()->position) <= RESUMEBACKUP)
++           Index = 0;
+         Index -= RESUMEBACKUP;
+         if (Index > 0)
+            Index = index->GetNextIFrame(Index, false);
+@@ -368,11 +373,26 @@ void cDvbPlayer::Action(void)
+   uchar *b = NULL;
+   uchar *p = NULL;
+   int pc = 0;
++  bool cutIn = false;
++  int total = -1;
+ 
+   readIndex = Resume();
+   if (readIndex >= 0)
+      isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true));
+ 
++  if (Setup.PlayJump && readIndex <= 0 && marks.First() && index) {
++     int Index = marks.First()->position;
++     uchar FileNumber;
++     int FileOffset;
++     if (index->Get(Index, &FileNumber, &FileOffset) &&
++         NextFile(FileNumber, FileOffset)) {
++        isyslog("PlayJump: start replay at first mark %d (%s)",
++                Index, *IndexToHMSF(Index, true));
++        readIndex = Index;
++        }
++     }
++
++  bool LastMarkPause = false;
+   nonBlockingFileReader = new cNonBlockingFileReader;
+   int Length = 0;
+   bool Sleep = false;
+@@ -393,7 +413,7 @@ void cDvbPlayer::Action(void)
+ 
+            // Read the next frame from the file:
+ 
+-           if (playMode != pmStill && playMode != pmPause) {
++           if (playMode != pmStill && playMode != pmPause && !LastMarkPause) {
+               if (!readFrame && (replayFile || readIndex >= 0)) {
+                  if (!nonBlockingFileReader->Reading()) {
+                     if (playMode == pmFast || (playMode == pmSlow && playDir == pdBackward)) {
+@@ -438,6 +458,44 @@ void cDvbPlayer::Action(void)
+                        uchar FileNumber;
+                        int FileOffset;
+                        readIndex++;
++                       if (Setup.PlayJump || Setup.PauseLastMark) {
++                          // check for end mark - jump to next mark or pause
++                          marks.Reload();
++                          cMark *m = marks.Get(readIndex);
++                          if (m && (m->Index() & 0x01) != 0) {
++                             m = marks.Next(m);
++                             int Index;
++                             if (m)
++                                Index = m->position;
++                             else if (Setup.PauseLastMark) {
++                                // pause at last mark
++                                isyslog("PauseLastMark: pause at position %d (%s)",
++                                        readIndex, *IndexToHMSF(readIndex, true));
++                                LastMarkPause = true;
++                                Index = -1;
++                                }
++                             else if (total == index->Last())
++                                // at last mark jump to end of recording
++                                Index = index->Last() - 1;
++                             else
++                                // jump but stay off end of live-recordings
++                                Index = index->GetNextIFrame(index->Last() - 150, true);
++                             // don't jump in edited recordings
++                             if (Setup.PlayJump && Index > readIndex &&
++                                 Index > index->GetNextIFrame(readIndex, true)) {
++                                isyslog("PlayJump: %d frames to %d (%s)",
++                                        Index - readIndex, Index,
++                                        *IndexToHMSF(Index, true));
++                                readIndex = Index;
++                                cutIn = true;
++                                }
++                             }
++                          }
++                       // for detecting growing length of live-recordings
++                       uchar PictureType;
++                       if (index->Get(readIndex, &FileNumber, &FileOffset, &PictureType) &&
++                           PictureType == I_FRAME)
++                          total = index->Last();
+                        if (!(index->Get(readIndex, &FileNumber, &FileOffset, NULL, &Length) && NextFile(FileNumber, FileOffset))) {
+                           readIndex = -1;
+                           eof = true;
+@@ -473,6 +531,10 @@ void cDvbPlayer::Action(void)
+               // Store the frame in the buffer:
+ 
+               if (readFrame) {
++                 if (cutIn) {
++                    cRemux::SetBrokenLink(readFrame->Data(), readFrame->Count());
++                    cutIn = false;
++                    }
+                  if (ringBuffer->Put(readFrame))
+                     readFrame = NULL;
+                  }
+@@ -521,8 +583,14 @@ void cDvbPlayer::Action(void)
+                  p = NULL;
+                  }
+               }
+-           else
++           else {
++              if (LastMarkPause) {
++                 LastMarkPause = false;
++                 playMode = pmPause;
++                 writeIndex = readIndex;
++                 }
+               Sleep = true;
++              }
+            }
+         }
+ 
+diff -Naurp vdr-1.6.0/menu.c vdr-1.6.0-jumpplay-1.0/menu.c
+--- vdr-1.6.0/menu.c	2008-03-16 11:15:28.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/menu.c	2009-03-31 00:11:13.000000000 +0000
+@@ -2775,6 +2775,10 @@ cMenuSetupReplay::cMenuSetupReplay(void)
+   Add(new cMenuEditBoolItem(tr("Setup.Replay$Multi speed mode"), &data.MultiSpeedMode));
+   Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
+   Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
++  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"), &data.JumpPlay));
++  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"), &data.PlayJump));
++  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
++  Add(new cMenuEditBoolItem(tr("Setup.Replay$Reload marks"), &data.ReloadMarks));
+ }
+ 
+ void cMenuSetupReplay::Store(void)
+@@ -4064,7 +4068,7 @@ char *cReplayControl::fileName = NULL;
+ char *cReplayControl::title = NULL;
+ 
+ cReplayControl::cReplayControl(void)
+-:cDvbPlayerControl(fileName)
++:cDvbPlayerControl(fileName), marks(fileName)
+ {
+   currentReplayControl = this;
+   displayReplay = NULL;
+@@ -4074,7 +4078,6 @@ cReplayControl::cReplayControl(void)
+   lastSpeed = -2; // an invalid value
+   timeoutShow = 0;
+   timeSearchActive = false;
+-  marks.Load(fileName);
+   cRecording Recording(fileName);
+   cStatus::MsgReplaying(this, Recording.Name(), Recording.FileName(), true);
+   SetTrackDescriptions(false);
+@@ -4304,8 +4307,10 @@ void cReplayControl::MarkToggle(void)
+         ShowTimed(2);
+         bool Play, Forward;
+         int Speed;
+-        if (GetReplayMode(Play, Forward, Speed) && !Play)
++        if (GetReplayMode(Play, Forward, Speed) && !Play) {
+            Goto(Current, true);
++           displayFrames = true;
++           }
+         }
+      marks.Save();
+      }
+@@ -4318,8 +4323,17 @@ void cReplayControl::MarkJump(bool Forwa
+      if (GetIndex(Current, Total)) {
+         cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current);
+         if (m) {
+-           Goto(m->position, true);
+-           displayFrames = true;
++           bool Play2, Forward2;
++           int Speed;
++           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
++               Play2 && Forward && m->position < Total - SecondsToFrames(3)) {
++              Goto(m->position);
++              Play();
++              }
++           else {
++              Goto(m->position, true);
++              displayFrames = true;
++              }
+            }
+         }
+      }
+@@ -4374,7 +4388,7 @@ void cReplayControl::EditTest(void)
+      if (!m)
+         m = marks.GetNext(Current);
+      if (m) {
+-        if ((m->Index() & 0x01) != 0)
++        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
+            m = marks.Next(m);
+         if (m) {
+            Goto(m->position - SecondsToFrames(3));
+@@ -4396,6 +4410,7 @@ eOSState cReplayControl::ProcessKey(eKey
+ {
+   if (!Active())
+      return osEnd;
++  marks.Reload();
+   if (visible) {
+      if (timeoutShow && time(NULL) > timeoutShow) {
+         Hide();
+diff -Naurp vdr-1.6.0/menu.h vdr-1.6.0-jumpplay-1.0/menu.h
+--- vdr-1.6.0/menu.h	2008-02-10 16:01:53.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/menu.h	2009-03-31 00:11:13.000000000 +0000
+@@ -212,7 +212,7 @@ public:
+ class cReplayControl : public cDvbPlayerControl {
+ private:
+   cSkinDisplayReplay *displayReplay;
+-  cMarks marks;
++  cMarksReload marks;
+   bool visible, modeOnly, shown, displayFrames;
+   int lastCurrent, lastTotal;
+   bool lastPlay, lastForward;
+diff -Naurp vdr-1.6.0/po/de_DE.po vdr-1.6.0-jumpplay-1.0/po/de_DE.po
+--- vdr-1.6.0/po/de_DE.po	2008-03-23 10:31:29.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/po/de_DE.po	2009-03-31 00:11:13.000000000 +0000
+@@ -746,6 +746,18 @@ msgstr "Editierte Dateien aufteilen"
+ msgid "Replay"
+ msgstr "Wiedergabe"
+ 
++msgid "Setup.Replay$Jump&Play"
++msgstr "Wiedergabe nach Sprung"
++
++msgid "Setup.Replay$Play&Jump"
++msgstr "Sprung bei Schnittmarke"
++
++msgid "Setup.Replay$Pause at last mark"
++msgstr "Pause bei letzter Marke"
++
++msgid "Setup.Replay$Reload marks"
++msgstr "Marken aktualisieren"
++
+ msgid "Setup.Replay$Multi speed mode"
+ msgstr "Mehrstufiger Vor-/Rcklauf"
+ 
+diff -Naurp vdr-1.6.0/po/fr_FR.po vdr-1.6.0-jumpplay-1.0/po/fr_FR.po
+--- vdr-1.6.0/po/fr_FR.po	2008-03-23 10:31:29.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/po/fr_FR.po	2009-03-31 00:11:13.000000000 +0000
+@@ -752,6 +752,18 @@ msgstr "Sparer les squences dites"
+ msgid "Replay"
+ msgstr "Lecture"
+ 
++msgid "Setup.Replay$Jump&Play"
++msgstr "Lecture aprs saut"
++
++msgid "Setup.Replay$Play&Jump"
++msgstr "Saut sur les marques de dcoupes"
++
++msgid "Setup.Replay$Pause at last mark"
++msgstr "Pause aprs la dernire marque"
++
++msgid "Setup.Replay$Reload marks"
++msgstr "Actualiser les marques"
++
+ msgid "Setup.Replay$Multi speed mode"
+ msgstr "Mode multi-vitesses"
+ 
+diff -Naurp vdr-1.6.0/recording.c vdr-1.6.0-jumpplay-1.0/recording.c
+--- vdr-1.6.0/recording.c	2008-02-24 10:28:53.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/recording.c	2009-03-31 00:11:13.000000000 +0000
+@@ -1154,6 +1154,49 @@ cMark *cMarks::GetNext(int Position)
+   return NULL;
+ }
+ 
++// --- cMarksReload ----------------------------------------------------------
++
++#define MARKS_RELOAD_MS 10000
++
++time_t cMarksReload::lastsavetime = 0;
++
++cMarksReload::cMarksReload(const char *RecordingFileName)
++:recDir(RecordingFileName)
++{
++  struct stat sbuf;
++  if (Load(recDir) && stat(FileName(), &sbuf) == 0)
++     lastmodtime = sbuf.st_mtime;
++  else
++     lastmodtime = 0;
++  nextreload.Set(MARKS_RELOAD_MS - cTimeMs::Now() % MARKS_RELOAD_MS);
++}
++
++bool cMarksReload::Reload(void)
++{
++  // Check the timestamp of marks.vdr in 10 seconds intervals
++  // Independent but synchronized reloading of marks in two threads
++  if ((Setup.ReloadMarks && nextreload.TimedOut()) ||
++      lastsavetime > lastmodtime) {
++     nextreload.Set(MARKS_RELOAD_MS - cTimeMs::Now() % MARKS_RELOAD_MS);
++     struct stat sbuf;
++     if (stat(FileName(), &sbuf) == 0 && sbuf.st_mtime != lastmodtime) {
++        lastmodtime = sbuf.st_mtime;
++        if (Load(recDir))
++           return true;
++        }
++     }
++  return false;
++}
++
++bool cMarksReload::Save(void)
++{
++  bool ok = cMarks::Save();
++  struct stat sbuf;
++  if (ok && stat(FileName(), &sbuf) == 0)
++     lastsavetime = lastmodtime = sbuf.st_mtime;
++  return ok;
++}
++
+ // --- cRecordingUserCommand -------------------------------------------------
+ 
+ const char *cRecordingUserCommand::command = NULL;
+diff -Naurp vdr-1.6.0/recording.h vdr-1.6.0-jumpplay-1.0/recording.h
+--- vdr-1.6.0/recording.h	2007-10-14 10:11:34.000000000 +0000
++++ vdr-1.6.0-jumpplay-1.0/recording.h	2009-03-31 00:11:13.000000000 +0000
+@@ -170,6 +170,18 @@ public:
+   cMark *GetNext(int Position);
+   };
+ 
++class cMarksReload : public cMarks {
++private:
++  cString recDir;
++  cTimeMs nextreload;
++  time_t lastmodtime;
++  static time_t lastsavetime;
++public:
++  cMarksReload(const char *RecordingFileName);
++  bool Reload(void);
++  bool Save(void);
++  };
++
+ #define RUC_BEFORERECORDING "before"
+ #define RUC_AFTERRECORDING  "after"
+ #define RUC_EDITEDRECORDING "edited"
--- vdr-1.6.0.orig/debian/patches/XX_patchtest-compile-error.dpatch
+++ vdr-1.6.0/debian/patches/XX_patchtest-compile-error.dpatch
@@ -0,0 +1,20 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## XX_patchtest-compile-error
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch to check patchtest against compile error
+
+@DPATCH@
+diff -Nur vdr.orig/vdr.c vdr/vdr.c
+--- vdr.orig/vdr.c	2004-03-12 21:37:17.000000000 +0100
++++ vdr/vdr.c	2004-03-13 14:22:01.000000000 +0100
+@@ -79,6 +79,8 @@
+ 
+ int main(int argc, char *argv[])
+ {
++  RaiseCompilerError();
++  
+   // Save terminal settings:
+ 
+   struct termios savedTm;
--- vdr-1.6.0.orig/debian/patches/11_sortrecordings.dpatch
+++ vdr-1.6.0/debian/patches/11_sortrecordings.dpatch
@@ -0,0 +1,34 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 11_sortrecordings.dpatch by FrankJepsen at vdrportal.de
+## http://www.jepsennet.de/vdr/download/11_sortrecordings.dpatch
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.3.42
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Sort recordings dirs first and by name, recs by date or name (if last
+## DP: char in dir is one of '.-$').
+
+@DPATCH@
+--- vdrdevel-1.3.24.org/recording.c	2005-05-07 17:25:15.000000000 +0200
++++ vdrdevel-1.3.24/recording.c	2005-06-17 00:24:44.000000000 +0200
+@@ -445,8 +445,8 @@
+               s1 = t;
+            }
+         t++;
+-        }
+-  if (s1 && s2)
++        } *s1 = 255;
++  if (s1 && s2 && s1 != s && !strchr(".-$", *(s1 - 1)))
+      memmove(s1 + 1, s2, t - s2 + 1);
+   return s;
+ }
+@@ -454,7 +454,7 @@
+ char *cRecording::SortName(void) const
+ {
+   if (!sortBuffer) {
+-     char *s = StripEpisodeName(strdup(FileName() + strlen(VideoDirectory) + 1));
++     char *s = StripEpisodeName(strdup(FileName() + strlen(VideoDirectory) ));
+      strreplace(s, '/', 'a'); // some locales ignore '/' when sorting
+      int l = strxfrm(NULL, s, 0) + 1;
+      sortBuffer = MALLOC(char, l);
--- vdr-1.6.0.orig/debian/patches/99_ncursesw-include.dpatch
+++ vdr-1.6.0/debian/patches/99_ncursesw-include.dpatch
@@ -0,0 +1,19 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 99_ncursesw-include.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Use ncursesw header file
+
+@DPATCH@
+diff -urNad vdr-1.5.16~/PLUGINS/src/skincurses/skincurses.c vdr-1.5.16/PLUGINS/src/skincurses/skincurses.c
+--- vdr-1.5.16~/PLUGINS/src/skincurses/skincurses.c	2008-02-23 11:38:04.000000000 +0100
++++ vdr-1.5.16/PLUGINS/src/skincurses/skincurses.c	2008-02-28 00:52:23.000000000 +0100
+@@ -6,7 +6,7 @@
+  * $Id: skincurses.c 1.22 2008/02/23 10:38:04 kls Exp $
+  */
+ 
+-#include <ncurses.h>
++#include <ncursesw/ncurses.h>
+ #include <vdr/osd.h>
+ #include <vdr/plugin.h>
+ #include <vdr/skins.h>
--- vdr-1.6.0.orig/debian/patches/opt-49-x_pvrinput.dpatch
+++ vdr-1.6.0/debian/patches/opt-49-x_pvrinput.dpatch
@@ -0,0 +1,24 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-49-x_pvrinput.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is required by the pvrinput plugin and was taken from
+## DP: version 2007-11-29 of the plugin.
+## DP: http://drseltsam.device.name/vdr/pvr/src/pvrinput
+## DP:
+## DP: 2008-05-14: Added CA-Id's 0xA1 and 0xA2, required by pvrusb2
+## DP:             (as suggested by Christian Jarczyk)
+
+@DPATCH@
+diff -urNad vdr-1.5.15~/dvbdevice.c vdr-1.5.15/dvbdevice.c
+--- vdr-1.5.15~/dvbdevice.c	2008-02-09 17:11:44.000000000 +0100
++++ vdr-1.5.15/dvbdevice.c	2008-02-20 14:38:36.000000000 +0100
+@@ -759,7 +759,7 @@
+   bool result = false;
+   bool hasPriority = Priority < 0 || Priority > this->Priority();
+   bool needsDetachReceivers = false;
+-
++  if (Channel->Ca(0) == 0xA0 || Channel->Ca(0) == 0xA1 || Channel->Ca(0) == 0xA2) return false; /* this caid marks a pvrinput plugin channel, no dvb */
+   if (ProvidesSource(Channel->Source())) {
+      result = hasPriority;
+      if (Priority >= 0 && Receiving(true)) {
--- vdr-1.6.0.orig/debian/patches/list_uncritical_patches
+++ vdr-1.6.0/debian/patches/list_uncritical_patches
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+# find all patches that don't modify any header files
+
+patches=`find ./ -name "*.dpatch"`
+
+for patch in $patches ; do
+    grep -q -e "^---.*\.h" $patch
+    if [ $? -ne 0 ] ; then
+	basename $patch
+    fi
+done
--- vdr-1.6.0.orig/debian/patches/opt-52_hard_link_cutter.dpatch
+++ vdr-1.6.0/debian/patches/opt-52_hard_link_cutter.dpatch
@@ -0,0 +1,553 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-52_hard_link_cutter.dpatch by Udo Richter <udo_richter@gmx.de>
+## http://www.udo-richter.de/vdr/patches.en.html#hlcutter
+##
+## This is version 0.2.2 of the patch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: The hard link cutter patch changes the recording editing algorithms
+## DP: of VDR to use filesystem hard links to 'copy' recording files whenever
+## DP: possible to speed up editing recordings noticeably.
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/README-HLCUTTER vdr-1.6.0/README-HLCUTTER
+--- vdr-1.6.0~/README-HLCUTTER	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0/README-HLCUTTER	2009-11-28 12:09:29.000000000 +0100
+@@ -0,0 +1,117 @@
++
++                    VDR-HLCUTTER README
++
++
++Written by:           Udo Richter
++Available at:         http://www.udo-richter.de/vdr/patches.html#hlcutter
++                      http://www.udo-richter.de/vdr/patches.en.html#hlcutter
++Contact:              udo_richter@gmx.de
++
++
++
++About
++-----
++
++The hard link cutter patch changes the recording editing algorithms of VDR to
++use filesystem hard links to 'copy' recording files whenever possible to speed
++up editing recordings noticeably.
++
++The patch has matured to be quite stable, at least I'm using it without issues.
++Nevertheless the patch is still in development and should be used with caution. 
++The patch is EXPERIMENTAL for multiple /videoxx folders. The safety checks 
++should prevent data loss, but you should always carefully check the results.
++
++While editing a recording, the patch searches for any 00x.vdr files that dont
++contain editing marks and would normally be copied 1:1 unmodified to the edited
++recording. In this case the current target 00x.vdr file will be aborted, and 
++the cutter process attempts to duplicate the source file as a hard link, so 
++that both files share the same disk space. If this succeeds, the editing 
++process fast-forwards through the duplicated file and continues normally 
++beginning with the next source file. If hard linking fails, the cutter process
++continues with plain old copying. (but does not take up the aborted last file.)
++
++After editing, the un-edited recording can be deleted as usual, the hard linked
++copies will continue to exist as the only remaining copy.
++
++To be effective, the default 'Max. video file size (MB)' should be lowered. 
++The patch lowers the smallest possible file size to 1mb. Since VDR only 
++supports up to 255 files, this would limit the recording size to 255Mb or
++10 minutes, in other words: This setting is insane!
++
++To make sure that the 255 file limit will not be reached, the patch also 
++introduces "Max. recording size (GB)" with a default of 100Gb (66 hours), and 
++increases the file size to 2000Mb early enough, so that 100Gb-recordings will
++fit into the 255 files.
++
++Picking the right parameters can be tricky. The smaller the file size, the 
++faster the editing process works. However, with a small file size, long 
++recordings will fall back to 2000Mb files soon, that are slow on editing again.
++
++Here are some examples:
++
++Max file size:      100Gb   100Gb   100Gb   100Gb   100Gb   100Gb   100Gb
++Max recording size: 1Mb     10Mb    20Mb    30Mb    40Mb    50Mb    100Mb
++
++Small files:        1-203   1-204   1-205   1-206   1-207   1-209   1-214
++  GBytes:           0.2     2.0     4.0     6.0     8.1     10.2    20.9
++  Hours:            0.13    1.3     2.65    4       5.4     6.8     13.9
++
++Big (2000mb) files: 204-255 204-255 206-255 207-255 208-255 210-255 215-255
++  GBytes:           101.5   99.6    97.7    95.7    93.8    89.8    80.1
++  Hours:            67      66      65      63      62      60      53
++
++A recording limit of 100Gb keeps plenty of reserve without blocking too much
++file numbers. And with a file size of 30-40Mb, recordings of 4-5 hours fit into
++small files completely. (depends on bit rate of course)
++
++
++
++The patch must be enabled in Setup-> Recordings-> Hard Link Cutter. When 
++disabled, the cutter process behaves identical to VDR's default cutter.
++
++There's a //#define HARDLINK_TEST_ONLY in the videodir.c file that enables a
++test-mode that hard-links 00x.vdr_ files only, and continues the classic 
++editing. The resulting 00x.vdr and 00x.vdr_ files should be identical. If you 
++delete the un-edited recording, dont forget to delete the *.vdr_ files too, 
++they will now eat real disk space.
++
++Note: 'du' displays the disk space of hard links only on first appearance, and
++usually you will see a noticeably smaller size on the edited recording.
++
++
++History
++-------
++
++Version 0.2.0
++  New: Support for multiple /videoXX recording folders, using advanced searching
++       for matching file systems where a hard link can be created.
++       Also supports deep mounted file systems.
++  Fix: Do not fail if last mark is a cut-in. (Again.)
++
++Version 0.1.4
++  New: Dynamic increase of file size before running out of xxx.vdr files
++  Fix: Last edit mark is not a cut-out
++  Fix: Write error if link-copied file is smaller than allowed file size
++  Fix: Broken index/marks if cut-in is at the start of a new file
++  Fix: Clear dangeling pointer to free'd cUnbufferedFile, 
++       thx to Matthias Schwarzott
++
++Version 0.1.0
++  Initial release
++
++
++
++
++Future plans
++------------
++
++Since original and edited copy share disk space, free space is wrong if one of
++them is moved to *.del. Free space should only count files with hard link 
++count = 1. This still goes wrong if all copies get deleted.
++
++
++For more safety, the hard-linked files may be made read-only, as modifications
++to one copy will affect the other copy too. (except deleting, of course)
++
++
++SetBrokenLink may get lost on rare cases, this needs some more thoughts.
+diff -urNad vdr-1.6.0~/config.c vdr-1.6.0/config.c
+--- vdr-1.6.0~/config.c	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/config.c	2009-11-28 12:09:29.000000000 +0100
+@@ -321,7 +321,9 @@
+   FontSmlSize = 18;
+   FontFixSize = 20;
+   MaxVideoFileSize = MAXVIDEOFILESIZE;
++  MaxRecordingSize = DEFAULTRECORDINGSIZE;
+   SplitEditedFiles = 0;
++  HardLinkCutter = 0;
+   MinEventTimeout = 30;
+   MinUserInactivity = 300;
+   NextWakeupTime = 0;
+@@ -567,7 +569,9 @@
+     noEPGList=strdup(Value ? Value : "");
+   }
+   else if (!strcasecmp(Name, "MaxVideoFileSize"))    MaxVideoFileSize   = atoi(Value);
++  else if (!strcasecmp(Name, "MaxRecordingSize"))    MaxRecordingSize   = atoi(Value);
+   else if (!strcasecmp(Name, "SplitEditedFiles"))    SplitEditedFiles   = atoi(Value);
++  else if (!strcasecmp(Name, "HardLinkCutter"))      HardLinkCutter     = atoi(Value);
+   else if (!strcasecmp(Name, "MinEventTimeout"))     MinEventTimeout    = atoi(Value);
+   else if (!strcasecmp(Name, "MinUserInactivity"))   MinUserInactivity  = atoi(Value);
+   else if (!strcasecmp(Name, "NextWakeupTime"))      NextWakeupTime     = atoi(Value);
+@@ -669,7 +673,9 @@
+   Store("FontSmlSize",        FontSmlSize);
+   Store("FontFixSize",        FontFixSize);
+   Store("MaxVideoFileSize",   MaxVideoFileSize);
++  Store("MaxRecordingSize",   MaxRecordingSize);
+   Store("SplitEditedFiles",   SplitEditedFiles);
++  Store("HardLinkCutter",     HardLinkCutter);
+   Store("MinEventTimeout",    MinEventTimeout);
+   Store("MinUserInactivity",  MinUserInactivity);
+   Store("NextWakeupTime",     NextWakeupTime);
+diff -urNad vdr-1.6.0~/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0~/config.h	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/config.h	2009-11-28 12:09:29.000000000 +0100
+@@ -293,7 +293,9 @@
+   int FontFixSize;
+   int noEPGMode;
+   int MaxVideoFileSize;
++  int MaxRecordingSize;
+   int SplitEditedFiles;
++  int HardLinkCutter;
+   int MinEventTimeout, MinUserInactivity;
+   time_t NextWakeupTime;
+   int MultiSpeedMode;
+diff -urNad vdr-1.6.0~/cutter.c vdr-1.6.0/cutter.c
+--- vdr-1.6.0~/cutter.c	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/cutter.c	2009-11-28 12:09:28.000000000 +0100
+@@ -71,6 +71,7 @@
+      Mark = fromMarks.Next(Mark);
+      int FileSize = 0;
+      int CurrentFileNumber = 0;
++     bool SkipThisSourceFile = false;
+      int LastIFrame = 0;
+      toMarks.Add(0);
+      toMarks.Save();
+@@ -88,12 +89,92 @@
+ 
+            // Read one frame:
+ 
+-           if (fromIndex->Get(Index++, &FileNumber, &FileOffset, &PictureType, &Length)) {
+-              if (FileNumber != CurrentFileNumber) {
+-                 fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
+-                 fromFile->SetReadAhead(MEGABYTE(20));
+-                 CurrentFileNumber = FileNumber;
+-                 }
++           if (!fromIndex->Get(Index++, &FileNumber, &FileOffset, &PictureType, &Length)) {
++              // Error, unless we're past last cut-in and there's no cut-out
++              if (Mark || LastMark)
++                 error = "index";
++              break;
++              }
++
++           if (FileNumber != CurrentFileNumber) {
++              fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
++              fromFile->SetReadAhead(MEGABYTE(20));
++              CurrentFileNumber = FileNumber;
++              if (SkipThisSourceFile) {
++                 // At end of fast forward: Always skip to next file
++                 toFile = toFileName->NextFile();
++                 if (!toFile) {
++                    error = "toFile 4";
++                    break;
++                    }
++                 FileSize = 0;
++                 SkipThisSourceFile = false;
++                 }                 
++              
++
++              if (Setup.HardLinkCutter && FileOffset == 0) {
++                 // We are at the beginning of a new source file.
++                 // Do we need to copy the whole file?
++
++                 // if !Mark && LastMark, then we're past the last cut-out and continue to next I-frame
++                 // if !Mark && !LastMark, then there's just a cut-in, but no cut-out
++                 // if Mark, then we're between a cut-in and a cut-out
++                 
++                 uchar MarkFileNumber;
++                 int MarkFileOffset;
++                 // Get file number of next cut mark
++                 if (!Mark && !LastMark
++                     || Mark
++                        && fromIndex->Get(Mark->position, &MarkFileNumber, &MarkFileOffset)
++                        && (MarkFileNumber != CurrentFileNumber)) {
++                    // The current source file will be copied completely.
++                    // Start new output file unless we did that already
++                    if (FileSize != 0) {
++                       toFile = toFileName->NextFile();
++                       if (!toFile) {
++                          error = "toFile 3";
++                          break;
++                          }
++                       FileSize = 0;
++                       }
++
++                    // Safety check that file has zero size
++                    struct stat buf;
++                    if (stat(toFileName->Name(), &buf) == 0) {
++                       if (buf.st_size != 0) {
++                          esyslog("cCuttingThread: File %s exists and has nonzero size", toFileName->Name());
++                          error = "nonzero file exist";
++                          break;
++                          }
++                       }
++                    else if (errno != ENOENT) {
++                       esyslog("cCuttingThread: stat failed on %s", toFileName->Name());
++                       error = "stat";
++                       break;
++                       }
++
++                    // Clean the existing 0-byte file
++                    toFileName->Close();
++                    cString ActualToFileName(ReadLink(toFileName->Name()), true);
++                    unlink(ActualToFileName);
++                    unlink(toFileName->Name());
++
++                    // Try to create a hard link
++                    if (HardLinkVideoFile(fromFileName->Name(), toFileName->Name())) {
++                       // Success. Skip all data transfer for this file
++                       SkipThisSourceFile = true;
++                       cutIn = false;
++                       toFile = NULL; // was deleted by toFileName->Close()
++                       } 
++                    else {
++                       // Fallback: Re-open the file if necessary
++                       toFile = toFileName->Open();
++                       }
++                    }
++                 } 
++              }
++
++           if (!SkipThisSourceFile) {
+               if (fromFile) {
+                  int len = ReadFrame(fromFile, buffer,  Length, sizeof(buffer));
+                  if (len < 0) {
+@@ -110,19 +191,12 @@
+                  break;
+                  }
+               }
+-           else {
+-              // Error, unless we're past the last cut-in and there's no cut-out
+-              if (Mark || LastMark)
+-                 error = "index";
+-              break;
+-              }
+-
+            // Write one frame:
+ 
+            if (PictureType == I_FRAME) { // every file shall start with an I_FRAME
+               if (LastMark) // edited version shall end before next I-frame
+                  break;
+-              if (FileSize > MEGABYTE(Setup.MaxVideoFileSize)) {
++              if (!SkipThisSourceFile && FileSize > toFileName->MaxFileSize()) {
+                  toFile = toFileName->NextFile();
+                  if (!toFile) {
+                     error = "toFile 1";
+@@ -132,12 +206,12 @@
+                  }
+               LastIFrame = 0;
+ 
+-              if (cutIn) {
++              if (!SkipThisSourceFile && cutIn) {
+                  cRemux::SetBrokenLink(buffer, Length);
+                  cutIn = false;
+                  }
+               }
+-           if (toFile->Write(buffer, Length) < 0) {
++           if (!SkipThisSourceFile && toFile->Write(buffer, Length) < 0) {
+               error = "safe_write";
+               break;
+               }
+@@ -172,7 +246,7 @@
+                     }
+                  }
+               else
+-                 LastMark = true;
++                 LastMark = true; // After last cut-out: Write on until next I-frame, then exit
+               }
+            }
+      Recordings.TouchUpdate();
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/menu.c	2009-11-28 12:10:21.000000000 +0100
+@@ -3185,7 +3185,9 @@
+   Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 1, MAXINSTANTRECTIME));
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZE));
++  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. recording size (GB)"),  &data.MaxRecordingSize, MINRECORDINGSIZE, MAXRECORDINGSIZE));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
++  Add(new cMenuEditBoolItem(tr("Setup.Recording$Hard Link Cutter"),          &data.HardLinkCutter));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show date"),                 &data.ShowRecDate));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show time"),                 &data.ShowRecTime));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show length"),               &data.ShowRecLength));
+diff -urNad vdr-1.6.0~/recorder.c vdr-1.6.0/recorder.c
+--- vdr-1.6.0~/recorder.c	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/recorder.c	2009-11-28 12:09:29.000000000 +0100
+@@ -90,7 +90,7 @@
+ bool cFileWriter::NextFile(void)
+ {
+   if (recordFile && pictureType == I_FRAME) { // every file shall start with an I_FRAME
+-     if (fileSize > MEGABYTE(Setup.MaxVideoFileSize) || RunningLowOnDiskSpace()) {
++     if (fileSize > fileName->MaxFileSize() || RunningLowOnDiskSpace()) {
+         recordFile = fileName->NextFile();
+         fileSize = 0;
+         }
+diff -urNad vdr-1.6.0~/recording.c vdr-1.6.0/recording.c
+--- vdr-1.6.0~/recording.c	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/recording.c	2009-11-28 12:09:29.000000000 +0100
+@@ -1630,6 +1630,16 @@
+   return NULL;
+ }
+ 
++int cFileName::MaxFileSize() {
++  const int smallFiles = (255 * MAXVIDEOFILESIZE - 1024 * Setup.MaxRecordingSize)
++                          / max(MAXVIDEOFILESIZE - Setup.MaxVideoFileSize, 1);
++
++  if (fileNumber <= smallFiles)
++     return MEGABYTE(Setup.MaxVideoFileSize);
++  
++  return MEGABYTE(MAXVIDEOFILESIZE);
++}
++
+ cUnbufferedFile *cFileName::NextFile(void)
+ {
+   return SetOffset(fileNumber + 1);
+diff -urNad vdr-1.6.0~/recording.h vdr-1.6.0/recording.h
+--- vdr-1.6.0~/recording.h	2009-11-28 12:09:25.000000000 +0100
++++ vdr-1.6.0/recording.h	2009-11-28 12:09:29.000000000 +0100
+@@ -213,7 +213,15 @@
+ // may be slightly higher because we stop recording only before the next
+ // 'I' frame, to have a complete Group Of Pictures):
+ #define MAXVIDEOFILESIZE 2000 // MB
+-#define MINVIDEOFILESIZE  100 // MB
++#define MINVIDEOFILESIZE    1 // MB
++
++#define MINRECORDINGSIZE      25 // GB
++#define MAXRECORDINGSIZE     500 // GB
++#define DEFAULTRECORDINGSIZE 100 // GB
++// Dynamic recording size:
++// Keep recording file size at Setup.MaxVideoFileSize for as long as possible,
++// but switch to MAXVIDEOFILESIZE early enough, so that Setup.MaxRecordingSize
++// will be reached, before recording to file 255.vdr
+ 
+ class cIndexFile {
+ private:
+@@ -256,6 +264,8 @@
+   cUnbufferedFile *Open(void);
+   void Close(void);
+   cUnbufferedFile *SetOffset(int Number, int Offset = 0);
++  int MaxFileSize();
++      // Dynamic file size for this file
+   cUnbufferedFile *NextFile(void);
+   };
+ 
+diff -urNad vdr-1.6.0~/videodir.c vdr-1.6.0/videodir.c
+--- vdr-1.6.0~/videodir.c	2009-11-28 11:57:20.000000000 +0100
++++ vdr-1.6.0/videodir.c	2009-11-28 12:09:29.000000000 +0100
+@@ -19,6 +19,9 @@
+ #include "recording.h"
+ #include "tools.h"
+ 
++
++//#define HARDLINK_TEST_ONLY
++
+ const char *VideoDirectory = VIDEODIR;
+ 
+ class cVideoDirectory {
+@@ -168,6 +171,120 @@
+   return RemoveFileOrDir(FileName, true);
+ }
+ 
++static bool StatNearestDir(const char *FileName, struct stat *Stat)
++{
++  cString Name(FileName);
++  char *p;
++  while ((p = strrchr((char*)(const char*)Name + 1, '/')) != NULL) {
++        *p = 0; // truncate at last '/'
++        if (stat(Name, Stat) == 0) {
++           isyslog("StatNearestDir: Stating %s", (const char*)Name);
++           return true;
++           }
++        }
++  return false;
++}
++
++bool HardLinkVideoFile(const char *OldName, const char *NewName)
++{
++  // Incoming name must be in base video directory:
++  if (strstr(OldName, VideoDirectory) != OldName) {
++     esyslog("ERROR: %s not in %s", OldName, VideoDirectory);
++     return false;
++     }
++  if (strstr(NewName, VideoDirectory) != NewName) {
++     esyslog("ERROR: %s not in %s", NewName, VideoDirectory);
++     return false;
++     }
++
++  const char *ActualNewName = NewName;
++  cString ActualOldName(ReadLink(OldName), true);
++
++  // Some safety checks:
++  struct stat StatOldName;
++  if (lstat(ActualOldName, &StatOldName) == 0) {
++     if (S_ISLNK(StatOldName.st_mode)) {
++        esyslog("HardLinkVideoFile: Failed to resolve symbolic link %s", (const char*)ActualOldName);
++        return false;
++        }
++     }
++  else {
++     esyslog("HardLinkVideoFile: lstat failed on %s", (const char*)ActualOldName);
++     return false;
++     }
++  isyslog("HardLinkVideoFile: %s is on %i", (const char*)ActualOldName, (int)StatOldName.st_dev);
++
++  // Find the video directory where ActualOldName is located
++
++  cVideoDirectory Dir;
++  struct stat StatDir;
++  if (!StatNearestDir(NewName, &StatDir)) {
++     esyslog("HardLinkVideoFile: stat failed on %s", NewName);
++     return false;
++     }
++  
++  isyslog("HardLinkVideoFile: %s is on %i", NewName, (int)StatDir.st_dev);
++  if (StatDir.st_dev != StatOldName.st_dev) {
++     // Not yet found.
++     
++     if (!Dir.IsDistributed()) {
++        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
++        return false;
++        }
++
++     // Search in video01 and upwards
++     bool found = false;
++     while (Dir.Next()) {
++           Dir.Store();
++           const char *TmpNewName = Dir.Adjust(NewName);
++           if (StatNearestDir(TmpNewName, &StatDir) && StatDir.st_dev == StatOldName.st_dev) {
++              isyslog("HardLinkVideoFile: %s is on %i (match)", TmpNewName, (int)StatDir.st_dev);
++              ActualNewName = TmpNewName;
++              found = true;
++              break;
++              }
++           isyslog("HardLinkVideoFile: %s is on %i", TmpNewName, (int)StatDir.st_dev);
++           }
++     if (ActualNewName == NewName) {
++        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
++        return false;
++        }
++
++     // Looking good, we have a match. Create necessary folders.
++     if (!MakeDirs(ActualNewName, false))
++        return false;
++     // There's no guarantee that the directory of ActualNewName 
++     // is on the same device as the dir that StatNearestDir found.
++     // But worst case is that the link fails.
++     }
++
++#ifdef HARDLINK_TEST_ONLY
++  // Do the hard link to *.vdr_ for testing only
++  char *name = NULL;
++  asprintf(&name, "%s_",ActualNewName);
++  link(ActualOldName, name); 
++  free(name);
++  return false;
++#endif // HARDLINK_TEST_ONLY
++  
++  // Try creating the hard link
++  if (link(ActualOldName, ActualNewName) != 0) {
++     // Failed to hard link. Maybe not allowed on file system.
++     LOG_ERROR_STR(ActualNewName);
++     isyslog("HardLinkVideoFile: failed to hard link from %s to %s", (const char*)ActualOldName, ActualNewName);
++     return false;
++     }
++  
++  if (ActualNewName != NewName) {
++     // video01 and up. Do the remaining symlink
++     if (symlink(ActualNewName, NewName) < 0) {
++        LOG_ERROR_STR(NewName);
++        return false;
++        }
++     }
++  return true;
++}
++
+ bool VideoFileSpaceAvailable(int SizeMB)
+ {
+   cVideoDirectory Dir;
+diff -urNad vdr-1.6.0~/videodir.h vdr-1.6.0/videodir.h
+--- vdr-1.6.0~/videodir.h	2009-11-28 11:57:20.000000000 +0100
++++ vdr-1.6.0/videodir.h	2009-11-28 12:09:29.000000000 +0100
+@@ -19,6 +19,7 @@
+ int CloseVideoFile(cUnbufferedFile *File);
+ bool RenameVideoFile(const char *OldName, const char *NewName);
+ bool RemoveVideoFile(const char *FileName);
++bool HardLinkVideoFile(const char *OldName, const char *NewName);
+ bool VideoFileSpaceAvailable(int SizeMB);
+ int VideoDiskSpace(int *FreeMB = NULL, int *UsedMB = NULL); // returns the used disk space in percent
+ cString PrefixVideoFileName(const char *FileName, char Prefix);
--- vdr-1.6.0.orig/debian/patches/04_newplugin.dpatch
+++ vdr-1.6.0/debian/patches/04_newplugin.dpatch
@@ -0,0 +1,49 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 04_newplugin.dpatch by Thomas Schmidt <tschmidt@debian.org>
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.7
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch for the newplugin-script, to not require a normal vdr-source-dir
+
+@DPATCH@
+--- vdr-1.5.7/newplugin
++++ vdr-1.5.7/newplugin
+@@ -24,7 +24,7 @@
+ $PLUGIN_DESCRIPTION = "Enter description for '$PLUGIN_NAME' plugin";
+ $PLUGIN_MAINENTRY = $PLUGIN_CLASS;
+ 
+-$PLUGINS_SRC = "PLUGINS/src";
++$PLUGINS_SRC = "./";
+ 
+ $README = qq
+ {This is a "plugin" for the Video Disk Recorder (VDR).
+@@ -159,7 +159,7 @@
+ 	\@-rm -rf \$(TMPDIR)/\$(ARCHIVE)
+ 	\@mkdir \$(TMPDIR)/\$(ARCHIVE)
+ 	\@cp -a * \$(TMPDIR)/\$(ARCHIVE)
+-	\@tar czf \$(PACKAGE).tgz -C \$(TMPDIR) \$(ARCHIVE)
++	\@tar czf \$(PACKAGE).tgz -C \$(TMPDIR) --exclude debian --exclude CVS --exclude .svn \$(ARCHIVE)
+ 	\@-rm -rf \$(TMPDIR)/\$(ARCHIVE)
+ 	\@echo Distribution package created as \$(PACKAGE).tgz
+ 
+@@ -311,7 +311,7 @@
+ VDRPLUGINCREATOR(cPlugin$PLUGIN_CLASS); // Don't touch this!
+ };
+ 
+-$PLUGINDIR = "$PLUGINS_SRC/$PLUGIN_NAME";
++$PLUGINDIR = "$PLUGINS_SRC/$PLUGIN_NAME-$PLUGIN_VERSION";
+ 
+ die "The directory $PLUGINS_SRC doesn't exist!\n" unless (-d "$PLUGINS_SRC");
+ die "A plugin named '$PLUGIN_NAME' already exists in $PLUGINS_SRC!\n" if (-e "$PLUGINDIR");
+@@ -332,7 +332,8 @@
+ * fill in the code skeleton in "$PLUGIN_NAME.c" to implement your plugin function
+ * add further source files if necessary
+ * adapt the "Makefile" if necessary
+-* do "make plugins" from the VDR source directory to build your plugin
++* do "make all DVBDIR=/usr VDRDIR=/usr/include/vdr LIBDIR=." from the source
++  directory to build your plugin
+ 
+ };
+ 
--- vdr-1.6.0.orig/debian/patches/patchtest
+++ vdr-1.6.0/debian/patches/patchtest
@@ -0,0 +1,199 @@
+#!/bin/sh
+
+# Define some patch levels here: foo="patch1 patch2 ..."
+#
+standard="\
+    03_cmdsubmenu \
+    04_newplugin \
+    06_default_svdrp_port_0 \
+    09_sort_options \
+    10_dd-record-option \
+    11_sortrecordings \
+    12_osdbase-maxitems \
+    14_cap-memsize \
+    15_dvbplayer \
+    16_channels.conf.terr-fix \
+    17_vdr-maintenance-1.6.0-1 \
+    18_vdr-maintenance-1.6.0-2 \
+    81_Make_config \
+    82_valgrind \
+    99_ncursesw-include"
+multipatch="$standard \
+    opt-20_liemikuutio \
+    opt-24_jumpplay \
+    opt-27_ttxtsubs \
+    opt-28_audioindexer \
+    opt-29_syncearly-audioindexer \
+    opt-30-x_analogtv \
+    opt-31-x_reelchannelscan \
+    opt-37-x_menuorg \
+    opt-38_disableDoubleEpgEntrys \
+    opt-39_noepg \
+    opt-40_iptv \
+    opt-41-x_timer-info \
+    opt-42-x_MainMenuHooks \
+    opt-43-x_recordshowfree \
+    opt-44_rotor \
+    opt-45_yaepg \
+    opt-47_sourcecaps \
+    opt-48-x_pin \
+    opt-49-x_pvrinput \
+    opt-50_graphtft \
+    opt-51_cuttime \
+    opt-52_hard_link_cutter \
+    opt-53_dvbsetup \
+    opt-54_deltimeshiftrec"
+testpatch="$standard \
+    opt-20_liemikuutio \
+    opt-24_jumpplay \
+    opt-27_ttxtsubs \
+    opt-29_syncearly \
+    opt-30-x_analogtv \
+    opt-31-x_reelchannelscan \
+    opt-37-x_menuorg \
+    opt-38_disableDoubleEpgEntrys \
+    opt-39_noepg \
+    opt-40_iptv \
+    opt-41-x_timer-info \
+    opt-42-x_MainMenuHooks \
+    opt-44_rotor \
+    opt-45_yaepg \
+    opt-48-x_pin \
+    opt-49-x_pvrinput \
+    opt-50_graphtft \
+    opt-51_cuttime \
+    opt-52_hard_link_cutter"
+mustfail_patch="XX_patchtest-patch-error"
+mustfail_compile="XX_patchtest-compile-error"
+
+# List the patch levels to be tested:
+#
+patchLevels=(\
+    "standard $standard"\
+    "multipatch $multipatch"\
+    "testpatch $testpatch"\
+    "mustfail_patch $mustfail_patch"\
+    "mustfail_compile $mustfail_compile")
+
+currentDir=`pwd`
+
+testPatchLevel ()
+{
+    patchLevelName=$1
+    tempDir=/tmp/vdr.$$.tmp
+    mkdir -p $tempDir
+    cp -r . $tempDir/vdr
+    cd $tempDir/vdr
+    # don't use dpatch:
+    touch patch-stamp
+    Failed="false"
+    shift
+    while [ "$1" ]
+    do
+        if [ $SOLVE = "true" ] ; then
+            rm -rf ../vdr.orig
+            cp -r . ../vdr.orig
+        fi
+        chmod a+x debian/patches/$1.dpatch
+        debian/patches/$1.dpatch -patch >/tmp/patchtest_patch.log 2>&1
+        if [ $? -ne 0 ] ; then
+            echo "FAILED $patchLevelName at $1"
+            Failed="true"
+            break
+        fi
+        shift
+    done
+
+    if [ $Failed = "false" ] ; then
+        if [ $QUICK = "true" ] ; then
+            echo "    OK $patchLevelName"
+        else
+            fakeroot debian/rules binary >/tmp/patchtest_build.log 2>&1
+            if [ $? -ne 0 ] ; then
+                Failed="true"
+                echo "FAILED $patchLevelName - Build Error"
+            else
+                echo "    OK $patchLevelName"
+            fi
+        fi
+    fi
+    if [ $Failed = "true" -a $SOLVE = "true" ] ; then
+        cd ..
+        exit 1
+    fi
+    cd $currentDir
+    rm -rf $tempDir
+}
+
+listPatchLevels ()
+{
+    len=${#patchLevels[*]}
+    i=0
+    while [ $i -lt $len ]
+    do
+        patchset=${patchLevels[$i]}
+        isPatchLevelName="true"
+        for patch in $patchset
+        do
+            if [ "$isPatchLevelName" = "true" ] ; then
+                echo "[$patch] contains these patches:"
+            else
+                echo -n "$patch, "
+            fi
+            isPatchLevelName="false"
+        done
+        let i++
+        echo
+        echo
+    done
+}
+
+
+testPatchLevels ()
+{
+    len=${#patchLevels[*]}
+    i=0
+    while [ $i -lt $len ]
+    do
+        patchset=${patchLevels[$i]}
+        testPatchLevel $patchset
+        let i++
+    done
+}
+
+echo
+echo "Patch-Level-Test"
+echo "----------------"
+echo
+
+QUICK='false'
+SOLVE='false'
+
+case $1 in
+    --help)
+        echo "Usage: debian/patches/patchtest [ --help | --quick | --solve ]"
+        echo
+        echo "With the --quick option no compilation will be performed."
+        echo "Using the --solve option will stop the test on failure and open"
+        echo "a new shell where you can solve any problems."
+        echo
+        exit 0
+    ;;
+    --quick)
+        QUICK="true"
+    ;;
+    --solve)
+        QUICK="true"
+        SOLVE="true"
+    ;;
+esac
+
+if [ -d debian/patches ] ; then
+    listPatchLevels
+    echo
+    testPatchLevels
+else
+    echo "Could not find debian/patches"
+fi
+
+echo
--- vdr-1.6.0.orig/debian/patches/19_dvb-api-v5.dpatch
+++ vdr-1.6.0/debian/patches/19_dvb-api-v5.dpatch
@@ -0,0 +1,21 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 19_dvb-api-v5.dpatch by Tobias Grimm <etobi@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/dvbdevice.h vdr-1.6.0/dvbdevice.h
+--- vdr-1.6.0~/dvbdevice.h	2008-02-08 14:48:31.000000000 +0100
++++ vdr-1.6.0/dvbdevice.h	2009-02-22 10:04:59.000000000 +0100
+@@ -15,8 +15,8 @@
+ #include "device.h"
+ #include "dvbspu.h"
+ 
+-#if DVB_API_VERSION != 3
+-#error VDR requires Linux DVB driver API version 3!
++#if (DVB_API_VERSION != 3) && (DVB_API_VERSION != 5)
++#error VDR requires Linux DVB driver API version 3 or 5!
+ #endif
+ 
+ #define MAXDVBDEVICES  8
--- vdr-1.6.0.orig/debian/patches/opt-29_syncearly.dpatch
+++ vdr-1.6.0/debian/patches/opt-29_syncearly.dpatch
@@ -0,0 +1,165 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-29_syncearly.dpatch by Reinhard Nissl <rnissl@gmx.de>
+##
+## vdr-freak at vdrportal.de:
+##   - extracted from extensions patch
+##     http://vdrportal.de/board/thread.php?postid=668434#post668434
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Speed up zapping channels.
+
+@DPATCH@
+diff -ruN vdr-1.5.11/config.c vdr-1.5.11-syncearly/config.c
+--- vdr-1.5.11/config.c	2007-10-06 16:28:58.000000000 +0200
++++ vdr-1.5.11-syncearly/config.c	2007-11-11 19:44:35.000000000 +0100
+@@ -261,6 +261,7 @@
+   VideoFormat = 0;
+   UpdateChannels = 5;
+   UseDolbyDigital = 1;
++  UseSyncEarlyPatch = 0;
+   ChannelInfoPos = 0;
+   ChannelInfoTime = 5;
+   OSDLeft = 54;
+@@ -436,6 +437,7 @@
+   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
+   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
+   else if (!strcasecmp(Name, "UseDolbyDigital"))     UseDolbyDigital    = atoi(Value);
++  else if (!strcasecmp(Name, "UseSyncEarlyPatch"))   UseSyncEarlyPatch  = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoTime"))     ChannelInfoTime    = atoi(Value);
+   else if (!strcasecmp(Name, "OSDLeft"))             OSDLeft            = atoi(Value);
+@@ -518,6 +520,7 @@
+   Store("VideoFormat",        VideoFormat);
+   Store("UpdateChannels",     UpdateChannels);
+   Store("UseDolbyDigital",    UseDolbyDigital);
++  Store("UseSyncEarlyPatch",  UseSyncEarlyPatch);
+   Store("ChannelInfoPos",     ChannelInfoPos);
+   Store("ChannelInfoTime",    ChannelInfoTime);
+   Store("OSDLeft",            OSDLeft);
+diff -ruN vdr-1.5.11/config.h vdr-1.5.11-syncearly/config.h
+--- vdr-1.5.11/config.h	2007-10-17 20:34:17.000000000 +0200
++++ vdr-1.5.11-syncearly/config.h	2007-11-11 19:44:21.000000000 +0100
+@@ -242,6 +242,7 @@
+   int VideoFormat;
+   int UpdateChannels;
+   int UseDolbyDigital;
++  int UseSyncEarlyPatch;
+   int ChannelInfoPos;
+   int ChannelInfoTime;
+   int OSDLeft, OSDTop, OSDWidth, OSDHeight;
+diff -ruN vdr-1.5.11/device.c vdr-1.5.11-syncearly/device.c
+--- vdr-1.5.11/device.c	2007-11-03 14:30:09.000000000 +0100
++++ vdr-1.5.11-syncearly/device.c	2007-11-11 19:44:55.000000000 +0100
+@@ -824,7 +824,7 @@
+            }
+         for (int i = 0; i < MAXSPIDS; i++)
+             SetAvailableTrack(ttSubtitle, i, Channel->Spid(i), Channel->Slang(i));
+-        if (!NeedsTransferMode)
++        if ((Setup.UseSyncEarlyPatch && (!NeedsTransferMode || GetCurrentAudioTrack() == ttNone)) || (!Setup.UseSyncEarlyPatch && !NeedsTransferMode))
+            EnsureAudioTrack(true);
+         EnsureSubtitleTrack();
+         }
+diff -ruN vdr-1.5.11/menu.c vdr-1.5.11-syncearly/menu.c
+--- vdr-1.5.11/menu.c	2007-11-03 16:02:00.000000000 +0100
++++ vdr-1.5.11-syncearly/menu.c	2007-11-11 19:46:07.000000000 +0100
+@@ -2461,6 +2461,7 @@
+      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
+      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
+      }
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Sync Early Patch"),  &data.UseSyncEarlyPatch));
+ 
+   SetCurrent(Get(current));
+   Display();
+diff -ruN vdr-1.5.11/remux.c vdr-1.5.11-syncearly/remux.c
+--- vdr-1.5.11/remux.c	2007-11-03 15:18:07.000000000 +0100
++++ vdr-1.5.11-syncearly/remux.c	2007-11-11 19:45:54.000000000 +0100
+@@ -1874,12 +1874,13 @@
+ 
+ #define RESULTBUFFERSIZE KILOBYTE(256)
+ 
+-cRemux::cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure)
++cRemux::cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure, bool SyncEarly)
+ {
+   exitOnFailure = ExitOnFailure;
+   noVideo = VPid == 0 || VPid == 1 || VPid == 0x1FFF;
+   numUPTerrors = 0;
+   synced = false;
++  syncEarly = SyncEarly;
+   skipped = 0;
+   numTracks = 0;
+   resultSkipped = 0;
+@@ -2081,12 +2082,18 @@
+                         ShutdownHandler.RequestEmergencyExit();
+                      }
+                   else if (!synced) {
+-                     if (pt == I_FRAME) {
++                     if (pt == I_FRAME || syncEarly) {
+                         if (PictureType)
+                            *PictureType = pt;
+                         resultSkipped = i; // will drop everything before this position
++                        if (!syncEarly)
+                         SetBrokenLink(data + i, l);
+                         synced = true;
++                        if (syncEarly) {
++                           if (pt == I_FRAME) // syncEarly: it's ok but there is no need to call SetBrokenLink()
++                              SetBrokenLink(data + i, l);
++                           else fprintf(stderr, "video: synced early\n");
++                           }
+                         }
+                      }
+                   else if (Count)
+@@ -2099,12 +2106,13 @@
+                l = GetPacketLength(data, resultCount, i);
+                if (l < 0)
+                   return resultData;
+-               if (noVideo) {
++               if (noVideo || !synced && syncEarly) {
+                   if (!synced) {
+-                     if (PictureType)
++                     if (PictureType && noVideo)
+                         *PictureType = I_FRAME;
+                      resultSkipped = i; // will drop everything before this position
+                      synced = true;
++                     if (!noVideo && syncEarly) fprintf(stderr, "audio: synced early\n");
+                      }
+                   else if (Count)
+                      return resultData;
+diff -ruN vdr-1.5.11/remux.h vdr-1.5.11-syncearly/remux.h
+--- vdr-1.5.11/remux.h	2007-09-02 12:19:06.000000000 +0200
++++ vdr-1.5.11-syncearly/remux.h	2007-11-11 19:47:24.000000000 +0100
+@@ -40,6 +40,7 @@
+   bool noVideo;
+   int numUPTerrors;
+   bool synced;
++  bool syncEarly;
+   int skipped;
+   cTS2PES *ts2pes[MAXTRACKS];
+   int numTracks;
+@@ -47,12 +48,14 @@
+   int resultSkipped;
+   int GetPid(const uchar *Data);
+ public:
+-  cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure = false);
++  cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure = false, bool SyncEarly = false);
+        ///< Creates a new remuxer for the given PIDs. VPid is the video PID, while
+        ///< APids, DPids and SPids are pointers to zero terminated lists of audio,
+        ///< dolby and subtitle PIDs (the pointers may be NULL if there is no such
+        ///< PID). If ExitOnFailure is true, the remuxer will initiate an "emergency
+        ///< exit" in case of problems with the data stream.
++       ///< SyncEarly causes cRemux to sync as soon as a video or audio frame is seen.
++
+   ~cRemux();
+   void SetTimeouts(int PutTimeout, int GetTimeout) { resultBuffer->SetTimeouts(PutTimeout, GetTimeout); }
+        ///< By default cRemux assumes that Put() and Get() are called from different
+diff -ruN vdr-1.5.11/transfer.c vdr-1.5.11-syncearly/transfer.c
+--- vdr-1.5.11/transfer.c	2007-01-05 11:45:28.000000000 +0100
++++ vdr-1.5.11-syncearly/transfer.c	2007-11-11 19:45:08.000000000 +0100
+@@ -19,7 +19,7 @@
+ ,cThread("transfer")
+ {
+   ringBuffer = new cRingBufferLinear(TRANSFERBUFSIZE, TS_SIZE * 2, true, "Transfer");
+-  remux = new cRemux(VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids);
++  remux = new cRemux(VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids, false, Setup.UseSyncEarlyPatch);
+ }
+ 
+ cTransfer::~cTransfer()
--- vdr-1.6.0.orig/debian/patches/opt-29_syncearly-audioindexer.dpatch
+++ vdr-1.6.0/debian/patches/opt-29_syncearly-audioindexer.dpatch
@@ -0,0 +1,172 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-29_syncearly-audioindexer.dpatch by Reinhard Nissl <rnissl@gmx.de>
+##
+## vdr-freak at vdrportal.de:
+##   - extracted from extensions patch
+##     http://vdrportal.de/board/thread.php?postid=668434#post668434
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to audioindexer patch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Speed up zapping channels.
+
+@DPATCH@
+diff -Naurp vdr-1.5.11-audioindexer/config.c vdr-1.5.11-audioindexer-syncearly/config.c
+--- vdr-1.5.11-audioindexer/config.c	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/config.c	2007-11-13 23:00:17.000000000 +0000
+@@ -305,6 +305,7 @@ cSetup::cSetup(void)
+   UpdateChannels = 5;
+   RecordDolbyDigital = 1;
+   UseDolbyDigital = 1;
++  UseSyncEarlyPatch = 0;
+   ChannelInfoPos = 0;
+   ChannelInfoTime = 5;
+   OSDLeft = 54;
+@@ -540,6 +541,7 @@ bool cSetup::Parse(const char *Name, con
+   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
+   else if (!strcasecmp(Name, "RecordDolbyDigital"))  RecordDolbyDigital = atoi(Value);
+   else if (!strcasecmp(Name, "UseDolbyDigital"))     UseDolbyDigital    = atoi(Value);
++  else if (!strcasecmp(Name, "UseSyncEarlyPatch"))   UseSyncEarlyPatch  = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
+   else if (!strcasecmp(Name, "ChannelInfoTime"))     ChannelInfoTime    = atoi(Value);
+   else if (!strcasecmp(Name, "OSDLeft"))             OSDLeft            = atoi(Value);
+@@ -643,6 +645,7 @@ bool cSetup::Save(void)
+   Store("UpdateChannels",     UpdateChannels);
+   Store("RecordDolbyDigital", RecordDolbyDigital);
+   Store("UseDolbyDigital",    UseDolbyDigital);
++  Store("UseSyncEarlyPatch",  UseSyncEarlyPatch);
+   Store("ChannelInfoPos",     ChannelInfoPos);
+   Store("ChannelInfoTime",    ChannelInfoTime);
+   Store("OSDLeft",            OSDLeft);
+diff -Naurp vdr-1.5.11-audioindexer/config.h vdr-1.5.11-audioindexer-syncearly/config.h
+--- vdr-1.5.11-audioindexer/config.h	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/config.h	2007-11-13 23:00:17.000000000 +0000
+@@ -278,6 +278,7 @@ public:
+   int UpdateChannels;
+   int RecordDolbyDigital;
+   int UseDolbyDigital;
++  int UseSyncEarlyPatch;
+   int ChannelInfoPos;
+   int ChannelInfoTime;
+   int OSDLeft, OSDTop, OSDWidth, OSDHeight;
+diff -Naurp vdr-1.5.11-audioindexer/device.c vdr-1.5.11-audioindexer-syncearly/device.c
+--- vdr-1.5.11-audioindexer/device.c	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/device.c	2007-11-13 23:00:17.000000000 +0000
+@@ -842,7 +842,7 @@ eSetChannelResult cDevice::SetChannel(co
+            }
+         for (int i = 0; i < MAXSPIDS; i++)
+             SetAvailableTrack(ttSubtitle, i, Channel->Spid(i), Channel->Slang(i));
+-        if (!NeedsTransferMode)
++        if ((Setup.UseSyncEarlyPatch && (!NeedsTransferMode || GetCurrentAudioTrack() == ttNone)) || (!Setup.UseSyncEarlyPatch && !NeedsTransferMode))
+            EnsureAudioTrack(true);
+         EnsureSubtitleTrack();
+         }
+diff -Naurp vdr-1.5.11-audioindexer/menu.c vdr-1.5.11-audioindexer-syncearly/menu.c
+--- vdr-1.5.11-audioindexer/menu.c	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/menu.c	2007-11-13 23:00:17.000000000 +0000
+@@ -2898,6 +2898,7 @@ void cMenuSetupDVB::Setup(void)
+      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
+      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
+      }
++  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Sync Early Patch"),  &data.UseSyncEarlyPatch));
+ 
+   SetCurrent(Get(current));
+   Display();
+diff -Naurp vdr-1.5.11-audioindexer/remux.c vdr-1.5.11-audioindexer-syncearly/remux.c
+--- vdr-1.5.11-audioindexer/remux.c	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/remux.c	2007-11-13 23:19:05.000000000 +0000
+@@ -1976,13 +1976,14 @@ void cAudioIndexer::ProcessFrame(void)
+ 
+ #define RESULTBUFFERSIZE KILOBYTE(256)
+ 
+-cRemux::cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure)
++cRemux::cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure, bool SyncEarly)
+ {
+   exitOnFailure = ExitOnFailure;
+   noVideo = VPid == 0 || VPid == 1 || VPid == 0x1FFF;
+   audioIndexer = (noVideo ? new cAudioIndexer : NULL);
+   numUPTerrors = 0;
+   synced = false;
++  syncEarly = SyncEarly;
+   skipped = 0;
+   numTracks = 0;
+   resultSkipped = 0;
+@@ -2196,12 +2197,18 @@ uchar *cRemux::Get(int &Count, uchar *Pi
+                         ShutdownHandler.RequestEmergencyExit();
+                      }
+                   else if (!synced) {
+-                     if (pt == I_FRAME) {
++                     if (pt == I_FRAME || syncEarly) {
+                         if (PictureType)
+                            *PictureType = pt;
+                         resultSkipped = i; // will drop everything before this position
++                        if (!syncEarly)
+                         SetBrokenLink(data + i, l);
+                         synced = true;
++                        if (syncEarly) {
++                           if (pt == I_FRAME) // syncEarly: it's ok but there is no need to call SetBrokenLink()
++                              SetBrokenLink(data + i, l);
++                           else fprintf(stderr, "video: synced early\n");
++                           }
+                         }
+                      }
+                   else if (Count)
+@@ -2214,15 +2221,16 @@ uchar *cRemux::Get(int &Count, uchar *Pi
+                l = GetPacketLength(data, resultCount, i);
+                if (l < 0)
+                   return resultData;
+-               if (noVideo) {
++               if (noVideo || !synced && syncEarly) {
+                   uchar pt = NO_PICTURE;
+                   if (audioIndexer && !Count)
+                      audioIndexer->PrepareFrame(data, resultCount, i, pt); 
+                   if (!synced) {
+-                     if (PictureType)
++                     if (PictureType && noVideo)
+                         *PictureType = pt;
+                      resultSkipped = i; // will drop everything before this position
+                      synced = true;
++                     if (!noVideo && syncEarly) fprintf(stderr, "audio: synced early\n");
+                      }
+                   else if (Count)
+                      return resultData;
+diff -Naurp vdr-1.5.11-audioindexer/remux.h vdr-1.5.11-audioindexer-syncearly/remux.h
+--- vdr-1.5.11-audioindexer/remux.h	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/remux.h	2007-11-13 23:00:17.000000000 +0000
+@@ -41,6 +41,7 @@ private:
+   bool noVideo;
+   int numUPTerrors;
+   bool synced;
++  bool syncEarly;
+   int skipped;
+   cTS2PES *ts2pes[MAXTRACKS];
+   int numTracks;
+@@ -49,12 +50,14 @@ private:
+   cAudioIndexer *audioIndexer;
+   int GetPid(const uchar *Data);
+ public:
+-  cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure = false);
++  cRemux(int VPid, const int *APids, const int *DPids, const int *SPids, bool ExitOnFailure = false, bool SyncEarly = false);
+        ///< Creates a new remuxer for the given PIDs. VPid is the video PID, while
+        ///< APids, DPids and SPids are pointers to zero terminated lists of audio,
+        ///< dolby and subtitle PIDs (the pointers may be NULL if there is no such
+        ///< PID). If ExitOnFailure is true, the remuxer will initiate an "emergency
+        ///< exit" in case of problems with the data stream.
++       ///< SyncEarly causes cRemux to sync as soon as a video or audio frame is seen.
++
+   ~cRemux();
+   void SetTimeouts(int PutTimeout, int GetTimeout) { resultBuffer->SetTimeouts(PutTimeout, GetTimeout); }
+        ///< By default cRemux assumes that Put() and Get() are called from different
+diff -Naurp vdr-1.5.11-audioindexer/transfer.c vdr-1.5.11-audioindexer-syncearly/transfer.c
+--- vdr-1.5.11-audioindexer/transfer.c	2007-11-13 23:00:17.000000000 +0000
++++ vdr-1.5.11-audioindexer-syncearly/transfer.c	2007-11-13 23:00:17.000000000 +0000
+@@ -19,7 +19,7 @@ cTransfer::cTransfer(tChannelID ChannelI
+ ,cThread("transfer")
+ {
+   ringBuffer = new cRingBufferLinear(TRANSFERBUFSIZE, TS_SIZE * 2, true, "Transfer");
+-  remux = new cRemux(VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids);
++  remux = new cRemux(VPid, APids, Setup.UseDolbyDigital ? DPids : NULL, SPids, false, Setup.UseSyncEarlyPatch);
+ }
+ 
+ cTransfer::~cTransfer()
--- vdr-1.6.0.orig/debian/patches/82_valgrind.dpatch
+++ vdr-1.6.0/debian/patches/82_valgrind.dpatch
@@ -0,0 +1,97 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 82_valgrind.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: In order to allow valgrind to find memory leaks in VDR plugins, VDR
+## DP: must not unload the plugin libraries when shutting down. This
+## DP: patch adds a new option -k / --keep-plugins (which is only available
+## DP: in the debug build) to disable plugin unloading.
+
+@DPATCH@
+diff -urNad vdr-1.3.49~/plugin.c vdr-1.3.49/plugin.c
+--- vdr-1.3.49~/plugin.c	2006-04-17 11:20:05.000000000 +0200
++++ vdr-1.3.49/plugin.c	2006-05-01 12:17:01.000000000 +0200
+@@ -144,6 +144,10 @@
+ 
+ // --- cDll ------------------------------------------------------------------
+ 
++#ifdef VDRDEBUG
++bool cDll::keepPlugins = false;
++#endif
++
+ cDll::cDll(const char *FileName, const char *Args)
+ {
+   fileName = strdup(FileName);
+@@ -155,8 +159,16 @@
+ cDll::~cDll()
+ {
+   delete plugin;
++#ifdef VDRDEBUG
++  if (!keepPlugins)
++  {
++    if (handle)
++       dlclose(handle);
++    }
++#else
+   if (handle)
+      dlclose(handle);
++#endif
+   free(args);
+   free(fileName);
+ }
+diff -urNad vdr-1.3.49~/plugin.h vdr-1.3.49/plugin.h
+--- vdr-1.3.49~/plugin.h	2006-04-17 11:18:16.000000000 +0200
++++ vdr-1.3.49/plugin.h	2006-05-01 12:16:44.000000000 +0200
+@@ -67,6 +67,9 @@
+   void *handle;
+   cPlugin *plugin;
+ public:
++  #ifdef VDRDEBUG
++  static bool keepPlugins;
++  #endif
+   cDll(const char *FileName, const char *Args);
+   virtual ~cDll();
+   bool Load(bool Log = false);
+diff -urNad vdr-1.3.49~/vdr.c vdr-1.3.49/vdr.c
+--- vdr-1.3.49~/vdr.c	2006-05-01 12:13:12.000000000 +0200
++++ vdr-1.3.49/vdr.c	2006-05-01 12:17:12.000000000 +0200
+@@ -213,6 +213,9 @@
+       { "epgfile",  required_argument, NULL, 'E' },
+       { "grab",     required_argument, NULL, 'g' },
+       { "help",     no_argument,       NULL, 'h' },
++#ifdef VDRDEBUG
++      { "keep-plugins", no_argument,   NULL, 'k' },
++#endif
+       { "lib",      required_argument, NULL, 'L' },
+       { "lirc",     optional_argument, NULL, 'l' | 0x100 },
+       { "log",      required_argument, NULL, 'l' },
+@@ -233,7 +236,7 @@
+     };
+ 
+   int c;
+-  while ((c = getopt_long(argc, argv, "a:c:dD:E:g:hl:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
++  while ((c = getopt_long(argc, argv, "a:c:dD:E:g:hkl:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
+         switch (c) {
+           case 'a': AudioCommand = optarg;
+                     break;
+@@ -256,6 +259,10 @@
+                     break;
+           case 'h': DisplayHelp = true;
+                     break;
++#ifdef VDRDEBUG
++          case 'k': cDll::keepPlugins = true;
++                    break;
++#endif
+           case 'l': {
+                       char *p = strchr(optarg, '.');
+                       if (p)
+@@ -385,6 +392,9 @@
+                "                           existing directory, without any \"..\", double '/'\n"
+                "                           or symlinks (default: none, same as -g-)\n"
+                "  -h,       --help         print this help and exit\n"
++#ifdef VDRDEBUG
++               "  -k        --keep-plugins Support valgrind by not unloading plugins\n"
++#endif
+                "  -l LEVEL, --log=LEVEL    set log level (default: 3)\n"
+                "                           0 = no logging, 1 = errors only,\n"
+                "                           2 = errors and info, 3 = errors, info and debug\n"
--- vdr-1.6.0.orig/debian/patches/03_cmdsubmenu.dpatch
+++ vdr-1.6.0/debian/patches/03_cmdsubmenu.dpatch
@@ -0,0 +1,226 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 03_cmdsubmenu.dpatch by Albu at vdrportal.de
+## http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.7-1.5.15.diff
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Adds submenus within the commands and recording commands menu.
+## DP: To create a submenu entry, prefix the name by one ore more "-".
+
+@DPATCH@
+diff -urNad vdr-1.5.15~/README.cmdsubmenu vdr-1.5.15/README.cmdsubmenu
+--- vdr-1.5.15~/README.cmdsubmenu	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.5.15/README.cmdsubmenu	2008-02-17 21:01:18.000000000 +0100
+@@ -0,0 +1,58 @@
++CmdSubmenu patch for VDR
++------------------------
++
++With this patch the commands and recording commands menus can be organised
++hierarchically. To create a submenu entry, prefix the name by one ore more "-".
++
++
++Standard:
++
++description_1 : cmd_1
++description_2 : cmd_2
++
++
++A submenu with two entries:
++
++Submenu title ... : echo "submenu"
++-description_1 : cmd_1
++-description_2 : cmd_2
++
++The dummy command in the title row is necessary.
++
++
++* History
++
++  2003-10-08: Version 0.1 - Albu at vdrportal.de
++    http://vdrportal.de/board/thread.php?threadid=6319
++
++  2003-10-09: Version 0.2 - Tobias Grimm <tg@e-tobi.net>
++    - Added Define CMD_SUBMENUS in Makefile
++
++  2004-05-28: Version 0.3 - Thomas Gnther <tom@toms-cafe.de>
++    - Fixed compilation with gcc-3.3.3
++    - Added new virtual method AddConfig in cConfig
++    - Redefining of method Add in cListBase to virtual no longer necessary
++    - Improved code in menu.c
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.3.diff
++
++  2004-12-20: Version 0.4 - Thomas Gnther <tom@toms-cafe.de>
++    - Solved conflict with jumpplay patch 0.6
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.4.diff
++
++  2006-04-22: Version 0.5 - Thomas Gnther <tom@toms-cafe.de>
++    - Added version define CMDSUBMENUVERSNUM
++    - Reformated to VDR style indentions
++    - Added description in README.cmdsubmenu
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.5-1.3.47.diff
++
++  2006-04-23: Version 0.6 - Thomas Gnther <tom@toms-cafe.de>
++    - Fixed menus with more than one level
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.6-1.3.47.diff
++
++  2006-05-15: Version 0.7 - Thomas Gnther <tom@toms-cafe.de>
++    - Fixed build with G++ 4.1 (extra qualification)
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.7-1.4.0.diff
++
++  2007-02-17:             - Tobias Grimm <tg@e-tobi.net>
++    - Adapted to vdr-1.5.15
++    http://toms-cafe.de/vdr/download/vdr-cmdsubmenu-0.7-1.5.15.diff
+diff -urNad vdr-1.5.15~/config.c vdr-1.5.15/config.c
+--- vdr-1.5.15~/config.c	2008-02-17 14:39:00.000000000 +0100
++++ vdr-1.5.15/config.c	2008-02-17 21:03:48.000000000 +0100
+@@ -28,18 +28,26 @@
+ {
+   title = command = NULL;
+   confirm = false;
++  nIndent = 0;
++  childs = NULL;
+ }
+ 
+ cCommand::~cCommand()
+ {
+   free(title);
+   free(command);
++  delete childs;
+ }
+ 
+ bool cCommand::Parse(const char *s)
+ {
+   const char *p = strchr(s, ':');
+   if (p) {
++     nIndent = 0;
++     while (*s == '-') {
++           nIndent++;
++           s++;
++           }
+      int l = p - s;
+      if (l > 0) {
+         title = MALLOC(char, l + 1);
+@@ -85,6 +93,18 @@
+   return result;
+ }
+ 
++int cCommand::getChildCount(void)
++{
++  return childs ? childs->Count() : 0;
++}
++
++void cCommand::addChild(cCommand *newChild)
++{
++  if (!childs)
++     childs = new cCommands();
++  childs->AddConfig(newChild);
++}
++
+ // --- cSVDRPhost ------------------------------------------------------------
+ 
+ cSVDRPhost::cSVDRPhost(void)
+@@ -126,6 +146,21 @@
+ cCommands Commands;
+ cCommands RecordingCommands;
+ 
++void cCommands::AddConfig(cCommand *Object)
++{
++  if (!Object)
++     return;
++  //isyslog ("Indent %d %s\n", Object->getIndent(), Object->Title());
++  for (int index = Count() - 1; index >= 0; index--) {
++      cCommand *parent = Get(index);
++      if (parent->getIndent() < Object->getIndent()) {
++         parent->addChild(Object);
++         return;
++         }
++      }
++  cConfig<cCommand>::Add(Object);
++}
++
+ // --- cSVDRPhosts -----------------------------------------------------------
+ 
+ cSVDRPhosts SVDRPhosts;
+diff -urNad vdr-1.5.15~/config.h vdr-1.5.15/config.h
+--- vdr-1.5.15~/config.h	2008-02-05 16:35:11.000000000 +0100
++++ vdr-1.5.15/config.h	2008-02-17 21:01:18.000000000 +0100
+@@ -36,6 +36,8 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++#define CMDSUBMENUVERSNUM 7
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
+@@ -48,11 +50,15 @@
+ #define MaxSkinName 16
+ #define MaxThemeName 16
+ 
++class cCommands;
++
+ class cCommand : public cListObject {
+ private:
+   char *title;
+   char *command;
+   bool confirm;
++  int nIndent;
++  cCommands *childs;
+   static char *result;
+ public:
+   cCommand(void);
+@@ -61,6 +67,12 @@
+   const char *Title(void) { return title; }
+   bool Confirm(void) { return confirm; }
+   const char *Execute(const char *Parameters = NULL);
++  int getIndent(void) { return nIndent; }
++  void setIndent(int nNewIndent) { nIndent = nNewIndent; }
++  cCommands *getChilds(void) { return childs; }
++  int getChildCount(void);
++  bool hasChilds(void) { return getChildCount() > 0; }
++  void addChild(cCommand *newChild);
+   };
+ 
+ typedef uint32_t in_addr_t; //XXX from /usr/include/netinet/in.h (apparently this is not defined on systems with glibc < 2.2)
+@@ -88,6 +100,7 @@
+ public:
+   cConfig(void) { fileName = NULL; }
+   virtual ~cConfig() { free(fileName); }
++  virtual void AddConfig(T *Object) { cList<T>::Add(Object); }
+   const char *FileName(void) { return fileName; }
+   bool Load(const char *FileName = NULL, bool AllowComments = false, bool MustExist = false)
+   {
+@@ -117,7 +130,7 @@
+                 if (!isempty(s)) {
+                    T *l = new T;
+                    if (l->Parse(s))
+-                      Add(l);
++                      AddConfig(l);
+                    else {
+                       esyslog("ERROR: error in %s, line %d", fileName, line);
+                       delete l;
+@@ -159,7 +172,10 @@
+   }
+   };
+ 
+-class cCommands : public cConfig<cCommand> {};
++class cCommands : public cConfig<cCommand> {
++public:
++  virtual void AddConfig(cCommand *Object);
++  };
+ 
+ class cSVDRPhosts : public cConfig<cSVDRPhost> {
+ public:
+diff -urNad vdr-1.5.15~/menu.c vdr-1.5.15/menu.c
+--- vdr-1.5.15~/menu.c	2008-02-16 14:53:26.000000000 +0100
++++ vdr-1.5.15/menu.c	2008-02-17 21:04:33.000000000 +0100
+@@ -1579,6 +1579,10 @@
+   cCommand *command = commands->Get(Current());
+   if (command) {
+      bool confirmed = true;
++     if (command->hasChilds()) {
++        AddSubMenu(new cMenuCommands(command->Title(), command->getChilds(), parameters));
++        return osContinue;
++        }
+      if (command->Confirm())
+         confirmed = Interface->Confirm(cString::sprintf("%s?", command->Title()));
+      if (confirmed) {
--- vdr-1.6.0.orig/debian/patches/14_cap-memsize.dpatch
+++ vdr-1.6.0/debian/patches/14_cap-memsize.dpatch
@@ -0,0 +1,20 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 14_cap-memsize.dpatch by Thomas Gnther <tom@toms-cafe.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Add OSD_CAP_MEMSIZE from newer dvb drivers to compile with Debian package
+## DP: linux-kernel-headers_2.5.999-test7-bk-17 (Sarge).
+
+@DPATCH@
+--- vdr-1.3.37/dvbosd.c
++++ vdr-1.3.37/dvbosd.c
+@@ -11,1 +11,9 @@
+ #include <linux/dvb/osd.h>
++#ifndef OSD_CAP_MEMSIZE
++typedef struct osd_cap_s {
++        int  cmd;
++#define OSD_CAP_MEMSIZE         1  /* memory size */
++        long val;
++} osd_cap_t;
++#define OSD_GET_CAPABILITY      _IOR('o', 161, osd_cap_t)
++#endif
--- vdr-1.6.0.orig/debian/patches/opt-20_liemikuutio.dpatch
+++ vdr-1.6.0/debian/patches/opt-20_liemikuutio.dpatch
@@ -0,0 +1,1517 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-20_liemikuutio.dpatch by Rolf Ahrenberg <Rolf.Ahrenberg AT sci.fi>
+## http://www.saunalahti.fi/~rahrenbe/vdr/patches/vdr-1.6.0-liemikuutio-1.27.diff.gz
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch collection - see HISTORY-liemikuutio for details.
+
+@DPATCH@
+diff -Nru vdr-1.6.0-vanilla/config.c vdr-1.6.0-liemikuutio/config.c
+--- vdr-1.6.0-vanilla/config.c	2008-02-17 15:39:00.000000000 +0200
++++ vdr-1.6.0-liemikuutio/config.c	2009-02-27 23:06:59.000000000 +0200
+@@ -289,6 +289,11 @@
+   InitialChannel = 0;
+   InitialVolume = -1;
+   EmergencyExit = 1;
++  ShowRecDate = 1;
++  ShowRecTime = 1;
++  ShowRecLength = 0;
++  ShowProgressBar = 0;
++  MenuCmdPosition = 0;
+ }
+ 
+ cSetup& cSetup::operator= (const cSetup &s)
+@@ -462,6 +467,11 @@
+   else if (!strcasecmp(Name, "InitialChannel"))      InitialChannel     = atoi(Value);
+   else if (!strcasecmp(Name, "InitialVolume"))       InitialVolume      = atoi(Value);
+   else if (!strcasecmp(Name, "EmergencyExit"))       EmergencyExit      = atoi(Value);
++  else if (!strcasecmp(Name, "ShowRecDate"))         ShowRecDate        = atoi(Value);
++  else if (!strcasecmp(Name, "ShowRecTime"))         ShowRecTime        = atoi(Value);
++  else if (!strcasecmp(Name, "ShowRecLength"))       ShowRecLength      = atoi(Value);
++  else if (!strcasecmp(Name, "ShowProgressBar"))     ShowProgressBar    = atoi(Value);
++  else if (!strcasecmp(Name, "MenuCmdPosition"))     MenuCmdPosition    = atoi(Value);
+   else
+      return false;
+   return true;
+@@ -545,6 +555,11 @@
+   Store("InitialChannel",     InitialChannel);
+   Store("InitialVolume",      InitialVolume);
+   Store("EmergencyExit",      EmergencyExit);
++  Store("ShowRecDate",        ShowRecDate);
++  Store("ShowRecTime",        ShowRecTime);
++  Store("ShowRecLength",      ShowRecLength);
++  Store("ShowProgressBar",    ShowProgressBar);
++  Store("MenuCmdPosition",    MenuCmdPosition);
+ 
+   Sort();
+ 
+diff -Nru vdr-1.6.0-vanilla/config.h vdr-1.6.0-liemikuutio/config.h
+--- vdr-1.6.0-vanilla/config.h	2008-03-23 12:26:10.000000000 +0200
++++ vdr-1.6.0-liemikuutio/config.h	2009-04-26 09:00:51.000000000 +0300
+@@ -36,6 +36,8 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++#define LIEMIKUUTIO  127
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
+@@ -267,6 +269,7 @@
+   int InitialChannel;
+   int InitialVolume;
+   int EmergencyExit;
++  int ShowRecDate, ShowRecTime, ShowRecLength, ShowProgressBar, MenuCmdPosition;
+   int __EndData__;
+   cSetup(void);
+   cSetup& operator= (const cSetup &s);
+diff -Nru vdr-1.6.0-vanilla/device.c vdr-1.6.0-liemikuutio/device.c
+--- vdr-1.6.0-vanilla/device.c	2008-03-09 12:03:34.000000000 +0200
++++ vdr-1.6.0-liemikuutio/device.c	2009-02-27 23:06:59.000000000 +0200
+@@ -1100,7 +1100,8 @@
+      int LanguagePreference = INT_MAX; // higher than the maximum possible value
+      for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
+          const tTrackId *TrackId = GetTrack(eTrackType(i));
+-         if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference))
++         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
++             ((i == ttSubtitleFirst + 8) && !(*TrackId->language) && (LanguagePreference == INT_MAX))))
+             PreferredTrack = eTrackType(i);
+          }
+      // Make sure we're set to an available subtitle track:
+diff -Nru vdr-1.6.0-vanilla/HISTORY-liemikuutio vdr-1.6.0-liemikuutio/HISTORY-liemikuutio
+--- vdr-1.6.0-vanilla/HISTORY-liemikuutio	1970-01-01 02:00:00.000000000 +0200
++++ vdr-1.6.0-liemikuutio/HISTORY-liemikuutio	2009-04-26 09:05:26.000000000 +0300
+@@ -0,0 +1,132 @@
++-----------------------------------
++Liemikuutio for Video Disc Recorder
++
++Maintainer: Rolf Ahrenberg
++-----------------------------------
++
++2006-01-08: Version 1.0
++
++- Based on enAIO with these original patches:
++  Simple recordings sorting by Walter@VDRPortal
++  Alternate rename recordings by Ralf Mller
++  Menu selection by Peter Dittmann
++  Recording length by Tobias Faust
++
++2006-01-15: Version 1.1
++
++- Removed patches already found in vdr-1.3.39.
++
++2006-01-25: Version 1.2
++
++- Added "Main menu command position" feature.
++
++2006-02-05: Version 1.3
++
++- Improved menu selection response.
++
++2006-04-18: Version 1.4
++
++- Added Estonian translation (Thanks to Arthur Konovalov).
++
++2006-04-30: Version 1.5
++
++- Added progress bar view into "What's on now?" menu.
++
++2006-06-06: Version 1.6
++
++- Added French translation (Thanks to ECLiPSE).
++
++2006-06-14: Version 1.7
++
++- Fixed RENR crash.
++
++2006-07-14: Version 1.8
++
++- Fixed RENR/OSD bug.
++
++2006-08-27: Version 1.9
++
++- Some modifications to the recording length and rename recordings
++  patches (Thanks to Firefly).
++- Added k1_k3_jumps_20s patch by Petri Hintukainen.
++
++2006-08-29: Version 1.10
++
++- The cRecording:Title() method now defaults to original formatting.
++
++2006-09-04: Version 1.11
++
++- Removed unused variable from cRecording::Title() method (Thanks to
++  C.Y.M.).
++- Some modifications to the rename recordings patch (Thanks to Firefly).
++
++2006-09-13: Version 1.12
++
++- More modifications to the rename recordings patch (Thanks to Firefly).
++
++2006-10-01: Version 1.13
++
++- Removed unnecessary syslog printing (Thanks to Firefly).
++
++2007-08-14: Version 1.14
++
++- Updated for vdr-1.5.7.
++
++2007-10-16: Version 1.15
++
++- Added recmenu play patch (Thanks to Ville Skytt).
++- Updated French translation (Thanks to ECLiPSE).
++
++2007-11-04: Version 1.16
++
++- Updated for vdr-1.5.11.
++
++2007-12-08: Version 1.17
++
++- Added binary skip patch.
++- Removed k1_k3_jumps_20s patch.
++
++2008-02-17: Version 1.18
++
++- Updated for vdr-1.5.15.
++
++2008-03-02: Version 1.19
++
++- Modified binary skip to use kPrev and kNext keys and the skip is now
++  always shortened after a direction change (Thanks to Timo Eskola).
++- Readded k1_k3_jumps_20s patch.
++
++2008-04-04: Version 1.20
++
++- Added bitrate information into rename menu.
++- Readded the path editing support of rename recordings patch (Thanks
++  to Firefly).
++
++2008-05-08: Version 1.21
++
++- Fixed rename recordings (Thanks to Firefly).
++- Added a DVB subtitles hack for old recordings (Thanks to Anssi Hannula).
++
++2009-01-08: Version 1.22
++
++- Updated for vdr-1.7.3.
++
++2009-01-25: Version 1.23
++
++- Updated for vdr-1.7.4.
++
++2009-02-27: Version 1.24
++
++- Fixed compilation under gcc-4.4.
++
++2009-04-05: Version 1.25
++
++- Fixed the length detection of recordings (Thanks to Thomas Gnther).
++
++2009-04-17: Version 1.26
++
++- Fixed the length detection of audio recordings (Thanks to Thomas Gnther).
++
++2009-04-26: Version 1.27
++
++- Fixed the length detection of empty recordings (Thanks to Thomas Gnther).
+diff -Nru vdr-1.6.0-vanilla/menu.c vdr-1.6.0-liemikuutio/menu.c
+--- vdr-1.6.0-vanilla/menu.c	2008-03-16 13:15:28.000000000 +0200
++++ vdr-1.6.0-liemikuutio/menu.c	2009-04-05 13:04:51.000000000 +0300
+@@ -13,6 +13,7 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
++#include <math.h>
+ #include "channels.h"
+ #include "config.h"
+ #include "cutter.h"
+@@ -705,7 +706,22 @@
+      Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
+      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
+      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+-     Add(new cMenuEditStrItem( tr("File"),          data.file, sizeof(data.file)));
++
++     char* p = strrchr(data.file, '~');
++     if (p) {
++        p++;
++        Utf8Strn0Cpy(name, p, sizeof(name));
++        Utf8Strn0Cpy(path, data.file, sizeof(path));
++        p = strrchr(path, '~');
++        if (p)
++           p[0] = 0;
++        }
++     else {
++        Utf8Strn0Cpy(name, data.file, sizeof(name));
++        Utf8Strn0Cpy(path, "", sizeof(path));
++        }
++     Add(new cMenuEditStrItem( tr("File"),          name, sizeof(name), tr(FileNameChars)));
++     Add(new cMenuEditRecPathItem(tr("Path"),       path, sizeof(path)));
+      SetFirstDayItem();
+      }
+   Timers.IncBeingEdited();
+@@ -745,6 +761,10 @@
+                           Skins.Message(mtError, tr("*** Invalid Channel ***"));
+                           break;
+                           }
++                       if(strlen(path))
++                          snprintf(data.file, sizeof(data.file), "%s~%s", path, name);
++                       else
++                          snprintf(data.file, sizeof(data.file), "%s", name);
+                        if (!*data.file)
+                           strcpy(data.file, data.Channel()->ShortName(true));
+                        if (timer) {
+@@ -1048,7 +1068,8 @@
+   const cChannel *channel;
+   bool withDate;
+   int timerMatch;
+-  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false);
++  bool withBar;
++  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false, bool WithBar = false);
+   static void SetSortMode(eScheduleSortMode SortMode) { sortMode = SortMode; }
+   static void IncSortMode(void) { sortMode = eScheduleSortMode((sortMode == ssmAllAll) ? ssmAllThis : sortMode + 1); }
+   static eScheduleSortMode SortMode(void) { return sortMode; }
+@@ -1058,12 +1079,13 @@
+ 
+ cMenuScheduleItem::eScheduleSortMode cMenuScheduleItem::sortMode = ssmAllThis;
+ 
+-cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate)
++cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate, bool WithBar)
+ {
+   event = Event;
+   channel = Channel;
+   withDate = WithDate;
+   timerMatch = tmNone;
++  withBar = WithBar;
+   Update(true);
+ }
+ 
+@@ -1080,6 +1102,17 @@
+ 
+ static const char *TimerMatchChars = " tT";
+ 
++static const char * const ProgressBar[7] =
++{
++  "[      ]",
++  "[|     ]",
++  "[||    ]",
++  "[|||   ]",
++  "[||||  ]",
++  "[||||| ]",
++  "[||||||]"
++};
++
+ bool cMenuScheduleItem::Update(bool Force)
+ {
+   bool result = false;
+@@ -1095,7 +1128,14 @@
+      if (channel && withDate)
+         buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+      else if (channel)
+-        buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
++        if (Setup.ShowProgressBar && withBar) {
++           int progress = (int)roundf( (float)(time(NULL) - event->StartTime()) / (float)(event->Duration()) * 6.0 );
++           if (progress < 0) progress = 0;
++           else if (progress > 6) progress = 6;
++           buffer = cString::sprintf("%d\t%.*s\t%s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), ProgressBar[progress], t, v, r, event->Title());
++           }
++        else
++           buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
+      else
+         buffer = cString::sprintf("%.*s\t%s\t%c%c%c\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+      SetText(buffer);
+@@ -1129,7 +1169,7 @@
+ const cEvent *cMenuWhatsOn::scheduleEvent = NULL;
+ 
+ cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr)
+-:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, 7, 6, 4)
++:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, 7, 6, 4, 4)
+ {
+   now = Now;
+   helpKeys = -1;
+@@ -1141,7 +1181,7 @@
+          if (Schedule) {
+             const cEvent *Event = Now ? Schedule->GetPresentEvent() : Schedule->GetFollowingEvent();
+             if (Event)
+-               Add(new cMenuScheduleItem(Event, Channel), Channel->Number() == CurrentChannelNr);
++               Add(new cMenuScheduleItem(Event, Channel, false, Now), Channel->Number() == CurrentChannelNr);
+             }
+          }
+       }
+@@ -1883,7 +1923,7 @@
+   fileName = strdup(Recording->FileName());
+   name = NULL;
+   totalEntries = newEntries = 0;
+-  SetText(Recording->Title('\t', true, Level));
++  SetText(Recording->Title('\t', true, Level, false));
+   if (*Text() == '\t')
+      name = strdup(Text() + 2); // 'Text() + 2' to skip the two '\t'
+ }
+@@ -1899,13 +1939,153 @@
+   totalEntries++;
+   if (New)
+      newEntries++;
+-  SetText(cString::sprintf("%d\t%d\t%s", totalEntries, newEntries, name));
++  switch (Setup.ShowRecTime + Setup.ShowRecDate + Setup.ShowRecLength) {
++     case 0:
++          SetText(cString::sprintf("%s", name));
++          break;
++     case 1:
++          SetText(cString::sprintf("%d\t%s", totalEntries, name));
++          break;
++     case 2:
++     default:
++          SetText(cString::sprintf("%d\t%d\t%s", totalEntries, newEntries, name));
++          break;
++     case 3:
++          SetText(cString::sprintf("%d\t%d\t\t%s", totalEntries, newEntries, name));
++          break;
++     }
++}
++
++// --- cMenuRenameRecording --------------------------------------------------
++
++class cMenuRenameRecording : public cOsdMenu {
++private:
++  int lifetime;
++  int priority;
++  char name[MaxFileName];
++  char path[MaxFileName];
++  cOsdItem *marksItem, *resumeItem;
++  bool isResume, isMarks;
++  cRecording *recording;
++public:
++  cMenuRenameRecording(cRecording *Recording);
++  virtual eOSState ProcessKey(eKeys Key);
++};
++
++cMenuRenameRecording::cMenuRenameRecording(cRecording *Recording)
++:cOsdMenu(tr("Rename recording"), 12)
++{
++  cMarks marks;
++
++  recording = Recording;
++  priority = recording->priority;
++  lifetime = recording->lifetime;
++
++  const char* pname = strrchr(recording->Name(), '~');
++  if (pname) {
++     Utf8Strn0Cpy(name, pname + 1, sizeof(name));
++     Utf8Strn0Cpy(path, recording->Name(), sizeof(path));
++     char *ppath = strrchr(path, '~');
++     if (ppath)
++        ppath[0] = 0;
++     }
++  else {
++     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
++     Utf8Strn0Cpy(path, "", sizeof(path));
++     }
++  Add(new cMenuEditStrItem(tr("Name"),      name,     sizeof(name), tr(FileNameChars)));
++  Add(new cMenuEditRecPathItem(tr("Path"),  path,     sizeof(path)                   ));
++  Add(new cMenuEditIntItem(tr("Priority"), &priority, 0,            MAXPRIORITY      ));
++  Add(new cMenuEditIntItem(tr("Lifetime"), &lifetime, 0,            MAXLIFETIME      ));
++
++  Add(new cOsdItem("", osUnknown, false));
++
++  Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->start)), osUnknown, false));
++
++  cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
++  if (channel)
++     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
++
++  int recLen = cIndexFile::Length(recording->FileName());
++  if (recLen >= 0)
++     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Length"), *IndexToHMSF(recLen)), osUnknown, false));
++  else
++     recLen = 0;
++  recLen /= FRAMESPERSEC;
++
++  int dirSize = DirSizeMB(recording->FileName());
++  cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
++  Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
++
++  Add(new cOsdItem("", osUnknown, false));
++
++  isMarks = marks.Load(recording->FileName()) && marks.Count();
++  marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
++  Add(marksItem);
++
++  cResumeFile ResumeFile(recording->FileName());
++  isResume = (ResumeFile.Read() != -1);
++  resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
++  Add(resumeItem);
++}
++
++eOSState cMenuRenameRecording::ProcessKey(eKeys Key)
++{
++  eOSState state = cOsdMenu::ProcessKey(Key);
++
++  if (state == osUnknown) {
++     if (Key == kOk) {
++        char buffer[MaxFileName];
++        if (Utf8StrLen(path))
++           snprintf(buffer, sizeof(buffer), "%s~%s", path, name);
++        else
++           snprintf(buffer, sizeof(buffer), "%s", name);
++        if (recording->Rename(buffer, &priority, &lifetime)) {
++           Recordings.ChangeState();
++           Recordings.TouchUpdate();
++           return osRecordings;
++           }
++        else
++           Skins.Message(mtError, tr("Error while accessing recording!"));
++        }
++     return osContinue;
++     }
++  else if (state == osUser1) {
++     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
++        cMarks marks;
++        marks.Load(recording->FileName());
++        cMark *mark = marks.First();
++        while (mark) {
++          cMark *nextmark = marks.Next(mark);
++          marks.Del(mark);
++          mark = nextmark;
++          }
++        marks.Save();
++        isMarks = false;
++        marksItem->SetSelectable(isMarks);
++        SetCurrent(First());
++        Display();
++        }
++     return osContinue;
++     }
++  else if (state == osUser2) {
++     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
++        cResumeFile ResumeFile(recording->FileName());
++        ResumeFile.Delete();
++        isResume = false;
++        resumeItem->SetSelectable(isResume);
++        SetCurrent(First());
++        Display();
++        }
++     return osContinue;
++     }
++  return state;
+ }
+ 
+ // --- cMenuRecordings -------------------------------------------------------
+ 
+ cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
+-:cOsdMenu(Base ? Base : tr("Recordings"), 9, 7)
++:cOsdMenu(Base ? Base : tr("Recordings"), 9, 7, 7)
+ {
+   base = Base ? strdup(Base) : NULL;
+   level = Setup.RecordingDirs ? Level : -1;
+@@ -2136,6 +2316,19 @@
+   return osContinue;
+ }
+ 
++eOSState cMenuRecordings::Rename(void)
++{
++  if (HasSubMenu() || Count() == 0)
++     return osContinue;
++  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
++  if (ri && !ri->IsDirectory()) {
++     cRecording *recording = GetRecording(ri);
++     if (recording)
++        return AddSubMenu(new cMenuRenameRecording(recording));
++     }
++  return osContinue;
++}
++
+ eOSState cMenuRecordings::ProcessKey(eKeys Key)
+ {
+   bool HadSubMenu = HasSubMenu();
+@@ -2150,7 +2343,12 @@
+        case kYellow: return Delete();
+        case kInfo:
+        case kBlue:   return Info();
+-       case k1...k9: return Commands(Key);
++       case k0:      DirOrderState = !DirOrderState;
++                     Set(true);
++                     return osContinue;
++       case k8:      return Rename();
++       case k9:
++       case k1...k7: return Commands(Key);
+        case kNone:   if (Recordings.StateChanged(recordingsState))
+                         Set(true);
+                      break;
+@@ -2276,6 +2474,7 @@
+   Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
+   Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu key closes"),        &data.MenuKeyCloses));
+   Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
++  Add(new cMenuEditBoolItem(tr("Setup.OSD$Main menu command position"), &data.MenuCmdPosition, tr("bottom"), tr("top")));
+   SetCurrent(Get(current));
+   Display();
+ }
+@@ -2380,6 +2579,7 @@
+   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
+   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG bugfix level"),          &data.EPGBugfixLevel, 0, MAXEPGBUGFIXLEVEL));
+   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG linger time (min)"),     &data.EPGLinger, 0));
++  Add(new cMenuEditBoolItem(tr("Setup.EPG$Show progress bar"),         &data.ShowProgressBar));
+   Add(new cMenuEditBoolItem(tr("Setup.EPG$Set system time"),           &data.SetSystemTime));
+   if (data.SetSystemTime)
+      Add(new cMenuEditTranItem(tr("Setup.EPG$Use time from transponder"), &data.TimeTransponder, &data.TimeSource));
+@@ -2758,6 +2958,9 @@
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 1, MAXINSTANTRECTIME));
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZE));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
++  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show date"),                 &data.ShowRecDate));
++  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show time"),                 &data.ShowRecTime));
++  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show length"),               &data.ShowRecLength));
+ }
+ 
+ // --- cMenuSetupReplay ------------------------------------------------------
+@@ -3045,6 +3248,7 @@
+      // Replay control:
+      if (replaying && !stopReplayItem)
+         // TRANSLATORS: note the leading blank!
++        if (Setup.MenuCmdPosition) Ins(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay)); else
+         Add(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay));
+      else if (stopReplayItem && !replaying) {
+         Del(stopReplayItem->Index());
+@@ -3059,6 +3263,7 @@
+   bool CutterActive = cCutter::Active();
+   if (CutterActive && !cancelEditingItem) {
+      // TRANSLATORS: note the leading blank!
++     if (Setup.MenuCmdPosition) Ins(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit)); else
+      Add(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit));
+      result = true;
+      }
+@@ -3079,6 +3284,7 @@
+      while ((s = cRecordControls::GetInstantId(s)) != NULL) {
+            cOsdItem *item = new cOsdItem(osStopRecord);
+            item->SetText(cString::sprintf("%s%s", tr(STOP_RECORDING), s));
++           if (Setup.MenuCmdPosition) Ins(item); else
+            Add(item);
+            if (!stopRecordingItem)
+               stopRecordingItem = item;
+@@ -4059,6 +4265,10 @@
+ 
+ // --- cReplayControl --------------------------------------------------------
+ 
++#define REPLAYCONTROLSKIPLIMIT   9    // s
++#define REPLAYCONTROLSKIPSECONDS 90   // s
++#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
++
+ cReplayControl *cReplayControl::currentReplayControl = NULL;
+ char *cReplayControl::fileName = NULL;
+ char *cReplayControl::title = NULL;
+@@ -4072,6 +4282,9 @@
+   lastCurrent = lastTotal = -1;
+   lastPlay = lastForward = false;
+   lastSpeed = -2; // an invalid value
++  lastSkipKey = kNone;
++  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
++  lastSkipTimeout.Set(0);
+   timeoutShow = 0;
+   timeSearchActive = false;
+   marks.Load(fileName);
+@@ -4435,6 +4648,32 @@
+     case kGreen:   SkipSeconds(-60); break;
+     case kYellow|k_Repeat:
+     case kYellow:  SkipSeconds( 60); break;
++    case k1|k_Repeat:
++    case k1:       SkipSeconds(-20); break;
++    case k3|k_Repeat:
++    case k3:       SkipSeconds( 20); break;
++    case kPrev|k_Repeat:
++    case kPrev:    if (lastSkipTimeout.TimedOut()) {
++                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
++                      lastSkipKey = kPrev;
++                   }
++                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
++                      lastSkipSeconds /= 2;
++                      lastSkipKey = kNone;
++                   }
++                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
++                   SkipSeconds(-lastSkipSeconds); break;
++    case kNext|k_Repeat:
++    case kNext:    if (lastSkipTimeout.TimedOut()) {
++                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
++                      lastSkipKey = kNext;	
++                   }
++                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
++                      lastSkipSeconds /= 2;
++                      lastSkipKey = kNone;
++                   }
++                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
++                   SkipSeconds(lastSkipSeconds); break;
+     case kStop:
+     case kBlue:    Hide();
+                    Stop();
+@@ -4444,12 +4683,8 @@
+       switch (Key) {
+         // Editing:
+         case kMarkToggle:      MarkToggle(); break;
+-        case kPrev|k_Repeat:
+-        case kPrev:
+         case kMarkJumpBack|k_Repeat:
+         case kMarkJumpBack:    MarkJump(false); break;
+-        case kNext|k_Repeat:
+-        case kNext:
+         case kMarkJumpForward|k_Repeat:
+         case kMarkJumpForward: MarkJump(true); break;
+         case kMarkMoveBack|k_Repeat:
+diff -Nru vdr-1.6.0-vanilla/menu.h vdr-1.6.0-liemikuutio/menu.h
+--- vdr-1.6.0-vanilla/menu.h	2008-02-10 18:01:53.000000000 +0200
++++ vdr-1.6.0-liemikuutio/menu.h	2009-02-27 23:06:59.000000000 +0200
+@@ -35,6 +35,8 @@
+ private:
+   cTimer *timer;
+   cTimer data;
++  char name[MaxFileName];
++  char path[MaxFileName];
+   int channel;
+   bool addIfConfirmed;
+   cMenuEditDateItem *firstday;
+@@ -163,6 +165,7 @@
+   eOSState Delete(void);
+   eOSState Info(void);
+   eOSState Commands(eKeys Key = kNone);
++  eOSState Rename(void);
+ protected:
+   cRecording *GetRecording(cMenuRecordingItem *Item);
+ public:
+@@ -217,6 +220,9 @@
+   int lastCurrent, lastTotal;
+   bool lastPlay, lastForward;
+   int lastSpeed;
++  int lastSkipSeconds;
++  eKeys lastSkipKey;
++  cTimeMs lastSkipTimeout;
+   time_t timeoutShow;
+   bool timeSearchActive, timeSearchHide;
+   int timeSearchTime, timeSearchPos;
+diff -Nru vdr-1.6.0-vanilla/menuitems.c vdr-1.6.0-liemikuutio/menuitems.c
+--- vdr-1.6.0-vanilla/menuitems.c	2008-02-10 18:03:30.000000000 +0200
++++ vdr-1.6.0-liemikuutio/menuitems.c	2009-02-27 23:06:59.000000000 +0200
+@@ -619,6 +619,168 @@
+   return osContinue;
+ }
+ 
++// --- cMenuEditRecPathItem --------------------------------------------------
++
++cMenuEditRecPathItem::cMenuEditRecPathItem(const char* Name, char* Path,
++   int Length): cMenuEditStrItem(Name, Path, Length, tr(FileNameChars))
++{
++  SetBase(Path);
++}
++
++cMenuEditRecPathItem::~cMenuEditRecPathItem()
++{
++}
++
++void cMenuEditRecPathItem::SetBase(const char* Path)
++{
++  if (!Path)
++      base[0] = 0;
++  Utf8Strn0Cpy(base, Path, sizeof(base));
++  char* p = strrchr(base, '~');
++  if (p)
++     p[0] = 0;
++  else
++     base[0] = 0;
++}
++
++void cMenuEditRecPathItem::FindNextLevel()
++{
++  char item[MaxFileName];
++
++  for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording))
++  {
++     char* p;
++     Utf8Strn0Cpy(item, recording->Name(), sizeof(item));
++     stripspace(value);
++     lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++     if (!lengthUtf8)
++        p = strchr(item, '~');
++     else {
++        if (strstr(item, value) != item)
++           continue;
++        if (item[strlen(value)] != '~')
++           continue;
++        p = strchr(item + strlen(value) + 1, '~');
++        }
++     if (!p)
++        continue;
++     p[0] = 0;
++     Utf8Strn0Cpy(base, value, length);
++     Utf8Strn0Cpy(value, item, length);
++     lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++     return;
++     }
++}
++
++void cMenuEditRecPathItem::Find(bool Next)
++{
++  char item[MaxFileName];
++  char lastItem[MaxFileName] = "";
++
++  for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording))
++  {
++     const char* recName = recording->Name();
++     if (Utf8StrLen(base) && strstr(recName, base) != recName)
++        continue;
++     if (strlen(base) && recName[strlen(base)] != '~')
++        continue;
++     Utf8Strn0Cpy(item, recName, sizeof(item));
++     char* p = strchr(item + strlen(base) + 1, '~');
++     if (!p)
++        continue;
++     p[0] = 0;
++     if (!Next && (strcmp(item, value) == 0)) {
++        if (strlen(lastItem))
++           Utf8Strn0Cpy(value, lastItem, length);
++        lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++        return;
++        }
++     if (strcmp(lastItem, item) != 0) {
++        if(Next && Utf8StrLen(lastItem) && strcmp(lastItem, value) == 0) {
++           Utf8Strn0Cpy(value, item, length);
++           lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++           return;
++           }
++        Utf8Strn0Cpy(lastItem, item, sizeof(lastItem));
++        }
++     }
++}
++
++void cMenuEditRecPathItem::SetHelpKeys(void)
++{
++  cSkinDisplay::Current()->SetButtons(tr("Rename$Up"), tr("Rename$Down"), tr("Rename$Previous"), tr("Rename$Next"));
++}
++
++eOSState cMenuEditRecPathItem::ProcessKey(eKeys Key)
++{
++  switch (Key) {
++    case kLeft:
++    case kRed:    // one level up
++                  if (!InEditMode())
++                     return cMenuEditItem::ProcessKey(Key);
++                  Utf8Strn0Cpy(value, base, lengthUtf8);
++                  lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++                  SetBase(base);
++                  pos = Utf8StrLen(base);
++                  if (pos)
++                     pos++;
++                  if (!lengthUtf8) {
++                     Utf8Strn0Cpy(value, " ", length);
++                     lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++                     }
++                  break;
++    case kRight:
++    case kGreen:  // one level down
++                  if (InEditMode())
++                     FindNextLevel();
++                  else
++                     EnterEditMode();
++                  if (!lengthUtf8) {
++                     Utf8Strn0Cpy(value, " ", length);
++                     lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++                     }
++                  pos = Utf8StrLen(base);
++                  if (pos)
++                     pos++;
++                  SetHelpKeys();
++                  break;
++    case kUp|k_Repeat:
++    case kUp:
++    case kYellow|k_Repeat:
++    case kYellow: // previous directory in list
++                  if (!InEditMode())
++                     return cMenuEditItem::ProcessKey(Key);
++                  Find(false);
++                  pos = Utf8StrLen(base);
++                  if (pos)
++                     pos++;
++                  break;
++    case kDown|k_Repeat:
++    case kDown:
++    case kBlue|k_Repeat:
++    case kBlue:   // next directory in list
++                  if (!InEditMode())
++                     return cMenuEditItem::ProcessKey(Key);
++                  Find(true);
++                  pos = Utf8StrLen(base);
++                  if (pos)
++                     pos++;
++                  break;
++    case kOk:     // done
++                  if (!InEditMode())
++                     return cMenuEditItem::ProcessKey(Key);
++                  stripspace(value);
++                  lengthUtf8 = Utf8ToArray(value, valueUtf8, length);
++                  cSkinDisplay::Current()->SetButtons(NULL);
++                  LeaveEditMode(Key == kOk);
++                  break;
++    default:
++                  return cMenuEditItem::ProcessKey(Key);
++    }
++  Set();
++  return osContinue;
++}
++
+ // --- cMenuEditStraItem -----------------------------------------------------
+ 
+ cMenuEditStraItem::cMenuEditStraItem(const char *Name, int *Value, int NumStrings, const char * const *Strings)
+diff -Nru vdr-1.6.0-vanilla/menuitems.h vdr-1.6.0-liemikuutio/menuitems.h
+--- vdr-1.6.0-vanilla/menuitems.h	2008-02-16 18:09:58.000000000 +0200
++++ vdr-1.6.0-liemikuutio/menuitems.h	2009-02-27 23:06:59.000000000 +0200
+@@ -78,26 +78,27 @@
+ 
+ class cMenuEditStrItem : public cMenuEditItem {
+ private:
+-  char *value;
+-  int length;
+-  const char *allowed;
+-  int pos, offset;
++  int offset;
+   bool insert, newchar, uppercase;
+-  int lengthUtf8;
+-  uint *valueUtf8;
+   uint *allowedUtf8;
+   uint *charMapUtf8;
+   uint *currentCharUtf8;
+   eKeys lastKey;
+   cTimeMs autoAdvanceTimeout;
+-  void SetHelpKeys(void);
+   uint *IsAllowed(uint c);
+   void AdvancePos(void);
+-  virtual void Set(void);
+   uint Inc(uint c, bool Up);
+   void Insert(void);
+   void Delete(void);
+ protected:
++  char *value;
++  int length;
++  uint *valueUtf8;
++  int lengthUtf8;
++  const char *allowed;
++  int pos;
++  void SetHelpKeys(void);
++  virtual void Set(void);
+   void EnterEditMode(void);
+   void LeaveEditMode(bool SaveValue = false);
+   bool InEditMode(void) { return valueUtf8 != NULL; }
+@@ -107,6 +108,19 @@
+   virtual eOSState ProcessKey(eKeys Key);
+   };
+ 
++class cMenuEditRecPathItem : public cMenuEditStrItem {
++protected:
++  char base[MaxFileName];
++  virtual void SetHelpKeys(void);
++  void SetBase(const char* Path);
++  void FindNextLevel();
++  void Find(bool Next);
++public:
++  cMenuEditRecPathItem(const char* Name, char* Path, int Length);
++  ~cMenuEditRecPathItem();
++  virtual eOSState ProcessKey(eKeys Key);
++  };
++
+ class cMenuEditStraItem : public cMenuEditIntItem {
+ private:
+   const char * const *strings;
+diff -Nru vdr-1.6.0-vanilla/osdbase.c vdr-1.6.0-liemikuutio/osdbase.c
+--- vdr-1.6.0-vanilla/osdbase.c	2008-02-17 13:33:04.000000000 +0200
++++ vdr-1.6.0-liemikuutio/osdbase.c	2009-02-27 23:06:59.000000000 +0200
+@@ -77,6 +77,7 @@
+ {
+   isMenu = true;
+   digit = 0;
++  key_nr = -1;
+   hasHotkeys = false;
+   title = NULL;
+   SetTitle(Title);
+@@ -119,7 +120,7 @@
+         digit = -1; // prevents automatic hotkeys - input already has them
+      if (digit >= 0) {
+         digit++;
+-        buffer = cString::sprintf(" %c %s", (digit < 10) ? '0' + digit : ' ' , s);
++        buffer = cString::sprintf(" %2d%s %s", digit, (digit > 9) ? "" : " ", s);
+         s = buffer;
+         }
+      }
+@@ -448,20 +449,62 @@
+      }
+ }
+ 
++#define MENUKEY_TIMEOUT 1500
++
+ eOSState cOsdMenu::HotKey(eKeys Key)
+ {
+-  for (cOsdItem *item = First(); item; item = Next(item)) {
++  bool match = false;
++  bool highlight = false;
++  int  item_nr;
++  int  i;
++
++  if (Key == kNone) {
++     if (lastActivity.TimedOut())
++        Key = kOk;
++     else
++        return osContinue;
++     }
++  else {
++     lastActivity.Set(MENUKEY_TIMEOUT);
++     }
++  for (cOsdItem *item = Last(); item; item = Prev(item)) {
+       const char *s = item->Text();
+-      if (s && (s = skipspace(s)) != NULL) {
+-         if (*s == Key - k1 + '1') {
++      i = 0;
++      item_nr = 0;
++      if (s && (s = skipspace(s)) != '\0' && '0' <= s[i] && s[i] <= '9') {
++         do {
++            item_nr = item_nr * 10 + (s[i] - '0');
++            }
++         while ( !((s[++i] == '\t')||(s[i] == ' ')) && (s[i] != '\0') && ('0' <= s[i]) && (s[i] <= '9'));
++         if ((Key == kOk) && (item_nr == key_nr)) {
+             current = item->Index();
+             RefreshCurrent();
+             Display();
+             cRemote::Put(kOk, true);
++            key_nr = -1;
+             break;
+             }
++         else if (Key != kOk) {
++            if (!highlight && (item_nr == (Key - k0))) {
++               highlight = true;
++               current = item->Index();
++               }
++            if (!match && (key_nr == -1) && ((item_nr / 10) == (Key - k0))) {
++               match = true;
++               key_nr = (Key - k0);
++               }
++            else if (((key_nr == -1) && (item_nr == (Key - k0))) || (!match && (key_nr >= 0) && (item_nr == (10 * key_nr + Key - k0)))) {
++               current = item->Index();
++               cRemote::Put(kOk, true);
++               key_nr = -1;
++               break;
++               }
++            }
+          }
+       }
++  if ((!match) && (Key != kNone)) {
++     key_nr = -1;
++     }
+   return osContinue;
+ }
+ 
+@@ -500,8 +543,8 @@
+         }
+      }
+   switch (Key) {
+-    case k0:      return osUnknown;
+-    case k1...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
++    case kNone:
++    case k0...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+     case kUp|k_Repeat:
+     case kUp:   CursorUp();   break;
+     case kDown|k_Repeat:
+diff -Nru vdr-1.6.0-vanilla/osdbase.h vdr-1.6.0-liemikuutio/osdbase.h
+--- vdr-1.6.0-vanilla/osdbase.h	2007-11-03 16:50:52.000000000 +0200
++++ vdr-1.6.0-liemikuutio/osdbase.h	2009-02-27 23:06:59.000000000 +0200
+@@ -95,6 +95,8 @@
+   char *status;
+   int digit;
+   bool hasHotkeys;
++  int key_nr;
++  cTimeMs lastActivity;
+ protected:
+   void SetDisplayMenu(void);
+   cSkinDisplayMenu *DisplayMenu(void) { return displayMenu; }
+diff -Nru vdr-1.6.0-vanilla/po/de_DE.po vdr-1.6.0-liemikuutio/po/de_DE.po
+--- vdr-1.6.0-vanilla/po/de_DE.po	2008-03-23 12:31:29.000000000 +0200
++++ vdr-1.6.0-liemikuutio/po/de_DE.po	2009-02-27 23:06:59.000000000 +0200
+@@ -998,3 +998,51 @@
+ #, c-format
+ msgid "VDR will shut down in %s minutes"
+ msgstr "VDR wird in %s Minuten ausschalten"
++
++msgid "Rename recording"
++msgstr "Aufzeichnung umbenennen"
++
++msgid "Date"
++msgstr "Datum"
++
++msgid "Length"
++msgstr "Lnge"
++
++msgid "Size"
++msgstr "Gre"
++
++msgid "Path"
++msgstr "Pfad"
++
++msgid "Rename$Up"
++msgstr "Hher"
++
++msgid "Rename$Down"
++msgstr "Tiefer"
++
++msgid "Rename$Previous"
++msgstr "Vorheriger"
++
++msgid "Rename$Next"
++msgstr "Nchster"
++
++msgid "Delete marks information?"
++msgstr "Marks lschen?"
++
++msgid "Delete resume information?"
++msgstr "Resume lschen?"
++
++msgid "Setup.OSD$Main menu command position"
++msgstr "Befehle Position im Hauptmen"
++
++msgid "Setup.EPG$Show progress bar"
++msgstr "Zeitbalken anzeigen"
++
++msgid "Setup.Recording$Show date"
++msgstr "Aufnahmedatum anzeigen"
++
++msgid "Setup.Recording$Show time"
++msgstr "AufnahmeZeit anzeigen"
++
++msgid "Setup.Recording$Show length"
++msgstr "Lnge der Aufnahme anzeigen"
+diff -Nru vdr-1.6.0-vanilla/po/et_EE.po vdr-1.6.0-liemikuutio/po/et_EE.po
+--- vdr-1.6.0-vanilla/po/et_EE.po	2008-03-23 12:31:29.000000000 +0200
++++ vdr-1.6.0-liemikuutio/po/et_EE.po	2009-02-27 23:06:59.000000000 +0200
+@@ -998,3 +998,51 @@
+ #, c-format
+ msgid "VDR will shut down in %s minutes"
+ msgstr "VDR llitub vlja %s minuti prast"
++
++msgid "Rename recording"
++msgstr "mbernimetamine"
++
++msgid "Date"
++msgstr ""
++
++msgid "Length"
++msgstr ""
++
++msgid "Size"
++msgstr ""
++
++msgid "Path"
++msgstr ""
++
++msgid "Rename$Up"
++msgstr "les"
++
++msgid "Rename$Down"
++msgstr "Alla"
++
++msgid "Rename$Previous"
++msgstr "Eelmine"
++
++msgid "Rename$Next"
++msgstr "Jrgmine"
++
++msgid "Delete marks information?"
++msgstr ""
++
++msgid "Delete resume information?"
++msgstr ""
++
++msgid "Setup.OSD$Main menu command position"
++msgstr "Ksu asukoht peamens"
++
++msgid "Setup.EPG$Show progress bar"
++msgstr "Edenemisriba"
++
++msgid "Setup.Recording$Show date"
++msgstr "Salvestuse kuupev"
++
++msgid "Setup.Recording$Show time"
++msgstr "Salvestuse kellaaeg"
++
++msgid "Setup.Recording$Show length"
++msgstr "Salvestuse pikkus"
+diff -Nru vdr-1.6.0-vanilla/po/fi_FI.po vdr-1.6.0-liemikuutio/po/fi_FI.po
+--- vdr-1.6.0-vanilla/po/fi_FI.po	2008-03-23 12:31:29.000000000 +0200
++++ vdr-1.6.0-liemikuutio/po/fi_FI.po	2009-02-27 23:06:59.000000000 +0200
+@@ -1001,3 +1001,51 @@
+ #, c-format
+ msgid "VDR will shut down in %s minutes"
+ msgstr "VDR sammuu %s minuutin kuluttua"
++
++msgid "Rename recording"
++msgstr "Nime tallenne"
++
++msgid "Date"
++msgstr "Pivys"
++
++msgid "Length"
++msgstr "Pituus"
++
++msgid "Size"
++msgstr "Koko"
++
++msgid "Path"
++msgstr "Polku"
++
++msgid "Rename$Up"
++msgstr "Ylemms"
++
++msgid "Rename$Down"
++msgstr "Alemmas"
++
++msgid "Rename$Previous"
++msgstr "Edellinen"
++
++msgid "Rename$Next"
++msgstr "Seuraava"
++
++msgid "Delete marks information?"
++msgstr "Poista tallenteen merkinnt?"
++
++msgid "Delete resume information?"
++msgstr "Poista tallenteen paluutiedot?"
++
++msgid "Setup.OSD$Main menu command position"
++msgstr "Komentojen sijainti pvalikossa"
++
++msgid "Setup.EPG$Show progress bar"
++msgstr "Nyt aikajana"
++
++msgid "Setup.Recording$Show date"
++msgstr "Nyt tallenteen pivys"
++
++msgid "Setup.Recording$Show time"
++msgstr "Nyt tallenteen ajankohta"
++
++msgid "Setup.Recording$Show length"
++msgstr "Nyt tallenteen kesto"
+diff -Nru vdr-1.6.0-vanilla/po/fr_FR.po vdr-1.6.0-liemikuutio/po/fr_FR.po
+--- vdr-1.6.0-vanilla/po/fr_FR.po	2008-03-23 12:31:29.000000000 +0200
++++ vdr-1.6.0-liemikuutio/po/fr_FR.po	2009-02-27 23:06:59.000000000 +0200
+@@ -1004,3 +1004,51 @@
+ #, c-format
+ msgid "VDR will shut down in %s minutes"
+ msgstr "VDR s'arrtera dans %s minutes"
++
++msgid "Rename recording"
++msgstr "Renommer l'enregistrement"
++
++msgid "Date"
++msgstr "Date"
++
++msgid "Length"
++msgstr "Longueur"
++
++msgid "Size"
++msgstr "Taille"
++
++msgid "Path"
++msgstr "Chemin"
++
++msgid "Rename$Up"
++msgstr "Haut"
++
++msgid "Rename$Down"
++msgstr "Bas"
++
++msgid "Rename$Previous"
++msgstr "Prcdent"
++
++msgid "Rename$Next"
++msgstr "Suivant"
++
++msgid "Delete marks information?"
++msgstr "Effacer les informations de marquage"
++
++msgid "Delete resume information?"
++msgstr "Effacer les informations de reprise"
++
++msgid "Setup.OSD$Main menu command position"
++msgstr "Position des commandes dans le menu"
++
++msgid "Setup.EPG$Show progress bar"
++msgstr "Montrer la barre de progression"
++
++msgid "Setup.Recording$Show date"
++msgstr "Montrer la date d'enregistrement"
++
++msgid "Setup.Recording$Show time"
++msgstr "Montrer l'heure d'enregistrement"
++
++msgid "Setup.Recording$Show length"
++msgstr "Montrer la longueur de l'enregistrement"
+diff -Nru vdr-1.6.0-vanilla/po/ru_RU.po vdr-1.6.0-liemikuutio/po/ru_RU.po
+--- vdr-1.6.0-vanilla/po/ru_RU.po	2008-03-23 12:31:29.000000000 +0200
++++ vdr-1.6.0-liemikuutio/po/ru_RU.po	2009-02-27 23:06:59.000000000 +0200
+@@ -999,3 +999,36 @@
+ #, c-format
+ msgid "VDR will shut down in %s minutes"
+ msgstr "VDR   %s "
++
++msgid "Rename recording"
++msgstr " "
++
++msgid "Date"
++msgstr ""
++
++msgid "Length"
++msgstr ""
++
++msgid "Size"
++msgstr ""
++
++msgid "Delete marks information?"
++msgstr ""
++
++msgid "Delete resume information?"
++msgstr ""
++
++msgid "Setup.OSD$Main menu command position"
++msgstr "    "
++
++msgid "Setup.EPG$Show progress bar"
++msgstr ""
++
++msgid "Setup.Recording$Show date"
++msgstr " "
++
++msgid "Setup.Recording$Show time"
++msgstr "  "
++
++msgid "Setup.Recording$Show length"
++msgstr "  "
+diff -Nru vdr-1.6.0-vanilla/recording.c vdr-1.6.0-liemikuutio/recording.c
+--- vdr-1.6.0-vanilla/recording.c	2008-02-24 12:28:53.000000000 +0200
++++ vdr-1.6.0-liemikuutio/recording.c	2009-04-26 09:00:43.000000000 +0300
+@@ -62,6 +62,7 @@
+ #define MAX_LINK_LEVEL  6
+ 
+ bool VfatFileSystem = false;
++bool DirOrderState = false;
+ 
+ cRecordings DeletedRecordings(true);
+ 
+@@ -690,6 +691,8 @@
+ int cRecording::Compare(const cListObject &ListObject) const
+ {
+   cRecording *r = (cRecording *)&ListObject;
++  if (DirOrderState)
++     return strcasecmp(FileName(), r->FileName());
+   return strcasecmp(SortName(), r->SortName());
+ }
+ 
+@@ -705,7 +708,7 @@
+   return fileName;
+ }
+ 
+-const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) const
++const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level, bool Original) const
+ {
+   char New = NewIndicator && IsNew() ? '*' : ' ';
+   free(titleBuffer);
+@@ -718,6 +721,7 @@
+         s++;
+      else
+         s = name;
++     if (Original) {
+      titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%c%c%s",
+                             t->tm_mday,
+                             t->tm_mon + 1,
+@@ -728,6 +732,27 @@
+                             New,
+                             Delimiter,
+                             s));
++        }
++     else {
++        cString RecLength("---");
++        if (Setup.ShowRecLength && FileName()) {
++           int length = cIndexFile::Length(FileName());
++           if (length >= 0)
++              RecLength = cString::sprintf("%d'", length / SecondsToFrames(60));
++           }
++        cString RecDate = cString::sprintf("%02d.%02d.%02d", t->tm_mday, t->tm_mon + 1, t->tm_year % 100);
++        cString RecTime = cString::sprintf("%02d:%02d", t->tm_hour, t->tm_min);
++        cString RecDelimiter = cString::sprintf("%c", Delimiter);
++        titleBuffer = strdup(cString::sprintf("%s%s%s%c%s%s%s%s",
++                               (Setup.ShowRecDate ? *RecDate        : ""),
++                               (Setup.ShowRecDate && Setup.ShowRecTime ? *RecDelimiter : ""),
++                               (Setup.ShowRecTime ? *RecTime        : ""),
++                               New,
++                               (Setup.ShowRecTime || Setup.ShowRecDate ? *RecDelimiter : ""),
++                               (Setup.ShowRecLength ? *RecLength    : ""),
++                               (Setup.ShowRecLength ? *RecDelimiter : ""),
++                               s));
++        }
+      // let's not display a trailing '~':
+      if (!NewIndicator)
+         stripspace(titleBuffer);
+@@ -864,6 +889,41 @@
+   resume = RESUME_NOT_INITIALIZED;
+ }
+ 
++bool cRecording::Rename(const char *newName, int *newPriority, int *newLifetime)
++{
++  bool result = false;
++  struct tm tm_r;
++  struct tm *t = localtime_r(&start, &tm_r);
++  char *localNewName = ExchangeChars(strdup(newName), true);
++  char *newFileName = strdup(cString::sprintf(NAMEFORMAT, VideoDirectory, localNewName, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, *newPriority, *newLifetime));
++  free(localNewName);
++  if (strcmp(FileName(), newFileName)) {
++     if (access(newFileName, F_OK) == 0) {
++        isyslog("recording %s already exists", newFileName);
++        }
++     else {
++        isyslog("renaming recording %s to %s", FileName(), newFileName);
++        result = MakeDirs(newFileName, true);
++        if (result)
++           result = RenameVideoFile(FileName(), newFileName);
++        if (result) {
++           priority = *newPriority;
++           lifetime = *newLifetime;
++           free(fileName);
++           fileName = strdup(newFileName);
++           free(name);
++           name = strdup(newName);
++           free(sortBuffer);
++           sortBuffer = NULL;
++           free(titleBuffer);
++           titleBuffer = NULL;
++           }
++        }
++     }
++  free(newFileName);
++  return result;
++}
++
+ // --- cRecordings -----------------------------------------------------------
+ 
+ cRecordings Recordings;
+@@ -1405,6 +1465,15 @@
+   return f >= 0;
+ }
+ 
++int cIndexFile::Length(const char *FileName)
++{
++  struct stat buf;
++  cString fullname = cString::sprintf("%s%s", FileName, INDEXFILESUFFIX);
++  if (FileName && *fullname && access(fullname, R_OK) == 0 && stat(fullname, &buf) == 0)
++     return buf.st_size ? (buf.st_size - 1) / sizeof(tIndex) + 1 : 0;
++  return -1;
++}
++
+ // --- cFileName -------------------------------------------------------------
+ 
+ #define MAXFILESPERRECORDING 255
+diff -Nru vdr-1.6.0-vanilla/recording.h vdr-1.6.0-liemikuutio/recording.h
+--- vdr-1.6.0-vanilla/recording.h	2007-10-14 13:11:34.000000000 +0300
++++ vdr-1.6.0-liemikuutio/recording.h	2009-04-05 13:07:48.000000000 +0300
+@@ -19,6 +19,7 @@
+ #include "tools.h"
+ 
+ extern bool VfatFileSystem;
++extern bool DirOrderState;
+ 
+ void RemoveDeletedRecordings(void);
+ void AssertFreeDiskSpace(int Priority = 0, bool Force = false);
+@@ -88,7 +89,7 @@
+   virtual int Compare(const cListObject &ListObject) const;
+   const char *Name(void) const { return name; }
+   const char *FileName(void) const;
+-  const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1) const;
++  const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1, bool Original = true) const;
+   const cRecordingInfo *Info(void) const { return info; }
+   const char *PrefixFileName(char Prefix);
+   int HierarchyLevels(void) const;
+@@ -106,6 +107,9 @@
+        // Changes the file name so that it will be visible in the "Recordings" menu again and
+        // not processed by cRemoveDeletedRecordingsThread.
+        // Returns false in case of error
++  bool Rename(const char *newName, int *newPriority, int *newLifetime);
++       // Changes the file name
++       // Returns false in case of error
+   };
+ 
+ class cRecordings : public cList<cRecording>, public cThread {
+@@ -219,6 +223,8 @@
+   int GetResume(void) { return resumeFile.Read(); }
+   bool StoreResume(int Index) { return resumeFile.Save(Index); }
+   bool IsStillRecording(void);
++  static int Length(const char *FileName);
++       ///< Calculates the recording length without reading the index.
+   };
+ 
+ class cFileName {
+diff -Nru vdr-1.6.0-vanilla/svdrp.c vdr-1.6.0-liemikuutio/svdrp.c
+--- vdr-1.6.0-vanilla/svdrp.c	2008-02-17 15:36:01.000000000 +0200
++++ vdr-1.6.0-liemikuutio/svdrp.c	2009-02-27 23:06:59.000000000 +0200
+@@ -296,6 +296,8 @@
+   "REMO [ on | off ]\n"
+   "    Turns the remote control on or off. Without a parameter, the current\n"
+   "    status of the remote control is reported.",
++  "RENR <number> <new name>\n"
++  "    Rename recording. Number must be the Number as returned by LSTR command.",
+   "SCAN\n"
+   "    Forces an EPG scan. If this is a single DVB device system, the scan\n"
+   "    will be done on the primary device unless it is currently recording.",
+@@ -1472,6 +1474,38 @@
+   Reply(250, "EPG scan triggered");
+ }
+ 
++void cSVDRP::CmdRENR(const char *Option)
++{
++  bool recordings = Recordings.Update(true);
++  if (recordings) {
++     if (*Option) {
++        char *tail;
++        int n = strtol(Option, &tail, 10);
++        cRecording *recording = Recordings.Get(n - 1);
++        if (recording && tail && tail != Option) {
++           int priority = recording->priority;
++           int lifetime = recording->lifetime;
++           char *oldName = strdup(recording->Name());
++           tail = skipspace(tail);
++           if (recording->Rename(tail, &priority, &lifetime)) {
++              Reply(250, "Renamed \"%s\" to \"%s\"", oldName, recording->Name());
++              Recordings.ChangeState();
++              Recordings.TouchUpdate();
++              }
++           else
++              Reply(501, "Renaming \"%s\" to \"%s\" failed", oldName, tail);
++           free(oldName);
++           }
++        else
++          Reply(501, "Recording not found or wrong syntax");
++        }
++     else
++        Reply(501, "Missing Input settings");
++     }
++  else
++     Reply(550, "No recordings available");
++}
++						
+ void cSVDRP::CmdSTAT(const char *Option)
+ {
+   if (*Option) {
+@@ -1587,6 +1621,7 @@
+   else if (CMD("PLUG"))  CmdPLUG(s);
+   else if (CMD("PUTE"))  CmdPUTE(s);
+   else if (CMD("REMO"))  CmdREMO(s);
++  else if (CMD("RENR"))  CmdRENR(s);
+   else if (CMD("SCAN"))  CmdSCAN(s);
+   else if (CMD("STAT"))  CmdSTAT(s);
+   else if (CMD("UPDT"))  CmdUPDT(s);
+diff -Nru vdr-1.6.0-vanilla/svdrp.h vdr-1.6.0-liemikuutio/svdrp.h
+--- vdr-1.6.0-vanilla/svdrp.h	2007-04-30 15:28:28.000000000 +0300
++++ vdr-1.6.0-liemikuutio/svdrp.h	2009-02-27 23:06:59.000000000 +0200
+@@ -79,6 +79,7 @@
+   void CmdPLUG(const char *Option);
+   void CmdPUTE(const char *Option);
+   void CmdREMO(const char *Option);
++  void CmdRENR(const char *Option);
+   void CmdSCAN(const char *Option);
+   void CmdSTAT(const char *Option);
+   void CmdUPDT(const char *Option);
--- vdr-1.6.0.orig/debian/patches/opt-39_noepg.dpatch
+++ vdr-1.6.0/debian/patches/opt-39_noepg.dpatch
@@ -0,0 +1,149 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-39_noepg.dpatch from version the vdr-noepgmenu plugin 0.0.6.beta3
+## http://winni.vdr-developer.org/noepgmenu/downloads/beta
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: The patch allows to disable normal epg update for specified channels.
+## DP: This is useful if you get epg data of the channels from external sources.
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/config.c vdr-1.6.0/config.c
+--- vdr-1.6.0~/config.c	2008-05-11 03:35:16.000000000 +0200
++++ vdr-1.6.0/config.c	2008-05-11 03:35:44.000000000 +0200
+@@ -339,11 +339,20 @@
+   ShowRecLength = 0;
+   ShowProgressBar = 0;
+   MenuCmdPosition = 0;
++  noEPGMode=0;
++  noEPGList=strdup("");
++}
++
++cSetup::~cSetup()
++{
++  free(noEPGList);
+ }
+ 
+ cSetup& cSetup::operator= (const cSetup &s)
+ {
+   memcpy(&__BeginData__, &s.__BeginData__, (char *)&s.__EndData__ - (char *)&s.__BeginData__);
++  free(noEPGList);
++  noEPGList = strdup(s.noEPGList);
+   return *this;
+ }
+ 
+@@ -504,6 +513,11 @@
+   else if (!strcasecmp(Name, "FontOsdSize"))         FontOsdSize        = atoi(Value);
+   else if (!strcasecmp(Name, "FontSmlSize"))         FontSmlSize        = atoi(Value);
+   else if (!strcasecmp(Name, "FontFixSize"))         FontFixSize        = atoi(Value);
++  else if (!strcasecmp(Name, "noEPGMode"))           noEPGMode          = atoi(Value);
++  else if (!strcasecmp(Name, "noEPGList")) {
++    free(noEPGList);
++    noEPGList=strdup(Value ? Value : "");
++  }
+   else if (!strcasecmp(Name, "MaxVideoFileSize"))    MaxVideoFileSize   = atoi(Value);
+   else if (!strcasecmp(Name, "SplitEditedFiles"))    SplitEditedFiles   = atoi(Value);
+   else if (!strcasecmp(Name, "MinEventTimeout"))     MinEventTimeout    = atoi(Value);
+@@ -599,6 +613,8 @@
+   Store("FontOsd",            FontOsd);
+   Store("FontSml",            FontSml);
+   Store("FontFix",            FontFix);
++  Store("noEPGMode",          noEPGMode);
++  Store("noEPGList",          noEPGList);
+   Store("FontOsdSize",        FontOsdSize);
+   Store("FontSmlSize",        FontSmlSize);
+   Store("FontFixSize",        FontFixSize);
+diff -urNad vdr-1.6.0~/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0~/config.h	2008-05-11 03:35:16.000000000 +0200
++++ vdr-1.6.0/config.h	2008-05-11 03:35:16.000000000 +0200
+@@ -280,6 +280,7 @@
+   int FontOsdSize;
+   int FontSmlSize;
+   int FontFixSize;
++  int noEPGMode;
+   int MaxVideoFileSize;
+   int SplitEditedFiles;
+   int MinEventTimeout, MinUserInactivity;
+@@ -299,7 +300,9 @@
+   int EmergencyExit;
+   int ShowRecDate, ShowRecTime, ShowRecLength, ShowProgressBar, MenuCmdPosition;
+   int __EndData__;
++  char *noEPGList; // pointer not to be flat-copied
+   cSetup(void);
++  ~cSetup();
+   cSetup& operator= (const cSetup &s);
+   bool Load(const char *FileName);
+   bool Save(void);
+diff -urNad vdr-1.6.0~/eit.c vdr-1.6.0/eit.c
+--- vdr-1.6.0~/eit.c	2008-05-11 03:35:16.000000000 +0200
++++ vdr-1.6.0/eit.c	2008-05-11 03:35:16.000000000 +0200
+@@ -22,8 +22,28 @@
+ class cEIT : public SI::EIT {
+ public:
+   cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bool OnlyRunningStatus = false);
++
++private:
++  bool allowedEPG(tChannelID kanalID);
+   };
+ 
++bool cEIT::allowedEPG(tChannelID kanalID) {
++  bool rc;
++
++  if (Setup.noEPGMode == 1) {
++     rc=false;
++     if (strstr(::Setup.noEPGList,kanalID.ToString())!=NULL)
++        rc=true;
++     }
++  else {
++     rc=true;
++     if (strstr(::Setup.noEPGList,kanalID.ToString())!=NULL)
++        rc=false;
++     }
++
++  return rc;
++}
++
+ cEIT::cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bool OnlyRunningStatus)
+ :SI::EIT(Data, false)
+ {
+@@ -35,6 +55,12 @@
+   if (!channel)
+      return; // only collect data for known channels
+ 
++  // only use epg from channels not blocked by noEPG-patch
++  tChannelID kanalID;
++  kanalID=channel->GetChannelID();
++  if (!allowedEPG(kanalID))
++    return;
++
+   cSchedule *pSchedule = (cSchedule *)Schedules->GetSchedule(channel, true);
+ 
+   bool Empty = true;
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2008-05-11 03:35:16.000000000 +0200
++++ vdr-1.6.0/menu.c	2008-05-11 03:35:16.000000000 +0200
+@@ -2604,6 +2604,7 @@
+ 
+ class cMenuSetupEPG : public cMenuSetupBase {
+ private:
++  const char *noEPGModes[2];
+   int originalNumLanguages;
+   int numLanguages;
+   void Setup(void);
+@@ -2626,6 +2627,9 @@
+ {
+   int current = Current();
+ 
++  noEPGModes[0]=tr("Blacklist");
++  noEPGModes[1]=tr("Whitelist");
++
+   Clear();
+ 
+   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
+@@ -2644,6 +2648,7 @@
+   Add(new cMenuEditBoolItem(tr("Setup.EPG$extern double Epg entry"),   &data.DoubleEpgAction, "adjust", "delete"));
+   Add(new cMenuEditBoolItem(tr("Setup.EPG$Mix intern and extern EPG"), &data.MixEpgAction));
+   Add(new cMenuEditBoolItem(tr("Setup.EPG$Disable running VPS event"), &data.DisableVPS));
++  Add(new cMenuEditStraItem(tr("Setup.EPG$Mode noEPG-Patch"),          &data.noEPGMode, 2, noEPGModes));
+ 
+   SetCurrent(Get(current));
+   Display();
--- vdr-1.6.0.orig/debian/patches/opt-51_cuttime.dpatch
+++ vdr-1.6.0/debian/patches/opt-51_cuttime.dpatch
@@ -0,0 +1,121 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-32_cuttime.dpatch by Udo Richter <udo_richter@gmx.de>
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.7 with liemikuutio patch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Modifies the start time of recordings to the first cutting mark.
+## DP: 
+## DP: 2007-07-01 Tobias Grimm <tg@e-tobi.net>
+## DP:     - Added setup option to enable/disable CutTime
+
+@DPATCH@
+diff -Naur vdr-1.5.7-liemikuutio/config.c vdr-1.5.7-liemikuutio-cuttime/config.c
+--- vdr-1.5.7-liemikuutio/config.c	2007-08-12 19:29:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/config.c	2007-08-12 19:30:55.000000000 +0000
+@@ -214,6 +214,7 @@
+ 
+ cSetup::cSetup(void)
+ {
++  CutTimePatchEnabled = 0;
+   strcpy(OSDLanguage, ""); // default is taken from environment
+   strcpy(OSDSkin, "sttng");
+   strcpy(OSDTheme, "default");
+@@ -464,6 +465,7 @@
+   else if (!strcasecmp(Name, "ShowRecLength"))       ShowRecLength      = atoi(Value);
+   else if (!strcasecmp(Name, "ShowProgressBar"))     ShowProgressBar    = atoi(Value);
+   else if (!strcasecmp(Name, "MenuCmdPosition"))     MenuCmdPosition    = atoi(Value);
++  else if (!strcasecmp(Name, "CutTimePatchEnabled")) CutTimePatchEnabled= atoi(Value);
+   else
+      return false;
+   return true;
+@@ -546,6 +548,7 @@
+   Store("ShowRecLength",      ShowRecLength);
+   Store("ShowProgressBar",    ShowProgressBar);
+   Store("MenuCmdPosition",    MenuCmdPosition);
++  Store("CutTimePatchEnabled",CutTimePatchEnabled);
+ 
+   Sort();
+ 
+diff -Naur vdr-1.5.7-liemikuutio/config.h vdr-1.5.7-liemikuutio-cuttime/config.h
+--- vdr-1.5.7-liemikuutio/config.h	2007-08-12 19:29:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/config.h	2007-08-12 19:29:39.000000000 +0000
+@@ -265,6 +265,7 @@
+   int InitialChannel;
+   int InitialVolume;
+   int ShowRecDate, ShowRecTime, ShowRecLength, ShowProgressBar, MenuCmdPosition;
++  int CutTimePatchEnabled;
+   int __EndData__;
+   cSetup(void);
+   cSetup& operator= (const cSetup &s);
+diff -Naur vdr-1.5.7-liemikuutio/cutter.c vdr-1.5.7-liemikuutio-cuttime/cutter.c
+--- vdr-1.5.7-liemikuutio/cutter.c	2006-07-30 10:22:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/cutter.c	2007-08-12 19:29:39.000000000 +0000
+@@ -190,6 +190,14 @@
+      error = false;
+      ended = false;
+      cRecording Recording(FileName);
++     
++     if (Setup.CutTimePatchEnabled) {
++        cMarks FromMarks;
++        FromMarks.Load(FileName);
++        cMark *First=FromMarks.First();
++        if (First) Recording.SetStartTime(Recording.start+((First->position/FRAMESPERSEC+30)/60)*60);
++     }
++     
+      const char *evn = Recording.PrefixFileName('%');
+      if (evn && RemoveVideoFile(evn) && MakeDirs(evn, true)) {
+         // XXX this can be removed once RenameVideoFile() follows symlinks (see videodir.c)
+diff -Naur vdr-1.5.7-liemikuutio/menu.c vdr-1.5.7-liemikuutio-cuttime/menu.c
+--- vdr-1.5.7-liemikuutio/menu.c	2007-08-12 19:29:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/menu.c	2007-08-12 19:29:39.000000000 +0000
+@@ -2887,6 +2887,7 @@
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show date"),                 &data.ShowRecDate));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show time"),                 &data.ShowRecTime));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show length"),               &data.ShowRecLength));
++  Add(new cMenuEditBoolItem(tr("Setup.CutTimePatch$Adapt start time to cutting marks"), &data.CutTimePatchEnabled));
+ }
+ 
+ // --- cMenuSetupReplay ------------------------------------------------------
+diff -Naur vdr-1.5.7-liemikuutio/po/de_DE.po vdr-1.5.7-liemikuutio-cuttime/po/de_DE.po
+--- vdr-1.5.7-liemikuutio/po/de_DE.po       2007-08-12 12:18:04.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/po/de_DE.po        2007-08-21 21:58:37.000000000 +0000
+@@ -606,2 +606,5 @@
+-msgid "Setup.Recording$Show length"
+-msgstr "Lnge der Aufnahme anzeigen"
++msgid "Setup.Recording$Show length"
++msgstr "Lnge der Aufnahme anzeigen"
++
++msgid "Setup.CutTimePatch$Adapt start time to cutting marks"
++msgstr "Startzeit an Schnittmarken anpassen"
+diff -Naur vdr-1.5.7-liemikuutio/recording.c vdr-1.5.7-liemikuutio-cuttime/recording.c
+--- vdr-1.5.7-liemikuutio/recording.c	2007-08-12 19:29:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/recording.c	2007-08-12 19:29:39.000000000 +0000
+@@ -780,6 +780,15 @@
+   return titleBuffer;
+ }
+ 
++void cRecording::SetStartTime(time_t Start) 
++{
++  start=Start;
++  if (fileName) {
++  	 free(fileName);
++  	 fileName = NULL;
++  	 }
++}
++
+ const char *cRecording::PrefixFileName(char Prefix)
+ {
+   cString p = PrefixVideoFileName(FileName(), Prefix);
+diff -Naur vdr-1.5.7-liemikuutio/recording.h vdr-1.5.7-liemikuutio-cuttime/recording.h
+--- vdr-1.5.7-liemikuutio/recording.h	2007-08-12 19:29:08.000000000 +0000
++++ vdr-1.5.7-liemikuutio-cuttime/recording.h	2007-08-12 19:29:39.000000000 +0000
+@@ -89,6 +89,7 @@
+   const char *FileName(void) const;
+   const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1, bool Original = true) const;
+   const cRecordingInfo *Info(void) const { return info; }
++  void SetStartTime(time_t Start);
+   const char *PrefixFileName(char Prefix);
+   int HierarchyLevels(void) const;
+   void ResetResume(void) const;
--- vdr-1.6.0.orig/debian/patches/opt-35_setup-show-valid.dpatch
+++ vdr-1.6.0/debian/patches/opt-35_setup-show-valid.dpatch
@@ -0,0 +1,83 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## opt-35_setup-show-valid.dpatch by ravemax at vdrportal.de
+##
+## downloaded from http://vdrportal.de/board/thread.php?threadid=25984
+## original file: setup_option-show_valid_input.patch.bz2
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Show if there is a valid setup value left or right with < and >.
+
+@DPATCH@
+diff -ur vdr_orig/menuitems.c vdr_patched/menuitems.c
+--- vdr_orig/menuitems.c	2004-12-05 17:59:12.452421104 +0100
++++ vdr_patched/menuitems.c	2004-12-05 18:01:54.726751656 +0100
+@@ -31,12 +31,18 @@
+   free(value);
+ }
+ 
+-void cMenuEditItem::SetValue(const char *Value)
++void cMenuEditItem::SetValue(const char *Value, bool HasPre, bool HasSucc)
+ {
+   free(value);
+   value = strdup(Value);
+   char *buffer = NULL;
+-  asprintf(&buffer, "%s:\t%s", name, value);
++  const char* fmt;
++  if (HasPre)
++    fmt = HasSucc ? "%s:\t<%s>" : "%s\t<%s";
++  else
++    fmt = HasSucc ? "%s\t%s>" : "%s\t%s";
++
++  asprintf(&buffer, fmt, name, value);
+   SetText(buffer, false);
+   cStatus::MsgOsdCurrentItem(buffer);
+ }
+@@ -56,7 +62,7 @@
+ {
+   char buf[16];
+   snprintf(buf, sizeof(buf), "%d", *value);
+-  SetValue(buf);
++  SetValue(buf, (*value > min), (*value < max));
+ }
+ 
+ eOSState cMenuEditIntItem::ProcessKey(eKeys Key)
+@@ -111,7 +117,7 @@
+ {
+   char buf[16];
+   snprintf(buf, sizeof(buf), "%s", *value ? trueString : falseString);
+-  SetValue(buf);
++  SetValue(buf, *value, !*value);
+ }
+ 
+ // --- cMenuEditBitItem ------------------------------------------------------
+@@ -459,7 +465,7 @@
+ 
+ void cMenuEditStraItem::Set(void)
+ {
+-  SetValue(strings[*value]);
++  SetValue(strings[*value], (*value > min), (*value < max));
+ }
+ 
+ // --- cMenuEditChanItem -----------------------------------------------------
+@@ -475,7 +481,7 @@
+   char buf[255];
+   cChannel *channel = Channels.GetByNumber(*value);
+   snprintf(buf, sizeof(buf), "%d %s", *value, channel ? channel->Name() : "");
+-  SetValue(buf);
++  SetValue(buf, (*value > 1), (*value < Channels.MaxNumber()));
+ }
+ 
+ eOSState cMenuEditChanItem::ProcessKey(eKeys Key)
+diff -ur vdr_orig/menuitems.h vdr_patched/menuitems.h
+--- vdr_orig/menuitems.h	2004-12-05 17:59:24.719556216 +0100
++++ vdr_patched/menuitems.h	2004-12-05 18:04:29.681195000 +0100
+@@ -21,7 +21,7 @@
+ public:
+   cMenuEditItem(const char *Name);
+   ~cMenuEditItem();
+-  void SetValue(const char *Value);
++  void cMenuEditItem::SetValue(const char *Value, bool HasPre=false, bool HasSucc=false);
+   };
+ 
+ class cMenuEditIntItem : public cMenuEditItem {
--- vdr-1.6.0.orig/debian/patches/XX_patchtest-patch-error.dpatch
+++ vdr-1.6.0/debian/patches/XX_patchtest-patch-error.dpatch
@@ -0,0 +1,20 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## XX_patchtest-patch-error
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch to check patchtest against patch error
+
+@DPATCH@
+diff -Nur vdr.orig/vdr.c vdr/vdr.c
+--- vdr.orig/vdr.c	2004-03-12 21:37:17.000000000 +0100
++++ vdr/vdr.c	2004-03-13 14:22:01.000000000 +0100
+@@ -79,6 +79,8 @@
+ 
+ int main(int argc, char *argv[])
+ ***PATCH-BUG***
++  RaiseCompilerError();
++  
+   // Save terminal settings:
+ 
+   struct termios savedTm;
--- vdr-1.6.0.orig/debian/patches/opt-50_graphtft.dpatch
+++ vdr-1.6.0/debian/patches/opt-50_graphtft.dpatch
@@ -0,0 +1,313 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-50_graphtft-0.1.dpatch by Jrg Wendel (Horchi)
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to pin patch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch from the Graphtft plugin version 0.1.6.alpha
+## DP: http://www.jwendel.de/vdr/
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2008-04-04 17:17:26.000000000 +0200
++++ vdr-1.6.0/menu.c	2008-04-04 17:19:44.000000000 +0200
+@@ -262,6 +262,7 @@
+ public:
+   cMenuEditChannel(cChannel *Channel, bool New = false);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuEditChannel"; }
+   };
+ 
+ cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
+@@ -484,6 +485,7 @@
+   cMenuChannels(void);
+   ~cMenuChannels();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuChannels"; }
+   };
+ 
+ cMenuChannels::cMenuChannels(void)
+@@ -955,6 +957,7 @@
+   virtual ~cMenuTimers();
+   virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuTimers"; }
+   };
+ 
+ cMenuTimers::cMenuTimers(void)
+@@ -1181,6 +1184,7 @@
+ {
+   cOsdMenu::Display();
+   DisplayMenu()->SetEvent(event);
++  cStatus::MsgOsdSetEvent(event);
+   if (event->Description())
+      cStatus::MsgOsdTextItem(event->Description());
+ }
+@@ -1323,6 +1327,7 @@
+   static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
+   static const cEvent *ScheduleEvent(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
+   };
+ 
+ int cMenuWhatsOn::currentChannel = 0;
+@@ -1490,6 +1495,7 @@
+   cMenuSchedule(void);
+   virtual ~cMenuSchedule();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSchedule"; }
+   };
+ 
+ cMenuSchedule::cMenuSchedule(void)
+@@ -1757,6 +1763,7 @@
+   cMenuCommands(const char *Title, cCommands *Commands, const char *Parameters = NULL);
+   virtual ~cMenuCommands();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuCommands"; }
+   };
+ 
+ cMenuCommands::cMenuCommands(const char *Title, cCommands *Commands, const char *Parameters)
+@@ -1833,6 +1840,7 @@
+   cMenuCam(cCamSlot *CamSlot);
+   virtual ~cMenuCam();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuCam"; }
+   };
+ 
+ cMenuCam::cMenuCam(cCamSlot *CamSlot)
+@@ -2012,6 +2020,7 @@
+   cMenuRecording(const cRecording *Recording, bool WithButtons = false);
+   virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuRecording"; }
+ };
+ 
+ cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
+@@ -2027,6 +2036,7 @@
+ {
+   cOsdMenu::Display();
+   DisplayMenu()->SetRecording(recording);
++  cStatus::MsgOsdSetRecording(recording);
+   if (recording->Info()->Description())
+      cStatus::MsgOsdTextItem(recording->Info()->Description());
+ }
+@@ -2133,6 +2143,7 @@
+ public:
+   cMenuRenameRecording(cRecording *Recording);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuRenameRecording"; }
+ };
+ 
+ cMenuRenameRecording::cMenuRenameRecording(cRecording *Recording)
+@@ -2573,6 +2584,7 @@
+   cMenuSetupOSD(void);
+   virtual ~cMenuSetupOSD();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupOsd"; }
+   };
+ 
+ cMenuSetupOSD::cMenuSetupOSD(void)
+@@ -2720,6 +2732,7 @@
+ public:
+   cMenuSetupEPG(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupEpg"; }
+   };
+ 
+ cMenuSetupEPG::cMenuSetupEPG(void)
+@@ -2824,6 +2837,7 @@
+ public:
+   cMenuSetupDVB(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupDvb"; }
+   };
+ 
+ cMenuSetupDVB::cMenuSetupDVB(void)
+@@ -2955,6 +2969,7 @@
+ public:
+   cMenuSetupLNB(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupLnb"; }
+   };
+ 
+ cMenuSetupLNB::cMenuSetupLNB(void)
+@@ -3035,6 +3050,7 @@
+ public:
+   cMenuSetupCAM(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupCam"; }
+   };
+ 
+ cMenuSetupCAM::cMenuSetupCAM(void)
+@@ -3205,6 +3221,7 @@
+ public:
+   cMenuSetupPlugins(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
+   };
+ 
+ cMenuSetupPlugins::cMenuSetupPlugins(void)
+@@ -3254,6 +3271,7 @@
+ public:
+   cMenuSetup(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuSetup"; }
+   };
+ 
+ cMenuSetup::cMenuSetup(void)
+diff -urNad vdr-1.6.0~/menu.h vdr-1.6.0/menu.h
+--- vdr-1.6.0~/menu.h	2008-04-04 17:17:25.000000000 +0200
++++ vdr-1.6.0/menu.h	2008-04-04 17:20:43.000000000 +0200
+@@ -29,6 +29,7 @@
+   void SetText(const char *Text);
+   virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuText"; }
+   };
+ 
+ class cMenuEditTimer : public cOsdMenu {
+@@ -44,6 +45,7 @@
+   cMenuEditTimer(cTimer *Timer, bool New = false);
+   virtual ~cMenuEditTimer();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuTimerEdit"; }
+   };
+ 
+ class cMenuEvent : public cOsdMenu {
+@@ -53,6 +55,7 @@
+   cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
+   virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuEvent"; }
+   };
+ 
+ class cMenuMain : public cOsdMenu {
+@@ -69,6 +72,7 @@
+   cMenuMain(eOSState State = osUnknown);
+   virtual eOSState ProcessKey(eKeys Key);
+   static cOsdObject *PluginOsdObject(void);
++  virtual const char* MenuKind() { return "MenuMain"; }
+   };
+ 
+ class cDisplayChannel : public cOsdObject {
+@@ -171,6 +175,7 @@
+   cMenuRecordings(const char *Base = NULL, int Level = 0, bool OpenSubMenus = false);
+   ~cMenuRecordings();
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuRecordings"; }
+   };
+ 
+ class cRecordControl {
+diff -urNad vdr-1.6.0~/menuitems.h vdr-1.6.0/menuitems.h
+--- vdr-1.6.0~/menuitems.h	2008-02-16 17:09:58.000000000 +0100
++++ vdr-1.6.0/menuitems.h	2008-04-04 17:17:53.000000000 +0200
+@@ -174,6 +174,7 @@
+   cMenuSetupPage(void);
+   virtual eOSState ProcessKey(eKeys Key);
+   void SetPlugin(cPlugin *Plugin);
++  const char* MenuKind() { return "MenuSetupPage"; }
+   };
+ 
+ #endif //__MENUITEMS_H
+diff -urNad vdr-1.6.0~/osdbase.c vdr-1.6.0/osdbase.c
+--- vdr-1.6.0~/osdbase.c	2008-04-04 17:17:25.000000000 +0200
++++ vdr-1.6.0/osdbase.c	2008-04-04 17:18:05.000000000 +0200
+@@ -98,6 +98,7 @@
+   free(status);
+   displayMenu->Clear();
+   cStatus::MsgOsdClear();
++  cStatus::MsgOsdMenuDestroy();
+   if (!--displayMenuCount)
+      DELETENULL(displayMenu);
+ }
+@@ -203,6 +204,7 @@
+   displayMenu->SetMessage(mtStatus, NULL);
+   displayMenu->Clear();
+   cStatus::MsgOsdClear();
++  cStatus::MsgOsdMenuDisplay(MenuKind());
+   displayMenu->SetTabs(cols[0], cols[1], cols[2], cols[3], cols[4]);//XXX
+   displayMenu->SetTitle(title);
+   cStatus::MsgOsdTitle(title);
+diff -urNad vdr-1.6.0~/osdbase.h vdr-1.6.0/osdbase.h
+--- vdr-1.6.0~/osdbase.h	2008-04-04 17:17:25.000000000 +0200
++++ vdr-1.6.0/osdbase.h	2008-04-04 17:18:11.000000000 +0200
+@@ -131,6 +131,7 @@
+   void Ins(cOsdItem *Item, bool Current = false, cOsdItem *Before = NULL);
+   virtual void Display(void);
+   virtual eOSState ProcessKey(eKeys Key);
++  virtual const char* MenuKind() { return "MenuUnknown"; }
+   };
+ 
+ #endif //__OSDBASE_H
+diff -urNad vdr-1.6.0~/recording.h vdr-1.6.0/recording.h
+--- vdr-1.6.0~/recording.h	2008-04-04 17:17:25.000000000 +0200
++++ vdr-1.6.0/recording.h	2008-04-04 17:19:50.000000000 +0200
+@@ -56,6 +56,7 @@
+   const char *ChannelName(void) const { return channelName; }
+   const char *Title(void) const { return event->Title(); }
+   const char *ShortText(void) const { return event->ShortText(); }
++  tEventID EventID(void) const { return event->EventID(); }
+   const char *Description(void) const { return event->Description(); }
+   const cComponents *Components(void) const { return event->Components(); }
+   const char *Aux(void) const { return aux; }
+diff -urNad vdr-1.6.0~/status.c vdr-1.6.0/status.c
+--- vdr-1.6.0~/status.c	2008-02-16 15:46:31.000000000 +0100
++++ vdr-1.6.0/status.c	2008-04-04 17:20:11.000000000 +0200
+@@ -124,3 +124,26 @@
+   for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+       sm->OsdProgramme(PresentTime, PresentTitle, PresentSubtitle, FollowingTime, FollowingTitle, FollowingSubtitle);
+ }
++void cStatus::MsgOsdSetEvent(const cEvent* event)
++{
++  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
++      sm->OsdSetEvent(event);
++}
++
++void cStatus::MsgOsdSetRecording(const cRecording* recording)
++{
++  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
++      sm->OsdSetRecording(recording);
++}
++
++void cStatus::MsgOsdMenuDisplay(const char* kind)
++{
++  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
++      sm->OsdMenuDisplay(kind);
++}
++
++void cStatus::MsgOsdMenuDestroy()
++{
++  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
++      sm->OsdMenuDestroy();
++}
+diff -urNad vdr-1.6.0~/status.h vdr-1.6.0/status.h
+--- vdr-1.6.0~/status.h	2008-02-16 16:00:33.000000000 +0100
++++ vdr-1.6.0/status.h	2008-04-04 17:20:03.000000000 +0200
+@@ -80,6 +80,15 @@
+                // The OSD displays the single line Text with the current channel information.
+   virtual void OsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle) {}
+                // The OSD displays the given programme information.
++  virtual void OsdSetRecording(const cRecording* recording) {}
++               // The OSD displays the recording information.
++  virtual void OsdSetEvent(const cEvent* event) {}
++               // The OSD displays the event information.
++  virtual void OsdMenuDisplay(const char* kind) {}
++               // report menu creation
++  virtual void OsdMenuDestroy() {}
++               // report menu destruvtion
++
+ public:
+   cStatus(void);
+   virtual ~cStatus();
+@@ -101,6 +110,10 @@
+   static void MsgOsdTextItem(const char *Text,  bool Scroll = false);
+   static void MsgOsdChannel(const char *Text);
+   static void MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle);
++  static void MsgOsdSetEvent(const cEvent* event);
++  static void MsgOsdSetRecording(const cRecording* recording);
++  static void MsgOsdMenuDisplay(const char* kind);
++  static void MsgOsdMenuDestroy();
+   };
+ 
+ #endif //__STATUS_H
--- vdr-1.6.0.orig/debian/patches/99_vdr-workaround-broken-sys-capability.dpatch
+++ vdr-1.6.0/debian/patches/99_vdr-workaround-broken-sys-capability.dpatch
@@ -0,0 +1,32 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run 
+## 99_vdr-workaround-broken-sys-capability.dpatch by Anssi Hannula <anssi.hannula@gmail.com>
+## http://www.linuxtv.org/pipermail/vdr/2009-August/021196.html
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This is a workaround for some trouble with the kernel headers
+## DP: in Linux 2.6.29.
+## DP: See: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=523424
+
+@DPATCH@
+Index: vdr-1.7.9/vdr.c
+===================================================================
+--- vdr-1.7.9/vdr.c
++++ vdr-1.7.9/vdr.c	2009-08-23 23:26:15.935332431 +0300
+@@ -32,7 +32,6 @@
+ #include <pwd.h>
+ #include <signal.h>
+ #include <stdlib.h>
+-#include <sys/capability.h>
+ #include <sys/prctl.h>
+ #include <termios.h>
+ #include <unistd.h>
+@@ -64,6 +63,9 @@
+ #include "tools.h"
+ #include "transfer.h"
+ #include "videodir.h"
++// include this one last due to some versions of it being buggy:
++// http://www.linuxtv.org/pipermail/vdr/2009-August/021194.html
++#include <sys/capability.h>
+ 
+ #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
+ #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
--- vdr-1.6.0.orig/debian/patches/opt-54_deltimeshiftrec.dpatch
+++ vdr-1.6.0/debian/patches/opt-54_deltimeshiftrec.dpatch
@@ -0,0 +1,169 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-54_deltimeshiftrec.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Offers the choice to delete timeshift recordings
+## DP: Taken from the Zulu extensions patch
+## DP: See http://www.zulu-entertainment.de/download.php?group=VDR
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/config.c vdr-1.6.0/config.c
+--- vdr-1.6.0~/config.c	2008-07-25 23:55:15.000000000 +0200
++++ vdr-1.6.0/config.c	2008-07-25 23:57:18.000000000 +0200
+@@ -276,6 +276,7 @@
+   TimeTransponder = 0;
+   MarginStart = 2;
+   MarginStop = 10;
++  DelTimeshiftRec = 0;
+   AudioLanguages[0] = -1;
+   DisplaySubtitles = 0;
+   SubtitleLanguages[0] = -1;
+@@ -522,6 +523,7 @@
+   else if (!strcasecmp(Name, "TimeTransponder"))     TimeTransponder    = atoi(Value);
+   else if (!strcasecmp(Name, "MarginStart"))         MarginStart        = atoi(Value);
+   else if (!strcasecmp(Name, "MarginStop"))          MarginStop         = atoi(Value);
++  else if (!strcasecmp(Name, "DelTimeshiftRec"))     DelTimeshiftRec    = atoi(Value);
+   else if (!strcasecmp(Name, "AudioLanguages"))      return ParseLanguages(Value, AudioLanguages);
+   else if (!strcasecmp(Name, "DisplaySubtitles"))    DisplaySubtitles   = atoi(Value);
+   else if (!strcasecmp(Name, "SubtitleLanguages"))   return ParseLanguages(Value, SubtitleLanguages);
+@@ -632,6 +634,7 @@
+   Store("TimeTransponder",    TimeTransponder);
+   Store("MarginStart",        MarginStart);
+   Store("MarginStop",         MarginStop);
++  Store("DelTimeshiftRec",    DelTimeshiftRec);
+   StoreLanguages("AudioLanguages", AudioLanguages);
+   Store("DisplaySubtitles",   DisplaySubtitles);
+   StoreLanguages("SubtitleLanguages", SubtitleLanguages);
+diff -urNad vdr-1.6.0~/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0~/config.h	2008-07-25 23:55:15.000000000 +0200
++++ vdr-1.6.0/config.h	2008-07-25 23:57:56.000000000 +0200
+@@ -253,6 +253,7 @@
+   int TimeSource;
+   int TimeTransponder;
+   int MarginStart, MarginStop;
++  int DelTimeshiftRec;
+   int AudioLanguages[I18N_MAX_LANGUAGES + 1];
+   int DisplaySubtitles;
+   int SubtitleLanguages[I18N_MAX_LANGUAGES + 1];
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2008-07-25 23:55:15.000000000 +0200
++++ vdr-1.6.0/menu.c	2008-07-25 23:58:27.000000000 +0200
+@@ -3170,12 +3170,17 @@
+ // --- cMenuSetupRecord ------------------------------------------------------
+ 
+ class cMenuSetupRecord : public cMenuSetupBase {
++private:
++  const char *DelTimeshiftRecValues[3];
+ public:
+   cMenuSetupRecord(void);
+   };
+ 
+ cMenuSetupRecord::cMenuSetupRecord(void)
+ {
++  DelTimeshiftRecValues[0] = tr("request");
++  DelTimeshiftRecValues[1] = tr("no");
++  DelTimeshiftRecValues[2] = tr("yes");
+   SetSection(tr("Recording"));
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at start (min)"),     &data.MarginStart));
+   Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
+@@ -3198,6 +3203,7 @@
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show time"),                 &data.ShowRecTime));
+   Add(new cMenuEditBoolItem(tr("Setup.Recording$Show length"),               &data.ShowRecLength));
+   Add(new cMenuEditBoolItem(tr("Setup.CutTimePatch$Adapt start time to cutting marks"), &data.CutTimePatchEnabled));
++  Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"), &data.DelTimeshiftRec, 3, DelTimeshiftRecValues));
+ }
+ 
+ // --- cMenuSetupReplay ------------------------------------------------------
+@@ -4666,6 +4672,56 @@
+      currentReplayControl = NULL;
+ }
+ 
++void cReplayControl::Stop(void)
++{
++  int dummy;
++  bool playing = GetIndex(dummy, dummy, false);
++  cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
++
++  if (playing && rc && rc->InstantId()) {
++     isyslog("found Timeshiftrecording");
++
++     if ((Setup.DelTimeshiftRec != 0 ) || (Interface->Confirm(tr("Delete recording?")))) {
++        cRecordControl *rc = cRecordControls::GetRecordControl(fileName);
++        if (rc) {
++           cTimer *timer = rc->Timer();
++           if (timer) {
++              const char* reccmd_backup = cRecordingUserCommand::GetCommand();
++              cRecordingUserCommand::SetCommand(NULL);
++ 
++              timer->Skip();
++              cRecordControls::Process(time(NULL));
++              if (timer->IsSingleEvent()) {
++                 isyslog("deleting timer %s", *timer->ToDescr());
++                 Timers.Del(timer);
++                 }
++              Timers.SetModified();
++
++              // restore reccmd
++              cRecordingUserCommand::SetCommand(reccmd_backup);
++              }
++           }
++        isyslog("stop replaying %s", fileName);
++        cDvbPlayerControl::Stop();
++
++        if (Setup.DelTimeshiftRec != 1) {
++           cRecording *recording = Recordings.GetByName(fileName);;
++           if (recording) {
++              if (recording->Delete()) {
++                 Recordings.DelByName(fileName);
++                 ClearLastReplayed(fileName);
++                 return;
++                 }
++              else
++                 Skins.Message(mtError, tr("Error while deleting recording!"));
++              }
++           }
++        }
++     else
++        cDvbPlayerControl::Stop();
++     }
++}
++
+ void cReplayControl::SetRecording(const char *FileName, const char *Title)
+ {
+   free(fileName);
+@@ -5080,7 +5136,12 @@
+                            else
+                               Show();
+                            break;
+-            case kBack:    return osRecordings;
++            case kBack: {  cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
++                           if (rc && rc->InstantId())
++                              return osEnd;
++                           else
++                              return osRecordings;
++                        }
+             default:       return osUnknown;
+             }
+           }
+diff -urNad vdr-1.6.0~/menu.h vdr-1.6.0/menu.h
+--- vdr-1.6.0~/menu.h	2008-07-25 23:55:15.000000000 +0200
++++ vdr-1.6.0/menu.h	2008-07-25 23:55:15.000000000 +0200
+@@ -248,6 +248,7 @@
+ public:
+   cReplayControl(void);
+   virtual ~cReplayControl();
++  void Stop(void);
+   virtual cOsdObject *GetInfo(void);
+   virtual eOSState ProcessKey(eKeys Key);
+   virtual void Show(void);
+diff -urNad vdr-1.6.0~/recording.h vdr-1.6.0/recording.h
+--- vdr-1.6.0~/recording.h	2008-07-25 23:55:15.000000000 +0200
++++ vdr-1.6.0/recording.h	2008-07-25 23:55:15.000000000 +0200
+@@ -196,6 +196,7 @@
+ private:
+   static const char *command;
+ public:
++  static const char *GetCommand(void) { return command; }
+   static void SetCommand(const char *Command) { command = Command; }
+   static void InvokeCommand(const char *State, const char *RecordingFileName);
+   };
--- vdr-1.6.0.orig/debian/patches/00list.multipatch
+++ vdr-1.6.0/debian/patches/00list.multipatch
@@ -0,0 +1,106 @@
+03_cmdsubmenu
+04_newplugin
+06_default_svdrp_port_0
+09_sort_options
+10_dd-record-option
+11_sortrecordings
+12_osdbase-maxitems
+14_cap-memsize
+15_dvbplayer
+16_channels.conf.terr-fix
+17_vdr-maintenance-1.6.0-1
+18_vdr-maintenance-1.6.0-2
+19_dvb-api-v5
+20_gcc44_ftbfs
+
+81_Make_config
+82_valgrind
+
+99_ncursesw-include
+99_vdr-workaround-broken-sys-capability
+
+# Patch collection (replaces enAIO).
+opt-20_liemikuutio
+
+# Allows to tune to non-FTA channels provided by internal devices, 
+# like streamdev
+opt-21_internal-cam-devices
+
+# Easy editing of cutting marks
+# (Requires opt-20_liemikuutio!)
+# opt-22-x_edit_marks
+
+# The Jump patch allows automatic jumping over cutting marks.
+opt-24_jumpplay
+
+# Patch needed for the ttxtsubs plugin.
+opt-27_ttxtsubs
+
+# Fixes length calculation for radio recordings
+opt-28_audioindexer
+
+# Speed up zapping channels.
+# opt-29_syncearly
+opt-29_syncearly-audioindexer
+
+# Patch needed for the analogtv plugin.
+opt-30-x_analogtv
+
+# Makes VDR aware of the reelchannelscan plugin
+opt-31-x_reelchannelscan
+
+# Patch that shows if there is a valid setup value left or right with < and >.
+# opt-35_setup-show-valid
+
+# Patch needed for the menuorg plugin.
+opt-37-x_menuorg
+
+# Patch that suppresses double EPG entries.
+opt-38_disableDoubleEpgEntrys
+
+# Patch to disable normal epg update for specified channels.
+opt-39_noepg
+
+# Patch required by the IPTV and other plugins
+opt-40_pluginparam
+
+# Patch to show an info, if it is possible to record an event in the timer-info.
+opt-41-x_timer-info
+
+# Patch to allow plugins to replace the VDR mainmenus
+opt-42-x_MainMenuHooks
+
+# Shows remaining recording capacity in recordings menu.
+# (Requires opt-41-x_timer-info !)
+opt-43-x_recordshowfree
+
+# Patch needed for the rotor plugin.
+opt-44_rotor
+
+# Patch needed for the yaepg plugin.
+opt-45_yaepg
+
+# Patch for assigning special satellites to one dvb card.
+opt-47_sourcecaps
+
+# Patch for the PIN plugin
+opt-48-x_pin
+
+# Patch for the pvrinput plugin
+opt-49-x_pvrinput
+
+# Patch required for the GraphTFT plugin
+opt-50_graphtft
+
+# Modifies the start time of recordings to the first cutting mark
+# (disabled by default - enable in VDR's recording setup)
+opt-51_cuttime
+
+# Records into smaller files and uses hardlinks to speed up cutting
+opt-52_hard_link_cutter
+
+# Setup for AC3 transfer, QAM_256, disable primary tuner
+opt-53_dvbsetup
+
+# Offers the choice to delete timeshift recordings
+opt-54_deltimeshiftrec
--- vdr-1.6.0.orig/debian/patches/opt-40_pluginparam.dpatch
+++ vdr-1.6.0/debian/patches/opt-40_pluginparam.dpatch
@@ -0,0 +1,296 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-40_pluginparam.dpatch
+## from version 0.2.6 of the IPTV plugin
+## http://www.saunalahti.fi/~rahrenbe/vdr/iptv/
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch required for the IPTV plugin and other plugins
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/channels.c vdr-1.6.0/channels.c
+--- vdr-1.6.0~/channels.c	2009-05-03 16:09:13.000000000 +0200
++++ vdr-1.6.0/channels.c	2009-05-03 16:09:13.000000000 +0200
+@@ -166,6 +166,7 @@
+   shortName = strdup("");
+   provider = strdup("");
+   portalName = strdup("");
++  pluginParam = strdup("");
+   memset(&__BeginData__, 0, (char *)&__EndData__ - (char *)&__BeginData__);
+   inversion    = INVERSION_AUTO;
+   bandwidth    = BANDWIDTH_AUTO;
+@@ -187,6 +188,7 @@
+   shortName = NULL;
+   provider = NULL;
+   portalName = NULL;
++  pluginParam = NULL;
+   schedule     = NULL;
+   linkChannels = NULL;
+   refChannel   = NULL;
+@@ -215,6 +217,7 @@
+   free(shortName);
+   free(provider);
+   free(portalName);
++  free(pluginParam);
+ }
+ 
+ cChannel& cChannel::operator= (const cChannel &Channel)
+@@ -223,6 +226,7 @@
+   shortName = strcpyrealloc(shortName, Channel.shortName);
+   provider = strcpyrealloc(provider, Channel.provider);
+   portalName = strcpyrealloc(portalName, Channel.portalName);
++  pluginParam = strcpyrealloc(pluginParam, Channel.pluginParam);
+   memcpy(&__BeginData__, &Channel.__BeginData__, (char *)&Channel.__EndData__ - (char *)&Channel.__BeginData__);
+   return *this;
+ }
+@@ -280,9 +284,26 @@
+      transmission = Channel->transmission;
+      guard        = Channel->guard;
+      hierarchy    = Channel->hierarchy;
++     if (IsPlug())  pluginParam = strcpyrealloc(pluginParam, Channel->pluginParam);
+      }
+ }
+ 
++bool cChannel::SetPlugTransponderData(int Source, int Frequency, const char *PluginParam)
++{
++  if (source != Source || frequency != Frequency || (strcmp(pluginParam, PluginParam) != 0)) {
++     if (Number()) {
++        dsyslog("changing transponder data of channel %d from %s:%d:%s to %s:%d:%s", Number(), *cSource::ToString(source), frequency, pluginParam, *cSource::ToString(Source), Frequency, PluginParam);
++        modification |= CHANNELMOD_TRANSP;
++        Channels.SetModified();
++        }
++     source = Source;
++     frequency = Frequency;
++     pluginParam = strcpyrealloc(pluginParam, PluginParam);
++     schedule = NULL;
++     }
++  return true;
++}
++
+ bool cChannel::SetSatTransponderData(int Source, int Frequency, char Polarization, int Srate, int CoderateH)
+ {
+   // Workarounds for broadcaster stupidity:
+@@ -407,6 +428,18 @@
+      }
+ }
+ 
++void cChannel::SetPluginParam(const char *PluginParam)
++{
++  if (!isempty(PluginParam) && strcmp(pluginParam, PluginParam) != 0) {
++     if (Number()) {
++        dsyslog("changing plugin parameters of channel %d from '%s' to '%s'", Number(), pluginParam, PluginParam);
++        modification |= CHANNELMOD_TRANSP;
++        Channels.SetModified();
++        }
++     pluginParam = strcpyrealloc(pluginParam, PluginParam);
++     }
++}
++
+ #define STRDIFF 0x01
+ #define VALDIFF 0x02
+ 
+@@ -593,7 +626,7 @@
+   if (isdigit(type))
+      type = 'S';
+ #define ST(s) if (strchr(s, type))
+-  char buffer[64];
++  char buffer[256];
+   char *q = buffer;
+   *q = 0;
+   ST(" S ")  q += sprintf(q, "%c", polarization);
+@@ -605,6 +638,7 @@
+   ST("  T")  q += PrintParameter(q, 'T', MapToUser(transmission, TransmissionValues));
+   ST("  T")  q += PrintParameter(q, 'G', MapToUser(guard, GuardValues));
+   ST("  T")  q += PrintParameter(q, 'Y', MapToUser(hierarchy, HierarchyValues));
++  ST("P  ")  snprintf(buffer, sizeof(buffer), "%s", pluginParam);
+   return buffer;
+ }
+ 
+@@ -626,7 +660,7 @@
+ 
+ bool cChannel::StringToParameters(const char *s)
+ {
+-  while (s && *s) {
++  while (s && *s && !IsPlug()) {
+         switch (toupper(*s)) {
+           case 'B': s = ParseParameter(s, bandwidth, BandwidthValues); break;
+           case 'C': s = ParseParameter(s, coderateH, CoderateValues); break;
+@@ -736,7 +770,7 @@
+         dpids[0] = 0;
+         ok = false;
+         if (parambuf && sourcebuf && vpidbuf && apidbuf) {
+-           ok = StringToParameters(parambuf) && (source = cSource::FromString(sourcebuf)) >= 0;
++           ok = ((source = cSource::FromString(sourcebuf)) >= 0) && StringToParameters(parambuf);
+ 
+            char *p = strchr(vpidbuf, '+');
+            if (p)
+@@ -827,6 +861,7 @@
+            shortName = strcpyrealloc(shortName, p);
+            }
+         name = strcpyrealloc(name, namebuf);
++        if (IsPlug()) pluginParam = strcpyrealloc(pluginParam, parambuf);
+ 
+         free(parambuf);
+         free(sourcebuf);
+diff -urNad vdr-1.6.0~/channels.h vdr-1.6.0/channels.h
+--- vdr-1.6.0~/channels.h	2009-05-03 16:08:42.000000000 +0200
++++ vdr-1.6.0/channels.h	2009-05-03 16:09:13.000000000 +0200
+@@ -114,6 +114,7 @@
+   char *shortName;
+   char *provider;
+   char *portalName;
++  char *pluginParam;
+   int __BeginData__;
+   int frequency; // MHz
+   int source;
+@@ -165,6 +166,7 @@
+   int Frequency(void) const { return frequency; } ///< Returns the actual frequency, as given in 'channels.conf'
+   int Transponder(void) const;                    ///< Returns the transponder frequency in MHz, plus the polarization in case of sat
+   static int Transponder(int Frequency, char Polarization); ///< builds the transponder from the given Frequency and Polarization
++  const char *PluginParam(void) const { return pluginParam; }
+   int Source(void) const { return source; }
+   int Srate(void) const { return srate; }
+   int Vpid(void) const { return vpid; }
+@@ -199,6 +201,7 @@
+   int Hierarchy(void) const { return hierarchy; }
+   const cLinkChannels* LinkChannels(void) const { return linkChannels; }
+   const cChannel *RefChannel(void) const { return refChannel; }
++  bool IsPlug(void) const { return cSource::IsPlug(source); }
+   bool IsCable(void) const { return cSource::IsCable(source); }
+   bool IsSat(void) const { return cSource::IsSat(source); }
+   bool IsTerr(void) const { return cSource::IsTerr(source); }
+@@ -206,12 +209,14 @@
+   bool HasTimer(void) const;
+   int Modification(int Mask = CHANNELMOD_ALL);
+   void CopyTransponderData(const cChannel *Channel);
++  bool SetPlugTransponderData(int Source, int Frequency, const char *PluginParam);
+   bool SetSatTransponderData(int Source, int Frequency, char Polarization, int Srate, int CoderateH);
+   bool SetCableTransponderData(int Source, int Frequency, int Modulation, int Srate, int CoderateH);
+   bool SetTerrTransponderData(int Source, int Frequency, int Bandwidth, int Modulation, int Hierarchy, int CodeRateH, int CodeRateL, int Guard, int Transmission);
+   void SetId(int Nid, int Tid, int Sid, int Rid = 0);
+   void SetName(const char *Name, const char *ShortName, const char *Provider);
+   void SetPortalName(const char *PortalName);
++  void SetPluginParam(const char *PluginParam);
+   void SetPids(int Vpid, int Ppid, int *Apids, char ALangs[][MAXLANGCODE2], int *Dpids, char DLangs[][MAXLANGCODE2], int *Spids, char SLangs[][MAXLANGCODE2], int Tpid);
+   void SetCaIds(const int *CaIds); // list must be zero-terminated
+   void SetCaDescriptors(int Level);
+diff -urNad vdr-1.6.0~/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0~/config.h	2009-05-03 16:09:13.000000000 +0200
++++ vdr-1.6.0/config.h	2009-05-03 16:09:13.000000000 +0200
+@@ -30,6 +30,8 @@
+ #define APIVERSION  "1.6.0"
+ #define APIVERSNUM   10600  // Version * 10000 + Major * 100 + Minor
+ 
++#define PLUGINPARAMPATCHVERSNUM 1
++
+ // When loading plugins, VDR searches them by their APIVERSION, which
+ // may be smaller than VDRVERSION in case there have been no changes to
+ // VDR header files since the last APIVERSION. This allows compiled
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2009-05-03 16:09:13.000000000 +0200
++++ vdr-1.6.0/menu.c	2009-05-03 16:09:13.000000000 +0200
+@@ -256,6 +256,7 @@
+   cChannel *channel;
+   cChannel data;
+   char name[256];
++  char pluginParam[256];
+   void Setup(void);
+ public:
+   cMenuEditChannel(cChannel *Channel, bool New = false);
+@@ -288,6 +289,7 @@
+ 
+   // Parameters for all types of sources:
+   strn0cpy(name, data.name, sizeof(name));
++  strn0cpy(pluginParam, data.pluginParam, sizeof(pluginParam));
+   Add(new cMenuEditStrItem( tr("Name"),          name, sizeof(name)));
+   Add(new cMenuEditSrcItem( tr("Source"),       &data.source));
+   Add(new cMenuEditIntItem( tr("Frequency"),    &data.frequency));
+@@ -318,6 +320,7 @@
+   ST("  T")  Add(new cMenuEditMapItem( tr("Transmission"), &data.transmission, TransmissionValues));
+   ST("  T")  Add(new cMenuEditMapItem( tr("Guard"),        &data.guard,        GuardValues));
+   ST("  T")  Add(new cMenuEditMapItem( tr("Hierarchy"),    &data.hierarchy,    HierarchyValues, tr("none")));
++  ST("P  ")  Add(new cMenuEditStrItem( tr("Parameters"),    pluginParam, sizeof(pluginParam), tr(FileNameChars)));
+ 
+   SetCurrent(Get(current));
+   Display();
+@@ -332,6 +335,7 @@
+      if (Key == kOk) {
+         if (Channels.HasUniqueChannelID(&data, channel)) {
+            data.name = strcpyrealloc(data.name, name);
++           data.pluginParam = strcpyrealloc(data.pluginParam, pluginParam);
+            if (channel) {
+               *channel = data;
+               isyslog("edited channel %d %s", channel->Number(), *data.ToText());
+diff -urNad vdr-1.6.0~/po/fi_FI.po vdr-1.6.0/po/fi_FI.po
+--- vdr-1.6.0~/po/fi_FI.po	2009-05-03 16:09:12.000000000 +0200
++++ vdr-1.6.0/po/fi_FI.po	2009-05-03 16:09:42.000000000 +0200
+@@ -1049,3 +1049,6 @@
+ 
+ msgid "Setup.Recording$Show length"
+ msgstr "Nyt tallenteen kesto"
++
++msgid "Parameters"
++msgstr "Parametrit"
+diff -urNad vdr-1.6.0~/po/fr_FR.po vdr-1.6.0/po/fr_FR.po
+--- vdr-1.6.0~/po/fr_FR.po	2009-05-03 16:09:13.000000000 +0200
++++ vdr-1.6.0/po/fr_FR.po	2009-05-03 16:10:02.000000000 +0200
+@@ -1079,3 +1079,6 @@
+ 
+ msgid "Setup.Recording$Show length"
+ msgstr "Montrer la longueur de l'enregistrement"
++
++msgid "Parameters"
++msgstr "Paramtres"
+diff -urNad vdr-1.6.0~/sources.c vdr-1.6.0/sources.c
+--- vdr-1.6.0~/sources.c	2009-05-03 16:08:42.000000000 +0200
++++ vdr-1.6.0/sources.c	2009-05-03 16:09:13.000000000 +0200
+@@ -37,6 +37,7 @@
+   char buffer[16];
+   char *q = buffer;
+   switch (Code & st_Mask) {
++    case stPlug:  *q++ = 'P'; break;
+     case stCable: *q++ = 'C'; break;
+     case stSat:   *q++ = 'S';
+                   {
+@@ -56,6 +57,7 @@
+ {
+   int type = stNone;
+   switch (toupper(*s)) {
++    case 'P': type = stPlug;  break;
+     case 'C': type = stCable; break;
+     case 'S': type = stSat;   break;
+     case 'T': type = stTerr;  break;
+diff -urNad vdr-1.6.0~/sources.conf vdr-1.6.0/sources.conf
+--- vdr-1.6.0~/sources.conf	2009-05-03 16:09:12.000000000 +0200
++++ vdr-1.6.0/sources.conf	2009-05-03 16:09:13.000000000 +0200
+@@ -194,3 +194,7 @@
+ # Terrestrial
+ 
+ T       Terrestrial
++
++# Plugin
++
++P       Plugin
+diff -urNad vdr-1.6.0~/sources.h vdr-1.6.0/sources.h
+--- vdr-1.6.0~/sources.h	2009-05-03 16:08:42.000000000 +0200
++++ vdr-1.6.0/sources.h	2009-05-03 16:09:13.000000000 +0200
+@@ -16,10 +16,11 @@
+ public:
+   enum eSourceType {
+     stNone  = 0x0000,
++    stPlug  = 0x2000,
+     stCable = 0x4000,
+     stSat   = 0x8000,
+     stTerr  = 0xC000,
+-    st_Mask = 0xC000,
++    st_Mask = 0xE000,
+     st_Neg  = 0x0800,
+     st_Pos  = 0x07FF,
+     };
+@@ -35,6 +36,7 @@
+   static cString ToString(int Code);
+   static int FromString(const char *s);
+   static int FromData(eSourceType SourceType, int Position = 0, bool East = false);
++  static bool IsPlug(int Code) { return (Code & st_Mask) == stPlug; }
+   static bool IsCable(int Code) { return (Code & st_Mask) == stCable; }
+   static bool IsSat(int Code) { return (Code & st_Mask) == stSat; }
+   static bool IsTerr(int Code) { return (Code & st_Mask) == stTerr; }
--- vdr-1.6.0.orig/debian/patches/opt-48-x_pin.dpatch
+++ vdr-1.6.0/debian/patches/opt-48-x_pin.dpatch
@@ -0,0 +1,628 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-48_pin.dpatch by Jrg Wendel (Horchi)
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to VDR-1.5.8 with liemikuutio, menuorg and MainMenuHooks patches
+##   - adapted to VDR-1.5.10 with liemikuutio, menuorg and MainMenuHooks patches
+##   - adapted to vdr-1.5.13-liemikuutio-1.17.diff.gz
+## Tobias Grimm <tg@e-tobi.net>##
+##   - adapted to VDR 1.5.15
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch for the PIN plugin from version 0.1.7 of the Plugin
+## (vdr-1.4.5.diff)
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/Makefile vdr-1.6.0/Makefile
+--- vdr-1.6.0~/Makefile	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/Makefile	2010-01-14 01:40:15.000000000 +0100
+@@ -45,6 +45,8 @@
+ 
+ OBJS += vdrttxtsubshooks.o
+ 
++OBJS += childlock.o
++
+ ifndef NO_KBD
+ DEFINES += -DREMOTE_KBD
+ endif
+diff -urNad vdr-1.6.0~/childlock.c vdr-1.6.0/childlock.c
+--- vdr-1.6.0~/childlock.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0/childlock.c	2010-01-14 01:40:15.000000000 +0100
+@@ -0,0 +1,166 @@
++#include "childlock.h"
++#include "childlockservice.h"
++#include "plugin.h"
++
++using namespace PinPatch;
++
++IChildLockService* ChildLock::_cachedChildLockService = NULL;
++INotificationService* ChildLock::_cachedNotificationService = NULL;
++
++IChildLockService* ChildLock::ChildLockService()
++{
++    if (!_cachedChildLockService)
++    {
++        IChildLockService* childLockService;
++
++        if (cPluginManager::CallFirstService(CHILDLOCK_SERVICE_ID, &childLockService))
++        {
++            _cachedChildLockService = childLockService;
++        }
++        else
++        {
++            _cachedChildLockService = NULL;
++        }
++    }
++
++    return _cachedChildLockService;
++}
++
++bool ChildLock::IsUnlocked()
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsUnlocked();
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsMenuProtected(const char* MenuName)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsMenuProtected(MenuName);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsChannelProtected(const cChannel* Channel)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsChannelProtected(Channel);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsRecordingProtected(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsRecordingProtected(Recording, Name, Base, isDirectory);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsPluginProtected(cPlugin* Plugin)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsPluginProtected(Plugin);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsMenuHidden(const char* MenuName)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsMenuHidden(MenuName);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsPluginHidden(cPlugin* Plugin)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsPluginHidden(Plugin);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++bool ChildLock::IsRecordingHidden(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory)
++{
++    if (IChildLockService* childLockService = ChildLockService())
++    {
++        return childLockService->IsRecordingHidden(Recording, Name, Base, isDirectory);
++    }
++    else
++    {
++        return false;
++    }
++}
++
++INotificationService* ChildLock::NotificationService()
++{
++    if (!_cachedNotificationService)
++    {
++        INotificationService* notificationService;
++
++        if (cPluginManager::CallFirstService(NOTIFICATION_SERVICE_ID, &notificationService))
++        {
++            _cachedNotificationService = notificationService;
++        }
++        else
++        {
++            _cachedNotificationService = NULL;
++        }
++    }
++
++    return _cachedNotificationService;
++}
++
++void ChildLock::NotifyTimerCreation(cTimer* Timer, const cEvent *Event)
++{
++    if (INotificationService* notificationService = NotificationService())
++    {
++        notificationService->NotifyTimerCreation(Timer, Event);
++    }
++}
++
++void ChildLock::NotifyRecordingStart(const char* FileName)
++{
++    if (INotificationService* notificationService = NotificationService())
++    {
++        notificationService->NotifyRecordingStart(FileName);
++    }
++}
++
++void ChildLock::NotifyUserAction(const eKeys key, const cOsdObject* Interact)
++{
++    if (INotificationService* notificationService = NotificationService())
++    {
++        notificationService->NotifyUserAction(key, Interact);
++    }
++}
+diff -urNad vdr-1.6.0~/childlock.h vdr-1.6.0/childlock.h
+--- vdr-1.6.0~/childlock.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0/childlock.h	2010-01-14 01:40:15.000000000 +0100
+@@ -0,0 +1,47 @@
++#ifndef __CHILDLOCK_H
++#define __CHILDLOCK_H
++
++#include "keys.h"
++
++class cChannel;
++class cRecording;
++class cPlugin;
++class cTimer;
++class cEvent;
++class cOsdObject;
++
++namespace PinPatch
++{
++
++class IChildLockService;
++class INotificationService;
++
++class ChildLock
++{
++    private:
++        static IChildLockService* _cachedChildLockService;
++        static INotificationService* _cachedNotificationService;
++        
++    private:
++        static IChildLockService* ChildLockService();
++        static INotificationService* NotificationService();
++
++    public:
++        static bool IsUnlocked();
++
++        static bool IsMenuProtected(const char* MenuName);
++        static bool IsChannelProtected(const cChannel* Channel);
++        static bool IsRecordingProtected(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory);
++        static bool IsPluginProtected(cPlugin* Plugin);
++        
++        static bool IsMenuHidden(const char* MenuName);
++        static bool IsPluginHidden(cPlugin* Plugin);
++        static bool IsRecordingHidden(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory);
++        
++        static void NotifyTimerCreation(cTimer* Timer, const cEvent *Event);
++        static void NotifyRecordingStart(const char* FileName);
++        static void NotifyUserAction(const eKeys key, const cOsdObject* Interact);
++};
++
++};
++#endif
+diff -urNad vdr-1.6.0~/childlockservice.h vdr-1.6.0/childlockservice.h
+--- vdr-1.6.0~/childlockservice.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0/childlockservice.h	2010-01-14 01:40:15.000000000 +0100
+@@ -0,0 +1,46 @@
++#ifndef __CHILDLOCKSERVICE_H
++#define __CHILDLOCKSERVICE_H
++
++#include "keys.h"
++
++class cChannel;
++class cRecording;
++class cPlugin;
++class cTimer;
++class cEvent;
++class cOsdObject;
++
++namespace PinPatch
++{
++
++#define CHILDLOCK_SERVICE_ID "ChildLockService-v0.1::ChildLockService"
++
++class IChildLockService
++{
++    public:
++        virtual ~IChildLockService() {};
++        virtual bool IsUnlocked() = 0;
++
++        virtual bool IsMenuProtected(const char* MenuName) = 0;
++        virtual bool IsChannelProtected(const cChannel* Channel) = 0;
++        virtual bool IsRecordingProtected(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory) = 0;
++        virtual bool IsPluginProtected(cPlugin* Plugin) = 0;
++        
++        virtual bool IsMenuHidden(const char* MenuName) = 0;
++        virtual bool IsPluginHidden(cPlugin* Plugin) = 0;
++        virtual bool IsRecordingHidden(const cRecording* Recording, const char* Name, const char* Base, bool isDirectory) = 0;
++};
++
++#define NOTIFICATION_SERVICE_ID "PinPlugin-v0.1::NotificationService"
++
++class INotificationService
++{
++    public:
++        virtual ~INotificationService() {};
++        virtual void NotifyTimerCreation(cTimer* Timer, const cEvent *Event) = 0;
++        virtual void NotifyRecordingStart(const char* FileName) = 0;
++        virtual void NotifyUserAction(const eKeys key, const cOsdObject* Interact) = 0;
++};
++
++};
++#endif
+diff -urNad vdr-1.6.0~/device.c vdr-1.6.0/device.c
+--- vdr-1.6.0~/device.c	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/device.c	2010-01-14 01:40:15.000000000 +0100
+@@ -18,6 +18,7 @@
+ #include "receiver.h"
+ #include "status.h"
+ #include "transfer.h"
++#include "childlock.h"
+ 
+ // --- cLiveSubtitle ---------------------------------------------------------
+ 
+@@ -769,6 +770,7 @@
+      cChannel *channel;
+      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
+            // try only channels which are currently available
++        if (PinPatch::ChildLock::IsChannelProtected(channel) == false)
+            if (GetDevice(channel, 0, true))
+               break;
+            n = channel->Number() + Direction;
+@@ -790,6 +792,9 @@
+ 
+ eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
+ {
++  if (LiveView && PinPatch::ChildLock::IsChannelProtected(Channel) == true)
++     return scrNotAvailable;
++
+   if (LiveView) {
+      StopReplay();
+      DELETENULL(liveSubtitle);
+diff -urNad vdr-1.6.0~/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0~/menu.c	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/menu.c	2010-01-14 01:40:15.000000000 +0100
+@@ -32,6 +32,7 @@
+ #include "vdrttxtsubshooks.h"
+ #include "videodir.h"
+ #include "menuorgpatch.h"
++#include "childlock.h"
+ 
+ #define MAXWAIT4EPGINFO   3 // seconds
+ #define MODETIMEOUT       3 // seconds
+@@ -757,6 +758,9 @@
+      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
+      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+ 
++     if (PinPatch::ChildLock::IsUnlocked())
++       Add(new cMenuEditBitItem(tr("Timer$Childlock"), &data.flags, tfProtected));
++
+      char* p = strrchr(data.file, '~');
+      if (p) {
+         p++;
+@@ -2342,7 +2346,8 @@
+   for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
+       if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == '~')) {
+          cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
+-         if (*Item->Text() && (!LastItem || strcmp(Item->Text(), LastItemText) != 0)) {
++         if ((*Item->Text() && (!LastItem || strcmp(Item->Text(), LastItemText) != 0))
++            && (!PinPatch::ChildLock::IsRecordingHidden(GetRecording(Item), Item->Name(), base, Item->IsDirectory()))) {
+             Add(Item);
+             LastItem = Item;
+             free(LastItemText);
+@@ -2405,6 +2410,9 @@
+ {
+   cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
+   if (ri) {
++     if (PinPatch::ChildLock::IsRecordingProtected(GetRecording(ri), ri->Name(), base, ri->IsDirectory()) == true)
++        return osContinue;
++
+      if (ri->IsDirectory())
+         Open();
+      else {
+@@ -3437,6 +3445,8 @@
+             }
+          else if ((*i)->IsPluginItem()) {
+             const char *item = (*i)->PluginMenuEntry();
++            cPlugin *plugin = cPluginManager::GetPlugin((*i)->PluginIndex());
++            if (!PinPatch::ChildLock::IsPluginHidden(plugin))
+             if (item)
+               osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
+             }
+@@ -3451,9 +3461,13 @@
+ 
+   // Basic menu items:
+ 
++  if (!PinPatch::ChildLock::IsMenuHidden("Schedule"))
+   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
++  if (!PinPatch::ChildLock::IsMenuHidden("Channels"))
+   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
++  if (!PinPatch::ChildLock::IsMenuHidden("Timers"))
+   Add(new cOsdItem(hk(tr("Timers")),     osTimers));
++  if (!PinPatch::ChildLock::IsMenuHidden("Recordings"))
+   Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+ 
+   // Plugins:
+@@ -3461,18 +3475,22 @@
+   for (int i = 0; ; i++) {
+       cPlugin *p = cPluginManager::GetPlugin(i);
+       if (p) {
++         if (!PinPatch::ChildLock::IsPluginHidden(p)) {
+          const char *item = p->MainMenuEntry();
+          if (item)
+             Add(new cMenuPluginItem(hk(item), i));
+          }
++         }
+       else
+          break;
+       }
+ 
+   // More basic menu items:
+ 
++  if (!PinPatch::ChildLock::IsMenuHidden("Setup"))
+   Add(new cOsdItem(hk(tr("Setup")),      osSetup));
+   if (Commands.Count())
++     if (!PinPatch::ChildLock::IsMenuHidden("Commands"))
+      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+ 
+   }
+@@ -3553,6 +3571,11 @@
+   eOSState state = cOsdMenu::ProcessKey(Key);
+   HadSubMenu |= HasSubMenu();
+ 
++  cOsdItem* item = Get(Current());
++  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
++     if (PinPatch::ChildLock::IsMenuProtected(item->Text()))
++        return osContinue;
++
+   cOsdMenu *menu = NULL;
+   switch (state) {
+     case osSchedule:
+@@ -3599,6 +3622,7 @@
+                          if (item) {
+                             cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
+                             if (p) {
++                               if (!PinPatch::ChildLock::IsPluginProtected(p)) {
+                                cOsdObject *menu = p->MainMenuAction();
+                                if (menu) {
+                                   if (menu->IsMenu())
+@@ -3610,6 +3634,7 @@
+                                   }
+                                }
+                             }
++                         }
+                          state = osEnd;
+                        }
+                        break;
+@@ -3812,6 +3837,7 @@
+   if (Direction) {
+      while (Channel) {
+            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
++        if (PinPatch::ChildLock::IsChannelProtected(Channel) == false)                                                       
+            if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, 0, true))
+               return Channel;
+            }
+@@ -4446,6 +4472,7 @@
+            for (int i = 0; i < MAXRECORDCONTROLS; i++) {
+                if (!RecordControls[i]) {
+                   RecordControls[i] = new cRecordControl(device, Timer, Pause);
++                  PinPatch::ChildLock::NotifyRecordingStart(RecordControls[i]->FileName());
+                   return RecordControls[i]->Process(time(NULL));
+                   }
+                }
+diff -urNad vdr-1.6.0~/po/de_DE.po vdr-1.6.0/po/de_DE.po
+--- vdr-1.6.0~/po/de_DE.po	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/po/de_DE.po	2010-01-14 01:40:15.000000000 +0100
+@@ -360,6 +360,9 @@
+ msgid "Lifetime"
+ msgstr "Lebensdauer"
+ 
++msgid "Timer$Childlock"
++msgstr "Gesichert"
++
+ msgid "File"
+ msgstr "Datei"
+ 
+diff -urNad vdr-1.6.0~/po/fr_FR.po vdr-1.6.0/po/fr_FR.po
+--- vdr-1.6.0~/po/fr_FR.po	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/po/fr_FR.po	2010-01-14 01:40:15.000000000 +0100
+@@ -366,6 +366,9 @@
+ msgid "Lifetime"
+ msgstr "Dure de vie"
+ 
++msgid "Timer$Childlock"
++msgstr "Adulte"
++
+ msgid "File"
+ msgstr "Fichier"
+ 
+diff -urNad vdr-1.6.0~/timers.c vdr-1.6.0/timers.c
+--- vdr-1.6.0~/timers.c	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/timers.c	2010-01-14 01:40:15.000000000 +0100
+@@ -16,6 +16,7 @@
+ #include "recording.h"
+ #include "remote.h"
+ #include "status.h"
++#include "childlock.h"
+ 
+ #define VFAT_MAX_FILENAME 40 // same as MAX_SUBTITLE_LENGTH in recording.c
+ 
+@@ -27,6 +28,7 @@
+ 
+ cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel)
+ {
++  aux = NULL;
+   startTime = stopTime = 0;
+   lastSetEvent = 0;
+   recording = pending = inVpsMargin = false;
+@@ -47,7 +49,6 @@
+   priority = Pause ? Setup.PausePriority : Setup.DefaultPriority;
+   lifetime = Pause ? Setup.PauseLifetime : Setup.DefaultLifetime;
+   *file = 0;
+-  aux = NULL;
+   event = NULL;
+   if (Instant && channel)
+      snprintf(file, sizeof(file), "%s%s", Setup.MarkInstantRecord ? "@" : "", *Setup.NameInstantRecord ? Setup.NameInstantRecord : channel->Name());
+@@ -55,6 +56,7 @@
+ 
+ cTimer::cTimer(const cEvent *Event)
+ {
++  aux = NULL;
+   startTime = stopTime = 0;
+   lastSetEvent = 0;
+   recording = pending = inVpsMargin = false;
+@@ -83,8 +85,8 @@
+   const char *Title = Event->Title();
+   if (!isempty(Title))
+      Utf8Strn0Cpy(file, Event->Title(), sizeof(file));
+-  aux = NULL;
+   event = NULL; // let SetEvent() be called to get a log message
++  PinPatch::ChildLock::NotifyTimerCreation(this, Event);
+ }
+ 
+ cTimer::cTimer(const cTimer &Timer)
+@@ -259,6 +261,8 @@
+   return ""; // not NULL, so the caller can always use the result
+ }
+ 
++#define AUX_STR_PROTECTED "<pin-plugin><protected>yes</protected></pin-plugin>"
++
+ bool cTimer::Parse(const char *s)
+ {
+   char *channelbuffer = NULL;
+@@ -313,6 +317,8 @@
+         result = false;
+         }
+      }
++  if (aux && strstr(aux, AUX_STR_PROTECTED))
++    SetFlags(tfProtected);
+   free(channelbuffer);
+   free(daybuffer);
+   free(filebuffer);
+@@ -582,6 +588,26 @@
+ void cTimer::SetFlags(uint Flags)
+ {
+   flags |= Flags;
++
++  char* tmp = NULL;
++  char* position;
++
++  if (HasFlags(tfProtected)) {
++     if (!aux || !strstr(aux, AUX_STR_PROTECTED)) {
++        if (aux) {
++           tmp = strdup(aux);
++           free(aux);
++           }
++        asprintf(&aux,"%s%s", tmp ? tmp : "", AUX_STR_PROTECTED);
++        }
++     }
++  else if (aux && (position = strstr(aux, AUX_STR_PROTECTED))) {
++     asprintf(&tmp, "%.*s%s", position-aux, aux, position+strlen(AUX_STR_PROTECTED));
++     free(aux);
++     aux = strdup(tmp);
++     }
++
++  free(tmp);
+ }
+ 
+ void cTimer::ClrFlags(uint Flags)
+diff -urNad vdr-1.6.0~/timers.h vdr-1.6.0/timers.h
+--- vdr-1.6.0~/timers.h	2008-02-16 15:33:23.000000000 +0100
++++ vdr-1.6.0/timers.h	2010-01-14 01:40:15.000000000 +0100
+@@ -20,6 +20,7 @@
+                    tfInstant   = 0x0002,
+                    tfVps       = 0x0004,
+                    tfRecording = 0x0008,
++                   tfProtected = 0x8000,
+                    tfAll       = 0xFFFF,
+                  };
+ enum eTimerMatch { tmNone, tmPartial, tmFull };
+diff -urNad vdr-1.6.0~/vdr.c vdr-1.6.0/vdr.c
+--- vdr-1.6.0~/vdr.c	2010-01-14 01:40:15.000000000 +0100
++++ vdr-1.6.0/vdr.c	2010-01-14 01:40:50.000000000 +0100
+@@ -66,6 +66,7 @@
+ // include this one last due to some versions of it being buggy:
+ // http://www.linuxtv.org/pipermail/vdr/2009-August/021194.html
+ #include <sys/capability.h>
++#include "childlock.h"
+ 
+ #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
+ #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
+@@ -924,6 +925,7 @@
+         cOsdObject *Interact = Menu ? Menu : cControl::Control();
+         eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
+         if (ISREALKEY(key)) {
++           PinPatch::ChildLock::NotifyUserAction(key, Interact);
+            EITScanner.Activity();
+            // Cancel shutdown countdown:
+            if (ShutdownHandler.countdown)
+@@ -996,10 +998,12 @@
+                      cControl::Control()->Hide();
+                   cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
+                   if (plugin) {
++                   if (!PinPatch::ChildLock::IsPluginProtected(plugin)) {
+                      Menu = plugin->MainMenuAction();
+                      if (Menu)
+                         Menu->Show();
+                      }
++                  }
+                   else
+                      esyslog("ERROR: unknown plugin '%s'", PluginName);
+                   }
+@@ -1209,9 +1213,11 @@
+              // Instant resume of the last viewed recording:
+              case kPlay:
+                   if (cReplayControl::LastReplayed()) {
++                     if (PinPatch::ChildLock::IsRecordingProtected(0, cReplayControl::LastReplayed(), 0, false) == false) {
+                      cControl::Shutdown();
+                      cControl::Launch(new cReplayControl);
+                      }
++                     }
+                   break;
+              default:    break;
+              }
--- vdr-1.6.0.orig/debian/patches/81_Make_config.dpatch
+++ vdr-1.6.0/debian/patches/81_Make_config.dpatch
@@ -0,0 +1,40 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## 81_Make_config.dpatch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Add Make.config to compile debug versions.
+
+@DPATCH@
+diff -urNad vdr-1.6.0~/Make.config vdr-1.6.0/Make.config
+--- vdr-1.6.0~/Make.config	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0/Make.config	2008-04-13 12:11:55.000000000 +0200
+@@ -0,0 +1,28 @@
++#
++# The following compiler settings are required for Debian builds and will be
++# included by the Makefile of VDR and most plugins.
++#
++
++CFLAGS   = -g -Wall
++CXXFLAGS = -g -Wall -Woverloaded-virtual -Wno-parentheses
++
++ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
++    CXXFLAGS += -O0
++    CFLAGS += -O0
++else
++    CXXFLAGS += -O2
++    CFLAGS += -O2
++endif
++
++ifndef BUILDVDR
++    # Required for plugins only, not for VDR itself
++    CXXFLAGS += -fPIC
++    CFLAGS += -fPIC
++endif
++
++ifdef VDRDEBUG
++    # Required for special debug build of VDR, where plugins are 
++    # not unloaded at runtime to give valgrind a chance to detect
++    # memory leaks in the plugin libs
++    DEFINES += -DVDRDEBUG
++endif
--- vdr-1.6.0.orig/debian/patches/opt-30-x_analogtv.dpatch
+++ vdr-1.6.0/debian/patches/opt-30-x_analogtv.dpatch
@@ -0,0 +1,25 @@
+#!/bin/sh /usr/share/dpatch/dpatch-run
+
+## opt-30-x_analogtv.dpatch by Andreas Kool <akool@gmx.de>
+##
+## extracted from the analogtv plugin 0.3.6
+## original file: vdr-1.3.0.patch
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is needed for the analogtv plugin.
+
+@DPATCH@
+--- vdr-1.3.0.orig/channels.c	2004-01-04 13:28:49.000000000 +0100
++++ vdr-1.3.0/channels.c	2004-01-04 18:50:40.000000000 +0100
+@@ -347,9 +347,9 @@
+   ST(" S ")  q += sprintf(q, "%c", polarization);
+   ST("CST")  q += PrintParameter(q, 'I', MapToUser(inversion, InversionValues));
+   ST("CST")  q += PrintParameter(q, 'C', MapToUser(coderateH, CoderateValues));
+-  ST("  T")  q += PrintParameter(q, 'D', MapToUser(coderateL, CoderateValues));
++  ST("C T")  q += PrintParameter(q, 'D', MapToUser(coderateL, CoderateValues));
+   ST("C T")  q += PrintParameter(q, 'M', MapToUser(modulation, ModulationValues));
+-  ST("  T")  q += PrintParameter(q, 'B', MapToUser(bandwidth, BandwidthValues));
++  ST("C T")  q += PrintParameter(q, 'B', MapToUser(bandwidth, BandwidthValues));
+   ST("  T")  q += PrintParameter(q, 'T', MapToUser(transmission, TransmissionValues));
+   ST("  T")  q += PrintParameter(q, 'G', MapToUser(guard, GuardValues));
+   ST("  T")  q += PrintParameter(q, 'Y', MapToUser(hierarchy, HierarchyValues));
--- vdr-1.6.0.orig/debian/patches/16_channels.conf.terr-fix.dpatch
+++ vdr-1.6.0/debian/patches/16_channels.conf.terr-fix.dpatch
@@ -0,0 +1,20 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+
+## 16_channels.conf.terr-fix.dpatch by Thomas Schmidt <tschmidt@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Removes Ch 14 fom example channels.conf.terr, because the entry is 
+## DP: invalid (reported as Ubuntu Bug #45721)
+
+@DPATCH@
+diff -urNad vdr-1.4.1~/channels.conf.terr vdr-1.4.1/channels.conf.terr
+--- vdr-1.4.1~/channels.conf.terr	2005-01-16 16:54:57.000000000 +0100
++++ vdr-1.4.1/channels.conf.terr	2006-08-13 15:19:13.000000000 +0200
+@@ -9,7 +9,6 @@
+ bid-up.tv (TV):561833:I0C23D0M64B8T2G32Y0:T:27500:6273:6274:0:0:14272:0:0:0
+ CBBC (TV):505833:I0C34D0M16B8T2G32Y0:T:27500:620:621,622:0:0:4671:0:0:0
+ Cbeebies (TV):529833:I0C34D0M16B8T2G32Y0:T:27500:201:401,402:0:0:16960:0:0:0
+-Ch 14 (TV):481833:I0C23D0M64B8T2G32Y0:T:27500:2840:2841:2843:0:0:8800:0:0
+ Ch 32 (TV):537833:I0C34D0M16B8T2G32Y0:T:27500:501:502,504:0:0:25984:0:0:0
+ Ch 44 (TV):537833:I0C34D0M16B8T2G32Y0:T:27500:501:502,504:0:0:26048:0:0:0
+ Channel 4 (TV):481833:I0C23D0M64B8T2G32Y0:T:27500:2827:2828,2830:0:0:8384:0:0:0
--- vdr-1.6.0.orig/debian/patches/00list
+++ vdr-1.6.0/debian/patches/00list
@@ -0,0 +1,106 @@
+03_cmdsubmenu
+04_newplugin
+06_default_svdrp_port_0
+09_sort_options
+10_dd-record-option
+11_sortrecordings
+12_osdbase-maxitems
+14_cap-memsize
+15_dvbplayer
+16_channels.conf.terr-fix
+17_vdr-maintenance-1.6.0-1
+18_vdr-maintenance-1.6.0-2
+19_dvb-api-v5
+20_gcc44_ftbfs
+
+81_Make_config
+82_valgrind
+
+99_ncursesw-include
+99_vdr-workaround-broken-sys-capability
+
+# Patch collection (replaces enAIO).
+# opt-20_liemikuutio
+
+# Allows to tune to non-FTA channels provided by internal devices, 
+# like streamdev
+# opt-21_internal-cam-devices
+
+# Easy editing of cutting marks
+# (Requires opt-20_liemikuutio!)
+# opt-22-x_edit_marks
+
+# The Jump patch allows automatic jumping over cutting marks.
+# opt-24_jumpplay
+
+# Patch needed for the ttxtsubs plugin.
+# opt-27_ttxtsubs
+
+# Fixes length calculation for radio recordings
+# opt-28_audioindexer
+
+# Speed up zapping channels.
+# opt-29_syncearly
+# opt-29_syncearly-audioindexer
+
+# Patch needed for the analogtv plugin.
+# opt-30-x_analogtv
+
+# Makes VDR aware of the reelchannelscan plugin
+# opt-31-x_reelchannelscan
+
+# Patch that shows if there is a valid setup value left or right with < and >.
+# opt-35_setup-show-valid
+
+# Patch needed for the menuorg plugin.
+# opt-37-x_menuorg
+
+# Patch that suppresses double EPG entries.
+# opt-38_disableDoubleEpgEntrys
+
+# Patch to disable normal epg update for specified channels.
+# opt-39_noepg
+
+# Patch required by the IPTV and other plugins
+# opt-40_pluginparam
+
+# Patch to show an info, if it is possible to record an event in the timer-info.
+# opt-41-x_timer-info
+
+# Patch to allow plugins to replace the VDR mainmenus
+# opt-42-x_MainMenuHooks
+
+# Shows remaining recording capacity in recordings menu.
+# (Requires opt-41-x_timer-info !)
+# opt-43-x_recordshowfree
+
+# Patch needed for the rotor plugin.
+# opt-44_rotor
+
+# Patch needed for the yaepg plugin.
+# opt-45_yaepg
+
+# Patch for assigning special satellites to one dvb card.
+# opt-47_sourcecaps
+
+# Patch for the PIN plugin
+# opt-48-x_pin
+
+# Patch for the pvrinput plugin
+# opt-49-x_pvrinput
+
+# Patch required for the GraphTFT plugin
+# opt-50_graphtft
+
+# Modifies the start time of recordings to the first cutting mark
+# (disabled by default - enable in VDR's recording setup)
+# opt-51_cuttime
+
+# Records into smaller files and uses hardlinks to speed up cutting
+# opt-52_hard_link_cutter
+
+# Setup for AC3 transfer, QAM_256, disable primary tuner
+# opt-53_dvbsetup
+
+# Offers the choice to delete timeshift recordings
+# opt-54_deltimeshiftrec
--- vdr-1.6.0.orig/debian/patches/06_default_svdrp_port_0.dpatch
+++ vdr-1.6.0/debian/patches/06_default_svdrp_port_0.dpatch
@@ -0,0 +1,22 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+
+## 06_default_svdrp_port_0.dpatch by Thomas Schmidt <tschmidt@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This sets the default svdrp-port to 0, which means that
+## DP: SVDRP is disabled by default unless someone specifies
+## DP: another port with the --port option when starting vdr
+
+@DPATCH@
+diff -urNad vdr-1.3.39/vdr.c /tmp/dpep.zhqxZj/vdr-1.3.39/vdr.c
+--- vdr-1.3.39/vdr.c	2006-01-17 21:24:47.597411250 +0100
++++ /tmp/dpep.zhqxZj/vdr-1.3.39/vdr.c	2006-01-17 21:25:18.987672000 +0100
+@@ -157,7 +157,7 @@
+ 
+   // Command line options:
+ 
+-#define DEFAULTSVDRPPORT 2001
++#define DEFAULTSVDRPPORT 0
+ #define DEFAULTWATCHDOG     0 // seconds
+ #define DEFAULTPLUGINDIR PLUGINDIR
+ #define DEFAULTEPGDATAFILENAME "epg.data"
--- vdr-1.6.0.orig/debian/patches/opt-42-x_MainMenuHooks.dpatch
+++ vdr-1.6.0/debian/patches/opt-42-x_MainMenuHooks.dpatch
@@ -0,0 +1,163 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-42-x_MainMenuHooks.dpatch by Frank Schmirler <vdrdev@schmirler.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch allows plugins to replace the VDR mainmenus "Schedule",
+## DP: "Channels", "Timers" and "Recordings" by a different implementation.
+
+@DPATCH@
+This is a "patch" for the Video Disk Recorder (VDR).
+
+* Authors:
+Tobias Grimm <vdr@e-tobi.net>
+Martin Prochnow <nordlicht@martins-kabuff.de>  
+Frank Schmirler <vdrdev@schmirler.de>
+Christian Wieninger <cwieninger@gmx.de>
+
+* Description:
+This patch allows plugins to replace the VDR mainmenus "Schedule",
+"Channels", "Timers" and "Recordings" by a different implementation.
+
+The patch is based on a suggestion of Christian Wieninger back in 2006
+(http://www.linuxtv.org/pipermail/vdr/2006-March/008234.html). It is
+meant to be an interim solution for VDR 1.4 until (maybe) VDR 1.5
+introduces an official API for this purpose.
+
+* Installation
+Change into the VDR source directory, then issue
+  patch -p1 < path/to/MainMenuHooks-v1_0.patch
+and recompile.
+
+* Notes for plugin authors
+The following code sample shows the required plugin code for replacing
+the original Schedule menu:
+
+bool cMyPlugin::Service(const char *Id, void *Data)
+{
+  cOsdMenu **menu = (cOsdMenu**) Data;
+  if (MySetup.replaceSchedule &&
+            strcmp(Id, "MainMenuHooksPatch-v1.0::osSchedule") == 0) {
+    if (menu)
+      *menu = (cOsdMenu*) MainMenuAction();
+    return true;
+  }
+  return false;
+}
+
+A plugin can replace more than one menu at a time. Simply replace the
+call to MainMenuAction() in the sample above by appropriate code.
+
+Note that a plugin *should* offer a setup option which allows the user
+to enable or disable the replacement. "Disabled" would be a reasonable
+default setting. By testing for define MAINMENUHOOKSVERSNUM, a plugin
+can leave the setup option out at compiletime.
+
+In case there is an internal problem when trying to open the replacement
+menu, it is safe to return true even though Data is NULL. However an
+OSD message should indicate the problem to the user.
+
+Feel free to ship this patch along with your plugin. However if you
+think you need to modify the patch, we'd encourage you to contact the
+authors first or at least use a service id which differs in more than
+just the version number.
+
+--- vdr-1.4.5/menu.c.orig	2007-02-07 08:23:49.000000000 +0100
++++ vdr-1.4.5/menu.c	2007-02-20 11:05:34.000000000 +0100
+@@ -2792,15 +2792,30 @@
+ 
+   // Initial submenus:
+ 
++  cOsdMenu *menu = NULL;
+   switch (State) {
+-    case osSchedule:   AddSubMenu(new cMenuSchedule); break;
+-    case osChannels:   AddSubMenu(new cMenuChannels); break;
+-    case osTimers:     AddSubMenu(new cMenuTimers); break;
+-    case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
+-    case osSetup:      AddSubMenu(new cMenuSetup); break;
+-    case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings(NULL, 0, true);
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     default: break;
+     }
++  if (menu)
++      AddSubMenu(menu);
+ }
+ 
+ cOsdObject *cMenuMain::PluginOsdObject(void)
+@@ -2927,13 +2942,34 @@
+   eOSState state = cOsdMenu::ProcessKey(Key);
+   HadSubMenu |= HasSubMenu();
+ 
++  cOsdMenu *menu = NULL;
+   switch (state) {
+-    case osSchedule:   return AddSubMenu(new cMenuSchedule);
+-    case osChannels:   return AddSubMenu(new cMenuChannels);
+-    case osTimers:     return AddSubMenu(new cMenuTimers);
+-    case osRecordings: return AddSubMenu(new cMenuRecordings);
+-    case osSetup:      return AddSubMenu(new cMenuSetup);
+-    case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        else
++            state = osContinue;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        else
++            state = osContinue;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        else
++            state = osContinue;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings;
++        else
++            state = osContinue;
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
+                           cOsdItem *item = Get(Current());
+                           if (item) {
+@@ -2985,6 +3021,8 @@
+                default:      break;
+                }
+     }
++  if (menu)
++      return AddSubMenu(menu);
+   if (!HasSubMenu() && Update(HadSubMenu))
+      Display();
+   if (Key != kNone) {
+--- vdr-1.4.5/config.h.orig	2007-02-20 11:55:40.000000000 +0100
++++ vdr-1.4.5/config.h	2007-02-20 11:56:43.000000000 +0100
+@@ -35,6 +35,8 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++#define MAINMENUHOOKSVERSNUM 1.0
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
--- vdr-1.6.0.orig/debian/patches/17_vdr-maintenance-1.6.0-1.dpatch
+++ vdr-1.6.0/debian/patches/17_vdr-maintenance-1.6.0-1.dpatch
@@ -0,0 +1,179 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 17_vdr-maintenance-1.6.0-1.dpatch by Klaus Schmidinger <Klaus.Schmidinger@tvdr.de>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: VDR 1.6.0 maintenance patch #1
+
+@DPATCH@
+diff -ruN vdr-1.6.0/CONTRIBUTORS vdr-1.6.0-1/CONTRIBUTORS
+--- vdr-1.6.0/CONTRIBUTORS	2008-03-18 18:34:00.000000000 +0100
++++ vdr-1.6.0-1/CONTRIBUTORS	2008-04-13 15:34:03.000000000 +0200
+@@ -595,6 +595,8 @@
+  not two hex digits after the '#'
+  for suggesting to suppress the automatic shutdown if the remote control is
+  currently disabled
++ for suggesting to improve logging system time changes to avoid problems on slow
++ systems under heavy load
+ 
+ Jeremy Hall <jhall@UU.NET>
+  for fixing an incomplete initialization of the filter parameters in eit.c
+@@ -958,6 +960,7 @@
+  for making the SVDRP command LSTC list the channels with group separators if the
+  option ':groups' is given
+  for fixing handling 3 and 4 byte UTF-8 symbols in Utf8CharGet()
++ for fixing initializing the timer's flags in the cTimer copy constructor
+ 
+ Olivier Jacques <jacquesolivier@hotmail.com>)
+  for translating OSD texts to the French language
+@@ -1174,6 +1177,7 @@
+  for reporting an invalid access in the section handler when ending VDR
+  for pointing out that cDevice::Transferring() doesn't return the right value in the
+  early stage of channel switching
++ for fixing handling the counter in detection of pre 1.3.19 PS data
+ 
+ Richard Robson <richard_robson@beeb.net>
+  for reporting freezing replay if a timer starts while in Transfer Mode from the
+@@ -1506,6 +1510,7 @@
+  for translating OSD texts to the Estonian language
+  for fixing a missing ',' in the Greek OSD texts
+  for fixing a missing ',' in the Swedish OSD texts
++ for reporting problems with CAMs when checking the CAM status too frequently
+ 
+ Milos Kapoun <m.kapoun@cra.cz>
+  for suggesting to skip code table info in SI data
+diff -ruN vdr-1.6.0/HISTORY vdr-1.6.0-1/HISTORY
+--- vdr-1.6.0/HISTORY	2008-03-23 11:26:08.000000000 +0100
++++ vdr-1.6.0-1/HISTORY	2008-04-13 15:33:46.000000000 +0200
+@@ -5729,3 +5729,14 @@
+ - Added Chinese language texts (thanks to Nan Feng).
+ - Updated the Portuguese language texts.
+ - Added a note about VDR_CHARSET_OVERRIDE to the INSTALL file.
++
++2008-04-13: Version 1.6.0-1
++
++- Fixed handling the counter in detection of pre 1.3.19 PS data (thanks to Reinhard
++  Nissl).
++- Improved logging system time changes to avoid problems on slow systems under
++  heavy load (suggested by Helmut Auer).
++- Fixed initializing the timer's flags in the cTimer copy constructor (thanks to
++  Andreas Mair).
++- Increased the time between checking the CAM status to 500ms to avoid problems
++  with some CAMs (reported by Arthur Konovalov).
+diff -ruN vdr-1.6.0/ci.c vdr-1.6.0-1/ci.c
+--- vdr-1.6.0/ci.c	2007-04-30 15:02:49.000000000 +0200
++++ vdr-1.6.0-1/ci.c	2008-04-13 15:33:32.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: ci.c 1.48 2007/04/30 13:02:49 kls Exp $
++ * $Id: ci.c 1.48.1.1 2008/04/13 13:33:32 kls Exp $
+  */
+ 
+ #include "ci.h"
+@@ -1525,7 +1525,7 @@
+ 
+ cCamSlots CamSlots;
+ 
+-#define MODULE_CHECK_INTERVAL 100 // ms
++#define MODULE_CHECK_INTERVAL 500 // ms
+ #define MODULE_RESET_TIMEOUT    2 // s
+ 
+ cCamSlot::cCamSlot(cCiAdapter *CiAdapter)
+diff -ruN vdr-1.6.0/config.h vdr-1.6.0-1/config.h
+--- vdr-1.6.0/config.h	2008-03-23 11:26:10.000000000 +0100
++++ vdr-1.6.0-1/config.h	2008-04-13 13:09:42.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: config.h 1.310 2008/03/23 10:26:10 kls Exp $
++ * $Id: config.h 1.310.1.1 2008/04/13 11:09:42 kls Exp $
+  */
+ 
+ #ifndef __CONFIG_H
+@@ -22,7 +22,7 @@
+ 
+ // VDR's own version number:
+ 
+-#define VDRVERSION  "1.6.0"
++#define VDRVERSION  "1.6.0-1"
+ #define VDRVERSNUM   10600  // Version * 10000 + Major * 100 + Minor
+ 
+ // The plugin API's version number:
+diff -ruN vdr-1.6.0/device.c vdr-1.6.0-1/device.c
+--- vdr-1.6.0/device.c	2008-03-09 11:03:34.000000000 +0100
++++ vdr-1.6.0-1/device.c	2008-04-13 13:16:00.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: device.c 1.157 2008/03/09 10:03:34 kls Exp $
++ * $Id: device.c 1.157.1.1 2008/04/13 11:16:00 kls Exp $
+  */
+ 
+ #include "device.h"
+@@ -1273,7 +1273,7 @@
+                uchar SubStreamIndex = SubStreamId & 0x1F;
+ 
+                // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
+-pre_1_3_19_PrivateStreamDeteced:
++pre_1_3_19_PrivateStreamDetected:
+                if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
+                   SubStreamId = c;
+                   SubStreamType = 0x80;
+@@ -1314,7 +1314,8 @@
+                          if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
+                             dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode - substream id = %02X", SubStreamId);
+                             ClrAvailableTracks();
+-                            goto pre_1_3_19_PrivateStreamDeteced;
++                            pre_1_3_19_PrivateStream = MIN_PRE_1_3_19_PRIVATESTREAM + 1;
++                            goto pre_1_3_19_PrivateStreamDetected;
+                             }
+                          }
+                  }
+diff -ruN vdr-1.6.0/eit.c vdr-1.6.0-1/eit.c
+--- vdr-1.6.0/eit.c	2007-08-26 12:56:33.000000000 +0200
++++ vdr-1.6.0-1/eit.c	2008-04-13 13:46:38.000000000 +0200
+@@ -8,7 +8,7 @@
+  * Robert Schneider <Robert.Schneider@web.de> and Rolf Hakenes <hakenes@hippomi.de>.
+  * Adapted to 'libsi' for VDR 1.3.0 by Marcel Wiesweg <marcel.wiesweg@gmx.de>.
+  *
+- * $Id: eit.c 1.126 2007/08/26 10:56:33 kls Exp $
++ * $Id: eit.c 1.126.1.1 2008/04/13 11:46:38 kls Exp $
+  */
+ 
+ #include "eit.h"
+@@ -300,9 +300,9 @@
+   if (diff > 2) {
+      mutex.Lock();
+      if (abs(diff - lastDiff) < 3) {
+-        isyslog("System Time = %s (%ld)", *TimeToString(loctim), loctim);
+-        isyslog("Local Time  = %s (%ld)", *TimeToString(sattim), sattim);
+-        if (stime(&sattim) < 0)
++        if (stime(&sattim) == 0)
++           isyslog("system time changed from %s (%ld) to %s (%ld)", *TimeToString(loctim), loctim, *TimeToString(sattim), sattim);
++        else
+            esyslog("ERROR while setting system time: %m");
+         }
+      lastDiff = diff;
+diff -ruN vdr-1.6.0/timers.c vdr-1.6.0-1/timers.c
+--- vdr-1.6.0/timers.c	2008-02-16 15:47:40.000000000 +0100
++++ vdr-1.6.0-1/timers.c	2008-04-13 14:47:12.000000000 +0200
+@@ -4,7 +4,7 @@
+  * See the main source file 'vdr.c' for copyright information and
+  * how to reach the author.
+  *
+- * $Id: timers.c 1.73 2008/02/16 14:47:40 kls Exp $
++ * $Id: timers.c 1.73.1.1 2008/04/13 12:47:12 kls Exp $
+  */
+ 
+ #include "timers.h"
+@@ -92,6 +92,7 @@
+   channel = NULL;
+   aux = NULL;
+   event = NULL;
++  flags = tfNone;
+   *this = Timer;
+ }
+ 
--- vdr-1.6.0.orig/debian/patches/opt-27_ttxtsubs.dpatch
+++ vdr-1.6.0/debian/patches/opt-27_ttxtsubs.dpatch
@@ -0,0 +1,297 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-27_ttxtsubs.dpatch by Rolf Ahrenberg <Rolf.Ahrenberg AT sci.fi>
+## http://www.saunalahti.fi/~rahrenbe/vdr/patches/vdr-1.5.14-ttxtsubs-0.0.5.diff.gz
+##
+## Thomas Gnther <tom@toms-cafe.de>:
+##   - adapted to dd-record-option patch (UseDolbyDigital -> RecordDolbyDigital)
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is needed for the ttxtsubs plugin.
+
+@DPATCH@
+diff -Nru vdr-1.5.14-vanilla/Makefile vdr-1.5.14-ttxtsubs/Makefile
+--- vdr-1.5.14-vanilla/Makefile	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/Makefile	2008-01-27 23:06:23.000000000 +0200
+@@ -43,6 +43,8 @@
+        skinclassic.o skins.o skinsttng.o sources.o spu.o status.o svdrp.o themes.o thread.o\
+        timers.o tools.o transfer.o vdr.o videodir.o
+ 
++OBJS += vdrttxtsubshooks.o
++
+ ifndef NO_KBD
+ DEFINES += -DREMOTE_KBD
+ endif
+diff -Nru vdr-1.5.14-vanilla/dvbplayer.c vdr-1.5.14-ttxtsubs/dvbplayer.c
+--- vdr-1.5.14-vanilla/dvbplayer.c	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/dvbplayer.c	2008-01-27 23:06:23.000000000 +0200
+@@ -14,6 +14,7 @@
+ #include "ringbuffer.h"
+ #include "thread.h"
+ #include "tools.h"
++#include "vdrttxtsubshooks.h"
+ 
+ // --- cBackTrace ------------------------------------------------------------
+ 
+@@ -312,6 +313,32 @@
+   firstPacket = true;
+ }
+ 
++static void StripExtendedPackets(uchar *b, int Length)
++{
++  for (int i = 0; i < Length - 6; i++) {
++      if (b[i] == 0x00 && b[i + 1] == 0x00 && b[i + 2] == 0x01) {
++         uchar c = b[i + 3];
++         int l = b[i + 4] * 256 + b[i + 5] + 6;
++         switch (c) {
++           case 0xBD: // dolby
++                // EBU Teletext data, ETSI EN 300 472
++                if (b[i + 8] == 0x24 && b[i + 45] >= 0x10 && b[i + 45] < 0x20) {
++                   cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData(&b[i], l);
++                   // continue with deleting the data - otherwise it disturbs DVB replay
++                   int n = l;
++                   for (int j = i; j < Length && n--; j++)
++                       b[j] = 0x00;
++                   }
++                break;
++           default:
++                break;
++           }
++         if (l)
++            i += l - 1; // the loop increments, too!
++         }
++      }
++}
++
+ bool cDvbPlayer::NextFile(uchar FileNumber, int FileOffset)
+ {
+   if (FileNumber > 0)
+@@ -503,6 +530,7 @@
+                     }
+                  }
+               if (p) {
++                 StripExtendedPackets(p, pc);
+                  int w = PlayPes(p, pc, playMode != pmPlay);
+                  if (w > 0) {
+                     p += w;
+diff -Nru vdr-1.5.14-vanilla/menu.c vdr-1.5.14-ttxtsubs/menu.c
+--- vdr-1.5.14-vanilla/menu.c	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/menu.c	2008-01-27 23:06:23.000000000 +0200
+@@ -28,6 +28,7 @@
+ #include "themes.h"
+ #include "timers.h"
+ #include "transfer.h"
++#include "vdrttxtsubshooks.h"
+ #include "videodir.h"
+ 
+ #define MAXWAIT4EPGINFO   3 // seconds
+@@ -3737,8 +3738,10 @@
+   isyslog("record %s", fileName);
+   if (MakeDirs(fileName, true)) {
+      const cChannel *ch = timer->Channel();
+-     recorder = new cRecorder(fileName, ch->GetChannelID(), timer->Priority(), ch->Vpid(), ch->Apids(), ch->Dpids(), ch->Spids());
++     cTtxtSubsRecorderBase *subsRecorder = cVDRTtxtsubsHookListener::Hook()->NewTtxtSubsRecorder(device, ch);
++     recorder = new cRecorder(fileName, ch->GetChannelID(), timer->Priority(), ch->Vpid(), ch->Apids(), ch->Dpids(), ch->Spids(), subsRecorder);
+      if (device->AttachReceiver(recorder)) {
++        if (subsRecorder) subsRecorder->DeviceAttach();
+         Recording.WriteInfo();
+         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
+         if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
+diff -Nru vdr-1.5.14-vanilla/osd.c vdr-1.5.14-ttxtsubs/osd.c
+--- vdr-1.5.14-vanilla/osd.c	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/osd.c	2008-01-27 23:06:23.000000000 +0200
+@@ -15,6 +15,7 @@
+ #include <sys/stat.h>
+ #include <sys/unistd.h>
+ #include "tools.h"
++#include "vdrttxtsubshooks.h"
+ 
+ // --- cPalette --------------------------------------------------------------
+ 
+diff -Nru vdr-1.5.14-vanilla/recorder.c vdr-1.5.14-ttxtsubs/recorder.c
+--- vdr-1.5.14-vanilla/recorder.c	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/recorder.c	2008-01-27 23:06:23.000000000 +0200
+@@ -11,6 +11,7 @@
+ #include <stdarg.h>
+ #include <stdio.h>
+ #include <unistd.h>
++#include <stdint.h>
+ #include "shutdown.h"
+ 
+ #define RECORDERBUFSIZE  MEGABYTE(5)
+@@ -26,6 +27,7 @@
+ 
+ class cFileWriter : public cThread {
+ private:
++  cTtxtSubsRecorderBase *ttxtSubsRecorder;
+   cRemux *remux;
+   cFileName *fileName;
+   cIndexFile *index;
+@@ -38,13 +40,14 @@
+ protected:
+   virtual void Action(void);
+ public:
+-  cFileWriter(const char *FileName, cRemux *Remux);
++  cFileWriter(const char *FileName, cRemux *Remux, cTtxtSubsRecorderBase *tsr);
+   virtual ~cFileWriter();
+   };
+ 
+-cFileWriter::cFileWriter(const char *FileName, cRemux *Remux)
++cFileWriter::cFileWriter(const char *FileName, cRemux *Remux, cTtxtSubsRecorderBase *tsr)
+ :cThread("file writer")
+ {
++  ttxtSubsRecorder = tsr;
+   fileName = NULL;
+   remux = Remux;
+   index = NULL;
+@@ -67,6 +70,8 @@
+   Cancel(3);
+   delete index;
+   delete fileName;
++  if (ttxtSubsRecorder)
++     delete ttxtSubsRecorder;
+ }
+ 
+ bool cFileWriter::RunningLowOnDiskSpace(void)
+@@ -111,6 +116,16 @@
+                  }
+               fileSize += Count;
+               remux->Del(Count);
++              // not sure if the pictureType test is needed, but it seems we can get
++              // incomplete pes packets from remux if we are not getting pictures?
++              if (ttxtSubsRecorder && pictureType != NO_PICTURE) {
++                 uint8_t *subsp;
++                 size_t len;
++                 if (ttxtSubsRecorder->GetPacket(&subsp, &len)) {
++                    recordFile->Write(subsp, len);
++                    fileSize += len;
++                    }
++                 }
+               }
+            else
+               break;
+@@ -126,7 +141,7 @@
+ 
+ // --- cRecorder -------------------------------------------------------------
+ 
+-cRecorder::cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids)
++cRecorder::cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids, cTtxtSubsRecorderBase *tsr)
+ :cReceiver(ChannelID, Priority, VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids)
+ ,cThread("recording")
+ {
+@@ -137,7 +152,7 @@
+   ringBuffer = new cRingBufferLinear(RECORDERBUFSIZE, TS_SIZE * 2, true, "Recorder");
+   ringBuffer->SetTimeouts(0, 100);
+   remux = new cRemux(VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids, true);
+-  writer = new cFileWriter(FileName, remux);
++  writer = new cFileWriter(FileName, remux, tsr);
+ }
+ 
+ cRecorder::~cRecorder()
+diff -Nru vdr-1.5.14-vanilla/recorder.h vdr-1.5.14-ttxtsubs/recorder.h
+--- vdr-1.5.14-vanilla/recorder.h	2008-01-27 23:04:26.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/recorder.h	2008-01-27 23:06:23.000000000 +0200
+@@ -15,6 +15,7 @@
+ #include "remux.h"
+ #include "ringbuffer.h"
+ #include "thread.h"
++#include "vdrttxtsubshooks.h"
+ 
+ class cFileWriter;
+ 
+@@ -28,7 +29,7 @@
+   virtual void Receive(uchar *Data, int Length);
+   virtual void Action(void);
+ public:
+-  cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids);
++  cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids, cTtxtSubsRecorderBase *tsr);
+                // Creates a new recorder for the channel with the given ChannelID and
+                // the given Priority that will record the given PIDs into the file FileName.
+   virtual ~cRecorder();
+diff -Nru vdr-1.5.14-vanilla/vdrttxtsubshooks.c vdr-1.5.14-ttxtsubs/vdrttxtsubshooks.c
+--- vdr-1.5.14-vanilla/vdrttxtsubshooks.c	1970-01-01 02:00:00.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/vdrttxtsubshooks.c	2008-01-27 23:06:23.000000000 +0200
+@@ -0,0 +1,44 @@
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++
++#include "vdrttxtsubshooks.h"
++
++// XXX Really should be a list...
++static cVDRTtxtsubsHookListener *gListener;
++
++// ------ class cVDRTtxtsubsHookProxy ------
++
++class cVDRTtxtsubsHookProxy : public cVDRTtxtsubsHookListener
++{
++ public:
++  virtual void HideOSD(void) { if(gListener) gListener->HideOSD(); };
++  virtual void ShowOSD(void) { if(gListener) gListener->ShowOSD(); };
++  virtual void PlayerTeletextData(uint8_t *p, int length)
++    { if(gListener) gListener->PlayerTeletextData(p, length); };
++  virtual cTtxtSubsRecorderBase *NewTtxtSubsRecorder(cDevice *dev, const cChannel *ch)
++    { if(gListener) return gListener->NewTtxtSubsRecorder(dev, ch); else return NULL; };
++};
++
++
++// ------ class cVDRTtxtsubsHookListener ------
++
++cVDRTtxtsubsHookListener::~cVDRTtxtsubsHookListener()
++{
++  gListener = 0;
++}
++
++void cVDRTtxtsubsHookListener::HookAttach(void)
++{
++  gListener = this;
++  //printf("cVDRTtxtsubsHookListener::HookAttach\n");
++}
++
++static cVDRTtxtsubsHookProxy gProxy;
++
++cVDRTtxtsubsHookListener *cVDRTtxtsubsHookListener::Hook(void)
++{
++  return &gProxy;
++}
++
+diff -Nru vdr-1.5.14-vanilla/vdrttxtsubshooks.h vdr-1.5.14-ttxtsubs/vdrttxtsubshooks.h
+--- vdr-1.5.14-vanilla/vdrttxtsubshooks.h	1970-01-01 02:00:00.000000000 +0200
++++ vdr-1.5.14-ttxtsubs/vdrttxtsubshooks.h	2008-01-27 23:06:23.000000000 +0200
+@@ -0,0 +1,36 @@
++
++#ifndef __VDRTTXTSUBSHOOKS_H
++#define __VDRTTXTSUBSHOOKS_H
++
++class cDevice;
++class cChannel;
++
++#define VDRTTXTSUBSHOOKS
++
++class cTtxtSubsRecorderBase {
++ public:
++  virtual ~cTtxtSubsRecorderBase() {};
++
++  // returns a PES packet if there is data to add to the recording
++  virtual uint8_t *GetPacket(uint8_t **buf, size_t *len) { return NULL; };
++  virtual void DeviceAttach(void) {};
++};
++
++class cVDRTtxtsubsHookListener {
++ public:
++  cVDRTtxtsubsHookListener(void) {};
++  virtual ~cVDRTtxtsubsHookListener();
++
++  void HookAttach(void);
++  
++  virtual void HideOSD(void) {};
++  virtual void ShowOSD(void) {};
++  virtual void PlayerTeletextData(uint8_t *p, int length) {};
++  virtual cTtxtSubsRecorderBase *NewTtxtSubsRecorder(cDevice *dev, const cChannel *ch)
++    { return NULL; };
++
++  // used by VDR to call hook listeners
++  static cVDRTtxtsubsHookListener *Hook(void);
++};
++
++#endif
--- vdr-1.6.0.orig/debian/patches/opt-37-x_menuorg.dpatch
+++ vdr-1.6.0/debian/patches/opt-37-x_menuorg.dpatch
@@ -0,0 +1,281 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## opt-37-x_menuorg.dpatch by Tobias Grimm <tg@e-tobi.net>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: This patch is required by the MenuOrg plugin. It adds a service
+## DP: interface, that can be implemented by plugins to reorganize 
+## DP: VDR's main menu entries with the ability to create custom sub
+## DP: menus.
+## DP: This is version 0.4.s of the patch
+
+@DPATCH@
+diff -Nur vdr-1.5.18.orig/mainmenuitemsprovider.h vdr-1.5.18/mainmenuitemsprovider.h
+--- vdr-1.5.18.orig/mainmenuitemsprovider.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.5.18/mainmenuitemsprovider.h	2008-03-25 21:17:28.000000000 +0100
+@@ -0,0 +1,60 @@
++/*
++ * vdr-menuorg - A plugin for the Linux Video Disk Recorder
++ * Copyright (c) 2007 - 2008 Tobias Grimm <vdr@e-tobi.net>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
++ * details.
++ *
++ * You should have received a copy of the GNU General Public License along with
++ * this program; if not, write to the Free Software Foundation, Inc.,
++ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ *
++ * $Id$
++ *
++ */
++
++#ifndef __MAINMENUITEMSPROVIDER_H
++#define __MAINMENUITEMSPROVIDER_H
++
++#include <vector>
++
++class cOsdItem;
++class cOsdMenu;
++
++class IMenuItemDefinition
++{
++    public:
++        virtual ~IMenuItemDefinition() {};
++        virtual bool IsCustomOsdItem() = 0;
++        virtual bool IsPluginItem() = 0;
++        virtual bool IsSeparatorItem() = 0;
++        virtual cOsdItem* CustomOsdItem() = 0;
++        virtual const char* PluginMenuEntry() = 0;
++        virtual bool IsSelected() = 0;
++        virtual int PluginIndex() = 0;
++};
++
++typedef std::vector<IMenuItemDefinition*> MenuItemDefinitions;
++
++#define MENU_ITEMS_PROVIDER_SERVICE_ID "MenuOrgPatch-v0.4.2::MainMenuItemsProvider"
++
++class IMainMenuItemsProvider
++{
++    public:
++        virtual ~IMainMenuItemsProvider() {};
++        virtual bool IsCustomMenuAvailable() = 0;
++        virtual MenuItemDefinitions* MainMenuItems() = 0;
++        virtual void EnterRootMenu() = 0;
++        virtual void EnterSubMenu(cOsdItem* item) = 0;
++        virtual bool LeaveSubMenu() = 0;
++        virtual cOsdMenu* Execute(cOsdItem* item) = 0;
++};
++
++#endif //__MAINMENUITEMSPROVIDER_H
+diff -Nur vdr-1.5.18.orig/menu.c vdr-1.5.18/menu.c
+--- vdr-1.5.18.orig/menu.c	2008-03-16 12:15:28.000000000 +0100
++++ vdr-1.5.18/menu.c	2008-03-25 21:17:28.000000000 +0100
+@@ -29,6 +29,7 @@
+ #include "timers.h"
+ #include "transfer.h"
+ #include "videodir.h"
++#include "menuorgpatch.h"
+ 
+ #define MAXWAIT4EPGINFO   3 // seconds
+ #define MODETIMEOUT       3 // seconds
+@@ -2969,6 +2970,9 @@
+   cancelEditingItem = NULL;
+   stopRecordingItem = NULL;
+   recordControlsState = 0;
++
++  MenuOrgPatch::EnterRootMenu();
++
+   Set();
+ 
+   // Initial submenus:
+@@ -2997,6 +3001,29 @@
+   SetTitle("VDR");
+   SetHasHotkeys();
+ 
++  if (MenuOrgPatch::IsCustomMenuAvailable()) {
++     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
++     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
++         cOsdItem* osdItem = NULL;
++         if ((*i)->IsCustomOsdItem()) {
++            osdItem = (*i)->CustomOsdItem();
++            if (osdItem &&  !(*i)->IsSeparatorItem())
++                   osdItem->SetText(hk(osdItem->Text()));
++            }
++         else if ((*i)->IsPluginItem()) {
++            const char *item = (*i)->PluginMenuEntry();
++            if (item)
++              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
++            }
++         if (osdItem) {
++            Add(osdItem);
++            if ((*i)->IsSelected())
++               SetCurrent(osdItem);
++            }
++         }
++     }
++  else {
++
+   // Basic menu items:
+ 
+   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+@@ -3023,6 +3050,8 @@
+   if (Commands.Count())
+      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+ 
++  }
++
+   Update(true);
+ 
+   Display();
+@@ -3135,6 +3164,41 @@
+                          state = osEnd;
+                        }
+                        break;
++    case osBack:       {
++                          if (MenuOrgPatch::IsCustomMenuAvailable())
++                          {
++                            bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
++                            Set();
++                            stopReplayItem = NULL;
++                            cancelEditingItem = NULL;
++                            stopRecordingItem = NULL;
++                            recordControlsState = 0;
++                            Update(true);
++                            Display();
++                            if (leavingMenuSucceeded)
++                              return osContinue;
++                            else
++                              return osEnd;
++                          }
++                       }
++                       break;
++    case osUser1:      {
++                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
++                            MenuOrgPatch::EnterSubMenu(Get(Current()));
++                            Set();
++                            return osContinue;
++                          }
++                       }
++                       break;
++    case osUser2:      {
++                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
++                            cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
++                            if (osdMenu)
++                              return AddSubMenu(osdMenu);
++                            return osEnd;
++                          }
++                       }
++                       break;
+     default: switch (Key) {
+                case kRecord:
+                case kRed:    if (!HadSubMenu)
+diff -Nur vdr-1.5.18.orig/menuorgpatch.h vdr-1.5.18/menuorgpatch.h
+--- vdr-1.5.18.orig/menuorgpatch.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.5.18/menuorgpatch.h	2008-03-25 21:17:28.000000000 +0100
+@@ -0,0 +1,100 @@
++/*
++ * vdr-menuorg - A plugin for the Linux Video Disk Recorder
++ * Copyright (c) 2007 - 2008 Tobias Grimm <vdr@e-tobi.net>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
++ * details.
++ *
++ * You should have received a copy of the GNU General Public License along with
++ * this program; if not, write to the Free Software Foundation, Inc.,
++ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ *
++ * $Id$
++ *
++ */
++
++#ifndef __MENUORGPATCH_H
++#define __MENUORGPATCH_H
++
++#include "mainmenuitemsprovider.h"
++
++class MenuOrgPatch
++{
++    private:
++        static IMainMenuItemsProvider* _mainMenuItemsProvider;
++
++    private:
++        static IMainMenuItemsProvider* MainMenuItemsProvider()
++        {
++            if (!_mainMenuItemsProvider)
++            {
++                IMainMenuItemsProvider* mainMenuItemsProvider;
++
++                if (cPluginManager::CallFirstService(MENU_ITEMS_PROVIDER_SERVICE_ID, &mainMenuItemsProvider))
++                {
++                    _mainMenuItemsProvider = mainMenuItemsProvider;
++                }
++            }
++            return _mainMenuItemsProvider;
++        }
++
++    public:
++        static bool IsCustomMenuAvailable()
++        {
++            return (MainMenuItemsProvider() != NULL) && (MainMenuItemsProvider()->IsCustomMenuAvailable());
++        }
++
++        static void EnterRootMenu()
++        {
++            if (MainMenuItemsProvider())
++            {
++                MainMenuItemsProvider()->EnterRootMenu();
++            }
++        }
++
++        static bool LeaveSubMenu()
++        {
++            if (MainMenuItemsProvider())
++            {
++                return MainMenuItemsProvider()->LeaveSubMenu();
++            }
++            return false;
++        }
++
++        static void EnterSubMenu(cOsdItem* item)
++        {
++            if (MainMenuItemsProvider())
++            {
++                MainMenuItemsProvider()->EnterSubMenu(item);
++            }
++        }
++
++        static MenuItemDefinitions* MainMenuItems()
++        {
++            if (MainMenuItemsProvider())
++            {
++                return MainMenuItemsProvider()->MainMenuItems();
++            }
++            return NULL;
++        }
++
++        static cOsdMenu* Execute(cOsdItem* item)
++        {
++            if (MainMenuItemsProvider())
++            {
++                return MainMenuItemsProvider()->Execute(item);
++            }
++            return NULL;
++        }
++};
++
++IMainMenuItemsProvider* MenuOrgPatch::_mainMenuItemsProvider = NULL;
++
++#endif //__MENUORGPATCH_H
--- vdr-1.6.0.orig/debian/lintian/vdr-dev
+++ vdr-1.6.0/debian/lintian/vdr-dev
@@ -0,0 +1,5 @@
+vdr-dev: script-not-executable ./usr/share/vdr-dev/plugin-template/postinst.ex
+vdr-dev: script-not-executable ./usr/share/vdr-dev/plugin-template/postrm.ex
+vdr-dev: script-not-executable ./usr/share/vdr-dev/plugin-template/preinst.ex
+vdr-dev: script-not-executable ./usr/share/vdr-dev/plugin-template/prerm.ex
+vdr-dev: script-not-executable ./usr/share/vdr-dev/plugin-template/rules
--- vdr-1.6.0.orig/debian/lintian/vdr
+++ vdr-1.6.0/debian/lintian/vdr
@@ -0,0 +1,2 @@
+vdr: package-contains-upstream-install-documentation usr/share/doc/vdr/INSTALL.gz
+vdr: package-contains-empty-directory usr/lib/vdr/plugins/
