diff -Nur ffmpeg-20070524-old/libavcodec/alac.c ffmpeg-20070524/libavcodec/alac.c
--- ffmpeg-20070524-old/libavcodec/alac.c	2008-05-07 20:45:30.000000000 +0300
+++ ffmpeg-20070524/libavcodec/alac.c	2008-05-07 20:57:02.000000000 +0300
@@ -230,7 +230,7 @@
 
         /* special case: there may be compressed blocks of 0 */
         if ((history < 128) && (output_count+1 < output_size)) {
-            int block_size;
+            unsigned int block_size;
 
             sign_modifier = 1;
 
@@ -263,6 +263,10 @@
             }
 
             if (block_size > 0) {
+                if(block_size >= output_size - output_count){
+                    av_log(alac->avctx, AV_LOG_ERROR, "invalid zero block size of %d %d %d\n", block_size, output_size, output_count);
+                    block_size= output_size - output_count - 1;
+                }
                 memset(&output_buffer[output_count+1], 0, block_size * 4);
                 output_count += block_size;
 
@@ -459,7 +463,7 @@
     ALACContext *alac = avctx->priv_data;
 
     int channels;
-    int32_t outputsamples;
+    unsigned int outputsamples;
 
     /* short-circuit null buffers */
     if (!inbuffer || !input_buffer_size)
@@ -514,6 +518,14 @@
             /* now read the number of samples,
              * as a 32bit integer */
             outputsamples = get_bits(&alac->gb, 32);
+            if(outputsamples > alac->setinfo_max_samples_per_frame){
+                av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame);
+                return -1;
+            }
+            if(outputsamples > *outputsize / alac->bytespersample){
+                av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n");
+                return -1;
+            }
             *outputsize = outputsamples * alac->bytespersample;
         }
 
