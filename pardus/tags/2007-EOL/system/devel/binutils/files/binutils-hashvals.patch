diff -ur binutils-2.16.1.orig/bfd/elf.c binutils-2.16.1/bfd/elf.c
--- binutils-2.16.1.orig/bfd/elf.c	2005-05-30 01:00:10.000000000 +0300
+++ binutils-2.16.1/bfd/elf.c	2006-03-19 20:03:06.000000000 +0200
@@ -1155,6 +1155,7 @@
 	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
 	    case DT_USED: name = "USED"; break;
 	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
+	    case DT_PARDUS_HASHVALS: name = "PARDUS_HASHVALS"; break;
 	    }
 
 	  fprintf (f, "  %-11s ", name);
diff -ur binutils-2.16.1.orig/bfd/elflink.c binutils-2.16.1/bfd/elflink.c
--- binutils-2.16.1.orig/bfd/elflink.c	2006-03-19 18:06:07.000000000 +0200
+++ binutils-2.16.1/bfd/elflink.c	2006-03-19 20:03:06.000000000 +0200
@@ -152,6 +152,15 @@
 
   flags = bed->dynamic_sec_flags;
 
+  if (info->hashvals)
+    {
+      s = bfd_make_section (abfd, ".pardus.hashvals");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	  || ! bfd_set_section_alignment (abfd, s, 2))
+	return FALSE;
+    }
+
   /* A dynamically linked executable has a .interp section, but a
      shared library does not.  */
   if (info->executable)
@@ -5698,6 +5707,24 @@
 	  bed->s->swap_symbol_out (output_bfd, &isym, s->contents, 0);
 	}
 
+      /* Create the direct bindings section - 1 entry per dynsym.  */
+      s = bfd_get_section_by_name (dynobj, ".pardus.hashvals");
+      if (s != NULL)
+        {
+  	  if (dynsymcount == 0)
+	    s->flags |= SEC_EXCLUDE;
+	  else
+	    {
+	      s->size = dynsymcount * bed->s->sizeof_hash_entry;
+	      s->contents = bfd_zalloc (output_bfd, s->size);
+	      if (s->contents == NULL)
+	        return FALSE;
+	      memset (s->contents, 0xfe, s->size);
+	      if (!_bfd_elf_add_dynamic_entry (info, DT_PARDUS_HASHVALS, 0))
+	        return FALSE;
+	    }
+	}
+
       /* Compute the size of the hashing table.  As a side effect this
 	 computes the hash values for all the names we export.  */
       bucketcount = compute_bucket_count (info);
@@ -5769,6 +5796,8 @@
   /* Array large enough to hold a section pointer for each local
      symbol of any input BFD.  */
   asection **sections;
+  /* .pardus.hashvals section.  */
+  asection *hashvals_sec;
   /* Buffer to hold swapped out symbols.  */
   bfd_byte *symbuf;
   /* And one for symbol section indices.  */
@@ -6574,6 +6603,15 @@
 	       ((bfd_byte *) finfo->hash_sec->contents
 		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));
 
+      if (finfo->hashvals_sec != NULL)
+      {
+	  bfd_vma offset = hash_entry_size * h->dynindx;
+	  BFD_ASSERT (offset <= finfo->hashvals_sec->size);
+	  bfd_put (8 * hash_entry_size, finfo->output_bfd,
+		   h->u.elf_hash_value,
+		   finfo->hashvals_sec->contents + offset);
+      }
+
       if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
 	{
 	  Elf_Internal_Versym iversym;
@@ -7732,6 +7770,7 @@
       finfo.dynsym_sec = NULL;
       finfo.hash_sec = NULL;
       finfo.symver_sec = NULL;
+      finfo.hashvals_sec = NULL;
     }
   else
     {
@@ -7740,6 +7779,7 @@
       BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
       finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
       /* Note that it is OK if symver_sec is NULL.  */
+      finfo.hashvals_sec = bfd_get_section_by_name (dynobj, ".pardus.hashvals");
     }
 
   finfo.contents = NULL;
@@ -8480,6 +8520,9 @@
 	    case DT_HASH:
 	      name = ".hash";
 	      goto get_vma;
+	    case DT_PARDUS_HASHVALS:
+	      name = ".pardus.hashvals";
+	      goto get_vma;
 	    case DT_STRTAB:
 	      name = ".dynstr";
 	      goto get_vma;
diff -ur binutils-2.16.1.orig/include/bfdlink.h binutils-2.16.1/include/bfdlink.h
--- binutils-2.16.1.orig/include/bfdlink.h	2005-03-03 13:58:00.000000000 +0200
+++ binutils-2.16.1/include/bfdlink.h	2006-03-19 20:03:06.000000000 +0200
@@ -261,6 +261,10 @@
      need much more time and therefore must be explicitly selected.  */
   unsigned int optimize: 1;
 
+  /* TRUE if we want to produced a section containing pre-computed
+     hash values. This consumes more space.  */
+  unsigned int hashvals: 1;
+
   /* TRUE if ok to have multiple definition.  */
   unsigned int allow_multiple_definition: 1;
 
diff -ur binutils-2.16.1.orig/include/elf/common.h binutils-2.16.1/include/elf/common.h
--- binutils-2.16.1.orig/include/elf/common.h	2004-10-08 16:55:08.000000000 +0300
+++ binutils-2.16.1/include/elf/common.h	2006-03-19 20:03:06.000000000 +0200
@@ -598,6 +598,12 @@
 #define DT_FILTER	0x7fffffff
 
 
+/* Selected at random.  */
+#define DT_PARDUS_LO 0x6cbdd030
+#define DT_PARDUS_HASHVALS DT_PARDUS_LO
+#define DT_PARDUS_DIRECT DT_PARDUS_LO + 1
+#define DT_PARDUS_HI 0x6cbdd040
+
 /* Values used in DT_FEATURE .dynamic entry.  */
 #define DTF_1_PARINIT	0x00000001
 /* From
diff -ur binutils-2.16.1.orig/ld/lexsup.c binutils-2.16.1/ld/lexsup.c
--- binutils-2.16.1.orig/ld/lexsup.c	2005-03-03 13:52:00.000000000 +0200
+++ binutils-2.16.1/ld/lexsup.c	2006-03-19 20:03:06.000000000 +0200
@@ -76,6 +76,7 @@
   OPTION_EL,
   OPTION_EMBEDDED_RELOCS,
   OPTION_EXPORT_DYNAMIC,
+  OPTION_HASHVALS,
   OPTION_HELP,
   OPTION_IGNORE,
   OPTION_MAP,
@@ -339,6 +340,8 @@
     '\0', NULL, NULL, ONE_DASH },
   { {"static", no_argument, NULL, OPTION_NON_SHARED},
     '\0', NULL, NULL, ONE_DASH },
+  { {"hashvals", no_argument, NULL, OPTION_HASHVALS},
+    '\0', NULL, N_("Store pre-computed elf hash codes"), ONE_DASH },
   { {"Bsymbolic", no_argument, NULL, OPTION_SYMBOLIC},
     '\0', NULL, N_("Bind global references locally"), ONE_DASH },
   { {"check-sections", no_argument, NULL, OPTION_CHECK_SECTIONS},
@@ -1110,6 +1113,9 @@
 	case OPTION_SYMBOLIC:
 	  link_info.symbolic = TRUE;
 	  break;
+	case OPTION_HASHVALS:
+	  link_info.hashvals = TRUE;
+	  break;
 	case 't':
 	  trace_files = TRUE;
 	  break;
