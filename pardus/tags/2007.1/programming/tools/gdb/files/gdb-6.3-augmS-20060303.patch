Installed upstream after GDB 6.5 branched.

for gdb/ChangeLog
2006-03-03  Alexandre Oliva  <aoliva@redhat.com>

	* dwarf2-frame.c (struct dwarf2_cie): Add signal_frame field.
	(dwarf2_frame_sniffer): Use it.
	(decode_frame_entry_1): Set it according to augmentation "S".

Index: gdb-6.5/gdb/dwarf2-frame.c
===================================================================
--- gdb-6.5.orig/gdb/dwarf2-frame.c	2006-07-11 02:08:30.000000000 -0300
+++ gdb-6.5/gdb/dwarf2-frame.c	2006-07-11 02:09:19.000000000 -0300
@@ -69,6 +69,9 @@ struct dwarf2_cie
   /* True if a 'z' augmentation existed.  */
   unsigned char saw_z_augmentation;
 
+  /* True if an 'S' augmentation existed.  */
+  unsigned char signal_frame;
+
   struct dwarf2_cie *next;
 };
 
@@ -1053,15 +1056,17 @@ dwarf2_frame_sniffer (struct frame_info 
      function.  frame_pc_unwind(), for a no-return next function, can
      end up returning something past the end of this function's body.  */
   CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame);
-  if (!dwarf2_frame_find_fde (&block_addr))
+  struct dwarf2_fde *fde = dwarf2_frame_find_fde (&block_addr);
+  if (!fde)
     return NULL;
 
   /* On some targets, signal trampolines may have unwind information.
      We need to recognize them so that we set the frame type
      correctly.  */
 
-  if (dwarf2_frame_signal_frame_p (get_frame_arch (next_frame),
-				   next_frame))
+  if (fde->cie->signal_frame
+      || dwarf2_frame_signal_frame_p (get_frame_arch (next_frame),
+				      next_frame))
     return &dwarf2_signal_frame_unwind;
 
   return &dwarf2_frame_unwind;
@@ -1521,6 +1526,10 @@ decode_frame_entry_1 (struct comp_unit *
          depends on the target address size.  */
       cie->encoding = DW_EH_PE_absptr;
 
+      /* We'll determine the final value later, but we need to
+	 initialize it conservatively.  */
+      cie->signal_frame = 0;
+
       /* Check version number.  */
       cie_version = read_1_byte (unit->abfd, buf);
       if (cie_version != 1 && cie_version != 3)
@@ -1604,6 +1613,17 @@ decode_frame_entry_1 (struct comp_unit *
 	      augmentation++;
 	    }
 
+	  /* "S" indicates a signal frame, such that the return
+	     address must not be decremented to locate the call frame
+	     info for the previous frame; it might even be the first
+	     instruction of a function, so decrementing it would take
+	     us to a different function.  */
+	  else if (*augmentation == 'S')
+	    {
+	      cie->signal_frame = 1;
+	      augmentation++;
+	    }
+
 	  /* Otherwise we have an unknown augmentation.
 	     Bail out unless we saw a 'z' prefix.  */
 	  else
