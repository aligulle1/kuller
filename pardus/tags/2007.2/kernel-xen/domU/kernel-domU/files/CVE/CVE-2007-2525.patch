commit 202a03acf9994076055df40ae093a5c5474ad0bd
Author: Florian Zumbiehl <florz@florz.de>
Date:   Fri Apr 20 16:58:14 2007 -0700

    [PPPOE]: memory leak when socket is release()d before PPPIOCGCHAN has been called on it
    
    below you find a patch that fixes a memory leak when a PPPoE socket is
    release()d after it has been connect()ed, but before the PPPIOCGCHAN ioctl
    ever has been called on it.
    
    This is somewhat of a security problem, too, since PPPoE sockets can be
    created by any user, so any user can easily allocate all the machine's
    RAM to non-swappable address space and thus DoS the system.
    
    Is there any specific reason for PPPoE sockets being available to any
    unprivileged process, BTW? After all, you need a packet socket for the
    discovery stage anyway, so it's unlikely that any unprivileged process
    will ever need to create a PPPoE socket, no? Allocating all session IDs
    for a known AC is a kind of DoS, too, after all - with Juniper ERXes,
    this is really easy, actually, since they don't ever assign session ids
    above 8000 ...
    
    Signed-off-by: Florian Zumbiehl <florz@florz.de>
    Acked-by: Michal Ostrowski <mostrows@earthlink.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

---
 drivers/net/pppox.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: linux-2.6.18/drivers/net/pppox.c
===================================================================
--- linux-2.6.18.orig/drivers/net/pppox.c
+++ linux-2.6.18/drivers/net/pppox.c
@@ -58,7 +58,7 @@ void pppox_unbind_sock(struct sock *sk)
 {
 	/* Clear connection to ppp device, if attached. */
 
-	if (sk->sk_state & (PPPOX_BOUND | PPPOX_ZOMBIE)) {
+	if (sk->sk_state & (PPPOX_BOUND | PPPOX_CONNECTED | PPPOX_ZOMBIE)) {
 		ppp_unregister_channel(&pppox_sk(sk)->chan);
 		sk->sk_state = PPPOX_DEAD;
 	}
