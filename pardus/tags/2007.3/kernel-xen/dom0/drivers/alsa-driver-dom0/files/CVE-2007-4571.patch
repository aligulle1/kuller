diff -ur alsa-driver-1.0.14.orig/acore/memalloc.patch alsa-driver-1.0.14/acore/memalloc.patch
--- alsa-driver-1.0.14.orig/acore/memalloc.patch	2007-06-04 10:28:51.000000000 +0300
+++ alsa-driver-1.0.14/acore/memalloc.patch	2007-09-25 10:30:59.000000000 +0300
@@ -1,11 +1,20 @@
---- ../alsa-kernel/core/memalloc.c	2006-01-28 23:14:55.000000000 +0100
-+++ memalloc.c	2006-01-28 23:16:09.000000000 +0100
+diff -u memalloc.c memalloc.c
+--- memalloc.c	2006-01-28 23:16:09.000000000 +0100
++++ memalloc.c	2007-09-25 10:19:37.000000000 +0300
 @@ -1,3 +1,4 @@
 +#include "memalloc.inc"
  /*
   *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
   *                   Takashi Iwai <tiwai@suse.de>
-@@ -83,7 +84,50 @@
+@@ -27,6 +28,7 @@
+ #include <linux/pci.h>
+ #include <linux/slab.h>
+ #include <linux/mm.h>
++#include <linux/seq_file.h>
+ #include <asm/uaccess.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/moduleparam.h>
+@@ -83,7 +85,50 @@
   *  Hacks
   */
  
@@ -57,7 +66,7 @@
  /*
   * A hack to allocate large buffers via dma_alloc_coherent()
   *
-@@ -100,6 +144,30 @@
+@@ -100,6 +145,30 @@
   * so dma_mask doesn't have to be messed with.
   */
  
@@ -88,7 +97,7 @@
  static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
  					 dma_addr_t *dma_handle,
  					 gfp_t flags)
-@@ -107,15 +175,15 @@
+@@ -107,15 +176,15 @@
  	void *ret;
  	u64 dma_mask, coherent_dma_mask;
  
@@ -111,7 +120,7 @@
  	if (ret) {
  		/* obtained address is out of range? */
  		if (((unsigned long)*dma_handle + size - 1) & ~dma_mask) {
-@@ -140,6 +208,8 @@
+@@ -140,6 +209,8 @@
  #define dma_alloc_coherent snd_dma_hack_alloc_coherent
  
  #endif /* arch */
@@ -120,7 +129,7 @@
  
  /*
   *
-@@ -159,6 +229,24 @@
+@@ -159,6 +230,24 @@
  	snd_allocated_pages -= 1 << order;
  }
  
@@ -145,7 +154,7 @@
  /**
   * snd_malloc_pages - allocate pages with the given size
   * @size: the size to allocate in bytes
-@@ -177,8 +265,10 @@
+@@ -177,8 +266,10 @@
  	snd_assert(gfp_flags != 0, return NULL);
  	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
  	pg = get_order(size);
@@ -157,7 +166,7 @@
  	return res;
  }
  
-@@ -197,6 +287,7 @@
+@@ -197,6 +288,7 @@
  		return;
  	pg = get_order(size);
  	dec_snd_pages(pg);
@@ -165,7 +174,7 @@
  	free_pages((unsigned long) ptr, pg);
  }
  
-@@ -221,8 +312,10 @@
+@@ -221,8 +313,10 @@
  		| __GFP_NORETRY /* don't trigger OOM-killer */
  		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
  	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
@@ -177,7 +186,7 @@
  
  	return res;
  }
-@@ -237,6 +330,7 @@
+@@ -237,6 +331,7 @@
  		return;
  	pg = get_order(size);
  	dec_snd_pages(pg);
@@ -185,36 +194,146 @@
  	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
  }
  
-@@ -515,6 +609,7 @@
+@@ -481,53 +576,54 @@
+ #define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
+ static struct proc_dir_entry *snd_mem_proc;
+ 
+-static int snd_mem_proc_read(char *page, char **start, off_t off,
+-			     int count, int *eof, void *data)
++static int snd_mem_proc_read(struct seq_file *seq, void *offset)
+ {
+-	int len = 0;
+ 	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
+ 	struct snd_mem_list *mem;
+ 	int devno;
+ 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
+ 
+ 	mutex_lock(&list_mutex);
+-	len += snprintf(page + len, count - len,
+-			"pages  : %li bytes (%li pages per %likB)\n",
+-			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
++	seq_printf(seq, "pages  : %li bytes (%li pages per %likB)\n",
++		pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
+ 	devno = 0;
+ 	list_for_each_entry(mem, &mem_list_head, list) {
+ 		devno++;
+-		len += snprintf(page + len, count - len,
+-				"buffer %d : ID %08x : type %s\n",
++		seq_printf(seq, "buffer %d : ID %08x : type %s\n",
+ 				devno, mem->id, types[mem->buffer.dev.type]);
+-		len += snprintf(page + len, count - len,
+-				"  addr = 0x%lx, size = %d bytes\n",
+-				(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);
++		seq_printf(seq, "  addr = 0x%lx, size = %d bytes\n",
++				(unsigned long)mem->buffer.addr,
++				(int)mem->buffer.bytes);
+ 	}
+ 	mutex_unlock(&list_mutex);
+-	return len;
++	return 0;
++}
++
++static int snd_mem_proc_open(struct inode *inode, struct file *file)
++{
++		return single_open(file, snd_mem_proc_read, NULL);
+ }
  
  /* FIXME: for pci only - other bus? */
  #ifdef CONFIG_PCI
 +#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
  #define gettoken(bufp) strsep(bufp, " \t\n")
- 
- static int snd_mem_proc_write(struct file *file, const char __user *buffer,
-@@ -603,6 +698,7 @@
+-
+-static int snd_mem_proc_write(struct file *file, const char __user *buffer,
+-			      unsigned long count, void *data)
++static ssize_t snd_mem_proc_write(struct file *file, const char __user * buffer,
++		size_t count, loff_t * ppos)
+ {
+ 	char buf[128];
+ 	char *token, *p;
+ 
+-	if (count > ARRAY_SIZE(buf) - 1)
+-		count = ARRAY_SIZE(buf) - 1;
++	if (count > sizeof(buf) - 1)
++		return -EINVAL;
+ 	if (copy_from_user(buf, buffer, count))
+ 		return -EFAULT;
+-	buf[ARRAY_SIZE(buf) - 1] = '\0';
++	buf[count] = '\0';
+ 
+ 	p = buf;
+ 	token = gettoken(&p);
+ 	if (! token || *token == '#')
+-		return (int)count;
++		return count;
+ 	if (strcmp(token, "add") == 0) {
+ 		char *endp;
+ 		int vendor, device, size, buffers;
+@@ -548,7 +644,7 @@
+ 		    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||
+ 		    buffers > 4) {
+ 			printk(KERN_ERR "snd-page-alloc: invalid proc write format\n");
+-			return (int)count;
++			return count;
+ 		}
+ 		vendor &= 0xffff;
+ 		device &= 0xffff;
+@@ -560,7 +656,7 @@
+ 				if (pci_set_dma_mask(pci, mask) < 0 ||
+ 				    pci_set_consistent_dma_mask(pci, mask) < 0) {
+ 					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
+-					return (int)count;
++					return count;
+ 				}
+ 			}
+ 			for (i = 0; i < buffers; i++) {
+@@ -570,7 +666,7 @@
+ 							size, &dmab) < 0) {
+ 					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+ 					pci_dev_put(pci);
+-					return (int)count;
++					return count;
+ 				}
+ 				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
+ 			}
+@@ -596,9 +692,22 @@
+ 		free_all_reserved_pages();
+ 	else
  		printk(KERN_ERR "snd-page-alloc: invalid proc cmd\n");
- 	return (int)count;
+-	return (int)count;
++	return count;
  }
 +#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0) */
  #endif /* CONFIG_PCI */
++
++static const struct file_operations snd_mem_proc_fops = {
++	.owner		= THIS_MODULE,
++	.open		 = snd_mem_proc_open,
++	.read		 = seq_read,
++#ifdef CONFIG_PCI
++	.write		= snd_mem_proc_write,
++#endif
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
  #endif /* CONFIG_PROC_FS */
  
-@@ -617,8 +713,10 @@
- 	if (snd_mem_proc) {
- 		snd_mem_proc->read_proc = snd_mem_proc_read;
- #ifdef CONFIG_PCI
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
- 		snd_mem_proc->write_proc = snd_mem_proc_write;
- #endif
-+#endif
- 	}
+ /*
+@@ -609,12 +718,8 @@
+ {
+ #ifdef CONFIG_PROC_FS
+ 	snd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);
+-	if (snd_mem_proc) {
+-		snd_mem_proc->read_proc = snd_mem_proc_read;
+-#ifdef CONFIG_PCI
+-		snd_mem_proc->write_proc = snd_mem_proc_write;
+-#endif
+-	}
++	if (snd_mem_proc)
++		snd_mem_proc->proc_fops = &snd_mem_proc_fops;
  #endif
  	return 0;
-@@ -649,3 +747,5 @@
- 
- EXPORT_SYMBOL(snd_malloc_pages);
- EXPORT_SYMBOL(snd_free_pages);
+ }
+@@ -651,0 +757,2 @@
 +
 +#include "memalloc.inc1"
