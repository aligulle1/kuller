--- nifticlib-1.1.0.orig/CMakeLists.txt
+++ nifticlib-1.1.0/CMakeLists.txt
@@ -1,6 +1,13 @@
 #File Generated by Hans J. Johnson
 #Please contact hans-johnson@uiowa.edu for making enhancments/corrections
 PROJECT(NIFTI)
+
+# address warnings by cmake 2.6
+cmake_minimum_required(VERSION 2.4)
+if(COMMAND cmake_policy)
+  cmake_policy(SET CMP0003 NEW)
+endif(COMMAND cmake_policy)
+
 # Configure Dart testing support.
 INCLUDE(${CMAKE_ROOT}/Modules/Dart.cmake)
 
--- nifticlib-1.1.0.orig/Testing/CMakeLists.txt
+++ nifticlib-1.1.0/Testing/CMakeLists.txt
@@ -3,5 +3,5 @@
 PROJECT(TESTING)
 
 SUBDIRS(niftilib)
-SUBDIRS(nifti_regress_test)
+#SUBDIRS(nifti_regress_test)
 
--- nifticlib-1.1.0.orig/fsliolib/CMakeLists.txt
+++ nifticlib-1.1.0/fsliolib/CMakeLists.txt
@@ -17,6 +17,10 @@
   SET_TARGET_PROPERTIES(${NIFTI_FSLIOLIB_NAME} PROPERTIES ${NIFTI_LIBRARY_PROPERTIES})
 ENDIF (BUILD_SHARED_LIBS)
 
+# install im* and remove_ext scripts
+INSTALL( PROGRAMS imcp imglob imln immv imrm imtest remove_ext
+         DESTINATION ${NIFTI_INSTALL_BIN_DIR} )
+
 IF(NOT NIFTI_INSTALL_NO_LIBRARIES)
   INSTALL(TARGETS ${NIFTI_FSLIOLIB_NAME}
     RUNTIME DESTINATION ${NIFTI_INSTALL_BIN_DIR} COMPONENT RuntimeLibraries
--- nifticlib-1.1.0.orig/fsliolib/fslio.c
+++ nifticlib-1.1.0/fsliolib/fslio.c
@@ -482,6 +482,8 @@
 
     /* restore old values */
     if (preserve_nifti_values) {
+      dest->niftiptr->fname = fname;
+      dest->niftiptr->iname = iname; 
       dest->niftiptr->data = data; 
     } else { 
         /* destroy the values that the nifti copy creates */
@@ -717,6 +719,17 @@
   FslSetFileType(fslio,imgtype);
   FslSetWriteMode(fslio,0);
 
+  /* if it is a nifti file but has inconsistent left-right ordering in the sform and qform then complain/crash */
+  if (FslBaseFileType(FslGetFileType(fslio))==FSL_TYPE_NIFTI) {
+    if (FslGetLeftRightOrder(fslio) == FSL_INCONSISTENT)
+      {
+	fprintf(stderr,"ERROR: inconsistent left-right order stored in sform and qform in file %s\n",filename); 
+	fprintf(stderr,"       Using sform instead of qform values\n\n");
+	/* return NULL; */
+      }
+  }
+
+
   if (FslBaseFileType(FslGetFileType(fslio))==FSL_TYPE_ANALYZE) {
     /* For the ANALYZE case in FSL, must cheat and grab the originator field! */
     /* Note that the header file is always separate here and closed by now */
@@ -860,7 +873,7 @@
  */
 void FslWriteAllVolumes(FSLIO *fslio, const void *buffer)
 {
-  short x,y,z,t;
+  short x,y,z,t=1;
 
   if (fslio==NULL)  FSLIOERR("FslWriteAllVolumes: Null pointer passed for FSLIO");
 
@@ -892,7 +905,7 @@
 size_t FslWriteVolumes(FSLIO *fslio, const void *buffer, size_t nvols)
 {
   /* The dimensions and datatype must be set before calling this function */
-  int retval;
+  int retval=0;
   if (fslio==NULL)  FSLIOERR("FslWriteVolumes: Null pointer passed for FSLIO");
   if ( (!fslio->written_hdr) && (FslIsSingleFileType(FslGetFileType(fslio))) &&
        (FslIsCompressedFileType(FslGetFileType(fslio))) )
@@ -909,7 +922,7 @@
       /* This is nasty - but what else can be done?!? */
       char *tmpbuf, *inbuf;
       long int x, b, n, nrows;
-      short nx, ny, nz, nv;
+      short nx=1, ny, nz, nv;
       inbuf = (char *) buffer;
       tmpbuf = (char *)calloc(nbytes,1);
       FslGetDim(fslio,&nx,&ny,&nz,&nv);
@@ -930,7 +943,7 @@
   if (fslio->mincptr!=NULL) {
     fprintf(stderr,"Warning:: Minc is not yet supported\n");
   }
-  return 0;  /* failure */
+  return retval;  /* failure */
 }
 
 
@@ -944,14 +957,27 @@
  */
 void FslWriteHeader(FSLIO *fslio)
 {
+  short sform_code, qform_code;
+  mat44 smat, qmat;
   /* writes header and opens img file ready for writing */
   if (fslio==NULL)  FSLIOERR("FslWriteHeader: Null pointer passed for FSLIO");
 
   if (fslio->niftiptr!=NULL) {
     fslio->written_hdr = 1;
     if (znz_isnull(fslio->fileptr)) FSLIOERR("FslWriteHeader: no file opened!");
-
-    strcpy(fslio->niftiptr->descrip,"FSL3.2beta");
+    /* modify niftiptr for FSL-specific purposes */
+    strcpy(fslio->niftiptr->descrip,"FSL4.0");
+    /* set qform to equal sform if currently unset (or vice versa) */
+    qform_code = FslGetRigidXform(fslio,&qmat);
+    sform_code = FslGetStdXform(fslio,&smat);
+    if ( (sform_code != NIFTI_XFORM_UNKNOWN) && 
+	 (qform_code == NIFTI_XFORM_UNKNOWN) ) {
+      FslSetRigidXform(fslio,sform_code,smat);
+    }
+    if ( (qform_code != NIFTI_XFORM_UNKNOWN) && 
+	 (sform_code == NIFTI_XFORM_UNKNOWN) ) {
+      FslSetStdXform(fslio,qform_code,qmat);
+    }
     if (FslIsSingleFileType(FslGetFileType(fslio))) {
       /* write header info but don't close the file */
       nifti_image_write_hdr_img2(fslio->niftiptr,2,"wb",fslio->fileptr,NULL);
@@ -1639,7 +1665,7 @@
         rigidmat->m[3][3] = 1.0;
         
         /* the code gives a default but it should never really be used */
-        if (fslio->niftiptr->sform_code == NIFTI_XFORM_UNKNOWN) {
+        if (fslio->niftiptr->qform_code == NIFTI_XFORM_UNKNOWN) {
           FslGetVoxDim(fslio,&dx,&dy,&dz,&tr);
           rigidmat->m[0][0] = dx;
           rigidmat->m[0][1] = 0;
@@ -1652,6 +1678,7 @@
           rigidmat->m[2][0] = 0;
           rigidmat->m[2][1] = 0;
           rigidmat->m[2][2] = dz;
+          rigidmat->m[2][3] = 0;
           rigidmat->m[3][0] = 0.0;
           rigidmat->m[3][1] = 0.0;
           rigidmat->m[3][2] = 0.0;
@@ -1754,27 +1781,44 @@
 }
 
 
-int FslGetLeftRightOrder(FSLIO *fslio)
+int FslGetLeftRightOrder2(int sform_code, mat44 sform44, 
+			  int qform_code, mat44 qform44)
 {
   /* Determines if the image is stored in neurological or radiological convention */
+  int order=FSL_RADIOLOGICAL;
+  float dets=-1.0, detq=-1.0, det=-1.0;
+  mat33 sform33, qform33;
+  if (qform_code!=NIFTI_XFORM_UNKNOWN) { 
+    qform33 = mat44_to_mat33(qform44);
+    detq = nifti_mat33_determ(qform33);
+    det = detq;
+  }
+  if (sform_code!=NIFTI_XFORM_UNKNOWN) { 
+    sform33 = mat44_to_mat33(sform44);
+    dets = nifti_mat33_determ(sform33);
+    det = dets;
+  }
+  
+  if (det<0.0) order=FSL_RADIOLOGICAL;
+  else order=FSL_NEUROLOGICAL;
+  /* check for inconsistency if both are set */
+  if ( (sform_code!=NIFTI_XFORM_UNKNOWN) && 
+       (qform_code!=NIFTI_XFORM_UNKNOWN) ) { 
+    if (dets * detq < 0.0) order=FSL_INCONSISTENT;
+  }
+  return order;
+}
+
+
+int FslGetLeftRightOrder(FSLIO *fslio)
+{
   int order=FSL_RADIOLOGICAL, sform_code, qform_code;
-  float det=-1.0;
   mat44 sform44, qform44;
-  mat33 sform33, qform33;
   if (fslio==NULL)  FSLIOERR("FslGetLeftRightOrder: Null pointer passed for FSLIO");
   if (fslio->niftiptr!=NULL) {
     sform_code = FslGetStdXform(fslio,&sform44);
     qform_code = FslGetRigidXform(fslio,&qform44);
-    if (sform_code!=NIFTI_XFORM_UNKNOWN) { 
-      sform33 = mat44_to_mat33(sform44);
-      det = nifti_mat33_determ(sform33);
-    } else if (qform_code!=NIFTI_XFORM_UNKNOWN) { 
-      qform33 = mat44_to_mat33(qform44);
-      det = nifti_mat33_determ(qform33); 
-    }
-
-    if (det<0.0) order=FSL_RADIOLOGICAL;
-    else order=FSL_NEUROLOGICAL;
+    return FslGetLeftRightOrder2(sform_code,sform44,qform_code,qform44);
   }
   if (fslio->mincptr!=NULL) {
     fprintf(stderr,"Warning:: Minc is not yet supported\n");
@@ -1783,6 +1827,68 @@
 }
 
 
+short FslGetVox2mmMatrix2(mat44 *vox2mm, int sform_code, mat44 sform44, 
+			  int qform_code, mat44 qform44, 
+			  float dx, float dy, float dz)
+{
+  short retcode=NIFTI_XFORM_UNKNOWN;
+  int ii,jj;
+  if (sform_code!=NIFTI_XFORM_UNKNOWN) { 
+    for (ii=0; ii<4; ii++) { 
+      for (jj=0; jj<4; jj++) {
+	vox2mm->m[ii][jj] = sform44.m[ii][jj];
+      } 
+    }
+    retcode=sform_code;
+  } else if (qform_code!=NIFTI_XFORM_UNKNOWN) { 
+    for (ii=0; ii<4; ii++) { 
+      for (jj=0; jj<4; jj++) {
+	vox2mm->m[ii][jj] = qform44.m[ii][jj];
+      } 
+    }
+    retcode=qform_code;
+  } else {
+    /* default case - for FSLView is positive voxel to mm scalings */
+    vox2mm->m[0][0] = dx;
+    vox2mm->m[0][1] = 0.0;
+    vox2mm->m[0][2] = 0.0;
+    vox2mm->m[0][3] = 0.0;
+    vox2mm->m[1][0] = 0.0;
+    vox2mm->m[1][1] = dy;
+    vox2mm->m[1][2] = 0.0;
+    vox2mm->m[1][3] = 0.0;
+    vox2mm->m[2][0] = 0.0;
+    vox2mm->m[2][1] = 0.0;
+    vox2mm->m[2][2] = dz;
+    vox2mm->m[2][3] = 0.0;
+    vox2mm->m[3][0] = 0.0;
+    vox2mm->m[3][1] = 0.0;
+    vox2mm->m[3][2] = 0.0;
+    vox2mm->m[3][3] = 1.0;
+    retcode=NIFTI_XFORM_UNKNOWN;
+  }
+  return retcode;
+}
+
+
+short FslGetVox2mmMatrix(FSLIO *fslio, mat44 *vox2mm)
+{
+  int sform_code, qform_code;
+  float dx, dy, dz, tr;
+  mat44 sform44, qform44;
+  if (fslio==NULL)  FSLIOERR("FslGetVox2mmMatrix: Null pointer passed for FSLIO");
+  if (fslio->niftiptr!=NULL) {
+    sform_code = FslGetStdXform(fslio,&sform44);
+    qform_code = FslGetRigidXform(fslio,&qform44);
+    FslGetVoxDim(fslio,&dx,&dy,&dz,&tr);
+    return FslGetVox2mmMatrix2(vox2mm,sform_code,sform44,
+			       qform_code,qform44,dx,dy,dz);
+  }
+  if (fslio->mincptr!=NULL) {
+    fprintf(stderr,"Warning:: Minc is not yet supported\n");
+  }
+  return NIFTI_XFORM_UNKNOWN;
+}
 
 void FslSetAnalyzeSform(FSLIO *fslio, const short *orig,
                         float dx, float dy, float dz)
@@ -1929,7 +2035,7 @@
 
     /* must write the header now */
     filetype = FslGetFileType(fslio);
-    strcpy(fslio->niftiptr->descrip,"FSL3.2beta");
+    strcpy(fslio->niftiptr->descrip,"FSL4.0");
     if (!FslIsSingleFileType(filetype)) {
       /* for file pairs - open new header file and write it */
       nifti_image_write_hdr_img(fslio->niftiptr,0,"wb");
--- nifticlib-1.1.0.orig/fsliolib/fslio.h
+++ nifticlib-1.1.0/fsliolib/fslio.h
@@ -113,7 +113,7 @@
 
 #define FSL_RADIOLOGICAL        -1
 #define FSL_NEUROLOGICAL         1
-
+#define FSL_INCONSISTENT         0
 
 /*! \struct FSLIO
     \brief High level data structure for open datasets in the fslio API.
@@ -210,6 +210,7 @@
 void FslSetDataType(FSLIO *fslio, short t);
 size_t FslGetDataType(FSLIO *fslio, short *t);
 int    FslGetIntensityScaling(FSLIO *fslio, float *slope, float *intercept);
+void   FslSetIntensityScaling(FSLIO *fslio, float slope, float intercept);
 void   FslSetIntent(FSLIO *fslio, short intent_code, float p1, float p2, float p3);
 short  FslGetIntent(FSLIO *fslio, short *intent_code, float *p1, float *p2,
                     float *p3);
@@ -225,6 +226,13 @@
 short FslGetRigidXform(FSLIO *fslio, mat44 *rigidmat);
 void  FslSetRigidXform(FSLIO *fslio, short qform_code, mat44 rigidmat);
 int   FslGetLeftRightOrder(FSLIO *fslio);
+short FslGetVox2mmMatrix(FSLIO *fslio, mat44 *vox2mm);
+  /* the following are the best higher level coordinate routines for FSL */
+int   FslGetLeftRightOrder2(int sform_code, mat44 sform44, 
+			    int qform_code, mat44 qform44);
+short FslGetVox2mmMatrix2(mat44 *vox2mm, int sform_code, mat44 sform44, 
+			  int qform_code, mat44 qform44, 
+			  float dx, float dy, float dz);
 
   /* these two functions are deprecated with the nifti/analyze support */
   /* please do all spatial coordinate origins via the Std and Rigid Xforms */
--- nifticlib-1.1.0.orig/fsliolib/imtest
+++ nifticlib-1.1.0/fsliolib/imtest
@@ -22,7 +22,18 @@
  exit;
 fi
 
-filename=`${FSLDIR}/bin/remove_ext $1`;
+inputfile=$1
+
+
+
+for i in 1 2 3 4 5 6 7 8 9 10 11 12
+do
+if [ -h $inputfile ] ; then 
+inputfile=`readlink $inputfile`;
+fi
+done
+
+filename=`${FSLDIR}/bin/remove_ext $inputfile`;
 
 if [ -r ${filename}.nii -o -r ${filename}.nii.gz ] ; then
   echo "1";
--- nifticlib-1.1.0.orig/nifticdf/CMakeLists.txt
+++ nifticlib-1.1.0/nifticdf/CMakeLists.txt
@@ -6,8 +6,11 @@
 
 SET(NIFTI_CDFLIB_NAME ${PACKAGE_PREFIX}nifticdf)
 
-ADD_LIBRARY(${NIFTI_CDFLIB_NAME} ${NIFTICDFLIB_SRC} )
+# Debian: enable 'unused' function as the AFNI package needs them
+ADD_DEFINITIONS( -D__COMPILE_UNUSED_FUNCTIONS__ )
 
+ADD_LIBRARY(${NIFTI_CDFLIB_NAME} ${NIFTICDFLIB_SRC} )
+TARGET_LINK_LIBRARIES(${NIFTI_CDFLIB_NAME} m )
 IF (BUILD_SHARED_LIBS)
   SET_TARGET_PROPERTIES(${NIFTI_CDFLIB_NAME} PROPERTIES ${NIFTI_LIBRARY_PROPERTIES})
 ENDIF (BUILD_SHARED_LIBS)
--- nifticlib-1.1.0.orig/niftilib/nifti1_io.c
+++ nifticlib-1.1.0/niftilib/nifti1_io.c
@@ -22,6 +22,7 @@
            - revised by Mark Jenkinson, FMRIB
            - revised by Rick Reynolds, SSCC, NIMH
            - revised by Kate Fissell, University of Pittsburgh
+           - fixes   by Yaroslav O. Halchenko, Rutgers-Newark
 
         The library history can be viewed via "nifti_tool -nifti_hist".
     <br>The library version can be viewed via "nifti_tool -nifti_ver".
--- nifticlib-1.1.0.orig/utils/CMakeLists.txt
+++ nifticlib-1.1.0/utils/CMakeLists.txt
@@ -7,7 +7,7 @@
 ADD_EXECUTABLE(${PACKAGE_PREFIX}nifti_stats nifti_stats.c)
 ADD_EXECUTABLE(${PACKAGE_PREFIX}nifti_tool nifti_tool.c)
 ADD_EXECUTABLE(${PACKAGE_PREFIX}nifti1_test nifti1_test.c)
-TARGET_LINK_LIBRARIES( nifti_stats ${PACKAGE_PREFIX}niftiio ${PACKAGE_PREFIX}nifticdf)
+TARGET_LINK_LIBRARIES( nifti_stats ${PACKAGE_PREFIX}nifticdf)
 TARGET_LINK_LIBRARIES( nifti_tool  ${PACKAGE_PREFIX}niftiio)
 TARGET_LINK_LIBRARIES( nifti1_test ${PACKAGE_PREFIX}niftiio)
 
