--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube_config.h	2008-07-02 07:58:08.000000000 +0200
@@ -0,0 +1,57 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+ Copyright (C) 2008 Martin Gräßlin <ubuntu@martin-graesslin.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#ifndef KWIN_CUBE_CONFIG_H
+#define KWIN_CUBE_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_cube_config.h"
+
+
+namespace KWin
+{
+
+class CubeEffectConfigForm : public QWidget, public Ui::CubeEffectConfigForm
+{
+    Q_OBJECT
+    public:
+        explicit CubeEffectConfigForm(QWidget* parent);
+};
+
+class CubeEffectConfig : public KCModule
+    {
+    Q_OBJECT
+    public:
+        explicit CubeEffectConfig(QWidget* parent = 0, const QVariantList& args = QVariantList());
+
+    public slots:
+        virtual void save();
+        virtual void load();
+        virtual void defaults();
+
+    private:
+        CubeEffectConfigForm* m_ui;
+        KActionCollection* m_actionCollection;
+    };
+
+} // namespace
+
+#endif
--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube_config.cpp	2008-07-02 07:58:08.000000000 +0200
@@ -0,0 +1,162 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+ Copyright (C) 2008 Martin Gräßlin <ubuntu@martin-graesslin.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+#include "cube_config.h"
+#include <kwineffects.h>
+
+#include <kconfiggroup.h>
+#include <KActionCollection>
+#include <kaction.h>
+#include <KGlobalAccel>
+
+#include <QGridLayout>
+#include <QColor>
+#ifndef KDE_USE_FINAL
+KWIN_EFFECT_CONFIG_FACTORY
+#endif
+
+namespace KWin
+{
+
+CubeEffectConfigForm::CubeEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+  setupUi(this);
+}
+
+CubeEffectConfig::CubeEffectConfig(QWidget* parent, const QVariantList& args) :
+        KCModule(EffectFactory::componentData(), parent, args)
+    {
+    m_ui = new CubeEffectConfigForm(this);
+
+    QGridLayout* layout = new QGridLayout(this);
+
+    layout->addWidget(m_ui, 0, 0);
+
+    m_ui->screenEdgeCombo->addItem(i18n("Top"));
+    m_ui->screenEdgeCombo->addItem(i18n("Top-right"));
+    m_ui->screenEdgeCombo->addItem(i18n("Right"));
+    m_ui->screenEdgeCombo->addItem(i18n("Bottom-right"));
+    m_ui->screenEdgeCombo->addItem(i18n("Bottom"));
+    m_ui->screenEdgeCombo->addItem(i18n("Bottom-left"));
+    m_ui->screenEdgeCombo->addItem(i18n("Left"));
+    m_ui->screenEdgeCombo->addItem(i18n("Top-left"));
+    m_ui->screenEdgeCombo->addItem(i18n("None"));
+
+    m_actionCollection = new KActionCollection( this, componentData() );
+    m_actionCollection->setConfigGroup( "Cube" );
+    m_actionCollection->setConfigGlobal(true);
+
+    KAction* a = (KAction*) m_actionCollection->addAction( "Cube" );
+    a->setText( i18n("Desktop Cube" ));
+    a->setProperty("isConfigurationAction", true);
+    a->setGlobalShortcut( KShortcut( Qt::CTRL + Qt::Key_F11 ));
+
+    m_ui->editor->addCollection(m_actionCollection);
+
+    connect(m_ui->screenEdgeCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(changed()));
+    connect(m_ui->rotationDurationSpin, SIGNAL(valueChanged(int)), this, SLOT(changed()));
+    connect(m_ui->cubeOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(changed()));
+    connect(m_ui->cubeOpacitySpin, SIGNAL(valueChanged(int)), this, SLOT(changed()));
+    connect(m_ui->displayDesktopNameBox, SIGNAL(stateChanged(int)), this, SLOT(changed()));
+    connect(m_ui->reflectionBox, SIGNAL(stateChanged(int)), this, SLOT(changed()));
+    connect(m_ui->backgroundColorButton, SIGNAL(changed(QColor)), this, SLOT(changed()));
+
+    load();
+    }
+
+void CubeEffectConfig::load()
+    {
+    KCModule::load();
+
+    KConfigGroup conf = EffectsHandler::effectConfig( "Cube" );
+
+    int duration       = conf.readEntry( "RotationDuration", 500 );
+    float opacity      = conf.readEntry( "Opacity", 80 );
+    bool desktopName   = conf.readEntry( "DisplayDesktopName", true );
+    bool reflection    = conf.readEntry( "Reflection", true );
+    int activateBorder = conf.readEntry( "BorderActivate", (int)ElectricNone );
+    QColor background  = conf.readEntry( "BackgroundColor", QColor( Qt::black ) );
+    if( activateBorder == (int)ElectricNone )
+        activateBorder--;
+    m_ui->screenEdgeCombo->setCurrentIndex( activateBorder );
+    
+    m_ui->rotationDurationSpin->setValue( duration );
+    m_ui->cubeOpacitySlider->setValue( opacity );
+    m_ui->cubeOpacitySpin->setValue( opacity );
+    if( desktopName )
+        {
+        m_ui->displayDesktopNameBox->setCheckState( Qt::Checked );
+        }
+    else
+        {
+        m_ui->displayDesktopNameBox->setCheckState( Qt::Unchecked );
+        }
+    if( reflection )
+        {
+        m_ui->reflectionBox->setCheckState( Qt::Checked );
+        }
+    else
+        {
+        m_ui->reflectionBox->setCheckState( Qt::Unchecked );
+        }
+    m_ui->backgroundColorButton->setColor( background );
+
+    emit changed(false);
+    }
+
+void CubeEffectConfig::save()
+    {
+    KConfigGroup conf = EffectsHandler::effectConfig( "Cube" );
+
+    conf.writeEntry( "RotationDuration", m_ui->rotationDurationSpin->value() );
+    conf.writeEntry( "DisplayDesktopName", m_ui->displayDesktopNameBox->checkState() == Qt::Checked ? true : false );
+    conf.writeEntry( "Reflection", m_ui->reflectionBox->checkState() == Qt::Checked ? true : false );
+    conf.writeEntry( "Opacity", m_ui->cubeOpacitySpin->value() );
+    conf.writeEntry( "BackgroundColor", m_ui->backgroundColorButton->color() );
+
+    int activateBorder = m_ui->screenEdgeCombo->currentIndex();
+    if( activateBorder == (int)ELECTRIC_COUNT )
+        activateBorder = (int)ElectricNone;
+    conf.writeEntry( "BorderActivate", activateBorder );
+
+    m_ui->editor->save();
+
+    conf.sync();
+
+    emit changed(false);
+    EffectsHandler::sendReloadMessage( "cube" );
+    }
+
+void CubeEffectConfig::defaults()
+    {
+    m_ui->rotationDurationSpin->setValue( 500 );
+    m_ui->displayDesktopNameBox->setCheckState( Qt::Checked );
+    m_ui->reflectionBox->setCheckState( Qt::Checked );
+    m_ui->cubeOpacitySpin->setValue( 80 );
+    m_ui->cubeOpacitySlider->setValue( 80 );
+    m_ui->screenEdgeCombo->setCurrentIndex( (int)ElectricNone -1 );
+    m_ui->backgroundColorButton->setColor( QColor( Qt::black ) );
+    m_ui->editor->allDefault();
+    emit changed(true);
+    }
+
+
+} // namespace
+
+#include "cube_config.moc"
--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube_config.ui	2008-07-02 07:58:08.000000000 +0200
@@ -0,0 +1,218 @@
+<ui version="4.0" >
+ <class>KWin::CubeEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::CubeEffectConfigForm" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>396</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout" >
+   <item>
+    <widget class="QGroupBox" name="groupBox" >
+     <property name="title" >
+      <string>Appearance</string>
+     </property>
+     <layout class="QGridLayout" >
+      <item row="2" column="0" >
+       <widget class="QLabel" name="label" >
+        <property name="text" >
+         <string>Rotation &amp;duration:</string>
+        </property>
+        <property name="buddy" >
+         <cstring>rotationDurationSpin</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="2" column="1" >
+       <widget class="QSpinBox" name="rotationDurationSpin" >
+        <property name="suffix" >
+         <string> msec</string>
+        </property>
+        <property name="maximum" >
+         <number>5000</number>
+        </property>
+        <property name="value" >
+         <number>500</number>
+        </property>
+       </widget>
+      </item>
+      <item row="4" column="0" >
+       <widget class="QLabel" name="label_3" >
+        <property name="text" >
+         <string>Cube &amp;opacity:</string>
+        </property>
+        <property name="buddy" >
+         <cstring>cubeOpacitySpin</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="1" column="1" >
+       <widget class="QComboBox" name="screenEdgeCombo" />
+      </item>
+      <item row="1" column="0" >
+       <widget class="QLabel" name="label_2" >
+        <property name="text" >
+         <string>Screen &amp;edge:</string>
+        </property>
+        <property name="buddy" >
+         <cstring>screenEdgeCombo</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="5" column="0" >
+       <layout class="QVBoxLayout" name="verticalLayout" >
+        <item>
+         <widget class="QSlider" name="cubeOpacitySlider" >
+          <property name="maximum" >
+           <number>100</number>
+          </property>
+          <property name="singleStep" >
+           <number>1</number>
+          </property>
+          <property name="value" >
+           <number>100</number>
+          </property>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="tickPosition" >
+           <enum>QSlider::TicksBelow</enum>
+          </property>
+          <property name="tickInterval" >
+           <number>10</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" name="horizontalLayout" >
+          <item>
+           <widget class="QLabel" name="label_4" >
+            <property name="text" >
+             <string>Fully transparent</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer name="horizontalSpacer" >
+            <property name="orientation" >
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" stdset="0" >
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+          <item>
+           <widget class="QLabel" name="label_5" >
+            <property name="text" >
+             <string>Fully opaque</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+      <item row="5" column="1" >
+       <widget class="QSpinBox" name="cubeOpacitySpin" >
+        <property name="suffix" >
+         <string> %</string>
+        </property>
+        <property name="maximum" >
+         <number>100</number>
+        </property>
+        <property name="value" >
+         <number>100</number>
+        </property>
+       </widget>
+      </item>
+      <item row="7" column="0" >
+       <widget class="QCheckBox" name="displayDesktopNameBox" >
+        <property name="text" >
+         <string>Display desktop &amp;name</string>
+        </property>
+       </widget>
+      </item>
+      <item row="8" column="0" >
+       <widget class="QCheckBox" name="reflectionBox" >
+        <property name="text" >
+         <string>&amp;Reflection</string>
+        </property>
+       </widget>
+      </item>
+      <item row="9" column="0" >
+       <widget class="QLabel" name="label_6" >
+        <property name="text" >
+         <string>&amp;Background Color:</string>
+        </property>
+        <property name="buddy" >
+         <cstring>backgroundColorButton</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="9" column="1" >
+       <widget class="KColorButton" name="backgroundColorButton" />
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="KWin::GlobalShortcutsEditor" native="1" name="editor" />
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KColorButton</class>
+   <extends>QPushButton</extends>
+   <header>kcolorbutton.h</header>
+  </customwidget>
+  <customwidget>
+   <class>KWin::GlobalShortcutsEditor</class>
+   <extends>QWidget</extends>
+   <header location="global" >kwineffects.h</header>
+   <container>1</container>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>cubeOpacitySpin</sender>
+   <signal>valueChanged(int)</signal>
+   <receiver>cubeOpacitySlider</receiver>
+   <slot>setValue(int)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>329</x>
+     <y>133</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>221</x>
+     <y>171</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>cubeOpacitySlider</sender>
+   <signal>valueChanged(int)</signal>
+   <receiver>cubeOpacitySpin</receiver>
+   <slot>setValue(int)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>119</x>
+     <y>169</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>380</x>
+     <y>134</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube_config.desktop	2008-07-02 07:58:08.000000000 +0200
@@ -0,0 +1,9 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kcm_kwin4_effect_builtins
+X-KDE-ParentComponents=kwin4_effect_cube
+X-KDE-PluginKeyword=cube
+
+Name=Desktop Cube
--- kwin/effects/CMakeLists.txt	2008-06-18 14:41:39.000000000 +0200
+++ kwin/effects/CMakeLists.txt	2008-07-02 07:58:08.000000000 +0200
@@ -108,6 +108,7 @@
     SET(kwin4_effect_builtins_sources ${kwin4_effect_builtins_sources}
         blur.cpp
         coverswitch.cpp
+        cube.cpp
         explosioneffect.cpp
         flipswitch.cpp
         invert.cpp
@@ -122,6 +123,7 @@
     install( FILES
         blur.desktop
         coverswitch.desktop
+        cube.desktop
         explosion.desktop
         flipswitch.desktop
         invert.desktop
@@ -157,6 +159,8 @@
     SET(kwin4_effect_builtins_config_sources ${kwin4_effect_builtins_config_sources}
         coverswitch_config.cpp
         coverswitch_config.ui
+        cube_config.cpp
+        cube_config.ui
         flipswitch_config.cpp
         flipswitch_config.ui
         invert_config.cpp
@@ -175,6 +179,7 @@
         )
     install( FILES
         coverswitch_config.desktop
+        cube_config.desktop
         flipswitch_config.desktop
         invert_config.desktop
         lookingglass_config.desktop
--- kwin/effects/configs_builtins.cpp	2008-07-02 08:06:02.000000000 +0200
+++ kwin/effects/configs_builtins.cpp	2008-07-02 07:58:08.000000000 +0200
@@ -33,6 +33,7 @@
 
 #ifdef KWIN_HAVE_OPENGL_COMPOSITING
 #include "coverswitch_config.h"
+#include "cube_config.h"
 #include "flipswitch_config.h"
 #include "invert_config.h"
 #include "lookingglass_config.h"
@@ -69,6 +70,7 @@
 
 #define OPENGL_PLUGINS \
     registerPlugin<KWin::CoverSwitchEffectConfig>("coverswitch"); \
+    registerPlugin<KWin::CubeEffectConfig>("cube"); \
     registerPlugin<KWin::FlipSwitchEffectConfig>("flipswitch"); \
     registerPlugin<KWin::InvertEffectConfig>("invert"); \
     registerPlugin<KWin::LookingGlassEffectConfig>("lookingglass"); \
--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube.desktop	2008-06-17 21:15:44.000000000 +0200
@@ -0,0 +1,17 @@
+[Desktop Entry]
+Name=Desktop Cube
+Icon=preferences-system-windows-effect-cube
+Comment=Map virtual desktops on a cube
+
+Type=Service
+X-KDE-ServiceTypes=KWin/Effect
+X-KDE-PluginInfo-Author=Martin Gräßlin
+X-KDE-PluginInfo-Email=ubuntu@martin-graesslin.com
+X-KDE-PluginInfo-Name=kwin4_effect_cube
+X-KDE-PluginInfo-Version=0.1.0
+X-KDE-PluginInfo-Category=Window Management
+X-KDE-PluginInfo-Depends=
+X-KDE-PluginInfo-License=GPL
+X-KDE-PluginInfo-EnabledByDefault=false
+X-KDE-Library=kwin4_effect_builtins
+X-KDE-Ordering=50

--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube.cpp	2008-07-06 19:21:35.000000000 +0200
@@ -0,0 +1,916 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+ Copyright (C) 2008 Martin Gräßlin <ubuntu@martin-graesslin.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+#include "cube.h"
+
+#include <kaction.h>
+#include <kactioncollection.h>
+#include <klocale.h>
+#include <kwinconfig.h>
+#include <kconfiggroup.h>
+#include <kcolorscheme.h>
+#include <kdebug.h>
+
+#include <QColor>
+#include <QRect>
+#include <QEvent>
+#include <QKeyEvent>
+
+#include <math.h>
+
+#include <GL/gl.h>
+
+namespace KWin
+{
+
+KWIN_EFFECT( cube, CubeEffect )
+
+CubeEffect::CubeEffect()
+    : activated( false )
+    , cube_painting( false )
+    , keyboard_grab( false )
+    , schedule_close( false )
+    , frontDesktop( 0 )
+    , cubeOpacity( 1.0 )
+    , displayDesktopName( true )
+    , reflection( true )
+    , rotating( false )
+    , desktopChangedWhileRotating( false )
+    , rotationDirection( Left )
+    , verticalRotationDirection( Upwards )
+    , verticalPosition( Normal )
+    , wallpaper( NULL )
+    , manualAngle( 0.0 )
+    , manualVerticalAngle( 0.0 )
+    , currentShape( TimeLine::EaseInOutCurve )
+    {
+    KConfigGroup conf = effects->effectConfig( "Cube" );
+    borderActivate = (ElectricBorder)conf.readEntry( "BorderActivate", (int)ElectricNone );
+    effects->reserveElectricBorder( borderActivate );
+
+    cubeOpacity = (float)conf.readEntry( "Opacity", 80 )/100.0f;
+    displayDesktopName = conf.readEntry( "DisplayDesktopName", true );
+    reflection = conf.readEntry( "Reflection", true );
+    int rotationDuration = conf.readEntry( "RotationDuration", 500 );
+    backgroundColor = conf.readEntry( "BackgroundColor", QColor( Qt::black ) );
+    QString file = conf.readEntry( "Wallpaper", QString("") );
+    if( !file.isEmpty() )
+        {
+        QImage img = QImage( file );
+        if( !img.isNull() )
+            {
+            wallpaper = new GLTexture( img );
+            }
+        }
+
+    timeLine.setCurveShape( TimeLine::EaseInOutCurve );
+    timeLine.setDuration( rotationDuration );
+
+    verticalTimeLine.setCurveShape( TimeLine::EaseInOutCurve );
+    verticalTimeLine.setDuration( rotationDuration );
+
+    KActionCollection* actionCollection = new KActionCollection( this );
+    KAction* a = static_cast< KAction* >( actionCollection->addAction( "Cube" ));
+    a->setText( i18n("Desktop Cube" ));
+    a->setGlobalShortcut( KShortcut( Qt::CTRL + Qt::Key_F11 ));
+    connect( a, SIGNAL( triggered( bool )), this, SLOT( toggle()));
+
+    // calculate values for projection matrix
+    // we use the projection matrix as in compiz (see Compiz: screen.c)
+    // with following values:
+    // fovy = 60.0
+    // acpect = 1.0
+    // zNear = 0.1
+    // zFar = 100.0
+    fovy = 60.0f;
+    aspect = 1.0f;
+    zNear = 0.1f;
+    zFar = 100.0f;
+    ymax = zNear * tan( fovy  * M_PI / 360.0f );
+    ymin = -ymax;
+    xmin =  ymin * aspect;
+    xmax = ymax * aspect;
+    }
+
+CubeEffect::~CubeEffect()
+    {
+    effects->unreserveElectricBorder( borderActivate );
+    delete wallpaper;
+    }
+
+void CubeEffect::prePaintScreen( ScreenPrePaintData& data, int time )
+    {
+    if( activated )
+        {
+        //kDebug();
+        data.mask |= PAINT_SCREEN_TRANSFORMED | Effect::PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS | PAINT_SCREEN_BACKGROUND_FIRST;
+
+        if( rotating )
+            {
+            timeLine.addTime( time );
+            }
+        if( verticalRotating )
+            {
+            verticalTimeLine.addTime( time );
+            }
+        }
+    effects->prePaintScreen( data, time );
+    }
+
+void CubeEffect::paintScreen( int mask, QRegion region, ScreenPaintData& data )
+    {
+    if( activated )
+        {
+        //kDebug();
+        QRect rect = effects->clientArea( FullArea, effects->activeScreen(), effects->currentDesktop());
+
+        // background
+        float clearColor[4];
+        glGetFloatv( GL_COLOR_CLEAR_VALUE, clearColor );
+        glClearColor( backgroundColor.redF(), backgroundColor.greenF(), backgroundColor.blueF(), 1.0 );
+        glClear( GL_COLOR_BUFFER_BIT );
+        glClearColor( clearColor[0], clearColor[1], clearColor[2], clearColor[3] );
+
+        // wallpaper
+        if( wallpaper )
+            {            
+            wallpaper->bind();
+            wallpaper->render( region, rect );
+            wallpaper->unbind();
+            }
+
+        glMatrixMode( GL_PROJECTION );
+        glPushMatrix();
+        glPushAttrib( GL_CURRENT_BIT | GL_ENABLE_BIT );
+        glLoadIdentity();
+
+        glFrustum( xmin, xmax, ymin, ymax, zNear, zFar );
+        
+        glMatrixMode( GL_MODELVIEW );
+        glLoadIdentity();
+
+        glPushMatrix();
+        glTranslatef( 0.0, 0.0, -zNear*2-2);
+        glEnable( GL_BLEND );
+        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+
+        // reflection
+        if( reflection )
+            {
+            glPushMatrix();
+            float zValue = -1.0f;
+            float scaleFactor = ( zNear*2+1 - zValue * 0.8f ) * tan( fovy * M_PI / 360.0f )/ymax;
+            float scaleFactor2 = zFar*0.3* tan( fovy * M_PI / 360.0f )/ymax;
+            glScalef( 1.0, -1.0, 1.0 );
+            glTranslatef( 0.0, ymax*scaleFactor*2, 0.0 );
+            paintScene( mask, region, data );
+            glPopMatrix();
+            glPushMatrix();
+            glTranslatef( 0.0, ymin*scaleFactor, 0.0 );
+            float vertices[] = {
+                xmin*scaleFactor, 0.0, zNear*2+2,
+                xmax*scaleFactor, 0.0, zNear*2+2,
+                xmax*scaleFactor2, 0.0, -zFar*0.3+zNear*2+2,
+                xmin*scaleFactor2, 0.0, -zFar*0.3+zNear*2+2 };
+            // foreground
+            float alpha = 0.9;
+            /*if( start )
+                alpha = timeLine.value();
+            else if( stop )
+                alpha = 1.0 - timeLine.value();*/
+            glColor4f( 0.0, 0.0, 0.0, alpha );
+            glBegin( GL_POLYGON );
+            glVertex3f( vertices[0], vertices[1], vertices[2] );
+            glVertex3f( vertices[3], vertices[4], vertices[5] );
+            // rearground
+            alpha = -1.0;
+            glColor4f( 0.0, 0.0, 0.0, alpha );
+            glVertex3f( vertices[6], vertices[7], vertices[8] );
+            glVertex3f( vertices[9], vertices[10], vertices[11] );
+            glEnd();
+            glPopMatrix();
+            }
+        paintScene( mask, region, data );
+
+        glPopMatrix();
+        glDisable( GL_BLEND );
+        glPopAttrib();
+        glMatrixMode( GL_PROJECTION );
+        glPopMatrix();
+        glMatrixMode( GL_MODELVIEW );
+
+        // desktop name box - inspired from coverswitch
+        if( displayDesktopName )
+            {
+            QColor color_frame;
+            QColor color_text;
+            color_frame = KColorScheme( QPalette::Active, KColorScheme::Window ).background().color();
+            color_frame.setAlphaF( 0.5 );
+            color_text = KColorScheme( QPalette::Active, KColorScheme::Window ).foreground().color();
+            /*if( start )
+                {
+                color_frame.setAlphaF( 0.9 * timeLine.value() );
+                color_text.setAlphaF( timeLine.value() );
+                }
+            else if( stop )
+                {
+                color_frame.setAlphaF( 0.9 - 0.9 * timeLine.value() );
+                color_text.setAlphaF( 1.0 - timeLine.value() );
+                }*/
+            QFont text_font;
+            text_font.setBold( true );
+            text_font.setPointSize( 14 );
+            glPushAttrib( GL_CURRENT_BIT );
+            glColor4f( color_frame.redF(), color_frame.greenF(), color_frame.blueF(), color_frame.alphaF());
+            QRect frameRect = QRect( rect.width()*0.33f + rect.x(),
+                rect.height() + rect.y() - QFontMetrics( text_font ).height() * 1.2f,
+                rect.width()*0.33f,
+                QFontMetrics( text_font ).height() * 1.2f );
+            renderRoundBoxWithEdge( frameRect );
+            effects->paintText( effects->desktopName( frontDesktop ),
+                frameRect.center(),
+                frameRect.width(),
+                color_text,
+                text_font );
+            glPopAttrib();
+            }
+        }
+    else
+        {
+        effects->paintScreen( mask, region, data );
+        }
+    }
+
+void CubeEffect::paintScene( int mask, QRegion region, ScreenPaintData& data )
+    {
+    QRect rect = effects->clientArea( FullArea, effects->activeScreen(), effects->currentDesktop());
+        float zValue = -1.0f;
+        float scaleFactor = ( zNear*2+1 - zValue * 0.8f ) * tan( fovy * M_PI / 360.0f )/ymax;
+        int rightSteps = effects->numberOfDesktops()/2;
+        int leftSteps = rightSteps+1;
+        int rightSideCounter = 0;
+        int leftSideCounter = 0;
+        float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2 )/(float)effects->numberOfDesktops() * 180.0f);
+        cube_painting = true;
+        float yTranslate = ymax*scaleFactor;
+        float yTop = (ymax-ymin)*scaleFactor;
+        int desktopIndex = 0;
+        int rotationSteps = 0;
+
+        // Rotation of the cube
+        float point = 1.1547;
+        if( verticalRotating || verticalPosition != Normal || manualVerticalAngle != 0.0 )
+            {
+            // change the verticalPosition if manualVerticalAngle > 90 or < -90 degrees
+            if( manualVerticalAngle <= -90.0 )
+                {
+                manualVerticalAngle += 90.0;
+                if( verticalPosition == Normal )
+                    verticalPosition = Down;
+                if( verticalPosition == Up )
+                    verticalPosition = Normal;
+                }
+            if( manualVerticalAngle >= 90.0 )
+                {
+                manualVerticalAngle -= 90.0;
+                if( verticalPosition == Normal )
+                    verticalPosition = Up;
+                if( verticalPosition == Down )
+                    verticalPosition = Normal;
+                }
+            float angle = 0.0;
+            if( verticalPosition == Up )
+                {
+                angle = 90.0;
+                if( !verticalRotating)
+                    {
+                    if( manualVerticalAngle < 0.0 )
+                        angle += manualVerticalAngle;
+                    else
+                        manualVerticalAngle = 0.0;
+                    }
+                }
+            else if( verticalPosition == Down )
+                {
+                angle = -90.0;
+                if( !verticalRotating)
+                    {
+                    if( manualVerticalAngle > 0.0 )
+                        angle += manualVerticalAngle;
+                    else
+                        manualVerticalAngle = 0.0;
+                    }
+                }
+            else
+                {
+                angle = manualVerticalAngle;
+                }
+            if( verticalRotating )
+                {
+                angle *= verticalTimeLine.value();
+                if( verticalPosition == Normal && verticalRotationDirection == Upwards )
+                    angle = -90.0 + 90*verticalTimeLine.value();
+                if( verticalPosition == Normal && verticalRotationDirection == Downwards )
+                    angle = 90.0 - 90*verticalTimeLine.value();
+                angle += manualVerticalAngle * (1.0-verticalTimeLine.value());
+                }
+            glTranslatef( 0.0, 0.0, -point);
+            glRotatef( angle, 1.0, 0.0, 0.0 );
+            glTranslatef( 0.0, 0.0, point);
+            }
+        if( rotating || manualAngle != 0.0 )
+            {
+            if( manualAngle > cubeAngle * 0.5f )
+                {
+                manualAngle -= cubeAngle;
+                frontDesktop--;
+                if( frontDesktop == 0 )
+                    frontDesktop = effects->numberOfDesktops();
+                }
+            if( manualAngle < -cubeAngle * 0.5f )
+                {
+                manualAngle += cubeAngle;
+                frontDesktop++;
+                if( frontDesktop > effects->numberOfDesktops() )
+                    frontDesktop = 1;
+                }
+            float rotationAngle = cubeAngle * timeLine.value();
+            if( rotationAngle > cubeAngle * 0.5f )
+                {
+                rotationAngle -= cubeAngle;
+                if( !desktopChangedWhileRotating )
+                    {
+                    desktopChangedWhileRotating = true;
+                    if( rotationDirection == Left )
+                        {
+                        frontDesktop++;
+                        }
+                    else if( rotationDirection == Right )
+                        {
+                        frontDesktop--;
+                        }
+                    if( frontDesktop > effects->numberOfDesktops() )
+                        frontDesktop = 1;
+                    else if( frontDesktop == 0 )
+                        frontDesktop = effects->numberOfDesktops();
+                    }
+                }
+            if( rotationDirection == Left )
+                {
+                rotationAngle *= -1;
+                }
+            rotationAngle += manualAngle * (1.0 - timeLine.value());
+            glTranslatef( 0.0, 0.0, -point);
+            glRotatef( rotationAngle, 0.0, 1.0, 0.0 );
+            glTranslatef( 0.0, 0.0, point);
+            }
+        for( int i=0; i<effects->numberOfDesktops(); i++ )
+            {
+            float angle = 0.0f;
+            float xTranslate = 0.0f;
+            float xLeft = 0.0f;
+            float xRight = 0.0f;
+            int xScale = 1;
+            bool scaleTranslate = false;
+            if( i%2 == 0 &&  i != effects->numberOfDesktops() -1)
+                {
+                // desktops on the right (including back)
+                xTranslate = xmax*scaleFactor;
+                xLeft = (xmin-xmax)*scaleFactor;
+                xScale = -1;
+                angle = -cubeAngle;
+                desktopIndex = rightSteps - rightSideCounter;
+                rightSideCounter++;
+                rotationSteps = rightSteps - rightSideCounter;
+                }
+            else
+                {
+                // desktops on the left (including front)
+                xTranslate = xmin*scaleFactor;
+                xRight = (xmax-xmin)*scaleFactor;
+                angle = cubeAngle;
+                desktopIndex = leftSteps + leftSideCounter;
+                leftSideCounter++;
+                rotationSteps = leftSteps - leftSideCounter -2;
+                if( effects->numberOfDesktops()%2 == 1 )
+                    {
+                    rotationSteps++;
+                    }
+                scaleTranslate = true;
+                }
+            glPushMatrix();
+            glTranslatef( xTranslate, yTranslate, 0.0 );
+            if( i == effects->numberOfDesktops() -1 )
+                {
+                // special handling front desktop
+                desktopIndex = 0;
+                angle = 0.0f;
+                rotationSteps = 0;
+                scaleTranslate = false;
+                }
+            glRotatef( angle, 0.0, 1.0, 0.0 );
+            for( int j=0; j<rotationSteps; j++ )
+                {
+                glTranslatef( -xTranslate*2, 0.0, 0.0 );
+                int factor = 1;
+                if( j%2 == 1 )
+                    factor = -1;
+                glRotatef( factor*angle, 0.0, 1.0, 0.0 );
+                glScalef( -1.0, 1.0, 1.0 );
+                }
+            if( scaleTranslate )
+                {
+                glScalef( -1.0, 1.0, 1.0 );
+                glTranslatef( xTranslate*2, 0.0, 0.0 );
+                }
+            // start painting the cube
+            painting_desktop = (desktopIndex + frontDesktop )%effects->numberOfDesktops();
+            if( painting_desktop == 0 )
+                {
+                painting_desktop = effects->numberOfDesktops();
+                }
+            glScalef( xScale * (xRight-xLeft)/rect.width(), -yTop/rect.height(), 1.0 );
+            effects->paintScreen( mask, region, data );
+            glPopMatrix();
+            }
+        cube_painting = false;
+        painting_desktop = effects->currentDesktop();
+    }
+
+void CubeEffect::postPaintScreen()
+    {
+    effects->postPaintScreen();
+    if( activated )
+        {
+        //kDebug();
+        if( rotating || verticalRotating )
+            {
+            if( rotating && timeLine.value() == 1.0 )
+                {
+                timeLine.setProgress(0.0);
+                rotating = false;
+                desktopChangedWhileRotating = false;
+                manualAngle = 0.0;
+                // more rotations?
+                if( !rotations.empty() )
+                    {
+                    rotationDirection = rotations.dequeue();
+                    rotating = true;
+                    // change the curve shape if current shape is not easeInOut
+                    if( currentShape != TimeLine::EaseInOutCurve )
+                        {
+                        // more rotations follow -> linear curve
+                        if( !rotations.empty() )
+                            {
+                            currentShape = TimeLine::LinearCurve;
+                            }
+                        // last rotation step -> easeOut curve
+                        else
+                            {
+                            currentShape = TimeLine::EaseOutCurve;
+                            }
+                        timeLine.setCurveShape( currentShape );
+                        }
+                    else
+                        {
+                        // if there is at least one more rotation, we can change to easeIn
+                        if( !rotations.empty() )
+                            {
+                            currentShape = TimeLine::EaseInCurve;
+                            timeLine.setCurveShape( currentShape );
+                            }
+                        }
+                    }
+                else
+                    {
+                    // reset curve shape if there are no more rotations
+                    if( currentShape != TimeLine::EaseInOutCurve )
+                        {
+                        currentShape = TimeLine::EaseInOutCurve;
+                        timeLine.setCurveShape( currentShape );
+                        }
+                    }
+                }
+            if( verticalRotating && verticalTimeLine.value() == 1.0 )
+                {
+                verticalTimeLine.setProgress(0.0);
+                verticalRotating = false;
+                manualVerticalAngle = 0.0;
+                // more rotations?
+                if( !verticalRotations.empty() )
+                    {
+                    verticalRotationDirection = verticalRotations.dequeue();
+                    verticalRotating = true;
+                    if( verticalRotationDirection == Upwards )
+                        {
+                        if( verticalPosition == Normal )
+                            verticalPosition = Up;
+                        if( verticalPosition == Down )
+                            verticalPosition = Normal;
+                        }
+                    if( verticalRotationDirection == Downwards )
+                        {
+                        if( verticalPosition == Normal )
+                            verticalPosition = Down;
+                        if( verticalPosition == Up )
+                            verticalPosition = Normal;
+                        }
+                    }
+                }
+            effects->addRepaintFull();
+            return; // rotation has to end before cube is closed
+            }
+        if( schedule_close )
+            {
+            schedule_close = false;
+            activated = false;
+            if( keyboard_grab )
+                effects->ungrabKeyboard();
+            keyboard_grab = false;
+            effects->destroyInputWindow( input );
+
+            // set the new desktop
+            effects->setCurrentDesktop( frontDesktop );
+            effects->setActiveFullScreenEffect( 0 );
+            effects->addRepaintFull();
+            }
+        }
+    }
+
+void CubeEffect::prePaintWindow( EffectWindow* w, WindowPrePaintData& data, int time )
+    {
+    if( activated )
+        {
+        //kDebug();
+        if( cube_painting )
+            {
+            if( w->isOnDesktop( painting_desktop ))
+                w->enablePainting( EffectWindow::PAINT_DISABLED_BY_DESKTOP );
+            else
+                {
+                // check for windows belonging to the previous desktop
+                int prev_desktop = painting_desktop -1;
+                if( prev_desktop == 0 )
+                    prev_desktop = effects->numberOfDesktops();
+                if( w->isOnDesktop( prev_desktop ) )
+                    {
+                    QRect rect = effects->clientArea( FullArea, effects->activeScreen(), prev_desktop);
+                    if( w->x()+w->width() > rect.x() + rect.width() )
+                        {
+                        w->enablePainting( EffectWindow::PAINT_DISABLED_BY_DESKTOP );
+                        data.setTransformed();
+                        effects->prePaintWindow( w, data, time );
+                        return;
+                        }
+                    }
+                // check for windows belonging to the next desktop
+                int next_desktop = painting_desktop +1;
+                if( next_desktop > effects->numberOfDesktops() )
+                    next_desktop = 1;
+                if( w->isOnDesktop( next_desktop ) )
+                    {
+                    QRect rect = effects->clientArea( FullArea, effects->activeScreen(), next_desktop);
+                    if( w->x() < rect.x() )
+                        {
+                        w->enablePainting( EffectWindow::PAINT_DISABLED_BY_DESKTOP );
+                        data.setTransformed();
+                        effects->prePaintWindow( w, data, time );
+                        return;
+                        }
+                    }
+                w->disablePainting( EffectWindow::PAINT_DISABLED_BY_DESKTOP );
+                }
+            }
+        }
+    effects->prePaintWindow( w, data, time );
+    }
+
+void CubeEffect::paintWindow( EffectWindow* w, int mask, QRegion region, WindowPaintData& data )
+    {
+    if( activated && cube_painting )
+        {
+        //kDebug() << w->caption();
+        data.opacity *= cubeOpacity;
+        // check for windows belonging to the previous desktop
+        int prev_desktop = painting_desktop -1;
+        if( prev_desktop == 0 )
+            prev_desktop = effects->numberOfDesktops();
+        int next_desktop = painting_desktop +1;
+        if( next_desktop > effects->numberOfDesktops() )
+            next_desktop = 1;
+        if( w->isOnDesktop( prev_desktop ) && ( mask & PAINT_WINDOW_TRANSFORMED ) )
+            {
+            QRect rect = effects->clientArea( FullArea, effects->activeScreen(), prev_desktop);
+            data.xTranslate = -rect.width();
+            }
+        if( w->isOnDesktop( next_desktop ) )
+            {
+            QRect rect = effects->clientArea( FullArea, effects->activeScreen(), next_desktop);
+            data.xTranslate = rect.width();
+            }
+        }
+    effects->paintWindow( w, mask, region, data );
+    }
+
+void CubeEffect::postPaintWindow( EffectWindow* w )
+    {
+    if( activated && !cube_painting )
+        {
+        // a window was updated which has not been handled by cube_painting.
+        // trigger full repaint, so that this window will be updated
+        //effects->addRepaintFull();
+        }
+    effects->postPaintWindow( w );
+    }
+
+bool CubeEffect::borderActivated( ElectricBorder border )
+    {
+    if( effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this )
+        return false;
+    if( border == borderActivate && !activated )
+        {
+        kDebug() << "border activated";
+        toggle();
+        return true;
+        }
+    return false;
+    }
+
+void CubeEffect::toggle()
+    {
+    if( effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this )
+        return;
+    if( !activated )
+        {
+        setActive( true );
+        }
+    else
+        {
+        setActive( false );
+        }
+    }
+
+void CubeEffect::grabbedKeyboardEvent( QKeyEvent* e )
+    {
+    // taken from desktopgrid.cpp
+    if( e->type() == QEvent::KeyPress )
+        {
+        int desktop = -1;
+        // switch by F<number> or just <number>
+        if( e->key() >= Qt::Key_F1 && e->key() <= Qt::Key_F35 )
+            desktop = e->key() - Qt::Key_F1 + 1;
+        else if( e->key() >= Qt::Key_0 && e->key() <= Qt::Key_9 )
+            desktop = e->key() == Qt::Key_0 ? 10 : e->key() - Qt::Key_0;
+        if( desktop != -1 )
+            {
+            if( desktop <= effects->numberOfDesktops())
+                {
+                // we have to rotate to chosen desktop
+                // and end effect when rotation finished
+                int tempFrontDesktop = frontDesktop;
+                if( !rotations.empty() )
+                    {
+                    // all scheduled rotations will be removed as a speed up
+                    rotations.clear();
+                    }
+                if( rotating && !desktopChangedWhileRotating )
+                    {
+                    // front desktop will change during the actual rotation - this has to be considered
+                    if( rotationDirection == Left )
+                        {
+                        tempFrontDesktop++;
+                        }
+                    else if( rotationDirection == Right )
+                        {
+                        tempFrontDesktop--;
+                        }
+                    if( tempFrontDesktop > effects->numberOfDesktops() )
+                        tempFrontDesktop = 1;
+                    else if( tempFrontDesktop == 0 )
+                        tempFrontDesktop = effects->numberOfDesktops();
+                    }
+                // find the fastest rotation path from tempFrontDesktop to desktop
+                int rightRotations = tempFrontDesktop - desktop;
+                if( rightRotations < 0 )
+                    rightRotations += effects->numberOfDesktops();
+                int leftRotations = desktop - tempFrontDesktop;
+                if( leftRotations < 0 )
+                    leftRotations += effects->numberOfDesktops();
+                if( leftRotations <= rightRotations )
+                    {
+                    for( int i=0; i<leftRotations; i++ )
+                        {
+                        rotations.enqueue( Left );
+                        }
+                    }
+                else
+                    {
+                    for( int i=0; i<rightRotations; i++ )
+                        {
+                        rotations.enqueue( Right );
+                        }
+                    }
+                if( !rotating && !rotations.empty() )
+                    {
+                    rotating = true;
+                    rotationDirection = rotations.dequeue();
+                    }
+                // change timeline curve if more rotations are following
+                if( !rotations.empty() )
+                    {
+                    currentShape = TimeLine::EaseInCurve;
+                    timeLine.setCurveShape( currentShape );
+                    }
+                setActive( false );
+                }
+            return;
+            }
+        switch( e->key())
+            { // wrap only on autorepeat
+            case Qt::Key_Left:
+                // rotate to previous desktop
+                kDebug() << "left";
+                if( !rotating )
+                    {
+                    rotating = true;
+                    rotationDirection = Left;
+                    }
+                else
+                    {
+                    rotations.enqueue( Left );
+                    }
+                break;
+            case Qt::Key_Right:
+                // rotate to next desktop
+                kDebug() << "right";
+                if( !rotating )
+                    {
+                    rotating = true;
+                    rotationDirection = Right;
+                    }
+                else
+                    {
+                    rotations.enqueue( Right );
+                    }
+                break;
+            case Qt::Key_Up:
+                kDebug() << "up";
+                if( verticalPosition != Up )
+                    {
+                    if( !verticalRotating )
+                        {
+                        verticalRotating = true;
+                        verticalRotationDirection = Upwards;
+                        if( verticalPosition == Normal )
+                            verticalPosition = Up;
+                        if( verticalPosition == Down )
+                            verticalPosition = Normal;
+                        }
+                    else
+                        {
+                        verticalRotations.enqueue( Upwards );
+                        }
+                    }
+                else if( manualVerticalAngle < 0.0 && !verticalRotating )
+                    {
+                    // rotate to up position from the manual position
+                    verticalRotating = true;
+                    verticalRotationDirection = Upwards;
+                    verticalPosition = Up;
+                    manualVerticalAngle += 90.0;
+                    }
+                break;
+            case Qt::Key_Down:
+                kDebug() << "down";
+                if( verticalPosition != Down )
+                    {
+                    if( !verticalRotating )
+                        {
+                        verticalRotating = true;
+                        verticalRotationDirection = Downwards;
+                        if( verticalPosition == Normal )
+                            verticalPosition = Down;
+                        if( verticalPosition == Up )
+                            verticalPosition = Normal;
+                        }
+                    else
+                        {
+                        verticalRotations.enqueue( Downwards );
+                        }
+                    }
+                else if( manualVerticalAngle > 0.0 && !verticalRotating )
+                    {
+                    // rotate to down position from the manual position
+                    verticalRotating = true;
+                    verticalRotationDirection = Downwards;
+                    verticalPosition = Down;
+                    manualVerticalAngle -= 90.0;
+                    }
+                break;
+            case Qt::Key_Escape:
+                setActive( false );
+                return;
+            case Qt::Key_Enter:
+            case Qt::Key_Return:
+            case Qt::Key_Space:
+                //effects->setCurrentDesktop( highlighted_desktop );
+                setActive( false );
+                return;
+            default:
+                break;
+            }
+        effects->addRepaintFull();
+        }
+    }
+
+void CubeEffect::setActive( bool active )
+    {
+    if( active )
+        {
+        activated = true;
+        keyboard_grab = effects->grabKeyboard( this );
+        input = effects->createInputWindow( this, 0, 0, displayWidth(), displayHeight(),
+            Qt::PointingHandCursor );
+        effects->setActiveFullScreenEffect( this );
+        frontDesktop = effects->currentDesktop();
+        kDebug() << "Cube is activated";
+        verticalPosition = Normal;
+        verticalRotating = false;
+        manualAngle = 0.0;
+        manualVerticalAngle = 0.0;
+        effects->addRepaintFull();
+        }
+    else
+        {
+        schedule_close = true;
+        // we have to add a repaint, to start the deactivating
+        effects->addRepaintFull();
+        }
+    }
+
+void CubeEffect::mouseChanged( const QPoint& pos, const QPoint& oldpos, Qt::MouseButtons buttons, 
+            Qt::MouseButtons oldbuttons, Qt::KeyboardModifiers modifiers, Qt::KeyboardModifiers oldmodifiers )
+    {
+    if( !activated )
+        return;
+    QRect rect = effects->clientArea( FullArea, effects->activeScreen(), effects->currentDesktop());
+    if( buttons.testFlag( Qt::LeftButton ) )
+        {
+        bool repaint = false;
+        // vertical movement only if there is not a rotation
+        if( !verticalRotating )
+            {
+            // display height corresponds to 180*
+            int deltaY = oldpos.y() - pos.y();
+            float deltaVerticalDegrees = (float)deltaY/rect.height()*180.0f;
+            manualVerticalAngle -= deltaVerticalDegrees;
+            if( deltaVerticalDegrees != 0.0 )
+                repaint = true;
+            }
+        // horizontal movement only if there is not a rotation
+        if( !rotating )
+            {
+            // display width corresponds to sum of angles of the polyhedron
+            int deltaX = oldpos.x() - pos.x();
+            float deltaDegrees = (float)deltaX/rect.width() * 180.0f * ( effects->numberOfDesktops() - 2 );
+            manualAngle -= deltaDegrees;
+            if( deltaDegrees != 0.0 )
+                repaint = true;
+            }
+        if( repaint )
+            effects->addRepaintFull();
+        }
+    if( !oldbuttons.testFlag( Qt::LeftButton ) && buttons.testFlag( Qt::LeftButton ) )
+        {
+        kDebug() << "LMB pressed";
+        // TODO: change mouse courser to grab hand
+        }
+    if( oldbuttons.testFlag( Qt::LeftButton) && !buttons.testFlag( Qt::LeftButton ) )
+        {
+        kDebug() << "LMB released";
+        // TODO: change back mouse courser to normal hand
+        }
+    if( oldbuttons.testFlag( Qt::RightButton) && !buttons.testFlag( Qt::RightButton ) )
+        {
+        // end effect on right mouse button
+        setActive( false );
+        }
+    }
+
+} // namespace
--- /dev/null	2006-08-21 11:51:14.000000000 +0200
+++ kwin/effects/cube.h	2008-07-06 19:21:35.000000000 +0200
@@ -0,0 +1,107 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+ Copyright (C) 2008 Martin Gräßlin <ubuntu@martin-graesslin.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#ifndef KWIN_CUBE_H
+#define KWIN_CUBE_H
+
+#include <kwineffects.h>
+#include <kwinglutils.h>
+#include <QObject>
+#include <QQueue>
+
+namespace KWin
+{
+
+class CubeEffect
+    : public QObject, public Effect
+    {
+    Q_OBJECT
+    public:
+        CubeEffect();
+        ~CubeEffect();
+        virtual void prePaintScreen( ScreenPrePaintData& data, int time );
+        virtual void paintScreen( int mask, QRegion region, ScreenPaintData& data );
+        virtual void postPaintScreen();
+        virtual void prePaintWindow( EffectWindow* w, WindowPrePaintData& data, int time );
+        virtual void paintWindow( EffectWindow* w, int mask, QRegion region, WindowPaintData& data );
+        virtual void postPaintWindow( EffectWindow* w);
+        virtual bool borderActivated( ElectricBorder border );
+        virtual void grabbedKeyboardEvent( QKeyEvent* e );
+        virtual void mouseChanged( const QPoint& pos, const QPoint& oldpos, Qt::MouseButtons buttons, 
+            Qt::MouseButtons oldbuttons, Qt::KeyboardModifiers modifiers, Qt::KeyboardModifiers oldmodifiers );
+    private slots:
+        void toggle();
+    private:
+        enum RotationDirection
+            {
+            Left,
+            Right,
+            Upwards,
+            Downwards
+            };
+        enum VerticalRotationPosition
+            {
+            Up,
+            Normal,
+            Down
+            };
+        void paintScene( int mask, QRegion region, ScreenPaintData& data );
+        void setActive( bool active );
+        bool activated;
+        bool cube_painting;
+        bool keyboard_grab;
+        bool schedule_close;
+        ElectricBorder borderActivate;
+        int painting_desktop;
+        Window input;
+        int frontDesktop;
+        float cubeOpacity;
+        bool displayDesktopName;
+        bool reflection;
+        bool rotating;
+        bool verticalRotating;
+        bool desktopChangedWhileRotating;
+        TimeLine timeLine;
+        TimeLine verticalTimeLine;
+        RotationDirection rotationDirection;
+        RotationDirection verticalRotationDirection;
+        VerticalRotationPosition verticalPosition;
+        QQueue<RotationDirection> rotations;
+        QQueue<RotationDirection> verticalRotations;
+        QColor backgroundColor;
+        GLTexture* wallpaper;
+        float manualAngle;
+        float manualVerticalAngle;
+        TimeLine::CurveShape currentShape;
+
+        // variables for defining the projection matrix
+        float fovy;
+        float aspect;
+        float ymax;
+        float ymin;
+        float xmax;
+        float xmin;
+        float zNear;
+        float zFar;
+    };
+
+} // namespace
+
+#endif
