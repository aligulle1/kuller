--- devil-1.6.7.orig/include/IL/il.h
+++ devil-1.6.7/include/IL/il.h
@@ -114,8 +114,8 @@
 typedef unsigned int	ILenum;
 typedef unsigned char	ILboolean;
 typedef unsigned int	ILbitfield;
-typedef char			ILbyte;
-typedef short			ILshort;
+typedef signed char		ILbyte;
+typedef signed short		ILshort;
 typedef int				ILint;
 typedef int				ILsizei;
 typedef unsigned char	ILubyte;
--- devil-1.6.7.orig/include/IL/il_wrap.h
+++ devil-1.6.7/include/IL/il_wrap.h
@@ -3,7 +3,7 @@
 
 /*#include <il/il.h>
 #include <il/ilu.h>*/
-#include <il/ilut.h>  // Probably only have to #include this one
+#include <IL/ilut.h>  // Probably only have to #include this one
 
 #ifdef _MSC_VER
 	#ifndef _IL_WRAP_BUILD_LIB
@@ -202,4 +202,4 @@
 };
 
 
-#endif//WRAPPER_H
\ No newline at end of file
+#endif//WRAPPER_H
--- devil-1.6.7.orig/src-IL/include/il_endian.h
+++ devil-1.6.7/src-IL/include/il_endian.h
@@ -15,7 +15,9 @@
 
 #include "il_internal.h"
 
-#ifdef __BIG_ENDIAN__
+#if (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __BIG_ENDIAN__) \
+ || (defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__))
+	#undef __LITTLE_ENDIAN__
 	#define Short(s) _SwapShort(s)
 	#define UShort(s) _SwapUShort(s)
 	#define Int(i) _SwapInt(i)
@@ -30,6 +32,7 @@
 	#define BigFloat(f)  
 	#define BigDouble(d)  
 #else
+	#undef __BIG_ENDIAN__
 	#undef __LITTLE_ENDIAN__  // Not sure if it's defined by any compiler...
 	#define __LITTLE_ENDIAN__
 	#define Short(s)  
--- devil-1.6.7.orig/src-IL/src/il_pal.c
+++ devil-1.6.7/src-IL/src/il_pal.c
@@ -140,7 +140,7 @@
 //	MaxLen must be greater than 1, because the trailing NULL is always stored.
 char *iFgetw(char *Buff, ILint MaxLen, FILE *File)
 {
-	ILbyte Temp;
+	ILint Temp;
 	ILint i;
 
 	if (Buff == NULL || File == NULL || MaxLen < 2) {
--- devil-1.6.7.orig/src-IL/src/il_png.c
+++ devil-1.6.7/src-IL/src/il_png.c
@@ -284,7 +284,8 @@
 {
 	ILuint		i;
 	png_bytepp	row_pointers = NULL;
-	ILuint		width, height, channels;
+	ILuint		channels;
+	png_uint_32	width, height;
 	ILdouble	screen_gamma = 1.0, image_gamma;
 	ILuint		bit_depth;
 
--- devil-1.6.7.orig/src-IL/src/Makefile.am
+++ devil-1.6.7/src-IL/src/Makefile.am
@@ -14,7 +14,7 @@
 
 AM_CFLAGS = @LIBIL_CFLAGS@
 libIL_la_LDFLAGS = -no-undefined @VERSIONINFO@
-libIL_la_LIBADD = @LIBPNG@ @LIBJPG@ @LIBTIFF@ @LIBGIF@ @LIBMNG@ @LIBLCMS@ @LIBZ@
+libIL_la_LIBADD = @LIBPNG@ @LIBJPG@ @LIBTIFF@ @LIBMNG@ @LIBLCMS@ @LIBZ@
 
-INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/src-IL/include
+INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/src-IL/include -I$(top_builddir)/include
 
--- devil-1.6.7.orig/src-ILU/include/ilu_region.h
+++ devil-1.6.7/src-ILU/include/ilu_region.h
@@ -24,4 +24,31 @@
 } Edge;
 
 
+#endif//ILU_REGION_H
+//-----------------------------------------------------------------------------
+//
+// ImageLib Utility Sources
+// Copyright (C) 2000-2002 by Denton Woods
+// Last modified: 07/09/2002 <--Y2K Compliant! =]
+//
+// Filename: src-ILU/src/ilu_region.h
+//
+// Description: Creates an image region.
+//
+//-----------------------------------------------------------------------------
+
+#ifndef ILU_REGION_H
+#define ILU_REGION_H
+
+#include "ilu_internal.h"
+
+
+typedef struct Edge
+{
+	ILint	yUpper;
+	ILfloat	xIntersect, dxPerScan;
+	struct	Edge *next;
+} Edge;
+
+
 #endif//ILU_REGION_H
\ No newline at end of file
--- devil-1.6.7.orig/src-ILU/src/Makefile.am
+++ devil-1.6.7/src-ILU/src/Makefile.am
@@ -10,7 +10,7 @@
 AM_CFLAGS = @LIBILU_CFLAGS@
 
 libILU_la_LDFLAGS = -no-undefined @VERSIONINFO@ \
-                    -L$(top_srcdir)/src-IL/src/
+                    -L$(top_builddir)/src-IL/src/
 libILU_la_LIBADD = -lIL
 
 INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/src-ILU/include
--- devil-1.6.7.orig/src-ILUT/src/Makefile.am
+++ devil-1.6.7/src-ILUT/src/Makefile.am
@@ -9,8 +9,8 @@
 AM_CFLAGS = @LIBILUT_CFLAGS@
 
 libILUT_la_LDFLAGS = -no-undefined @VERSIONINFO@ \
-                     -L$(top_srcdir)/src-IL/src \
-                     -L$(top_srcdir)/src-ILU/src \
+                     -L$(top_builddir)/src-IL/src \
+                     -L$(top_builddir)/src-ILU/src \
                      @LIBSDL@ @LIBALLEGRO@ @LIBILUT_WIN32LIBPATH@
 
 libILUT_la_LIBADD = -lIL -lILU @LIBGL@ @LIBGDI32@
--- devil-1.6.7.orig/il_wrap.cpp
+++ devil-1.6.7/il_wrap.cpp
@@ -0,0 +1,879 @@
+#define _IL_WRAP_BUILD_LIB
+#include <IL/il_wrap.h>
+
+//#define TEST_WRAPPER  // Comment-out to get rid of main()
+
+#ifdef TEST_WRAPPER
+#include <iostream.h>
+
+int main(int argc, char **argv)
+{
+        ilInit();
+        iluInit();
+
+	if (argc < 2) {
+		cout << "Please specify a filename." << endl;
+		return 1;
+	}
+
+	ilImage Image(argv[1]);
+
+	cout << Image.Width() << ' ' << Image.Height() << ' ' << (ILuint)Image.Bpp() << endl;
+
+	ilEnable(IL_FILE_OVERWRITE);
+
+	Image.Save("test.tga");
+
+	return 0;
+}
+#endif
+
+
+//
+//
+// ILIMAGE
+//
+//
+
+ilImage::ilImage()
+{
+	this->Id = 0;
+	//this->iStartUp();
+	this->iGenBind();
+	return;
+}
+
+
+ilImage::ilImage(char *FileName)
+{
+	this->Id = 0;
+	//this->iStartUp();
+	this->iGenBind();
+	ilLoadImage(FileName);
+	return;
+}
+
+
+ilImage::ilImage(const ilImage &Image)
+{
+	this->Id = 0;
+	//this->iStartUp();
+	this->iGenBind();
+	*this = Image;
+	return;
+}
+
+
+ilImage::~ilImage()
+{
+	if (this->Id)
+		ilDeleteImages(1, &this->Id);
+	this->Id = 0;
+	return;
+}
+
+
+ILboolean ilImage::Load(char *FileName)
+{
+	this->iGenBind();
+	return ilLoadImage(FileName);
+}
+
+
+ILboolean ilImage::Load(char *FileName, ILenum Type)
+{
+	this->iGenBind();
+	return ilLoad(Type, FileName);
+}
+
+
+ILboolean ilImage::Save(char *FileName)
+{
+	this->iGenBind();
+	return ilSaveImage(FileName);
+}
+
+
+ILboolean ilImage::Save(char *FileName, ILenum Type)
+{
+	this->iGenBind();
+	return ilSave(Type, FileName);
+}
+
+
+
+//
+// ImageLib functions
+//
+
+ILboolean ilImage::ActiveImage(ILuint Number)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilActiveImage(Number);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::ActiveLayer(ILuint Number)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilActiveLayer(Number);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::ActiveMipmap(ILuint Number)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilActiveMipmap(Number);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::Clear()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilClearImage();
+	}
+	return IL_FALSE;
+}
+
+
+ILvoid ilImage::ClearColour(ILubyte Red, ILubyte Green, ILubyte Blue, ILubyte Alpha)
+{
+	ilClearColour(Red, Green, Blue, Alpha);
+	return;
+}
+
+
+ILboolean ilImage::Convert(ILenum NewFormat)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilConvertImage(NewFormat, IL_UNSIGNED_BYTE);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::Copy(ILuint Src)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilCopyImage(Src);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::Default()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilDefaultImage();
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::Flip()
+{
+	if (this->Id) {
+		this->Bind();
+		return iluFlipImage();
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::SwapColours()
+{
+	if (this->Id) {
+		this->Bind();
+		return iluSwapColours();
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::Resize(ILuint Width, ILuint Height, ILuint Depth)
+{
+	if (this->Id) {
+		this->Bind();
+		return iluScale(Width, Height, Depth);
+	}
+	return IL_FALSE;
+}
+
+
+ILboolean ilImage::TexImage(ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp, ILenum Format, ILenum Type, ILvoid *Data)
+{
+	if (this->Id) {
+		this->Bind();
+		return ilTexImage(Width, Height, Depth, Bpp, Format, Type, Data);
+	}
+	return IL_FALSE;
+}
+
+
+
+//
+// Image handling
+//
+
+ILvoid ilImage::Bind() const
+{
+	if (this->Id)
+		ilBindImage(this->Id);
+	return;
+}
+
+
+// Note:  Behaviour may be changed!
+ILvoid ilImage::Bind(ILuint Image)
+{
+	if (this->Id == Image)
+		return;
+	this->Delete();  // Should we delete it?
+	this->Id = Image;
+	ilBindImage(this->Id);
+	return;
+}
+
+
+ILvoid ilImage::Delete()
+{
+	if (this->Id == 0)
+		return;
+	ilDeleteImages(1, &this->Id);
+	this->Id = 0;
+	return;
+}
+
+
+
+
+//
+// Image characteristics
+//
+
+ILuint ilImage::Width()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_WIDTH);
+	}
+	return 0;
+}
+
+
+ILuint ilImage::Height()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_HEIGHT);
+	}
+	return 0;
+}
+
+
+ILuint ilImage::Depth()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_DEPTH);
+	}
+	return 0;
+}
+
+
+ILubyte ilImage::Bpp()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_BYTES_PER_PIXEL);
+	}
+	return 0;
+}
+
+
+ILubyte ilImage::Bitpp()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_BITS_PER_PIXEL);
+	}
+	return 0;
+}
+
+
+ILenum ilImage::Format()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_FORMAT);
+	}
+	return 0;
+}
+
+ILenum ilImage::PaletteType()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_PALETTE_TYPE);
+	}
+	return 0;
+}
+
+
+ILenum ilImage::Type()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_IMAGE_TYPE);
+	}
+	return 0;
+}
+
+
+ILenum ilImage::NumImages()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_NUM_IMAGES);
+	}
+	return 0;
+}
+
+
+ILenum ilImage::NumMipmaps()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetInteger(IL_NUM_MIPMAPS);
+	}
+	return 0;
+}
+
+
+ILuint ilImage::GetId() const
+{
+	return this->Id;
+}
+
+ILenum ilImage::GetOrigin(ILvoid)
+{
+    ILinfo Info;
+
+	if (this->Id) {
+		this->Bind();
+        iluGetImageInfo(&Info);
+		return Info.Origin;
+	}
+	return 0;
+}
+
+ILubyte* ilImage::GetData()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetData();
+	}
+	return 0;
+}
+
+
+ILubyte* ilImage::GetPalette()
+{
+	if (this->Id) {
+		this->Bind();
+		return ilGetPalette();
+	}
+	return 0;
+}
+
+
+
+//
+// Private members
+//
+
+ILvoid ilImage::iStartUp()
+{
+	ilInit();
+	iluInit();
+	ilutInit();
+	return;
+}
+
+
+ILvoid ilImage::iGenBind()
+{
+	if (this->Id == 0) {
+		ilGenImages(1, &this->Id);
+	}
+	ilBindImage(this->Id);
+	return;
+}
+
+
+
+//
+// Operators
+//
+
+ilImage& ilImage::operator = (ILuint Image)
+{
+	if (this->Id == 0)
+		this->Id = Image;
+	else {
+		this->Bind();
+		ilCopyImage(Image);
+	}
+
+	return *this;
+}
+
+
+ilImage& ilImage::operator = (const ilImage &Image)
+{
+	if (Id == 0)
+		Id = Image.GetId();
+	else {
+		Bind();
+		ilCopyImage(Image.GetId());
+	}
+
+	return *this;
+}
+
+
+
+//
+//
+// ILFILTERS
+//
+//
+
+ILboolean ilFilters::Alienify(ilImage &Image)
+{
+	Image.Bind();
+	return iluAlienify();
+}
+
+
+ILboolean ilFilters::BlurAvg(ilImage &Image, ILuint Iter)
+{
+	Image.Bind();
+	return iluBlurAvg(Iter);
+}
+
+
+
+ILboolean ilFilters::BlurGaussian(ilImage &Image, ILuint Iter)
+{
+	Image.Bind();
+	return iluBlurGaussian(Iter);
+}
+
+
+ILboolean ilFilters::Contrast(ilImage &Image, ILfloat Contrast)
+{
+	Image.Bind();
+	return iluContrast(Contrast);
+}
+
+
+ILboolean ilFilters::EdgeDetectE(ilImage &Image)
+{
+	Image.Bind();
+	return iluEdgeDetectP();
+}
+
+
+ILboolean ilFilters::EdgeDetectP(ilImage &Image)
+{
+	Image.Bind();
+	return iluEdgeDetectP();
+}
+
+
+ILboolean ilFilters::EdgeDetectS(ilImage &Image)
+{
+	Image.Bind();
+	return iluEdgeDetectS();
+}
+
+
+ILboolean ilFilters::Emboss(ilImage &Image)
+{
+	Image.Bind();
+	return iluEmboss();
+}
+
+
+ILboolean ilFilters::Gamma(ilImage &Image, ILfloat Gamma)
+{
+	Image.Bind();
+	return iluGammaCorrect(Gamma);
+}
+
+
+ILboolean ilFilters::Negative(ilImage &Image)
+{
+	Image.Bind();
+	return iluNegative();
+}
+
+
+ILboolean ilFilters::Noisify(ilImage &Image, ILubyte Factor)
+{
+	Image.Bind();
+	return iluNoisify(Factor);
+}
+
+
+ILboolean ilFilters::Pixelize(ilImage &Image, ILuint PixSize)
+{
+	Image.Bind();
+	return iluPixelize(PixSize);
+}
+
+
+ILboolean ilFilters::Saturate(ilImage &Image, ILfloat Saturation)
+{
+	Image.Bind();
+	return iluSaturate1f(Saturation);
+}
+
+
+ILboolean ilFilters::Saturate(ilImage &Image, ILfloat r, ILfloat g, ILfloat b, ILfloat Saturation)
+{
+	Image.Bind();
+	return iluSaturate4f(r, g, b, Saturation);
+}
+
+
+ILboolean ilFilters::ScaleColours(ilImage &Image, ILfloat r, ILfloat g, ILfloat b)
+{
+	Image.Bind();
+	return iluScaleColours(r, g, b);
+}
+
+
+ILboolean ilFilters::Sharpen(ilImage &Image, ILfloat Factor, ILuint Iter)
+{
+	Image.Bind();
+	return iluSharpen(Factor, Iter);
+}
+
+
+
+//
+//
+// ILOPENGL
+//
+//
+
+#ifdef ILUT_USE_OPENGL
+ILvoid ilOgl::Init()
+{
+	ilutRenderer(ILUT_OPENGL);
+	return;
+}
+
+
+GLuint ilOgl::BindTex(ilImage &Image)
+{
+	Image.Bind();
+	return ilutGLBindTexImage();
+}
+
+
+ILboolean ilOgl::Upload(ilImage &Image, ILuint Level)
+{
+	Image.Bind();
+	return ilutGLTexImage(Level);
+}
+
+
+GLuint ilOgl::Mipmap(ilImage &Image)
+{
+	Image.Bind();
+	return ilutGLBuildMipmaps();
+}
+
+
+ILboolean ilOgl::Screen()
+{
+	return ilutGLScreen();
+}
+
+
+ILboolean ilOgl::Screenie()
+{
+	return ilutGLScreenie();
+}
+#endif//ILUT_USE_OPENGL
+
+
+
+//
+//
+// ILALLEGRO
+//
+//
+
+#ifdef ILUT_USE_ALLEGRO
+ILvoid ilAlleg::Init()
+{
+	ilutRenderer(IL_ALLEGRO);
+	return;
+}
+
+
+BITMAP *ilAlleg::Convert(ilImage &Image, PALETTE Pal)
+{
+	Image.Bind();
+	return ilutConvertToAlleg(Pal);
+}
+#endif//ILUT_USE_ALLEGRO
+
+
+
+//
+//
+// ILWIN32
+//
+//
+
+#ifdef ILUT_USE_WIN32
+ILvoid ilWin32::Init()
+{
+	ilutRenderer(ILUT_WIN32);
+	return;
+}
+
+
+HBITMAP ilWin32::Convert(ilImage &Image)
+{
+	Image.Bind();
+	return ilutConvertToHBitmap(GetDC(NULL));
+}
+
+
+ILboolean ilWin32::GetClipboard(ilImage &Image)
+{
+	Image.Bind();
+	return ilutGetWinClipboard();
+}
+
+
+ILvoid ilWin32::GetInfo(ilImage &Image, BITMAPINFO *Info)
+{
+	Image.Bind();
+	ilutGetBmpInfo(Info);
+	return;
+}
+
+
+ILubyte* ilWin32::GetPadData(ilImage &Image)
+{
+	Image.Bind();
+	return ilutGetPaddedData();
+}
+
+
+HPALETTE ilWin32::GetPal(ilImage &Image)
+{
+	Image.Bind();
+	return ilutGetHPal();
+}
+
+
+ILboolean ilWin32::GetResource(ilImage &Image, HINSTANCE hInst, ILint ID, char *ResourceType)
+{
+	Image.Bind();
+	return ilutLoadResource(hInst, ID, ResourceType, IL_TYPE_UNKNOWN);
+}
+
+
+ILboolean ilWin32::GetResource(ilImage &Image, HINSTANCE hInst, ILint ID, char *ResourceType, ILenum Type)
+{
+	Image.Bind();
+	return ilutLoadResource(hInst, ID, ResourceType, Type);
+}
+
+
+ILboolean ilWin32::SetClipboard(ilImage &Image)
+{
+	Image.Bind();
+	return ilutSetWinClipboard();
+}
+#endif//ILUT_USE_WIN32
+
+
+
+//
+//
+// ILVALIDATE
+//
+//
+
+ILboolean ilValidate::Valid(ILenum Type, char *FileName)
+{
+	return ilIsValid(Type, FileName);
+}
+
+
+ILboolean ilValidate::Valid(ILenum Type, FILE *File)
+{
+	return ilIsValidF(Type, File);
+}
+
+
+ILboolean ilValidate::Valid(ILenum Type, ILvoid *Lump, ILuint Size)
+{
+	return ilIsValidL(Type, Lump, Size);
+}
+
+
+
+//
+//
+// ILSTATE
+//
+//
+
+ILboolean ilState::Disable(ILenum State)
+{
+	return ilDisable(State);
+}
+
+
+ILboolean ilState::Enable(ILenum State)
+{
+	return ilEnable(State);
+}
+
+
+ILvoid ilState::Get(ILenum Mode, ILboolean &Param)
+{
+	ilGetBooleanv(Mode, &Param);
+	return;
+}
+
+
+ILvoid ilState::Get(ILenum Mode, ILint &Param)
+{
+	ilGetIntegerv(Mode, &Param);
+	return;
+}
+
+
+ILboolean ilState::GetBool(ILenum Mode)
+{
+	return ilGetBoolean(Mode);
+}
+
+
+ILint ilState::GetInt(ILenum Mode)
+{
+	return ilGetInteger(Mode);
+}
+
+
+const char *ilState::GetString(ILenum StringName)
+{
+	return ilGetString(StringName);
+}
+
+
+ILboolean ilState::IsDisabled(ILenum Mode)
+{
+	return ilIsDisabled(Mode);
+}
+
+
+ILboolean ilState::IsEnabled(ILenum Mode)
+{
+	return ilIsEnabled(Mode);
+}
+
+
+ILboolean ilState::Origin(ILenum Mode)
+{
+	return ilOriginFunc(Mode);
+}
+
+
+ILvoid ilState::Pop()
+{
+	ilPopAttrib();
+	return;
+}
+
+
+ILvoid ilState::Push(ILuint Bits = IL_ALL_ATTRIB_BITS)
+{
+	ilPushAttrib(Bits);
+	return;
+}
+
+
+
+
+
+//
+//
+// ILERROR
+//
+//
+
+ILvoid ilError::Check(ILvoid (*Callback)(const char*))
+{
+	static ILenum Error;
+
+	while ((Error = ilGetError()) != IL_NO_ERROR) {
+		Callback(iluErrorString(Error));
+	}
+
+	return;
+}
+
+
+ILvoid ilError::Check(ILvoid (*Callback)(ILenum))
+{
+	static ILenum Error;
+
+	while ((Error = ilGetError()) != IL_NO_ERROR) {
+		Callback(Error);
+	}
+
+	return;
+}
+
+
+ILenum ilError::Get()
+{
+	return ilGetError();
+}
+
+
+const char *ilError::String()
+{
+	return iluErrorString(ilGetError());
+}
+
+
+const char *ilError::String(ILenum Error)
+{
+	return iluErrorString(Error);
+}
