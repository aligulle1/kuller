From: Jan Kara <jack@suse.cz>
References: fate#303336
Patch-mainline: 2.6.26
Subject: [PATCH] udf: Move filling of partition descriptor info into a separate function

Signed-off-by: Jan Kara <jack@suse.cz>
---
 fs/udf/super.c |  118 +++++++++++++++++++++++++++++--------------------------
 1 files changed, 62 insertions(+), 56 deletions(-)

diff --git a/fs/udf/super.c b/fs/udf/super.c
index d50e3f5..c5fef85 100644
--- a/fs/udf/super.c
+++ b/fs/udf/super.c
@@ -1024,41 +1024,14 @@ static struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)
 	return bitmap;
 }
 
-static int udf_load_partdesc(struct super_block *sb, sector_t block)
+static int udf_fill_partdesc_info(struct super_block *sb,
+		struct partitionDesc *p, int p_index)
 {
-	struct buffer_head *bh;
-	struct partitionHeaderDesc *phd;
-	struct partitionDesc *p;
 	struct udf_part_map *map;
 	struct udf_sb_info *sbi = UDF_SB(sb);
-	bool found = false;
-	int i;
-	uint16_t partitionNumber;
-	uint16_t ident;
-	int ret = 0;
-
-	bh = udf_read_tagged(sb, block, block, &ident);
-	if (!bh)
-		return 1;
-	if (ident != TAG_IDENT_PD)
-		goto out_bh;
-
-	p = (struct partitionDesc *)bh->b_data;
-	partitionNumber = le16_to_cpu(p->partitionNumber);
-	for (i = 0; i < sbi->s_partitions; i++) {
-		map = &sbi->s_partmaps[i];
-		udf_debug("Searching map: (%d == %d)\n",
-			  map->s_partition_num, partitionNumber);
-		found = map->s_partition_num == partitionNumber;
-		if (found)
-			break;
-	}
+	struct partitionHeaderDesc *phd;
 
-	if (!found) {
-		udf_debug("Partition (%d) not found in partition map\n",
-			  partitionNumber);
-		goto out_bh;
-	}
+	map = &sbi->s_partmaps[p_index];
 
 	map->s_partition_len = le32_to_cpu(p->partitionLength); /* blocks */
 	map->s_partition_root = le32_to_cpu(p->partitionStartingLocation);
@@ -1073,88 +1046,121 @@ static int udf_load_partdesc(struct super_block *sb, sector_t block)
 		map->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;
 
 	udf_debug("Partition (%d:%d type %x) starts at physical %d, "
-		  "block length %d\n", partitionNumber, i,
+		  "block length %d\n", partitionNumber, p_index,
 		  map->s_partition_type, map->s_partition_root,
 		  map->s_partition_len);
 
 	if (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&
 	    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))
-		goto out_bh;
+		return 0;
 
 	phd = (struct partitionHeaderDesc *)p->partitionContentsUse;
 	if (phd->unallocSpaceTable.extLength) {
 		kernel_lb_addr loc = {
 			.logicalBlockNum = le32_to_cpu(
 				phd->unallocSpaceTable.extPosition),
-			.partitionReferenceNum = i,
+			.partitionReferenceNum = p_index,
 		};
 
 		map->s_uspace.s_table = udf_iget(sb, loc);
 		if (!map->s_uspace.s_table) {
 			udf_debug("cannot load unallocSpaceTable (part %d)\n",
-					i);
-			ret = 1;
-			goto out_bh;
+					p_index);
+			return 1;
 		}
 		map->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;
 		udf_debug("unallocSpaceTable (part %d) @ %ld\n",
-				i, map->s_uspace.s_table->i_ino);
+				p_index, map->s_uspace.s_table->i_ino);
 	}
 
 	if (phd->unallocSpaceBitmap.extLength) {
-		struct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, i);
-		if (!bitmap) {
-			ret = 1;
-			goto out_bh;
-		}
+		struct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);
+		if (!bitmap)
+			return 1;
 		map->s_uspace.s_bitmap = bitmap;
 		bitmap->s_extLength = le32_to_cpu(
 				phd->unallocSpaceBitmap.extLength);
 		bitmap->s_extPosition = le32_to_cpu(
 				phd->unallocSpaceBitmap.extPosition);
 		map->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;
-		udf_debug("unallocSpaceBitmap (part %d) @ %d\n", i,
+		udf_debug("unallocSpaceBitmap (part %d) @ %d\n", p_index,
 						bitmap->s_extPosition);
 	}
 
 	if (phd->partitionIntegrityTable.extLength)
-		udf_debug("partitionIntegrityTable (part %d)\n", i);
+		udf_debug("partitionIntegrityTable (part %d)\n", p_index);
 
 	if (phd->freedSpaceTable.extLength) {
 		kernel_lb_addr loc = {
 			.logicalBlockNum = le32_to_cpu(
 				phd->freedSpaceTable.extPosition),
-			.partitionReferenceNum = i,
+			.partitionReferenceNum = p_index,
 		};
 
 		map->s_fspace.s_table = udf_iget(sb, loc);
 		if (!map->s_fspace.s_table) {
-			udf_debug("cannot load freedSpaceTable (part %d)\n", i);
-			ret = 1;
-			goto out_bh;
+			udf_debug("cannot load freedSpaceTable (part %d)\n",
+				p_index);
+			return 1;
 		}
 
 		map->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;
 		udf_debug("freedSpaceTable (part %d) @ %ld\n",
-				i, map->s_fspace.s_table->i_ino);
+				p_index, map->s_fspace.s_table->i_ino);
 	}
 
 	if (phd->freedSpaceBitmap.extLength) {
-		struct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, i);
-		if (!bitmap) {
-			ret = 1;
-			goto out_bh;
-		}
+		struct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);
+		if (!bitmap)
+			return 1;
 		map->s_fspace.s_bitmap = bitmap;
 		bitmap->s_extLength = le32_to_cpu(
 				phd->freedSpaceBitmap.extLength);
 		bitmap->s_extPosition = le32_to_cpu(
 				phd->freedSpaceBitmap.extPosition);
 		map->s_partition_flags |= UDF_PART_FLAG_FREED_BITMAP;
-		udf_debug("freedSpaceBitmap (part %d) @ %d\n", i,
+		udf_debug("freedSpaceBitmap (part %d) @ %d\n", p_index,
 					bitmap->s_extPosition);
 	}
+	return 0;
+}
+
+static int udf_load_partdesc(struct super_block *sb, sector_t block)
+{
+	struct buffer_head *bh;
+	struct partitionDesc *p;
+	struct udf_part_map *map;
+	struct udf_sb_info *sbi = UDF_SB(sb);
+	bool found = false;
+	int i;
+	uint16_t partitionNumber;
+	uint16_t ident;
+	int ret = 0;
+
+	bh = udf_read_tagged(sb, block, block, &ident);
+	if (!bh)
+		return 1;
+	if (ident != TAG_IDENT_PD)
+		goto out_bh;
+
+	p = (struct partitionDesc *)bh->b_data;
+	partitionNumber = le16_to_cpu(p->partitionNumber);
+	for (i = 0; i < sbi->s_partitions; i++) {
+		map = &sbi->s_partmaps[i];
+		udf_debug("Searching map: (%d == %d)\n",
+			  map->s_partition_num, partitionNumber);
+		found = map->s_partition_num == partitionNumber;
+		if (found)
+			break;
+	}
+
+	if (!found) {
+		udf_debug("Partition (%d) not found in partition map\n",
+			  partitionNumber);
+		goto out_bh;
+	}
 
+	ret = udf_fill_partdesc_info(sb, p, i);
 out_bh:
 	/* In case loading failed, we handle cleanup in udf_fill_super */
 	brelse(bh);
-- 
1.5.2.4

