diff --git xorg-server-1.4.2/hw/xfree86/common/xf86Config.c xorg-server-1.4.2/hw/xfree86/common/xf86Config.c
index 3c29497..12486e9 100644
--- xorg-server-1.4.2/hw/xfree86/common/xf86Config.c
+++ xorg-server-1.4.2/hw/xfree86/common/xf86Config.c
@@ -2065,8 +2065,7 @@ configMonitor(MonPtr monitorp, XF86ConfMonitorPtr conf_monitor)
      */
     cmodep = conf_monitor->mon_modeline_lst;
     while( cmodep ) {
-        mode = xnfalloc(sizeof(DisplayModeRec));
-        memset(mode,'\0',sizeof(DisplayModeRec));
+        mode = xnfcalloc(1, sizeof(DisplayModeRec));
 	mode->type       = 0;
         mode->Clock      = cmodep->ml_clock;
         mode->HDisplay   = cmodep->ml_hdisplay;
@@ -2399,10 +2398,7 @@ addDefaultModes(MonPtr monitorp)
 	if ( ! modeIsPresent(xf86DefaultModes[i].name,monitorp) )
 	    do
 	    {
-		mode = xnfalloc(sizeof(DisplayModeRec));
-		memcpy(mode,&xf86DefaultModes[i],sizeof(DisplayModeRec));
-		if (xf86DefaultModes[i].name)
-		    mode->name = xnfstrdup(xf86DefaultModes[i].name);
+		mode = xf86DuplicateMode(&xf86DefaultModes[i]);
 		if( last ) {
 		    mode->prev = last;
 		    last->next = mode;
diff --git xorg-server-1.4.2/hw/xfree86/common/xf86cvt.c xorg-server-1.4.2/hw/xfree86/common/xf86cvt.c
index dfb6e71..f8185a3 100644
--- xorg-server-1.4.2/hw/xfree86/common/xf86cvt.c
+++ xorg-server-1.4.2/hw/xfree86/common/xf86cvt.c
@@ -56,7 +56,7 @@ _X_EXPORT DisplayModePtr
 xf86CVTMode(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
             Bool Interlaced)
 {
-    DisplayModeRec  *Mode = xnfalloc(sizeof(DisplayModeRec));
+    DisplayModeRec  *Mode = xnfcalloc(1, sizeof(DisplayModeRec));
 
     /* 1) top/bottom margin size (% of height) - default: 1.8 */
 #define CVT_MARGIN_PERCENTAGE 1.8    
@@ -79,8 +79,6 @@ xf86CVTMode(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
     int  VDisplayRnd, VMargin, VSync;
     float  Interlace; /* Please rename this */
 
-    memset(Mode, 0, sizeof(DisplayModeRec));
-
     /* CVT default is 60.0Hz */
     if (!VRefresh)
         VRefresh = 60.0;
diff --git xorg-server-1.4.2/hw/xfree86/ddc/edid.h xorg-server-1.4.2/hw/xfree86/ddc/edid.h
index 0b6a15a..411288a 100644
--- xorg-server-1.4.2/hw/xfree86/ddc/edid.h
+++ xorg-server-1.4.2/hw/xfree86/ddc/edid.h
@@ -275,6 +275,9 @@
 #define _WHITE_GAMMA2(x) _GAMMA(x[14])
 #define WHITE_GAMMA2 _WHITE_GAMMA2(c)
 #define ADD_STD_TIMINGS 0xFA
+#define COLOR_MANAGEMENT_DATA 0xF9
+#define CVT_3BYTE_DATA 0xF8
+#define ADD_EST_TIMINGS 0xF7
 #define ADD_DUMMY 0x10
 
 #define _NEXT_DT_MD_SECTION(x) (x = (x + DET_TIMING_INFO_LEN))
@@ -317,6 +320,8 @@
 #define STD_COLOR_SPACE(x) (x & 0x4)
 #define PREFERRED_TIMING_MODE(x) (x & 0x2)
 #define GFT_SUPPORTED(x) (x & 0x1)
+#define GTF_SUPPORTED(x) (x & 0x1)
+#define CVT_SUPPORTED(x) (x & 0x1)
 
 /* detailed timing misc */
 #define IS_INTERLACED(x)  (x) 
@@ -407,8 +412,13 @@ struct detailed_timings {
 #define DS_RANGES 0xFD
 #define DS_WHITE_P 0xFB
 #define DS_STD_TIMINGS 0xFA
+#define DS_CMD 0xF9
+#define DS_CVT 0xF8
+#define DS_EST_III 0xF7
 #define DS_DUMMY 0x10
 #define DS_UNKOWN 0x100 /* type is an int */
+#define DS_VENDOR 0x101
+#define DS_VENDOR_MAX 0x110
 
 struct monitor_ranges {
   int min_v;
@@ -430,17 +440,33 @@ struct whitePoints{
   float white_gamma;
 };
 
+struct cvt_timings {
+    int width;
+    int height;
+    int rate;
+    int rates;
+};
+
+/*
+ * Be careful when adding new sections; this structure can't grow, it's
+ * embedded in the middle of xf86Monitor which is ABI.  Sizes below are
+ * in bytes, for ILP32 systems.  If all else fails just copy the section
+ * literally like serial and friends.
+ */
 struct detailed_monitor_section {
   int type;
   union {
-    struct detailed_timings d_timings;
+    struct detailed_timings d_timings;	/* 56 */
     Uchar serial[13];
     Uchar ascii_data[13];
     Uchar name[13];
-    struct monitor_ranges ranges;
-    struct std_timings std_t[5];
-    struct whitePoints wp[2];
-  } section;
+    struct monitor_ranges ranges;	/* 40 */
+    struct std_timings std_t[5];	/* 80 */
+    struct whitePoints wp[2];		/* 32 */
+    /* color management data */
+    struct cvt_timings cvt[4];		/* 64 */
+    /* established timings III */
+  } section;				/* max: 80 */
 };
 
 typedef struct {
diff --git xorg-server-1.4.2/hw/xfree86/ddc/interpret_edid.c xorg-server-1.4.2/hw/xfree86/ddc/interpret_edid.c
index 7b4b2b9..982a502 100644
--- xorg-server-1.4.2/hw/xfree86/ddc/interpret_edid.c
+++ xorg-server-1.4.2/hw/xfree86/ddc/interpret_edid.c
@@ -1,8 +1,28 @@
-
-/* interpret_edid.c: interpret a primary EDID block
- * 
+/*
  * Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ * Copyright 2007 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software")
+ * to deal in the software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * them Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTIBILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * interpret_edid.c: interpret a primary EDID block
  */
+
 #ifdef HAVE_XORG_CONFIG_H
 #include <xorg-config.h>
 #endif
@@ -155,6 +175,34 @@ get_established_timing_section(Uchar *c, struct established_timings *r)
 }
 
 static void
+get_cvt_timing_section(Uchar *c, struct cvt_timings *r)
+{
+    int i;
+
+    for (i = 0; i < 4; i++) {
+	if (c[0] && c[1] && c[2]) {
+	    r[i].height = (c[0] + ((c[1] & 0xF0) << 8) + 1) * 2;
+	    switch (c[1] & 0xc0) {
+		case 0x00: r[i].width = r[i].height * 4 / 3; break;
+		case 0x40: r[i].width = r[i].height * 16 / 9; break;
+		case 0x80: r[i].width = r[i].height * 16 / 10; break;
+		case 0xc0: r[i].width = r[i].height * 15 / 9; break;
+	    }
+	    switch (c[2] & 0x60) {
+		case 0x00: r[i].rate = 50; break;
+		case 0x20: r[i].rate = 60; break;
+		case 0x40: r[i].rate = 75; break;
+		case 0x60: r[i].rate = 85; break;
+	    }
+	    r[i].rates = c[2] & 0x1f;
+	} else {
+	    return;
+	}
+	c += 3;
+    }
+}
+
+static void
 get_std_timing_section(Uchar *c, struct std_timings *r,
 		       struct edid_version *v)
 {
@@ -207,6 +255,16 @@ get_dt_md_section(Uchar *c, struct edid_version *ver,
 	det_mon[i].type = DS_STD_TIMINGS;
 	get_dst_timing_section(c,det_mon[i].section.std_t, ver);
 	break;
+      case COLOR_MANAGEMENT_DATA:
+	det_mon[i].type = DS_CMD;
+	break;
+      case CVT_3BYTE_DATA:
+	det_mon[i].type = DS_CVT;
+	get_cvt_timing_section(c, det_mon[i].section.cvt);
+	break;
+      case ADD_EST_TIMINGS:
+	det_mon[i].type = DS_EST_III;
+	break;
       case ADD_DUMMY:
 	det_mon[i].type = DS_DUMMY;
         break;
@@ -214,6 +272,9 @@ get_dt_md_section(Uchar *c, struct edid_version *ver,
         det_mon[i].type = DS_UNKOWN;
         break;
       }
+      if (c[3] <= 0x0F) {
+	det_mon[i].type = DS_VENDOR + c[3];
+      }
     } else { 
       det_mon[i].type = DT;
       get_detailed_timing_section(c,&det_mon[i].section.d_timings);
diff --git xorg-server-1.4.2/hw/xfree86/ddc/print_edid.c xorg-server-1.4.2/hw/xfree86/ddc/print_edid.c
index 30b607d..5aebc6e 100644
--- xorg-server-1.4.2/hw/xfree86/ddc/print_edid.c
+++ xorg-server-1.4.2/hw/xfree86/ddc/print_edid.c
@@ -235,6 +235,24 @@ print_std_timings(int scrnIndex, struct std_timings *t)
 	}
     }
 }
+
+static void
+print_cvt_timings(int si, struct cvt_timings *t)
+{
+    int i;
+
+    for (i = 0; i < 4; i++) {
+	if (t[i].height) {
+	    xf86DrvMsg(si, X_INFO, "%dx%d @ %s%s%s%s%s Hz\n",
+		    t[i].width, t[i].height,
+		    t[i].rates & 0x10 ? "50," : "",
+		    t[i].rates & 0x08 ? "60," : "",
+		    t[i].rates & 0x04 ? "75," : "",
+		    t[i].rates & 0x02 ? "85," : "",
+		    t[i].rates & 0x01 ? "60RB" : "");
+	} else break;
+    }
+}
   
 static void
 print_detailed_monitor_section(int scrnIndex,
@@ -290,10 +308,28 @@ print_detailed_monitor_section(int scrnIndex,
 			       m[i].section.wp[j].white_y,
 			       m[i].section.wp[j].white_gamma);
 	    break;
+	case DS_CMD:
+	    xf86DrvMsg(scrnIndex, X_INFO,
+		       "Color management data: (not decoded)\n");
+	    break;
+	case DS_CVT:
+	    xf86DrvMsg(scrnIndex, X_INFO,
+		       "CVT 3-byte-code modes:\n");
+	    print_cvt_timings(scrnIndex, m[i].section.cvt);
+	    break;
+	case DS_EST_III:
+	    xf86DrvMsg(scrnIndex, X_INFO,
+		       "Established timings III: (not decoded)\n");
+	    break;
 	case DS_DUMMY:
 	default:
 	    break;
 	}
+	if (m[i].type >= DS_VENDOR && m[i].type <= DS_VENDOR_MAX) {
+	    xf86DrvMsg(scrnIndex, X_WARNING,
+		       "Unknown vendor-specific block %hx\n",
+		       m[i].type - DS_VENDOR);
+	}
     }
 }
   
diff --git xorg-server-1.4.2/hw/xfree86/fbdevhw/fbdevhw.c xorg-server-1.4.2/hw/xfree86/fbdevhw/fbdevhw.c
index b7eabb2..c8a1864 100644
--- xorg-server-1.4.2/hw/xfree86/fbdevhw/fbdevhw.c
+++ xorg-server-1.4.2/hw/xfree86/fbdevhw/fbdevhw.c
@@ -579,14 +579,11 @@ fbdevHWSetVideoModes(ScrnInfoPtr pScrn)
 			pScrn->virtualY = mode->VDisplay;
 
 		if (NULL == pScrn->modes) {
-			pScrn->modes = xnfalloc(sizeof(DisplayModeRec));
-			this = pScrn->modes;
-			memcpy(this,mode,sizeof(DisplayModeRec));
+			this = pScrn->modes = xf86DuplicateMode(mode);
 			this->next = this;
 			this->prev = this;
 		} else {
-			this = xnfalloc(sizeof(DisplayModeRec));
-			memcpy(this,mode,sizeof(DisplayModeRec));
+			this = xf86DuplicateMode(mode);
 			this->next = pScrn->modes;
 			this->prev = last;
 			last->next = this;
diff --git xorg-server-1.4.2/hw/xfree86/loader/xf86sym.c xorg-server-1.4.2/hw/xfree86/loader/xf86sym.c
index 23f8208..bb084e0 100644
--- xorg-server-1.4.2/hw/xfree86/loader/xf86sym.c
+++ xorg-server-1.4.2/hw/xfree86/loader/xf86sym.c
@@ -1160,6 +1160,7 @@ _X_HIDDEN void *xfree86LookupTab[] = {
     SYMFUNC(xf86CrtcSetSizeRange)
     SYMFUNC(xf86CrtcScreenInit)
     SYMFUNC(xf86CVTMode)
+    SYMFUNC(xf86GTFMode)
     SYMFUNC(xf86DisableUnusedFunctions)
     SYMFUNC(xf86DPMSSet)
     SYMFUNC(xf86DuplicateMode)
diff --git xorg-server-1.4.2/hw/xfree86/modes/Makefile.am xorg-server-1.4.2/hw/xfree86/modes/Makefile.am
index 1f82068..c137a2c 100644
--- xorg-server-1.4.2/hw/xfree86/modes/Makefile.am
+++ xorg-server-1.4.2/hw/xfree86/modes/Makefile.am
@@ -5,6 +5,7 @@ libxf86modes_a_SOURCES = \
 	xf86Crtc.h \
 	xf86Cursors.c \
 	xf86cvt.c \
+	xf86gtf.c \
 	xf86DiDGA.c \
 	xf86EdidModes.c \
 	xf86Modes.c \
diff --git xorg-server-1.4.2/hw/xfree86/modes/xf86Crtc.c xorg-server-1.4.2/hw/xfree86/modes/xf86Crtc.c
index d375da8..b424207 100644
--- xorg-server-1.4.2/hw/xfree86/modes/xf86Crtc.c
+++ xorg-server-1.4.2/hw/xfree86/modes/xf86Crtc.c
@@ -2134,8 +2134,12 @@ _X_EXPORT xf86MonPtr
 xf86OutputGetEDID (xf86OutputPtr output, I2CBusPtr pDDCBus)
 {
     ScrnInfoPtr	scrn = output->scrn;
+    xf86MonPtr mon;
 
-    return xf86DoEDID_DDC2 (scrn->scrnIndex, pDDCBus);
+    mon = xf86DoEDID_DDC2 (scrn->scrnIndex, pDDCBus);
+    xf86DDCApplyQuirks (scrn->scrnIndex, pDDCBus);
+
+    return mon;
 }
 
 static char *_xf86ConnectorNames[] = { "None", "VGA", "DVI-I", "DVI-D",
diff --git xorg-server-1.4.2/hw/xfree86/modes/xf86EdidModes.c xorg-server-1.4.2/hw/xfree86/modes/xf86EdidModes.c
index e2ae665..5e0eed8 100644
--- xorg-server-1.4.2/hw/xfree86/modes/xf86EdidModes.c
+++ xorg-server-1.4.2/hw/xfree86/modes/xf86EdidModes.c
@@ -54,13 +54,28 @@ typedef enum {
     DDC_QUIRK_PREFER_LARGE_60 = 1 << 0,
     /* 135MHz clock is too high, drop a bit */
     DDC_QUIRK_135_CLOCK_TOO_HIGH = 1 << 1,
+    /* Prefer the largest mode at 75 Hz */
+    DDC_QUIRK_PREFER_LARGE_75 = 1 << 2,
+    /* Convert detailed timing's horizontal from units of cm to mm */
+    DDC_QUIRK_DETAILED_H_IN_CM = 1 << 3,
+    /* Convert detailed timing's vertical from units of cm to mm */
+    DDC_QUIRK_DETAILED_V_IN_CM = 1 << 4,
+    /* Detailed timing descriptors have bogus size values, so just take the
+     * maximum size and use that.
+     */
+    DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE = 1 << 5,
+    /* Monitor forgot to set the first detailed is preferred bit. */
+    DDC_QUIRK_FIRST_DETAILED_PREFERRED = 1 << 6,
+    /* use +hsync +vsync for detailed mode */
+    DDC_QUIRK_DETAILED_SYNC_PP = 1 << 7,
 } ddc_quirk_t;
 
 static Bool quirk_prefer_large_60 (int scrnIndex, xf86MonPtr DDC)
 {
     /* Belinea 10 15 55 */
     if (memcmp (DDC->vendor.name, "MAX", 4) == 0 &&
-	DDC->vendor.prod_id == 1516)
+	((DDC->vendor.prod_id == 1516) ||
+	(DDC->vendor.prod_id == 0x77e)))
 	return TRUE;
     
     /* Acer AL1706 */
@@ -81,6 +96,53 @@ static Bool quirk_prefer_large_60 (int scrnIndex, xf86MonPtr DDC)
     return FALSE;
 }
 
+static Bool quirk_prefer_large_75 (int scrnIndex, xf86MonPtr DDC)
+{
+    /* Bug #11603: Funai Electronics PM36B */
+    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
+	DDC->vendor.prod_id == 13600)
+	return TRUE;
+
+    return FALSE;
+}
+
+static Bool quirk_detailed_h_in_cm (int scrnIndex, xf86MonPtr DDC)
+{
+    /* Bug #10304: "LGPhilipsLCD LP154W01-A5" */
+    /* Bug #12784: "LGPhilipsLCD LP154W01-TLA2" */
+    /* Red Hat #435216 "LGPhilipsLCD LP154W01-TLAE" */
+    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
+	(DDC->vendor.prod_id == 0 || DDC->vendor.prod_id == 0x2a00))
+	return TRUE;
+
+    /* Bug #11603: Funai Electronics PM36B */
+    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
+	DDC->vendor.prod_id == 13600)
+	return TRUE;
+
+    return FALSE;
+}
+
+static Bool quirk_detailed_v_in_cm (int scrnIndex, xf86MonPtr DDC)
+{
+    /* Bug #11603: Funai Electronics PM36B */
+    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
+	DDC->vendor.prod_id == 13600)
+	return TRUE;
+
+    return FALSE;
+}
+
+static Bool quirk_detailed_use_maximum_size (int scrnIndex, xf86MonPtr DDC)
+{
+    /* Bug #10304: LGPhilipsLCD LP154W01-A5 */
+    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
+	DDC->vendor.prod_id == 0)
+	return TRUE;
+
+    return FALSE;
+}
+
 static Bool quirk_135_clock_too_high (int scrnIndex, xf86MonPtr DDC)
 {
     /* Envision Peripherals, Inc. EN-7100e.  See bug #9550. */
@@ -91,6 +153,25 @@ static Bool quirk_135_clock_too_high (int scrnIndex, xf86MonPtr DDC)
     return FALSE;
 }
 
+static Bool quirk_first_detailed_preferred (int scrnIndex, xf86MonPtr DDC)
+{
+    /* Philips 107p5 CRT. Reported on xorg@ with pastebin. */
+    if (memcmp (DDC->vendor.name, "PHL", 4) == 0 &&
+	DDC->vendor.prod_id == 57364)
+	return TRUE;
+
+    return FALSE;
+}
+
+static Bool quirk_detailed_sync_pp(int scrnIndex, xf86MonPtr DDC)
+{
+    /* Bug #12439: Samsung SyncMaster 205BW */
+    if (memcmp (DDC->vendor.name, "SAM", 4) == 0 &&
+	DDC->vendor.prod_id == 541)
+	return TRUE;
+    return FALSE;
+}
+
 typedef struct {
     Bool	(*detect) (int scrnIndex, xf86MonPtr DDC);
     ddc_quirk_t	quirk;
@@ -106,6 +187,30 @@ static const ddc_quirk_map_t ddc_quirks[] = {
 	quirk_135_clock_too_high,   DDC_QUIRK_135_CLOCK_TOO_HIGH,
 	"Recommended 135MHz pixel clock is too high"
     },
+    {
+	quirk_prefer_large_75,   DDC_QUIRK_PREFER_LARGE_75,
+	"Detailed timing is not preferred, use largest mode at 75Hz"
+    },
+    {
+	quirk_detailed_h_in_cm,   DDC_QUIRK_DETAILED_H_IN_CM,
+	"Detailed timings give horizontal size in cm."
+    },
+    {
+	quirk_detailed_v_in_cm,   DDC_QUIRK_DETAILED_V_IN_CM,
+	"Detailed timings give vertical size in cm."
+    },
+    {
+	quirk_detailed_use_maximum_size,   DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE,
+	"Detailed timings give sizes in cm."
+    },
+    {
+	quirk_first_detailed_preferred, DDC_QUIRK_FIRST_DETAILED_PREFERRED,
+	"First detailed timing was not marked as preferred."
+    },
+    {
+	quirk_detailed_sync_pp, DDC_QUIRK_DETAILED_SYNC_PP,
+	"Use +hsync +vsync for detailed timing."
+    },
     { 
 	NULL,		DDC_QUIRK_NONE,
 	"No known quirks"
@@ -158,20 +263,57 @@ DDCModesFromEstablished(int scrnIndex, struct established_timings *timing,
     return Modes;
 }
 
+#define LEVEL_DMT 0
+#define LEVEL_GTF 1
+#define LEVEL_CVT 2
+
+static int
+MonitorStandardTimingLevel(xf86MonPtr DDC)
+{
+    if (DDC->ver.revision >= 2) {
+	if (DDC->ver.revision >= 4 && CVT_SUPPORTED(DDC->features.msc)) {
+	    return LEVEL_CVT;
+	}
+	return LEVEL_GTF;
+    }
+    return LEVEL_DMT;
+}
+
 /*
+ * This is not really correct.  Appendix B of the EDID 1.4 spec defines
+ * the right thing to do here.  If the timing given here matches a mode
+ * defined in the VESA DMT standard, we _must_ use that.  If the device
+ * supports CVT modes, then we should generate a CVT timing.  If both
+ * of the above fail, use GTF.
+ *
+ * There are some wrinkles here.  EDID 1.1 and 1.0 sinks can't really
+ * "support" GTF, since it wasn't a standard yet; so if they ask for a
+ * timing in this section that isn't defined in DMT, returning a GTF mode
+ * may not actually be valid.  EDID 1.3 sinks often report support for
+ * some CVT modes, but they are not required to support CVT timings for
+ * modes in the standard timing descriptor, so we should _not_ treat them
+ * as CVT-compliant (unless specified in an extension block I suppose).
  *
+ * EDID 1.4 requires that all sink devices support both GTF and CVT timings
+ * for modes in this section, but does say that CVT is preferred.
  */
 static DisplayModePtr
-DDCModesFromStandardTiming(int scrnIndex, struct std_timings *timing,
-			   ddc_quirk_t quirks)
+DDCModesFromStandardTiming(struct std_timings *timing, ddc_quirk_t quirks,
+			   int timing_level)
 {
     DisplayModePtr Modes = NULL, Mode = NULL;
     int i;
 
     for (i = 0; i < STD_TIMINGS; i++) {
         if (timing[i].hsize && timing[i].vsize && timing[i].refresh) {
-            Mode =  xf86CVTMode(timing[i].hsize, timing[i].vsize,
-                                timing[i].refresh, FALSE, FALSE);
+	    /* XXX check for DMT first, else... */
+	    if (timing_level == LEVEL_CVT)
+		Mode = xf86CVTMode(timing[i].hsize, timing[i].vsize,
+				   timing[i].refresh, FALSE, FALSE);
+	    else
+		Mode = xf86GTFMode(timing[i].hsize, timing[i].vsize,
+				   timing[i].refresh, FALSE, FALSE);
+
 	    Mode->type = M_T_DRIVER;
             Modes = xf86ModesAdd(Modes, Mode);
         }
@@ -185,7 +327,7 @@ DDCModesFromStandardTiming(int scrnIndex, struct std_timings *timing,
  */
 static DisplayModePtr
 DDCModeFromDetailedTiming(int scrnIndex, struct detailed_timings *timing,
-			  int preferred, ddc_quirk_t quirks)
+			  Bool preferred, ddc_quirk_t quirks)
 {
     DisplayModePtr Mode;
 
@@ -216,8 +358,7 @@ DDCModeFromDetailedTiming(int scrnIndex, struct detailed_timings *timing,
                     " sync.\n", __func__, timing->h_active, timing->v_active);
     }
 
-    Mode = xnfalloc(sizeof(DisplayModeRec));
-    memset(Mode, 0, sizeof(DisplayModeRec));
+    Mode = xnfcalloc(1, sizeof(DisplayModeRec));
 
     Mode->type = M_T_DRIVER;
     if (preferred)
@@ -252,21 +393,59 @@ DDCModeFromDetailedTiming(int scrnIndex, struct detailed_timings *timing,
     if (timing->interlaced)
         Mode->Flags |= V_INTERLACE;
 
-    if (timing->misc & 0x02)
-	Mode->Flags |= V_PVSYNC;
-    else
-	Mode->Flags |= V_NVSYNC;
-
-    if (timing->misc & 0x01)
-	Mode->Flags |= V_PHSYNC;
-    else
-	Mode->Flags |= V_NHSYNC;
+    if (quirks & DDC_QUIRK_DETAILED_SYNC_PP)
+	Mode->Flags |= V_PVSYNC | V_PHSYNC;
+    else {
+	if (timing->misc & 0x02)
+	    Mode->Flags |= V_PVSYNC;
+	else
+	    Mode->Flags |= V_NVSYNC;
+
+	if (timing->misc & 0x01)
+	    Mode->Flags |= V_PHSYNC;
+	else
+	    Mode->Flags |= V_NHSYNC;
+    }
 
     return Mode;
 }
 
+static DisplayModePtr
+DDCModesFromCVT(int scrnIndex, struct cvt_timings *t)
+{
+    DisplayModePtr modes = NULL;
+    int i;
+
+    for (i = 0; i < 4; i++) {
+	if (t[i].height) {
+	    if (t[i].rates & 0x10)
+		modes = xf86ModesAdd(modes,
+			xf86CVTMode(t[i].width, t[i].height, 50, 0, 0));
+	    if (t[i].rates & 0x08)
+		modes = xf86ModesAdd(modes,
+			xf86CVTMode(t[i].width, t[i].height, 60, 0, 0));
+	    if (t[i].rates & 0x04)
+		modes = xf86ModesAdd(modes,
+			xf86CVTMode(t[i].width, t[i].height, 75, 0, 0));
+	    if (t[i].rates & 0x02)
+		modes = xf86ModesAdd(modes,
+			xf86CVTMode(t[i].width, t[i].height, 85, 0, 0));
+	    if (t[i].rates & 0x01)
+		modes = xf86ModesAdd(modes,
+			xf86CVTMode(t[i].width, t[i].height, 60, 1, 0));
+	} else break;
+    }
+
+    return modes;
+}
+
+
 /*
- *
+ * This is only valid when the sink claims to be continuous-frequency
+ * but does not supply a detailed range descriptor.  Such sinks are
+ * arguably broken.  Currently the mode validation code isn't aware of
+ * this; the non-RANDR code even punts the decision of optional sync
+ * range checking to the driver.  Loss.
  */
 static void
 DDCGuessRangesFromModes(int scrnIndex, MonPtr Monitor, DisplayModePtr Modes)
@@ -309,27 +488,121 @@ DDCGuessRangesFromModes(int scrnIndex, MonPtr Monitor, DisplayModePtr Modes)
     }
 }
 
+static ddc_quirk_t
+xf86DDCDetectQuirks(int scrnIndex, xf86MonPtr DDC, Bool verbose)
+{
+    ddc_quirk_t	quirks;
+    int i;
+
+    quirks = DDC_QUIRK_NONE;
+    for (i = 0; ddc_quirks[i].detect; i++) {
+	if (ddc_quirks[i].detect (scrnIndex, DDC)) {
+	    if (verbose) {
+		xf86DrvMsg (scrnIndex, X_INFO, "    EDID quirk: %s\n",
+			    ddc_quirks[i].description);
+	    }
+	    quirks |= ddc_quirks[i].quirk;
+	}
+    }
+
+    return quirks;
+}
+
+/**
+ * Applies monitor-specific quirks to the decoded EDID information.
+ *
+ * Note that some quirks applying to the mode list are still implemented in
+ * xf86DDCGetModes.
+ */
+void
+xf86DDCApplyQuirks(int scrnIndex, xf86MonPtr DDC)
+{
+    ddc_quirk_t quirks = xf86DDCDetectQuirks (scrnIndex, DDC, FALSE);
+    int i;
+
+    for (i = 0; i < DET_TIMINGS; i++) {
+	struct detailed_monitor_section *det_mon = &DDC->det_mon[i];
+
+	if (det_mon->type != DT)
+	    continue;
+
+	if (quirks & DDC_QUIRK_DETAILED_H_IN_CM)
+	    det_mon->section.d_timings.h_size *= 10;
+
+	if (quirks & DDC_QUIRK_DETAILED_V_IN_CM)
+	    det_mon->section.d_timings.v_size *= 10;
+
+	if (quirks & DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {
+	    det_mon->section.d_timings.h_size = 10 * DDC->features.hsize;
+	    det_mon->section.d_timings.v_size = 10 * DDC->features.vsize;
+	}
+    }
+}
+
+/**
+ * Walks the modes list, finding the mode with the largest area which is
+ * closest to the target refresh rate, and marks it as the only preferred mode.
+*/
+static void
+xf86DDCSetPreferredRefresh(int scrnIndex, DisplayModePtr modes,
+			   float target_refresh)
+{
+	DisplayModePtr	mode, best = modes;
+
+	for (mode = modes; mode; mode = mode->next)
+	{
+	    mode->type &= ~M_T_PREFERRED;
+
+	    if (mode == best) continue;
+
+	    if (mode->HDisplay * mode->VDisplay >
+		best->HDisplay * best->VDisplay)
+	    {
+		best = mode;
+		continue;
+	    }
+	    if (mode->HDisplay * mode->VDisplay ==
+		best->HDisplay * best->VDisplay)
+	    {
+		double	mode_refresh = xf86ModeVRefresh (mode);
+		double	best_refresh = xf86ModeVRefresh (best);
+		double	mode_dist = fabs(mode_refresh - target_refresh);
+		double	best_dist = fabs(best_refresh - target_refresh);
+
+		if (mode_dist < best_dist)
+		{
+		    best = mode;
+		    continue;
+		}
+	    }
+	}
+	if (best)
+	    best->type |= M_T_PREFERRED;
+}
+
 _X_EXPORT DisplayModePtr
 xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC)
 {
-    int preferred, i;
+    int		    i;
     DisplayModePtr  Modes = NULL, Mode;
     ddc_quirk_t	    quirks;
+    Bool	    preferred;
+    int		    timing_level;
 
     xf86DrvMsg (scrnIndex, X_INFO, "EDID vendor \"%s\", prod id %d\n",
 		DDC->vendor.name, DDC->vendor.prod_id);
-    quirks = DDC_QUIRK_NONE;
-    for (i = 0; ddc_quirks[i].detect; i++)
-	if (ddc_quirks[i].detect (scrnIndex, DDC))
-	{
-	    xf86DrvMsg (scrnIndex, X_INFO, "    EDID quirk: %s\n",
-			ddc_quirks[i].description);
-	    quirks |= ddc_quirks[i].quirk;
-	}
-    
+
+    quirks = xf86DDCDetectQuirks(scrnIndex, DDC, TRUE);
+
     preferred = PREFERRED_TIMING_MODE(DDC->features.msc);
-    if (quirks & DDC_QUIRK_PREFER_LARGE_60)
-	preferred = 0;
+    if (DDC->ver.revision >= 4)
+	preferred = TRUE;
+    if (quirks & DDC_QUIRK_FIRST_DETAILED_PREFERRED)
+	preferred = TRUE;
+    if (quirks & (DDC_QUIRK_PREFER_LARGE_60 | DDC_QUIRK_PREFER_LARGE_75))
+	preferred = FALSE;
+
+    timing_level = MonitorStandardTimingLevel(DDC);
 
     for (i = 0; i < DET_TIMINGS; i++) {
 	struct detailed_monitor_section *det_mon = &DDC->det_mon[i];
@@ -340,15 +613,18 @@ xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC)
                                              &det_mon->section.d_timings,
 					     preferred,
 					     quirks);
-	    preferred = 0;
+	    preferred = FALSE;
             Modes = xf86ModesAdd(Modes, Mode);
             break;
         case DS_STD_TIMINGS:
-            Mode = DDCModesFromStandardTiming(scrnIndex,
-					      det_mon->section.std_t,
-					      quirks);
+            Mode = DDCModesFromStandardTiming(det_mon->section.std_t,
+					      quirks, timing_level);
             Modes = xf86ModesAdd(Modes, Mode);
             break;
+	case DS_CVT:
+	    Mode = DDCModesFromCVT(scrnIndex, det_mon->section.cvt);
+	    Modes = xf86ModesAdd(Modes, Mode);
+	    break;
         default:
             break;
         }
@@ -359,36 +635,15 @@ xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC)
     Modes = xf86ModesAdd(Modes, Mode);
 
     /* Add standard timings */
-    Mode = DDCModesFromStandardTiming(scrnIndex, DDC->timings2, quirks);
+    Mode = DDCModesFromStandardTiming(DDC->timings2, quirks, timing_level);
     Modes = xf86ModesAdd(Modes, Mode);
 
     if (quirks & DDC_QUIRK_PREFER_LARGE_60)
-    {
-	DisplayModePtr	best = Modes;
-	for (Mode = Modes; Mode; Mode = Mode->next)
-	{
-	    if (Mode == best) continue;
-	    if (Mode->HDisplay * Mode->VDisplay > best->HDisplay * best->VDisplay)
-	    {
-		best = Mode;
-		continue;
-	    }
-	    if (Mode->HDisplay * Mode->VDisplay == best->HDisplay * best->VDisplay)
-	    {
-		double	mode_refresh = xf86ModeVRefresh (Mode);
-		double	best_refresh = xf86ModeVRefresh (best);
-		double	mode_dist = fabs(mode_refresh - 60.0);
-		double	best_dist = fabs(best_refresh - 60.0);
-		if (mode_dist < best_dist)
-		{
-		    best = Mode;
-		    continue;
-		}
-	    }
-	}
-	if (best)
-	    best->type |= M_T_PREFERRED;
-    }
+	xf86DDCSetPreferredRefresh(scrnIndex, Modes, 60);
+
+    if (quirks & DDC_QUIRK_PREFER_LARGE_75)
+	xf86DDCSetPreferredRefresh(scrnIndex, Modes, 75);
+
     return Modes;
 }
 
@@ -407,13 +662,17 @@ xf86DDCMonitorSet(int scrnIndex, MonPtr Monitor, xf86MonPtr DDC)
 
     Monitor->DDC = DDC;
 
-    Monitor->widthmm = 10 * DDC->features.hsize;
-    Monitor->heightmm = 10 * DDC->features.vsize;
+    if (Monitor->widthmm <= 0 && Monitor->heightmm <= 0) {
+	Monitor->widthmm = 10 * DDC->features.hsize;
+	Monitor->heightmm = 10 * DDC->features.vsize;
+    }
 
-    /* If this is a digital display, then we can use reduced blanking */
+    /*
+     * If this is a digital display, then we can use reduced blanking.
+     * XXX This is a 1.3 heuristic.  1.4 explicitly defines rb support.
+     */
     if (DDC->features.input_type)
         Monitor->reducedblanking = TRUE;
-    /* Allow the user to also enable this through config */
 
     Modes = xf86DDCGetModes(scrnIndex, DDC);
 
diff --git xorg-server-1.4.2/hw/xfree86/modes/xf86Modes.h xorg-server-1.4.2/hw/xfree86/modes/xf86Modes.h
index 2bd4ede..bd5a45d 100644
--- xorg-server-1.4.2/hw/xfree86/modes/xf86Modes.h
+++ xorg-server-1.4.2/hw/xfree86/modes/xf86Modes.h
@@ -61,6 +61,7 @@ DisplayModePtr xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new);
 DisplayModePtr xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC);
 DisplayModePtr xf86CVTMode(int HDisplay, int VDisplay, float VRefresh,
 			   Bool Reduced, Bool Interlaced);
+DisplayModePtr xf86GTFMode(int h_pixels, int v_lines, float freq, int interlaced, int margins);
 
 void
 xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList,
@@ -95,4 +96,7 @@ xf86GetMonitorModes (ScrnInfoPtr pScrn, XF86ConfMonitorPtr conf_monitor);
 DisplayModePtr
 xf86GetDefaultModes (Bool interlaceAllowed, Bool doubleScanAllowed);
 
+void
+xf86DDCApplyQuirks(int scrnIndex, xf86MonPtr DDC);
+
 #endif /* _XF86MODES_H_ */
diff --git xorg-server-1.4.2/hw/xfree86/modes/xf86cvt.c xorg-server-1.4.2/hw/xfree86/modes/xf86cvt.c
index 69ccc42..68a9462 100644
--- xorg-server-1.4.2/hw/xfree86/modes/xf86cvt.c
+++ xorg-server-1.4.2/hw/xfree86/modes/xf86cvt.c
@@ -72,7 +72,7 @@ _X_EXPORT DisplayModePtr
 xf86CVTMode(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
 	    Bool Interlaced)
 {
-    DisplayModeRec  *Mode = xnfalloc(sizeof(DisplayModeRec));
+    DisplayModeRec  *Mode = xnfcalloc(1, sizeof(DisplayModeRec));
 
     /* 1) top/bottom margin size (% of height) - default: 1.8 */
 #define CVT_MARGIN_PERCENTAGE 1.8    
@@ -95,8 +95,6 @@ xf86CVTMode(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
     int  VDisplayRnd, VMargin, VSync;
     float  Interlace; /* Please rename this */
 
-    memset(Mode, 0, sizeof(DisplayModeRec));
-
     /* CVT default is 60.0Hz */
     if (!VRefresh)
         VRefresh = 60.0;
diff --git xorg-server-1.4.2/hw/xfree86/modes/xf86gtf.c xorg-server-1.4.2/hw/xfree86/modes/xf86gtf.c
new file mode 100644
index 0000000..acbac83
--- /dev/null
+++ xorg-server-1.4.2/hw/xfree86/modes/xf86gtf.c
@@ -0,0 +1,384 @@
+/*
+ * gtf.c  Generate mode timings using the GTF Timing Standard
+ *
+ * gcc gtf.c -o gtf -lm -Wall
+ *
+ * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * o Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * o Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer
+ *   in the documentation and/or other materials provided with the
+ *   distribution.
+ * o Neither the name of NVIDIA nor the names of its contributors
+ *   may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This program is based on the Generalized Timing Formula(GTF TM)
+ * Standard Version: 1.0, Revision: 1.0
+ *
+ * The GTF Document contains the following Copyright information:
+ *
+ * Copyright (c) 1994, 1995, 1996 - Video Electronics Standards
+ * Association. Duplication of this document within VESA member
+ * companies for review purposes is permitted. All other rights
+ * reserved.
+ *
+ * While every precaution has been taken in the preparation
+ * of this standard, the Video Electronics Standards Association and
+ * its contributors assume no responsibility for errors or omissions,
+ * and make no warranties, expressed or implied, of functionality
+ * of suitability for any purpose. The sample code contained within
+ * this standard may be used without restriction.
+ *
+ * 
+ *
+ * The GTF EXCEL(TM) SPREADSHEET, a sample (and the definitive)
+ * implementation of the GTF Timing Standard, is available at:
+ *
+ * ftp://ftp.vesa.org/pub/GTF/GTF_V1R1.xls
+ */
+
+/* Ruthlessly converted to server code by Adam Jackson <ajax@redhat.com> */
+
+#ifdef HAVE_XORG_CONFIG_H
+# include <xorg-config.h>
+#endif
+
+#include "xf86.h"
+#include "xf86Modes.h"
+#include <string.h>
+
+#define MARGIN_PERCENT    1.8   /* % of active vertical image                */
+#define CELL_GRAN         8.0   /* assumed character cell granularity        */
+#define MIN_PORCH         1     /* minimum front porch                       */
+#define V_SYNC_RQD        3     /* width of vsync in lines                   */
+#define H_SYNC_PERCENT    8.0   /* width of hsync as % of total line         */
+#define MIN_VSYNC_PLUS_BP 550.0 /* min time of vsync + back porch (microsec) */
+#define M                 600.0 /* blanking formula gradient                 */
+#define C                 40.0  /* blanking formula offset                   */
+#define K                 128.0 /* blanking formula scaling factor           */
+#define J                 20.0  /* blanking formula scaling factor           */
+
+/* C' and M' are part of the Blanking Duty Cycle computation */
+
+#define C_PRIME           (((C - J) * K/256.0) + J)
+#define M_PRIME           (K/256.0 * M)
+
+
+/*
+ * xf86GTFMode() - as defined by the GTF Timing Standard, compute the
+ * Stage 1 Parameters using the vertical refresh frequency.  In other
+ * words: input a desired resolution and desired refresh rate, and
+ * output the GTF mode timings.
+ *
+ * XXX All the code is in place to compute interlaced modes, but I don't
+ * feel like testing it right now.
+ *
+ * XXX margin computations are implemented but not tested (nor used by
+ * XServer of fbset mode descriptions, from what I can tell).
+ */
+
+_X_EXPORT DisplayModePtr
+xf86GTFMode(int h_pixels, int v_lines, float freq, int interlaced, int margins)
+{
+    DisplayModeRec *mode = xnfcalloc(1, sizeof(DisplayModeRec));
+
+    float h_pixels_rnd;
+    float v_lines_rnd;
+    float v_field_rate_rqd;
+    float top_margin;
+    float bottom_margin;
+    float interlace;
+    float h_period_est;
+    float vsync_plus_bp;
+    float v_back_porch;
+    float total_v_lines;
+    float v_field_rate_est;
+    float h_period;
+    float v_field_rate;
+    float v_frame_rate;
+    float left_margin;
+    float right_margin;
+    float total_active_pixels;
+    float ideal_duty_cycle;
+    float h_blank;
+    float total_pixels;
+    float pixel_freq;
+    float h_freq;
+
+    float h_sync;
+    float h_front_porch;
+    float v_odd_front_porch_lines;
+
+    /*  1. In order to give correct results, the number of horizontal
+     *  pixels requested is first processed to ensure that it is divisible
+     *  by the character size, by rounding it to the nearest character
+     *  cell boundary:
+     *
+     *  [H PIXELS RND] = ((ROUND([H PIXELS]/[CELL GRAN RND],0))*[CELLGRAN RND])
+     */
+    
+    h_pixels_rnd = rint((float) h_pixels / CELL_GRAN) * CELL_GRAN;
+    
+    /*  2. If interlace is requested, the number of vertical lines assumed
+     *  by the calculation must be halved, as the computation calculates
+     *  the number of vertical lines per field. In either case, the
+     *  number of lines is rounded to the nearest integer.
+     *   
+     *  [V LINES RND] = IF([INT RQD?]="y", ROUND([V LINES]/2,0),
+     *                                     ROUND([V LINES],0))
+     */
+
+    v_lines_rnd = interlaced ?
+            rint((float) v_lines) / 2.0 :
+            rint((float) v_lines);
+    
+    /*  3. Find the frame rate required:
+     *
+     *  [V FIELD RATE RQD] = IF([INT RQD?]="y", [I/P FREQ RQD]*2,
+     *                                          [I/P FREQ RQD])
+     */
+
+    v_field_rate_rqd = interlaced ? (freq * 2.0) : (freq);
+
+    /*  4. Find number of lines in Top margin:
+     *
+     *  [TOP MARGIN (LINES)] = IF([MARGINS RQD?]="Y",
+     *          ROUND(([MARGIN%]/100*[V LINES RND]),0),
+     *          0)
+     */
+
+    top_margin = margins ? rint(MARGIN_PERCENT / 100.0 * v_lines_rnd) : (0.0);
+
+    /*  5. Find number of lines in Bottom margin:
+     *
+     *  [BOT MARGIN (LINES)] = IF([MARGINS RQD?]="Y",
+     *          ROUND(([MARGIN%]/100*[V LINES RND]),0),
+     *          0)
+     */
+
+    bottom_margin = margins ? rint(MARGIN_PERCENT/100.0 * v_lines_rnd) : (0.0);
+
+    /*  6. If interlace is required, then set variable [INTERLACE]=0.5:
+     *   
+     *  [INTERLACE]=(IF([INT RQD?]="y",0.5,0))
+     */
+
+    interlace = interlaced ? 0.5 : 0.0;
+
+    /*  7. Estimate the Horizontal period
+     *
+     *  [H PERIOD EST] = ((1/[V FIELD RATE RQD]) - [MIN VSYNC+BP]/1000000) /
+     *                    ([V LINES RND] + (2*[TOP MARGIN (LINES)]) +
+     *                     [MIN PORCH RND]+[INTERLACE]) * 1000000
+     */
+
+    h_period_est = (((1.0/v_field_rate_rqd) - (MIN_VSYNC_PLUS_BP/1000000.0))
+                    / (v_lines_rnd + (2*top_margin) + MIN_PORCH + interlace)
+                    * 1000000.0);
+
+    /*  8. Find the number of lines in V sync + back porch:
+     *
+     *  [V SYNC+BP] = ROUND(([MIN VSYNC+BP]/[H PERIOD EST]),0)
+     */
+
+    vsync_plus_bp = rint(MIN_VSYNC_PLUS_BP/h_period_est);
+
+    /*  9. Find the number of lines in V back porch alone:
+     *
+     *  [V BACK PORCH] = [V SYNC+BP] - [V SYNC RND]
+     *
+     *  XXX is "[V SYNC RND]" a typo? should be [V SYNC RQD]?
+     */
+    
+    v_back_porch = vsync_plus_bp - V_SYNC_RQD;
+    
+    /*  10. Find the total number of lines in Vertical field period:
+     *
+     *  [TOTAL V LINES] = [V LINES RND] + [TOP MARGIN (LINES)] +
+     *                    [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] +
+     *                    [MIN PORCH RND]
+     */
+
+    total_v_lines = v_lines_rnd + top_margin + bottom_margin + vsync_plus_bp +
+        interlace + MIN_PORCH;
+    
+    /*  11. Estimate the Vertical field frequency:
+     *
+     *  [V FIELD RATE EST] = 1 / [H PERIOD EST] / [TOTAL V LINES] * 1000000
+     */
+
+    v_field_rate_est = 1.0 / h_period_est / total_v_lines * 1000000.0;
+    
+    /*  12. Find the actual horizontal period:
+     *
+     *  [H PERIOD] = [H PERIOD EST] / ([V FIELD RATE RQD] / [V FIELD RATE EST])
+     */
+
+    h_period = h_period_est / (v_field_rate_rqd / v_field_rate_est);
+    
+    /*  13. Find the actual Vertical field frequency:
+     *
+     *  [V FIELD RATE] = 1 / [H PERIOD] / [TOTAL V LINES] * 1000000
+     */
+
+    v_field_rate = 1.0 / h_period / total_v_lines * 1000000.0;
+
+    /*  14. Find the Vertical frame frequency:
+     *
+     *  [V FRAME RATE] = (IF([INT RQD?]="y", [V FIELD RATE]/2, [V FIELD RATE]))
+     */
+
+    v_frame_rate = interlaced ? v_field_rate / 2.0 : v_field_rate;
+
+    /*  15. Find number of pixels in left margin:
+     *
+     *  [LEFT MARGIN (PIXELS)] = (IF( [MARGINS RQD?]="Y",
+     *          (ROUND( ([H PIXELS RND] * [MARGIN%] / 100 /
+     *                   [CELL GRAN RND]),0)) * [CELL GRAN RND],
+     *          0))
+     */
+
+    left_margin = margins ?
+        rint(h_pixels_rnd * MARGIN_PERCENT / 100.0 / CELL_GRAN) * CELL_GRAN :
+        0.0;
+    
+    /*  16. Find number of pixels in right margin:
+     *
+     *  [RIGHT MARGIN (PIXELS)] = (IF( [MARGINS RQD?]="Y",
+     *          (ROUND( ([H PIXELS RND] * [MARGIN%] / 100 /
+     *                   [CELL GRAN RND]),0)) * [CELL GRAN RND],
+     *          0))
+     */
+    
+    right_margin = margins ?
+        rint(h_pixels_rnd * MARGIN_PERCENT / 100.0 / CELL_GRAN) * CELL_GRAN :
+        0.0;
+    
+    /*  17. Find total number of active pixels in image and left and right
+     *  margins:
+     *
+     *  [TOTAL ACTIVE PIXELS] = [H PIXELS RND] + [LEFT MARGIN (PIXELS)] +
+     *                          [RIGHT MARGIN (PIXELS)]
+     */
+
+    total_active_pixels = h_pixels_rnd + left_margin + right_margin;
+    
+    /*  18. Find the ideal blanking duty cycle from the blanking duty cycle
+     *  equation:
+     *
+     *  [IDEAL DUTY CYCLE] = [C'] - ([M']*[H PERIOD]/1000)
+     */
+
+    ideal_duty_cycle = C_PRIME - (M_PRIME * h_period / 1000.0);
+    
+    /*  19. Find the number of pixels in the blanking time to the nearest
+     *  double character cell:
+     *
+     *  [H BLANK (PIXELS)] = (ROUND(([TOTAL ACTIVE PIXELS] *
+     *                               [IDEAL DUTY CYCLE] /
+     *                               (100-[IDEAL DUTY CYCLE]) /
+     *                               (2*[CELL GRAN RND])), 0))
+     *                       * (2*[CELL GRAN RND])
+     */
+
+    h_blank = rint(total_active_pixels *
+                   ideal_duty_cycle /
+                   (100.0 - ideal_duty_cycle) /
+                   (2.0 * CELL_GRAN)) * (2.0 * CELL_GRAN);
+    
+    /*  20. Find total number of pixels:
+     *
+     *  [TOTAL PIXELS] = [TOTAL ACTIVE PIXELS] + [H BLANK (PIXELS)]
+     */
+
+    total_pixels = total_active_pixels + h_blank;
+    
+    /*  21. Find pixel clock frequency:
+     *
+     *  [PIXEL FREQ] = [TOTAL PIXELS] / [H PERIOD]
+     */
+    
+    pixel_freq = total_pixels / h_period;
+    
+    /*  22. Find horizontal frequency:
+     *
+     *  [H FREQ] = 1000 / [H PERIOD]
+     */
+
+    h_freq = 1000.0 / h_period;
+    
+
+    /* Stage 1 computations are now complete; I should really pass
+       the results to another function and do the Stage 2
+       computations, but I only need a few more values so I'll just
+       append the computations here for now */
+    
+
+    /*  17. Find the number of pixels in the horizontal sync period:
+     *
+     *  [H SYNC (PIXELS)] =(ROUND(([H SYNC%] / 100 * [TOTAL PIXELS] /
+     *                             [CELL GRAN RND]),0))*[CELL GRAN RND]
+     */
+
+    h_sync = rint(H_SYNC_PERCENT/100.0 * total_pixels / CELL_GRAN) * CELL_GRAN;
+
+    /*  18. Find the number of pixels in the horizontal front porch period:
+     *
+     *  [H FRONT PORCH (PIXELS)] = ([H BLANK (PIXELS)]/2)-[H SYNC (PIXELS)]
+     */
+
+    h_front_porch = (h_blank / 2.0) - h_sync;
+
+    /*  36. Find the number of lines in the odd front porch period:
+     *
+     *  [V ODD FRONT PORCH(LINES)]=([MIN PORCH RND]+[INTERLACE])
+     */
+    
+    v_odd_front_porch_lines = MIN_PORCH + interlace;
+    
+    /* finally, pack the results in the mode struct */
+
+    mode->HDisplay	= (int) (h_pixels_rnd);
+    mode->HSyncStart	= (int) (h_pixels_rnd + h_front_porch);
+    mode->HSyncEnd	= (int) (h_pixels_rnd + h_front_porch + h_sync);
+    mode->HTotal	= (int) (total_pixels);
+    mode->VDisplay	= (int) (v_lines_rnd);
+    mode->VSyncStart	= (int) (v_lines_rnd + v_odd_front_porch_lines);
+    mode->VSyncEnd	= (int) (v_lines_rnd + v_odd_front_porch_lines + V_SYNC_RQD);
+    mode->VTotal	= (int) (total_v_lines);
+
+    mode->Clock	    = (int) (pixel_freq * 1000.0);
+    mode->HSync	    = h_freq;
+    mode->VRefresh  = freq;
+
+    xf86SetModeDefaultName(mode);
+
+    mode->Flags = V_NHSYNC | V_PVSYNC;
+    if (interlaced) {
+	mode->VTotal *= 2;
+	mode->Flags |= V_INTERLACE;
+    }
+
+    return mode;
+}
