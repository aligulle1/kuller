Index: kscd/audiocd.cpp
===================================================================
--- kscd/audiocd.cpp
+++ kscd/audiocd.cpp	2009-09-24 10:19:42.000000000 +0200
@@ -88,7 +88,7 @@
 			{
 				cd = devList[i].as<Solid::OpticalDisc>();
 				block = odsign.as<Solid::Block>();
-				src = new MediaSource(Cd,block->device());
+                src = new MediaSource(Phonon::Cd, block->device());
 			}
 		}
 	}
@@ -164,7 +164,7 @@
 				kDebug() << "CD inserted!";
 				cd = devList[i].as<Solid::OpticalDisc>();
 				block = odsign.as<Solid::Block>();
-				src = new MediaSource(Cd,block->device());
+			    src = new MediaSource(Phonon::Cd, block->device());
 				emit(discChanged ());
 			}
 		}
Index: kscd/hwcontroler.cpp
===================================================================
--- kscd/hwcontroler.cpp
+++ kscd/hwcontroler.cpp	2009-09-24 10:25:29.000000000 +0200
@@ -75,13 +75,22 @@
 	// else loading  all optical drives
 	else
 	{
+      kDebug() << devList.size() << "Optical Drive detected in the computer";
 		for (int i = 0; i < devList.size();i++)
 		{
 			cdIn.append(new AudioCD(devList[i]));
+           if ((selectedCd==-1) && cdIn[i]->isCdInserted() && (cdIn[i]->getCd()->availableContent() == Solid::OpticalDisc::Audio))
+         { 
+                 selectedCd = i;
+                 kDebug() << "Optical Drive selected :" << cdIn[selectedCd]->getMediaSource()->deviceName();
+           }
+       }
+       if (selectedCd==-1)
+       {
 			selectedCd = 0;
-			connect(cdIn[selectedCd],SIGNAL(discChanged()),this,SLOT(configMedia()));
-		}
-	}
+       }
+       connect(cdIn[selectedCd],SIGNAL(discChanged()),this,SLOT(configMedia()));
+    }
 
 	//TODO: Load ALL audio output
 	speakers = new Phonon::AudioOutput ( MusicCategory, this );
@@ -491,14 +500,12 @@
 
 bool HWControler::isDiscValid()
 {
-/*	if(getCD()->isCdInserted())
+  if((selectedCd!=-1) && (cdIn[selectedCd]->isCdInserted()))
 	{
-		return !(getCD()->getCd()->discType()&0x01) ;
+		return (cdIn[selectedCd]->getCd()->availableContent() == Solid::OpticalDisc::Audio);
 	}
 	else
 		return false;
-*/
-return true;
 }
 
 void HWControler ::loadPlayList()
Index: kscd/kscd.cpp
===================================================================
--- kscd/kscd.cpp
+++ kscd/kscd.cpp	2009-09-24 10:27:21.000000000 +0200
@@ -69,6 +69,10 @@
 
 	/** Music Brainz initialisation	*/
 	m_MBManager = new MBManager();
+   if (devices->getCD()->isCdInserted())
+ {
+       m_MBManager->setDevice(devices->getCD()->getCdPath());
+ }
 	m_MBManager->discLookup();
 
 	setupActions();
@@ -490,7 +494,7 @@
 		}
 		else
 		{
-			if((devices->getState() == StoppedState) || (devices->getState()) == PausedState)
+          if((devices->getState() == StoppedState) || (devices->getState() == PausedState))
 			{
 				kDebug()<<"time total"<<devices->getTotalTime();
 				devices->play();
Index: kscd/mbmanager.cpp
===================================================================
--- kscd/mbmanager.cpp
+++ kscd/mbmanager.cpp	2009-09-24 10:30:12.000000000 +0200
@@ -42,6 +42,11 @@
 
 }
 
+void MBManager::setDevice(QString cdDevice)
+{
+   m_device = cdDevice;
+}
+
 void MBManager::discLookup()
 {
 	MusicBrainz MB;
@@ -81,6 +86,12 @@
 	// Tell the client library to return data in UTF-8
 	MB.UseUTF8(false);
 
+   if (!m_device.isNull())
+ {
+       QByteArray device = QFile::encodeName(m_device);
+       MB.SetDevice(device.constData());
+ }
+
 	// Execute the GetCDInfo query, which pulls the TOC from the
 	// audio CD in the cd-rom drive, calculates the disk id and
 	// requests the data from the server
Index: kscd/mbmanager.h
===================================================================
--- kscd/mbmanager.h
+++ kscd/mbmanager.h	2009-09-24 10:32:12.000000000 +0200
@@ -48,6 +48,7 @@
 // QT includes
 #include <qstring.h>
 #include <qlist.h>
+#include <qfile.h>
 
 struct DiscInfo
 {
@@ -74,6 +75,8 @@
 
 	bool m_validInfo;					/// Tells whether the lookup query succeeded
 
+    QString m_device;
+
 public:
 	MBManager();
 	~MBManager();
@@ -81,6 +84,8 @@
 /**
 * Getters/Setters
 */
+
+    void setDevice(QString cdDevice);
 	/** Returns the disc information */
 	DiscInfo getDiscInfo() const { return this->m_discInfo; }
 	QList <MBTrackInfo> getTrackList() const { return this->m_trackList; }
