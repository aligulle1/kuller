Index: kdepimlibs/akonadi/control.h
===================================================================
--- kdepimlibs/akonadi/control.h	(révision 1088292)
+++ kdepimlibs/akonadi/control.h	(révision 1088293)
@@ -29,17 +29,20 @@
 /**
  * @short Provides methods to control the Akonadi server process.
  *
- * This class provides high-level methods to control the Akonadi
- * server. These methods are synchronously (ie. use a sub-eventloop)
- * and can show dialogs. For more low-level methods see
+ * This class provides synchronous methods (ie. use a sub-eventloop)
+ * to control the Akonadi service. For asynchronous methods see
  * Akonadi::ServerManager.
  *
- * While the Akonadi server normally is started by the KDE session
- * manager, it is not guaranteed that your application is running
- * inside a KDE session. Therefore it is recommended to execute
- * Akonadi::Control::start() during startup to ensure the Akonadi
- * server is running.
+ * The most important method in here is widgetNeedsAkonadi(). It is
+ * recommended to call it with every top-level widget of your application
+ * as argument, assuming your application relies on Akonadi being operational
+ * of course.
  *
+ * While the Akonadi server automatically started by Akonadi::Session
+ * on first use, it might be necessary for some use-cases to guarantee
+ * a running Akonadi service at some point. This can be done using
+ * start().
+ *
  * Example:
  *
  * @code
@@ -114,7 +117,7 @@
     /**
      * Disable the given widget when Akonadi is not operational and show
      * an error overlay (given enough space). Cascading use is automatically
-     * detected.
+     * detected and resolved.
      * @param widget The widget depending on Akonadi being operational.
      * @since 4.2
      */
@@ -131,8 +134,7 @@
     class Private;
     Private* const d;
 
-    Q_PRIVATE_SLOT( d, void serverStarted() )
-    Q_PRIVATE_SLOT( d, void serverStopped() )
+    Q_PRIVATE_SLOT( d, void serverStateChanged(ServerManager::State) )
     Q_PRIVATE_SLOT( d, void createErrorOverlays() )
     Q_PRIVATE_SLOT( d, void cleanup() )
     //@endcond
Index: kdepimlibs/akonadi/control.cpp
===================================================================
--- kdepimlibs/akonadi/control.cpp	(révision 1088292)
+++ kdepimlibs/akonadi/control.cpp	(révision 1088293)
@@ -111,8 +111,7 @@
     }
 
     bool exec();
-    void serverStarted();
-    void serverStopped();
+    void serverStateChanged(ServerManager::State state);
 
     QPointer<Control> mParent;
     QEventLoop *mEventLoop;
@@ -130,10 +129,8 @@
   if ( mProgressIndicator )
     mProgressIndicator->show();
 
-  kDebug() << "Starting Akonadi (using an event loop).";
+  kDebug() << "Starting/Stopping Akonadi (using an event loop).";
   mEventLoop = new QEventLoop( mParent );
-  // safety timeout
-  QTimer::singleShot( 10000, mEventLoop, SLOT(quit()) );
   mEventLoop->exec();
   mEventLoop->deleteLater();
   mEventLoop = 0;
@@ -159,30 +156,22 @@
   return rv;
 }
 
-void Control::Private::serverStarted()
+void Control::Private::serverStateChanged(ServerManager::State state)
 {
-  if ( mEventLoop && mEventLoop->isRunning() && mStarting ) {
+  kDebug() << state;
+  if ( mEventLoop && mEventLoop->isRunning() ) {
     mEventLoop->quit();
-    mSuccess = true;
+    mSuccess = (mStarting && state == ServerManager::Running) || (mStopping && state == ServerManager::NotRunning);
   }
-  if ( !mFirstRunner )
+
+  if ( !mFirstRunner && ServerManager::state() == ServerManager::Running )
     mFirstRunner = new Firstrun( mParent );
 }
 
-void Control::Private::serverStopped()
-{
-  if ( mEventLoop && mEventLoop->isRunning() && mStopping ) {
-    mEventLoop->quit();
-    mSuccess = true;
-  }
-}
-
-
 Control::Control()
   : d( new Private( this ) )
 {
-  connect( ServerManager::self(), SIGNAL( started() ), SLOT( serverStarted() ) );
-  connect( ServerManager::self(), SIGNAL( stopped() ), SLOT( serverStopped() ) );
+  connect( ServerManager::self(), SIGNAL(stateChanged(ServerManager::State)), SLOT(serverStateChanged(ServerManager::State)) );
   // mProgressIndicator is a widget, so it better be deleted before the QApplication is deleted
   // Otherwise we get a crash in QCursor code with Qt-4.5
   if ( QCoreApplication::instance() )
@@ -196,19 +185,25 @@
 
 bool Control::start()
 {
-  if ( s_instance->d->mStopping )
+  if ( ServerManager::state() == ServerManager::Stopping ) {
+    kDebug() << "Server is currently being stopped, wont try to start it now";
     return false;
-  if ( ServerManager::isRunning() || s_instance->d->mEventLoop )
+  }
+  if ( ServerManager::isRunning() || s_instance->d->mEventLoop ) {
+    kDebug() << "Server is already running";
     return true;
+  }
   s_instance->d->mStarting = true;
-  if ( !ServerManager::start() )
+  if ( !ServerManager::start() ) {
+    kDebug() << "ServerManager::start failed -> return false";
     return false;
+  }
   return s_instance->d->exec();
 }
 
 bool Control::stop()
 {
-  if ( s_instance->d->mStarting )
+  if ( ServerManager::state() == ServerManager::Starting )
     return false;
   if ( !ServerManager::isRunning() || s_instance->d->mEventLoop )
     return true;
Index: kdepimlibs/akonadi/servermanager.h
===================================================================
--- kdepimlibs/akonadi/servermanager.h	(révision 1088292)
+++ kdepimlibs/akonadi/servermanager.h	(révision 1088293)
@@ -31,8 +31,8 @@
 /**
  * @short Provides methods to control the Akonadi server process.
  *
- * Low-level control of the Akonadi server.
- * Usually Akonadi::Control should be preferred over this.
+ * Asynchronous, low-level control of the Akonadi server.
+ * Akonadi::Control provides a synchronous interface to some of the methods in here.
  *
  * @author Volker Krause <vkrause@kde.org>
  * @see Akonadi::Control
@@ -42,7 +42,10 @@
 {
   Q_OBJECT
   public:
-    /** Enum for the various states the server can be in. */
+    /**
+     * Enum for the various states the server can be in.
+     * @since 4.5
+     */
     enum State {
         NotRunning, ///< Server is not running, could be noone started it yet or it failed to start.
         Starting, ///< Server was started but is not yet running.
@@ -53,10 +56,9 @@
 
     /**
      * Starts the server. This method returns imediately and does not wait
-     * until the server is actually up and running. It is not checked if the
-     * server is already running.
+     * until the server is actually up and running.
      * @return @c true if the start was possible (which not necessarily means
-     * the server is really running though) and @c false if an error occurred.
+     * the server is really running though) and @c false if an immediate error occurred.
      * @see Akonadi::Control::start()
      */
     static bool start();
@@ -78,12 +80,15 @@
     static void showSelfTestDialog( QWidget *parent );
 
     /**
-     * Checks if the server is available currently.
+     * Checks if the server is available currently. For more detailed status information
+     * see state().
+     * @see state()
      */
     static bool isRunning();
 
     /**
      * Returns the state of the server.
+     * @since 4.5
      */
     static State state();
 
