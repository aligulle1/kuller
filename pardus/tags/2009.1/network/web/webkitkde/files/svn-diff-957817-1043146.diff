
Property changes on: Messages.sh
___________________________________________________________________
Deleted: svn:executable
   - *

Index: tests/js.html
===================================================================
--- tests/js.html	(revision 957817)
+++ tests/js.html	(revision 1043437)
@@ -23,6 +23,11 @@
     window.status = 'A new status message.';
 }
 
+function openWindow()
+{
+    window.open("http://kde.org/");
+}
+
 </script>
 </head>
 <body>
@@ -34,5 +39,6 @@
 <a href="javascript:move()">moveTo</a><br />
 <a href="javascript:promptAndAlertMessage()">promptAndAlertMessage</a><br />
 <a href="javascript:statusMessage()">status</a><br />
+<a href="javascript:openWindow()">new window</a><br />
 </body>
 </html>
Index: tests/mailto_link_test.html
===================================================================
--- tests/mailto_link_test.html	(revision 0)
+++ tests/mailto_link_test.html	(revision 1043437)
@@ -0,0 +1,18 @@
+<html>
+<head>
+ <title>Email Link Test</title>
+</head>
+<body>
+<a href="mailto:joe@xyz.com&amp;CC=bob@xyz.com&amp;BCC=bob@xyz.com&amp;attach=%2Fetc%2Fpasswd&amp;subject=hello&amp;body=hello">Send Email - A</a>
+<br/>
+<a href="mailto:joe@xyz.com">Send Email - B</a>
+<br/><br/>
+<form action="mailto:someone@example.com?CC='bob@example.com&amp;attach=%2fetc%2fpasswd&amp;body=" method="post" enctype="application/x-www-form-urlencoded">
+Choose file to upload:<br />
+<input type="file" name="upload_file" size="20" />
+<br />
+<input type="submit" value="Send" />
+<input type="reset" value="Reset" />
+</form>
+</body>
+</html>
\ No newline at end of file
Index: tests/frameset_test.html
===================================================================
--- tests/frameset_test.html	(revision 0)
+++ tests/frameset_test.html	(revision 1043437)
@@ -0,0 +1,9 @@
+<html>
+<head>
+<title>&lt;FRAMESET&gt; test</title>
+</head>
+<frameset cols="120,*">
+  <frame src="frametest/frame_navigation.html" />
+  <frame src="frametest/frame_a.html" name="showframe" />
+</frameset>
+</html>
Index: tests/embed_tag_test.html
===================================================================
--- tests/embed_tag_test.html	(revision 0)
+++ tests/embed_tag_test.html	(revision 1043437)
@@ -0,0 +1,22 @@
+<html>
+<head>
+  <title> &lt;EMBED&gt; tests</title>
+</head>
+<body>
+  <h1>2009</h1>
+  <center>
+  <embed src="http://ev.kde.org/reports/ev-quarterly-2009Q1.pdf" width="75%" height="400"/>
+  </center>
+  <p/>
+  <h1>2008</h1>
+  <center>
+  <embed src="http://ev.kde.org/reports/ev-quarterly-2008Q3-Q4.pdf" width="75%" height="400"/>
+  </center>
+  <p/>
+  <center>
+  <video src="http://blip.tv/file/get/Sebasje-ThePlasmaDesktopShellInKDE42312.ogv" width="75%" height="450">
+  You browser does not support the <b>HTML 5</b>&lt;video&gt; tag.
+  </video>
+  </center>
+</body>
+</html>
\ No newline at end of file
Index: tests/frametest/frame_c.html
===================================================================
--- tests/frametest/frame_c.html	(revision 0)
+++ tests/frametest/frame_c.html	(revision 1043437)
@@ -0,0 +1,7 @@
+<html>
+<body bgcolor="#FFFFCC">
+
+<h3>Frame C</h3>
+<a href="http://www.kde.org">Go to KDE website</a>
+</body>
+</html>
\ No newline at end of file
Index: tests/frametest/frame_navigation.html
===================================================================
--- tests/frametest/frame_navigation.html	(revision 0)
+++ tests/frametest/frame_navigation.html	(revision 1043437)
@@ -0,0 +1,9 @@
+<html>
+<body>
+<a href ="frame_a.html" target ="showframe">Frame a</a><br/>
+<a href ="frame_b.html" target ="showframe">Frame b</a><br/>
+<a href ="frame_c.html" target ="showframe">Frame c</a><br/>
+<a href ="frame_d.html" target ="showframe">Invalid frame</a><br/>
+<a href ="https://bugs.kde.org" target ="showframe">bugs.kde.org</a>
+</body>
+</html>
\ No newline at end of file
Index: tests/frametest/frame_a.html
===================================================================
--- tests/frametest/frame_a.html	(revision 0)
+++ tests/frametest/frame_a.html	(revision 1043437)
@@ -0,0 +1,7 @@
+<html>
+<body bgcolor="#8F8FBD">
+
+<h3>Frame A</h3>
+
+</body>
+</html>
Index: tests/frametest/frame_b.html
===================================================================
--- tests/frametest/frame_b.html	(revision 0)
+++ tests/frametest/frame_b.html	(revision 1043437)
@@ -0,0 +1,7 @@
+<html>
+<body bgcolor="#EBC79E">
+
+<h3>Frame B</h3>
+
+</body>
+</html>
\ No newline at end of file
Index: kdelauncher/main.cpp
===================================================================
--- kdelauncher/main.cpp	(revision 0)
+++ kdelauncher/main.cpp	(revision 1043437)
@@ -0,0 +1,440 @@
+/*
+ * Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies)
+ * Copyright (C) 2006 George Staikos <staikos@kde.org>
+ * Copyright (C) 2006 Dirk Mueller <mueller@kde.org>
+ * Copyright (C) 2006 Zack Rusin <zack@kde.org>
+ * Copyright (C) 2006 Simon Hausmann <hausmann@kde.org>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <kwebview.h>
+
+#include <KDE/KApplication>
+#include <KDE/KAboutData>
+#include <KDE/KCmdLineArgs>
+#include <KDE/KDebug>
+#include <KDE/KIO/AccessManager>
+
+#include <QtUiTools/QUiLoader>
+#include <QtWebKit/QWebPage>
+#include <QtWebKit/QWebView>
+#include <QtWebKit/QWebFrame>
+#include <QtWebKit/QWebSettings>
+
+#if QT_VERSION >= 0x040600
+#include <QtWebKit/QWebElement>
+#endif
+
+#if QT_VERSION >= 0x040400 && !defined(QT_NO_PRINTER)
+#include <QtGui/QPrintPreviewDialog>
+#endif
+
+#include <QtGui/QAction>
+#include <QtGui/QCompleter>
+#include <QtGui/QInputDialog>
+#include <QtGui/QLineEdit>
+#include <QtGui/QMainWindow>
+#include <QtGui/QMenu>
+#include <QtGui/QMenuBar>
+#include <QtGui/QProgressBar>
+#include <QtGui/QStatusBar>
+#include <QtGui/QStringListModel>
+#include <QtGui/QToolBar>
+#include <QtGui/QToolTip>
+#include <QtCore/QDir>
+#include <QtCore/QFile>
+#include <QtCore/QVector>
+#include <QtCore/QTextStream>
+
+
+class MainWindow : public QMainWindow
+{
+    Q_OBJECT
+public:
+    MainWindow(const QString& url = QString()): currentZoom(100) {
+        view = new KWebView(this);
+        setCentralWidget(view);
+
+        connect(view, SIGNAL(loadFinished(bool)),
+                this, SLOT(loadFinished()));
+        connect(view, SIGNAL(titleChanged(const QString&)),
+                this, SLOT(setWindowTitle(const QString&)));
+        connect(view->page(), SIGNAL(linkHovered(const QString&, const QString&, const QString &)),
+                this, SLOT(showLinkHover(const QString&, const QString&)));
+        connect(view->page(), SIGNAL(windowCloseRequested()), this, SLOT(deleteLater()));
+
+        setupUI();
+
+#if QT_VERSION >= 0x040600
+        QUrl qurl = view->guessUrlFromString(url);
+#else
+        QUrl qurl(url);
+#endif
+        if (qurl.isValid()) {
+            urlEdit->setText(qurl.toEncoded());
+            view->load(qurl);
+
+            // the zoom values are chosen to be like in Mozilla Firefox 3
+            zoomLevels << 30 << 50 << 67 << 80 << 90;
+            zoomLevels << 100;
+            zoomLevels << 110 << 120 << 133 << 150 << 170 << 200 << 240 << 300;
+        }
+    }
+
+    QWebPage* webPage() const {
+        return view->page();
+    }
+
+    QWebView* webView() const {
+        return view;
+    }
+
+protected slots:
+
+    void changeLocation() {
+        QString string = urlEdit->text();
+#if QT_VERSION >= 0x040600
+        QUrl url = view->guessUrlFromString(string);
+#else
+        QUrl url(string);
+#endif
+        if (url.isRelative())
+            url = QUrl("http://" + string + "/");
+        urlEdit->setText(url.toEncoded());
+        view->load(url);
+        view->setFocus(Qt::OtherFocusReason);
+    }
+
+    void loadFinished() {
+        urlEdit->setText(view->url().toString());
+
+        QUrl::FormattingOptions opts;
+        opts |= QUrl::RemoveScheme;
+        opts |= QUrl::RemoveUserInfo;
+        opts |= QUrl::StripTrailingSlash;
+        QString s = view->url().toString(opts);
+        s = s.mid(2);
+        if (s.isEmpty())
+            return;
+
+        if (!urlList.contains(s))
+            urlList += s;
+        urlModel.setStringList(urlList);
+    }
+
+    void showLinkHover(const QString &link, const QString &toolTip) {
+        statusBar()->showMessage(link);
+#ifndef QT_NO_TOOLTIP
+        if (!toolTip.isEmpty())
+            QToolTip::showText(QCursor::pos(), toolTip);
+#endif
+    }
+
+    void zoomIn() {
+        int i = zoomLevels.indexOf(currentZoom);
+        Q_ASSERT(i >= 0);
+        if (i < zoomLevels.count() - 1)
+            currentZoom = zoomLevels[i + 1];
+
+        view->setZoomFactor(qreal(currentZoom)/100.0);
+    }
+
+    void zoomOut() {
+        int i = zoomLevels.indexOf(currentZoom);
+        Q_ASSERT(i >= 0);
+        if (i > 0)
+            currentZoom = zoomLevels[i - 1];
+
+        view->setZoomFactor(qreal(currentZoom)/100.0);
+    }
+
+    void resetZoom()
+    {
+       currentZoom = 100;
+       view->setZoomFactor(1.0);
+    }
+
+    void toggleZoomTextOnly(bool b)
+    {
+        view->page()->settings()->setAttribute(QWebSettings::ZoomTextOnly, b);
+    }
+
+    void print() {
+#if QT_VERSION >= 0x040400 && !defined(QT_NO_PRINTER)
+        QPrintPreviewDialog dlg(this);
+        connect(&dlg, SIGNAL(paintRequested(QPrinter *)),
+                view, SLOT(print(QPrinter *)));
+        dlg.exec();
+#endif
+    }
+
+    void setEditable(bool on) {
+        view->page()->setContentEditable(on);
+        formatMenuAction->setVisible(on);
+    }
+
+    void dumpHtml() {
+        kDebug() << "HTML: " << view->page()->mainFrame()->toHtml();
+    }
+
+    void selectElements() {
+        bool ok;
+        QString str = QInputDialog::getText(this, i18n("Select elements"), i18n("Choose elements"),
+                                            QLineEdit::Normal, "a", &ok);
+        if (ok && !str.isEmpty()) {
+#if QT_VERSION >= 0x040600
+            QList<QWebElement> result =  view->page()->mainFrame()->findAllElements(str);
+            foreach (QWebElement e, result)
+                e.setStyleProperty("background-color", "yellow");
+            statusBar()->showMessage(i18n("%1 element(s) selected",result.count()), 5000);
+#endif
+        }
+    }
+
+public slots:
+
+    void newWindow(const QString &url = QString()) {
+        MainWindow *mw = new MainWindow(url);
+        mw->show();
+    }
+
+private:
+
+    QVector<int> zoomLevels;
+    int currentZoom;
+
+    // create the status bar, tool bar & menu
+    void setupUI() {
+        progress = new QProgressBar(this);
+        progress->setRange(0, 100);
+        progress->setMinimumSize(100, 20);
+        progress->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);
+        progress->hide();
+        statusBar()->addPermanentWidget(progress);
+
+        connect(view, SIGNAL(loadProgress(int)), progress, SLOT(show()));
+        connect(view, SIGNAL(loadProgress(int)), progress, SLOT(setValue(int)));
+        connect(view, SIGNAL(loadFinished(bool)), progress, SLOT(hide()));
+
+        urlEdit = new QLineEdit(this);
+        urlEdit->setSizePolicy(QSizePolicy::Expanding, urlEdit->sizePolicy().verticalPolicy());
+        connect(urlEdit, SIGNAL(returnPressed()),
+                SLOT(changeLocation()));
+        QCompleter *completer = new QCompleter(this);
+        urlEdit->setCompleter(completer);
+        completer->setModel(&urlModel);
+
+        QToolBar *bar = addToolBar("Navigation");
+        bar->addAction(view->pageAction(QWebPage::Back));
+        bar->addAction(view->pageAction(QWebPage::Forward));
+        bar->addAction(view->pageAction(QWebPage::Reload));
+        bar->addAction(view->pageAction(QWebPage::Stop));
+        bar->addWidget(urlEdit);
+
+        QMenu *fileMenu = menuBar()->addMenu(i18n("&File"));
+        QAction *newWindow = fileMenu->addAction(i18n("New Window"), this, SLOT(newWindow()));
+#if QT_VERSION >= 0x040400
+        fileMenu->addAction(i18n("Print"), this, SLOT(print()));
+#endif
+        fileMenu->addAction(i18n("Close"), this, SLOT(close()));
+
+        QMenu *editMenu = menuBar()->addMenu(i18n("&Edit"));
+        editMenu->addAction(view->pageAction(QWebPage::Undo));
+        editMenu->addAction(view->pageAction(QWebPage::Redo));
+        editMenu->addSeparator();
+        editMenu->addAction(view->pageAction(QWebPage::Cut));
+        editMenu->addAction(view->pageAction(QWebPage::Copy));
+        editMenu->addAction(view->pageAction(QWebPage::Paste));
+        editMenu->addSeparator();
+        QAction *setEditable = editMenu->addAction(i18n("Set Editable"), this, SLOT(setEditable(bool)));
+        setEditable->setCheckable(true);
+
+        QMenu *viewMenu = menuBar()->addMenu(i18n("&View"));
+        viewMenu->addAction(view->pageAction(QWebPage::Stop));
+        viewMenu->addAction(view->pageAction(QWebPage::Reload));
+        viewMenu->addSeparator();
+        QAction *zoomIn = viewMenu->addAction(i18n("Zoom &In"), this, SLOT(zoomIn()));
+        QAction *zoomOut = viewMenu->addAction(i18n("Zoom &Out"), this, SLOT(zoomOut()));
+        QAction *resetZoom = viewMenu->addAction(i18n("Reset Zoom"), this, SLOT(resetZoom()));
+        QAction *zoomTextOnly = viewMenu->addAction(i18n("Zoom Text Only"), this, SLOT(toggleZoomTextOnly(bool)));
+        zoomTextOnly->setCheckable(true);
+        zoomTextOnly->setChecked(false);
+        viewMenu->addSeparator();
+        viewMenu->addAction(i18n("Dump HTML"), this, SLOT(dumpHtml()));
+
+        QMenu *formatMenu = new QMenu(i18n("F&ormat"));
+        formatMenuAction = menuBar()->addMenu(formatMenu);
+        formatMenuAction->setVisible(false);
+        formatMenu->addAction(view->pageAction(QWebPage::ToggleBold));
+        formatMenu->addAction(view->pageAction(QWebPage::ToggleItalic));
+        formatMenu->addAction(view->pageAction(QWebPage::ToggleUnderline));
+        QMenu *writingMenu = formatMenu->addMenu(i18n("Writing Direction"));
+        writingMenu->addAction(view->pageAction(QWebPage::SetTextDirectionDefault));
+        writingMenu->addAction(view->pageAction(QWebPage::SetTextDirectionLeftToRight));
+        writingMenu->addAction(view->pageAction(QWebPage::SetTextDirectionRightToLeft));
+
+        newWindow->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_N));
+        view->pageAction(QWebPage::Back)->setShortcut(QKeySequence::Back);
+        view->pageAction(QWebPage::Stop)->setShortcut(Qt::Key_Escape);
+        view->pageAction(QWebPage::Forward)->setShortcut(QKeySequence::Forward);
+        view->pageAction(QWebPage::Reload)->setShortcut(QKeySequence::Refresh);
+        view->pageAction(QWebPage::Undo)->setShortcut(QKeySequence::Undo);
+        view->pageAction(QWebPage::Redo)->setShortcut(QKeySequence::Redo);
+        view->pageAction(QWebPage::Cut)->setShortcut(QKeySequence::Cut);
+        view->pageAction(QWebPage::Copy)->setShortcut(QKeySequence::Copy);
+        view->pageAction(QWebPage::Paste)->setShortcut(QKeySequence::Paste);
+        zoomIn->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_Plus));
+        zoomOut->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_Minus));
+        resetZoom->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_0));
+        view->pageAction(QWebPage::ToggleBold)->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_B));
+        view->pageAction(QWebPage::ToggleItalic)->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_I));
+        view->pageAction(QWebPage::ToggleUnderline)->setShortcut(QKeySequence(Qt::CTRL | Qt::Key_U));
+
+        QMenu *toolsMenu = menuBar()->addMenu(i18n("&Tools"));
+        toolsMenu->addAction(i18n("Select elements..."), this, SLOT(selectElements()));
+
+    }
+
+    QWebView *view;
+    QLineEdit *urlEdit;
+    QProgressBar *progress;
+
+    QAction *formatMenuAction;
+
+    QStringList urlList;
+    QStringListModel urlModel;
+};
+
+class URLLoader : public QObject
+{
+    Q_OBJECT
+public:
+    URLLoader(QWebView* view, const QString& inputFileName)
+        : m_view(view)
+        , m_stdOut(stdout)
+    {
+        init(inputFileName);
+    }
+
+public slots:
+    void loadNext()
+    {
+        QString qstr;
+        if (getUrl(qstr)) {
+            QUrl url(qstr, QUrl::StrictMode);
+            if (url.isValid()) {
+                m_stdOut << "Loading " << qstr << " ......" << endl;
+                m_view->load(url);
+            } else
+                loadNext();
+        } else
+            disconnect(m_view, 0, this, 0);
+    }
+
+private:
+    void init(const QString& inputFileName)
+    {
+        QFile inputFile(inputFileName);
+        if (inputFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
+            QTextStream stream(&inputFile);
+            QString line;
+            while (true) {
+                line = stream.readLine();
+                if (line.isNull())
+                    break;
+                m_urls.append(line);
+            }
+        } else {
+            kDebug() << "Can't open list file";
+            exit(0);
+        }
+        m_index = 0;
+        inputFile.close();
+    }
+
+    bool getUrl(QString& qstr)
+    {
+        if (m_index == m_urls.size())
+            return false;
+
+        qstr = m_urls[m_index++];
+        return true;
+    }
+
+private:
+    QVector<QString> m_urls;
+    int m_index;
+    QWebView* m_view;
+    QTextStream m_stdOut;
+};
+
+
+int main(int argc, char **argv)
+{
+    KAboutData about("KDELauncher", 0, ki18n("KDELauncher"), "0.0000013");
+    KCmdLineArgs::init(argc, argv, &about);
+
+    KApplication app;
+    QString url = QString("%1/%2").arg(QDir::homePath()).arg(QLatin1String("index.html"));
+
+    QWebSettings::setMaximumPagesInCache(4);
+
+    QWebSettings::setObjectCacheCapacities((16*1024*1024) / 8, (16*1024*1024) / 8, 16*1024*1024);
+
+    QWebSettings::globalSettings()->setAttribute(QWebSettings::PluginsEnabled, true);
+    QWebSettings::globalSettings()->setAttribute(QWebSettings::DeveloperExtrasEnabled, true);
+
+    const QStringList args = app.arguments();
+
+    if (args.contains(QLatin1String("-r"))) {
+        // robotized
+        QString listFile = args.at(2);
+        if (!(args.count() == 3) && QFile::exists(listFile)) {
+            kDebug() << "Usage: KDELauncher -r listfile";
+            exit(0);
+        }
+        MainWindow window;
+        QWebView *view = window.webView();
+        URLLoader loader(view, listFile);
+        QObject::connect(view, SIGNAL(loadFinished(bool)), &loader, SLOT(loadNext()));
+        loader.loadNext();
+        window.show();
+        return app.exec();
+    } else {
+        if (args.count() > 1)
+            url = args.at(1);
+
+        MainWindow window(url);
+
+        // Opens every given urls in new windows
+        for (int i = 2; i < args.count(); i++)
+            window.newWindow(args.at(i));
+
+        window.show();
+        return app.exec();
+    }
+}
+
+#include "main.moc"
Index: kdelauncher/CMakeLists.txt
===================================================================
--- kdelauncher/CMakeLists.txt	(revision 0)
+++ kdelauncher/CMakeLists.txt	(revision 1043437)
@@ -0,0 +1,13 @@
+project(kdelauncher)
+
+find_package(KDE4 REQUIRED)
+include(KDE4Defaults)
+
+include_directories(${KDE4_INCLUDES} ${CMAKE_SOURCE_DIR}/kdenetwork ${CMAKE_CURRENT_SOURCE_DIR}/../kdewebkit)
+link_directories(${KDE4_LIB_DIR} ${CMAKE_SOURCE_DIR}/kdenetwork ${CMAKE_CURRENT_SOURCE_DIR}/../kdewebkit)
+add_definitions(${QT_DEFINITIONS} ${KDE4_DEFINITIONS})
+
+#qt4_add_resources( kdelauncher_SRCS kdelauncher.qrc )
+
+kde4_add_executable(kdelauncher main.cpp )
+target_link_libraries( kdelauncher ${KDE4_KDEUI_LIBS} kdewebkit )
Index: part/webkitpart.rc
===================================================================
--- part/webkitpart.rc	(revision 957817)
+++ part/webkitpart.rc	(revision 1043437)
@@ -1,5 +1,5 @@
 <!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
-<kpartgui name="webkitpart" version="5">
+<kpartgui name="webkitpart" version="6">
 <MenuBar>
  <Menu name="file">
   <Action name="saveDocument" />
@@ -13,14 +13,18 @@
   <Action name="find" />
  </Menu>
  <Menu name="view">
-  <Action name="incFontSizes" />
-  <Action name="decFontSizes" />
+  <Action name="zoomIn" />
+  <Action name="zoomOut" />
+  <Action name="zoomNormal" />
+  <Action name="zoomTextOnly" />
+  <Separator />
   <Action name="viewDocumentSource" />
   <ActionList name="debugScriptList" />
  </Menu>
 </MenuBar>
 <ToolBar name="htmlToolBar" iconText="icononly" iconSize="22" hidden="true"><text>HTML Toolbar</text>
- <Action name="incFontSizes" />
- <Action name="decFontSizes" />
+  <Action name="zoomIn" />
+  <Action name="zoomOut" />
+  <Action name="zoomNormal" />
 </ToolBar>
 </kpartgui>
Index: part/webkitpart_ext.h
===================================================================
--- part/webkitpart_ext.h	(revision 0)
+++ part/webkitpart_ext.h	(revision 1043437)
@@ -0,0 +1,84 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef WEBKITPART_EXT_H
+#define WEBKITPART_EXT_H
+
+#include <KDE/KParts/BrowserExtension>
+
+class QWebView;
+class KUrl;
+class WebKitPart;
+
+class WebKitBrowserExtension : public KParts::BrowserExtension
+{
+    Q_OBJECT
+
+public:
+    WebKitBrowserExtension(WebKitPart *parent);
+    ~WebKitBrowserExtension();
+
+  virtual void saveState( QDataStream &);
+  virtual void restoreState( QDataStream &);
+
+Q_SIGNALS:
+    void saveUrl(const KUrl &);
+
+public Q_SLOTS:
+    void cut();
+    void copy();
+    void paste();
+    void slotSaveDocument();
+    void slotSaveFrame();
+    void print();
+    void printFrame();
+    void searchProvider();
+    void reparseConfiguration();
+
+    void zoomIn();
+    void zoomOut();
+    void zoomNormal();
+    void toogleZoomTextOnly();
+    void slotSelectAll();
+
+    void slotFrameInWindow();
+    void slotFrameInTab();
+    void slotFrameInTop();
+
+    void slotSaveImageAs();
+    void slotSendImage();
+    void slotCopyImage();
+    void slotViewImage();
+
+    void slotCopyLinkLocation();
+    void slotSaveLinkAs();
+
+    void slotViewDocumentSource();
+
+    void updateEditActions();
+
+private:
+    class WebKitBrowserExtensionPrivate;
+    WebKitBrowserExtensionPrivate* const d;
+};
+
+#endif // WEBKITPART_EXT_H
Index: part/webkitpart.desktop
===================================================================
--- part/webkitpart.desktop	(revision 957817)
+++ part/webkitpart.desktop	(revision 1043437)
@@ -1,7 +1,11 @@
 [Desktop Entry]
 Type=Service
 Comment=Embeddable HTML component
+Comment[bg]=Компонент на HTML за вграждане
+Comment[da]=HTML-komponent som kan indlejres
 Comment[de]=Einbettungsfähige HTML-Komponente
+Comment[el]=Ενσωματώσιμο συστατικό HTML
+Comment[en_GB]=Embeddable HTML component
 Comment[es]=Componente de HTML empotrable
 Comment[et]=Põimitav HTML-komponent
 Comment[fr]=Composant HTML intégrable
@@ -9,8 +13,11 @@
 Comment[gl]=Compoñente HTML integrábel
 Comment[km]=សមាសធាតុ HTML ដែល​អាច​បង្កប់​បាន
 Comment[lt]=Įdedamas HTML komponentas
+Comment[ml]=എംബഡബിള്‍ ആയിട്ടുള്ള എച്ച്ടിഎംഎല്‍ ഘടകം
+Comment[ms]=Komponen HTML boleh lekap
 Comment[nds]=Inbettbor HTML-Komponent
 Comment[nl]=Inbedbare HTML-component
+Comment[nn]=Innebyggbar HTML-komponent
 Comment[pa]=ਇੰਬੈੱਡਡ HTML ਭਾਗ
 Comment[pt]=Componente de HTML incorporada
 Comment[pt_BR]=Componente HTML que pode ser embutido
@@ -22,12 +29,40 @@
 Comment[uk]=Вмонтований HTML-компонент
 Comment[x-test]=xxEmbeddable HTML componentxx
 Comment[zh_CN]=嵌入式 HTML 组件
+Comment[zh_TW]=可內嵌的 HTML 元件
 MimeType=text/html;application/xml;application/xhtml+xml;
 Icon=webkit
 Name=WebKit
+Name[bg]=WebKit
+Name[cs]=WebKit
+Name[da]=WebKit
+Name[de]=WebKit
+Name[el]=WebKit
+Name[en_GB]=WebKit
+Name[es]=WebKit
+Name[et]=WebKit
+Name[fr]=WebKit
+Name[ga]=WebKit
+Name[gl]=WebKit
+Name[km]=WebKit
+Name[lt]=WebKit
+Name[ml]=വെബ്കിറ്റ്
+Name[ms]=WebKit
+Name[nds]=WebKit
+Name[nl]=WebKit
+Name[nn]=WebKit
 Name[pa]=ਵੈੱਬਕਿੱਟ
+Name[pt]=WebKit
+Name[pt_BR]=WebKit
+Name[ro]=WebKit
 Name[sv]=Webkit
+Name[tg]=WebKit
+Name[th]=WebKit
+Name[tr]=WebKit
+Name[uk]=WebKit
 Name[x-test]=xxWebKitxx
+Name[zh_CN]=WebKit
+Name[zh_TW]=WebKit
 X-KDE-ServiceTypes=KParts/ReadOnlyPart,Browser/View
 X-KDE-Library=webkitkdepart
 InitialPreference=9
Index: part/webview.cpp
===================================================================
--- part/webview.cpp	(revision 957817)
+++ part/webview.cpp	(revision 1043437)
@@ -4,6 +4,7 @@
  * Copyright (C) 2007 Trolltech ASA
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Laurent Montel <montel@kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,33 +24,35 @@
  */
 
 #include "webview.h"
+#include "webpage.h"
 #include "webkitpart.h"
-#include "webpage.h"
 
-#include <KParts/GenericFactory>
-#include <KAboutData>
-#include <KAction>
-#include <KActionCollection>
-#include <KConfigGroup>
-#include <KMimeType>
-#include <KService>
-#include <KUriFilterData>
-#include <KStandardDirs>
-#include <KActionMenu>
+#include <kio/global.h>
+#include <KDE/KParts/GenericFactory>
+#include <KDE/KAboutData>
+#include <KDE/KAction>
+#include <KDE/KActionCollection>
+#include <KDE/KConfigGroup>
+#include <KDE/KMimeType>
+#include <KDE/KService>
+#include <KDE/KUriFilterData>
+#include <KDE/KStandardDirs>
+#include <KDE/KActionMenu>
+#include <KDE/KIO/AccessManager>
 
 #include <QtNetwork/QHttpRequestHeader>
+#include <QtNetwork/QNetworkRequest>
 #include <QtWebKit/QWebFrame>
+
 #include <QtWebKit/QWebHitTestResult>
 
 class WebView::WebViewPrivate
 {
 public:
-    WebViewPrivate(WebView *webView)
-    : webView(webView)
-    {}
+    WebViewPrivate() {}
 
-    void addSearchActions(QList<QAction *>& selectActions);
-    QString selectedTextAsOneLine() const;
+    void addSearchActions(QList<QAction *>& selectActions, QWebView*);
+    QString selectedTextAsOneLine(const QString &) const;
 
     /**
     * Returns selectedText without any leading or trailing whitespace,
@@ -58,22 +61,28 @@
     * Note that hasSelection can return true and yet simplifiedSelectedText can be empty,
     * e.g. when selecting a single space.
     */
-    QString simplifiedSelectedText() const;
+    QString simplifiedSelectedText(const QString&) const;
 
-    WebView *webView;
     KActionCollection* actionCollection;
     QWebHitTestResult result;
-    WebKitPart *part;
+    QPointer<WebKitPart> part;
 };
 
 
 WebView::WebView(WebKitPart *wpart, QWidget *parent)
-    : KWebView(parent), d(new WebViewPrivate(this))
+        :KWebView(parent), d(new WebViewPrivate())
 {
     d->part = wpart;
-    setPage(new WebPage(wpart, this));
     d->actionCollection = new KActionCollection(this);
     setAcceptDrops(true);
+
+    // Use our own custom re-implementation of KWebPage...
+    WebPage *webpage = new WebPage(wpart, this);
+    setPage(webpage);
+
+    // Connect parent's saveUrl signal...
+    connect(this, SIGNAL(saveUrl(const KUrl &)),
+            webpage, SLOT(saveUrl(const KUrl &)));
 }
 
 WebView::~WebView()
@@ -81,6 +90,24 @@
     delete d;
 }
 
+void WebView::loadUrl(const KUrl &url, const KParts::OpenUrlArguments &args, const KParts::BrowserArguments &bargs)
+{
+    if (args.reload()) {
+      pageAction(KWebPage::Reload)->trigger();
+      return;
+    }
+
+    QNetworkRequest req;
+    req.setUrl(url);
+    req.setRawHeader("Referer", args.metaData().value("referrer").toUtf8());
+
+    if (bargs.postData.isEmpty()) {
+        KWebView::load(req);
+    } else {
+        KWebView::load(req, QNetworkAccessManager::PostOperation, bargs.postData);
+    }
+}
+
 QWebHitTestResult WebView::contextMenuResult() const
 {
     return d->result;
@@ -148,6 +175,13 @@
         action = d->actionCollection->action("copyimage");
         action->setEnabled(!d->result.pixmap().isNull());
         partActions.append(action);
+
+        if (!d->actionCollection->action("viewimage")) {
+            action = new KAction(i18n("View Image (%1)").arg(KUrl(d->result.imageUrl()).fileName()), this);
+            d->actionCollection->addAction("viewimage", action);
+            connect(action, SIGNAL(triggered(bool)), d->part->browserExtension(), SLOT(slotViewImage()));
+        }
+        partActions.append(d->actionCollection->action("viewimage"));
     }
 
     if (d->result.linkUrl().isEmpty()) {
@@ -159,6 +193,10 @@
         partActions.append(action);
     }
 
+    if (settings()->testAttribute(QWebSettings::DeveloperExtrasEnabled)) {
+        partActions.append(pageAction(QWebPage::InspectElement));
+    }
+
     partGroupMap.insert("partactions", partActions);
 }
 
@@ -172,9 +210,9 @@
     }
     selectActions.append(d->actionCollection->action("copy"));
 
-    d->addSearchActions(selectActions);
+    d->addSearchActions(selectActions, this);
 
-    QString selectedTextURL = d->selectedTextAsOneLine();
+    QString selectedTextURL = d->selectedTextAsOneLine(selectedText());
     if (selectedTextURL.contains("://") && KUrl(selectedTextURL).isValid()) {
         if (selectedTextURL.length() > 18) {
             selectedTextURL.truncate(15);
@@ -216,7 +254,7 @@
     linkGroupMap.insert("linkactions", linkActions);
 }
 
-void WebView::WebViewPrivate::addSearchActions(QList<QAction *>& selectActions)
+void WebView::WebViewPrivate::addSearchActions(QList<QAction *>& selectActions, QWebView *view)
 {
     // Fill search provider entries
     KConfig config("kuriikwsfilterrc");
@@ -225,7 +263,7 @@
     const char keywordDelimiter = cg.readEntry("KeywordDelimiter", static_cast<int>(':'));
 
     // search text
-    QString selectedText = simplifiedSelectedText();
+    QString selectedText = simplifiedSelectedText(view->selectedText());
     if (selectedText.isEmpty())
         return;
 
@@ -247,7 +285,7 @@
 
     QString name;
     if (KUriFilter::self()->filterUri(data, list)) {
-        QString iconPath = KStandardDirs::locate("cache", KMimeType::favIconForUrl(data.uri()) + ".png");
+        const QString iconPath = KStandardDirs::locate("cache", KMimeType::favIconForUrl(data.uri()) + ".png");
         if (iconPath.isEmpty())
             icon = KIcon("edit-find");
         else
@@ -258,7 +296,7 @@
         name = "Google";
     }
 
-    KAction *action = new KAction(i18n("Search for '%1' with %2", selectedText, name), webView);
+    KAction *action = new KAction(i18n("Search for '%1' with %2", selectedText, name), view);
     actionCollection->addAction("searchProvider", action);
     selectActions.append(action);
     action->setIcon(icon);
@@ -270,7 +308,7 @@
     favoriteEngines = cg.readEntry("FavoriteSearchEngines", favoriteEngines);
 
     if (!favoriteEngines.isEmpty()) {
-        KActionMenu* providerList = new KActionMenu(i18n("Search for '%1' with",  selectedText), webView);
+        KActionMenu* providerList = new KActionMenu(i18n("Search for '%1' with",  selectedText), view);
         actionCollection->addAction("searchProviderList", providerList);
         selectActions.append(providerList);
 
@@ -285,14 +323,14 @@
             data.setData(searchProviderPrefix + "some keyword");
 
             if (KUriFilter::self()->filterUri(data, list)) {
-                QString iconPath = KStandardDirs::locate("cache", KMimeType::favIconForUrl(data.uri()) + ".png");
+                const QString iconPath = KStandardDirs::locate("cache", KMimeType::favIconForUrl(data.uri()) + ".png");
                 if (iconPath.isEmpty())
                     icon = KIcon("edit-find");
                 else
                     icon = KIcon(QPixmap(iconPath));
                 name = service->name();
 
-                KAction *action = new KAction(name, webView);
+                KAction *action = new KAction(name, view);
                 actionCollection->addAction(QString("searchProvider" + searchProviderPrefix).toLatin1().constData(), action);
                 action->setIcon(icon);
                 connect(action, SIGNAL(triggered(bool)), part->browserExtension(), SLOT(searchProvider()));
@@ -303,21 +341,21 @@
     }
 }
 
-QString WebView::WebViewPrivate::simplifiedSelectedText() const
+QString WebView::WebViewPrivate::simplifiedSelectedText(const QString &_text) const
 {
-    QString text = webView->selectedText();
+    QString text (_text);
     text.replace(QChar(0xa0), ' ');
     // remove leading and trailing whitespace
     while (!text.isEmpty() && text[0].isSpace())
         text = text.mid(1);
     while (!text.isEmpty() && text[text.length()-1].isSpace())
-        text.truncate(text.length()-1);
+        text.truncate(text.length() - 1);
     return text;
 }
 
-QString WebView::WebViewPrivate::selectedTextAsOneLine() const
+QString WebView::WebViewPrivate::selectedTextAsOneLine(const QString &_text) const
 {
-    QString text = this->simplifiedSelectedText();
+    QString text = this->simplifiedSelectedText(_text);
     // in addition to what simplifiedSelectedText does,
     // remove linefeeds and any whitespace surrounding it (#113177),
     // to get it all in a single line.
@@ -330,5 +368,5 @@
     KParts::BrowserArguments browserArgs;
     browserArgs.frameName = "_blank";
 
-    emit d->part->browserExtension()->openUrlRequest(d->selectedTextAsOneLine(), KParts::OpenUrlArguments(), browserArgs);
+    emit d->part->browserExtension()->openUrlRequest(d->selectedTextAsOneLine(selectedText()), KParts::OpenUrlArguments(), browserArgs);
 }
Index: part/webpage.cpp
===================================================================
--- part/webpage.cpp	(revision 957817)
+++ part/webpage.cpp	(revision 1043437)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2008 Dirk Mueller <mueller@kde.org>
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -22,10 +23,12 @@
  */
 
 #include "webpage.h"
-#include <kdewebkit/kwebpage.h>
+
 #include "webkitpart.h"
+#include "websslinfo.h"
 #include "webview.h"
-#include "kdewebkit/settings/webkitsettings.h"
+#include "sslinfodialog_p.h"
+#include "settings/webkitsettings.h"
 
 #include <KDE/KParts/GenericFactory>
 #include <KDE/KParts/BrowserRun>
@@ -41,57 +44,321 @@
 #include <KDE/KShell>
 #include <KDE/KStandardDirs>
 #include <KDE/KStandardShortcut>
+#include <KDE/KAuthorized>
 #include <KIO/Job>
+#include <KIO/AccessManager>
 
-#include <QWebFrame>
+#include <QtCore/QTimer>
+#include <QtGui/QTextDocument>
 #include <QtNetwork/QNetworkReply>
+#include <QtUiTools/QUiLoader>
+#include <QtWebKit/QWebFrame>
+#include <QtWebKit/QWebHistoryItem>
 
-WebPage::WebPage(WebKitPart *wpart, QWidget *parent)
-    : KWebPage(parent)
-    , m_part(wpart)
+#define QL1(x)  QLatin1String(x)
+
+typedef QPair<QString, QString> StringPair;
+
+// Sanitizes the "mailto:" url, e.g. strips out any "attach" parameters.
+static QUrl sanitizeMailToUrl(const QUrl &url, QStringList& files) {
+    QUrl sanitizedUrl;    
+    
+    // NOTE: This is necessary to ensure we can properly use QUrl's query
+    // related APIs to process 'mailto:' urls of form 'mailto:foo@bar.com'.
+    if (url.hasQuery())
+      sanitizedUrl = url;
+    else
+      sanitizedUrl = QUrl(url.scheme() + QL1(":?") + url.path());
+
+    QListIterator<StringPair> it (sanitizedUrl.queryItems());
+    sanitizedUrl.setEncodedQuery(QByteArray());    // clear out the query componenet
+
+    while (it.hasNext()) {
+        StringPair queryItem = it.next();
+        if (queryItem.first.contains(QChar('@')) && queryItem.second.isEmpty()) {
+            queryItem.second = queryItem.first;
+            queryItem.first = "to";
+        } else if (QString::compare(queryItem.first, QL1("attach"), Qt::CaseInsensitive) == 0) {
+            files << queryItem.second;
+            continue;
+        }        
+        sanitizedUrl.addQueryItem(queryItem.first, queryItem.second);
+    }
+
+    return sanitizedUrl;
+}
+
+// Converts QNetworkReply::NetworkError codes to the KIO equivalent ones...
+static int convertErrorCode(QNetworkReply* reply)
 {
+    // First check if there is a KIO error code sent back and use that,
+    // if not attempt to convert the QNetworkReply::
+    QVariant attr = reply->attribute(static_cast<QNetworkRequest::Attribute>(KIO::AccessManager::KioError));
+    if (attr.isValid() && attr.type() == QVariant::Int)
+        return attr.toInt();
+
+    switch (reply->error()) {
+        case QNetworkReply::ConnectionRefusedError:
+            return KIO::ERR_COULD_NOT_CONNECT;
+        case QNetworkReply::HostNotFoundError:
+            return KIO::ERR_UNKNOWN_HOST;
+        case QNetworkReply::TimeoutError:
+            return KIO::ERR_SERVER_TIMEOUT;
+        case QNetworkReply::OperationCanceledError:
+            return KIO::ERR_USER_CANCELED;
+        case QNetworkReply::ProxyNotFoundError:
+            return KIO::ERR_UNKNOWN_PROXY_HOST;
+        case QNetworkReply::ContentAccessDenied:
+            return KIO::ERR_ACCESS_DENIED;
+        case QNetworkReply::ContentOperationNotPermittedError:
+            return KIO::ERR_WRITE_ACCESS_DENIED;
+        case QNetworkReply::ContentNotFoundError:
+            return KIO::ERR_NO_CONTENT;
+        case QNetworkReply::AuthenticationRequiredError:
+            return KIO::ERR_COULD_NOT_AUTHENTICATE;
+        case QNetworkReply::ProtocolUnknownError:
+            return KIO::ERR_UNSUPPORTED_PROTOCOL;
+        case QNetworkReply::ProtocolInvalidOperationError:
+            return KIO::ERR_UNSUPPORTED_ACTION;
+        case QNetworkReply::UnknownNetworkError:
+            return KIO::ERR_UNKNOWN;
+        case QNetworkReply::NoError:
+        default:
+            return 0;
+    }
+}
+
+// Returns true if the scheme and domain of the two urls match...
+static bool domainSchemeMatch(const QUrl& u1, const QUrl& u2)
+{
+    if (u1.scheme() != u2.scheme())
+        return false;
+
+    QStringList u1List = u1.host().split(QChar('.'), QString::SkipEmptyParts);
+    QStringList u2List = u2.host().split(QChar('.'), QString::SkipEmptyParts);
+
+    if (qMin(u1List.count(), u2List.count()) < 2)
+        return false;  // better safe than sorry...
+
+    while (u1List.count() > 2)
+        u1List.removeFirst();
+
+    while (u2List.count() > 2)
+        u2List.removeFirst();
+
+    return (u1List == u2List);
+}
+
+static QString getFileNameForDownload(const QNetworkRequest &request, QNetworkReply *reply)
+{
+    QString fileName = KUrl(request.url()).fileName();
+
+    if (reply && reply->hasRawHeader("Content-Disposition")) { // based on code from arora, downloadmanger.cpp
+        const QString value = QL1(reply->rawHeader("Content-Disposition"));
+        const int pos = value.indexOf(QL1("filename="));
+        if (pos != -1) {
+            QString name = value.mid(pos + 9);
+            if (name.startsWith(QLatin1Char('"')) && name.endsWith(QLatin1Char('"')))
+                name = name.mid(1, name.size() - 2);
+            fileName = name;
+        }
+    }
+
+    return fileName;
+}
+
+class WebPage::WebPagePrivate
+{
+public:
+    WebPagePrivate() {}
+
+    // Holds list of requests including those from children frames
+    QMap<QUrl, QString> requestMap;
+    WebSslInfo sslInfo;
+    QPointer<WebKitPart> part;
+};
+
+WebPage::WebPage(WebKitPart *part, QWidget *parent)
+        :KWebPage(parent), d (new WebPagePrivate)
+{
+    d->part = part;
+    setSessionMetaData("ssl_activate_warnings", "TRUE");
+
+    // Set font sizes accordingly...
+    if (view())
+        WebKitSettings::self()->computeFontSizes(view()->logicalDpiY());
+
+    setForwardUnsupportedContent(true);
+
     connect(this, SIGNAL(geometryChangeRequested(const QRect &)),
             this, SLOT(slotGeometryChangeRequested(const QRect &)));
     connect(this, SIGNAL(windowCloseRequested()),
             this, SLOT(slotWindowCloseRequested()));
     connect(this, SIGNAL(statusBarMessage(const QString &)),
             this, SLOT(slotStatusBarMessage(const QString &)));
+    connect(this, SIGNAL(downloadRequested(const QNetworkRequest &)),
+            this, SLOT(slotDownloadRequest(const QNetworkRequest &)));
+    connect(this, SIGNAL(unsupportedContent(QNetworkReply *)),
+            this, SLOT(slotUnsupportedContent(QNetworkReply *)));
+    connect(networkAccessManager(), SIGNAL(finished(QNetworkReply*)),
+            this, SLOT(slotRequestFinished(QNetworkReply*)));
 }
 
-bool WebPage::acceptNavigationRequest(QWebFrame *frame, const QNetworkRequest &request,
-                                      NavigationType type)
+WebPage::~WebPage()
 {
-    kDebug() << "acceptNavigationRequest" << request.url();
+    delete d;
+}
 
+bool WebPage::authorizedRequest(const QUrl &url) const
+{
+    // Check for ad filtering...
+    return !(WebKitSettings::self()->isAdFilterEnabled() && WebKitSettings::self()->isAdFiltered(url.toString()));
+}
+
+const WebSslInfo& WebPage::sslInfo() const
+{
+    return d->sslInfo;
+}
+
+void WebPage::setSslInfo (const WebSslInfo& info)
+{
+    d->sslInfo = info;
+}
+
+void WebPage::saveUrl(const KUrl &url)
+{
+    slotDownloadRequest(QNetworkRequest(url));
+}
+
+bool WebPage::acceptNavigationRequest(QWebFrame *frame, const QNetworkRequest &request, NavigationType type)
+{
+    // Handle "mailto:" url here...
+    if (handleMailToUrl(request.url(), type))
+      return false;
+
+    if (frame) {
+        d->requestMap.insert (request.url(), frame->frameName());
+
+        /*
+          ISSUE: QtWebKit always sends user clicks on javascript based links
+          as NavigationTypeOther instead of NavigationTypeLink. As result the
+          checks below will fail to do their jobs if the request originated
+          from the following type of link in a web page:
+
+          <a href="javascript:location.href='http://qt.nokia.com'">javascript link</a>
+         */
+        switch (type) {
+            case QWebPage::NavigationTypeFormResubmitted:
+            case QWebPage::NavigationTypeFormSubmitted:
+                if (!checkFormData(request)) {
+                    return false;
+                }
+                // NOTE: Missing break statement is on purpose!
+            case QWebPage::NavigationTypeLinkClicked:
+                if (!checkLinkSecurity(request, type)) {
+                    return false;
+                }
+                if (d->sslInfo.isValid()) {
+                    setRequestMetaData("ssl_was_in_use", "TRUE");
+                }
+                // NOTE: Missing break statement is on purpose!
+            case QWebPage::NavigationTypeOther:
+                emit updateHistory(); // Make sure the history gets updated...
+                break;                
+            default:
+                break;
+        }
+
+        if (frame == mainFrame()) {
+            setRequestMetaData("main_frame_request", "TRUE");
+        } else {
+            setRequestMetaData("main_frame_request", "FALSE");
+        }
+    }
+
     return KWebPage::acceptNavigationRequest(frame, request, type);
 }
 
-KWebPage *WebPage::newWindow(WebWindowType type)
+QWebPage *WebPage::createWindow(WebWindowType type)
 {
     kDebug() << type;
     KParts::ReadOnlyPart *part = 0;
     KParts::OpenUrlArguments args;
     args.metaData()["referrer"] = mainFrame()->url().toString();
-    //if (type == WebModalDialog) //TODO: correct behavior?
-        args.metaData()["forcenewwindow"] = "true";
 
-    emit m_part->browserExtension()->createNewWindow(KUrl("about:blank"), args,
-                                                     KParts::BrowserArguments(),
-                                                     KParts::WindowArgs(), &part);
+    KParts::BrowserArguments bargs;
+    bargs.setLockHistory(true);
+    if (type == WebModalDialog)
+        bargs.setForcesNewWindow(true);
+
+    emit d->part->browserExtension()->createNewWindow(KUrl("about:blank"), args, bargs,
+                                                      KParts::WindowArgs(), &part);
+
     WebKitPart *webKitPart = qobject_cast<WebKitPart*>(part);
+
     if (!webKitPart) {
-        kDebug() << "got NOT a WebKitPart but a" << part->metaObject()->className();
+        if (part)
+            kDebug() << "Got a non WebKitPart" << part->metaObject()->className();
+        else
+            kDebug() << "part is null";
+
         return 0;
     }
+
     return webKitPart->view()->page();
 }
 
+void WebPage::slotUnsupportedContent(QNetworkReply *reply)
+{
+    KParts::OpenUrlArguments args;
+    const KUrl url(reply->url());
+    kDebug() << url;
+
+    Q_FOREACH (const QByteArray &headerName, reply->rawHeaderList()) {
+        args.metaData().insert(QString(headerName), QString(reply->rawHeader(headerName)));
+    }
+
+    emit d->part->browserExtension()->openUrlRequest(url, args, KParts::BrowserArguments());
+}
+
+void WebPage::slotDownloadRequest(const QNetworkRequest &request)
+{
+    const KUrl url(request.url());
+    kDebug() << url;
+
+    // Integration with a download manager...
+    if (!url.isLocalFile()) {
+        KConfigGroup cfg = KSharedConfig::openConfig("konquerorrc", KConfig::NoGlobals)->group("HTML Settings");
+        const QString downloadManger = cfg.readPathEntry("DownloadManager", QString());
+
+        if (!downloadManger.isEmpty()) {
+            // then find the download manager location
+            kDebug() << "Using: " << downloadManger << " as Download Manager";
+            QString cmd = KStandardDirs::findExe(downloadManger);
+            if (cmd.isEmpty()) {
+                QString errMsg = i18n("The Download Manager (%1) could not be found in your $PATH.", downloadManger);
+                QString errMsgEx = i18n("Try to reinstall it. \n\nThe integration with Konqueror will be disabled.");
+                KMessageBox::detailedSorry(view(), errMsg, errMsgEx);
+                cfg.writePathEntry("DownloadManager", QString());
+                cfg.sync();
+            } else {
+                cmd += ' ' + KShell::quoteArg(url.url());
+                kDebug() << "Calling command" << cmd;
+                KRun::runCommand(cmd, view());
+                return;
+            }
+        }
+    }
+
+    KWebPage::downloadRequest(request);
+}
+
 void WebPage::slotGeometryChangeRequested(const QRect &rect)
 {
     const QString host = mainFrame()->url().host();
 
     if (WebKitSettings::self()->windowMovePolicy(host) == WebKitSettings::KJSWindowMoveAllow) { // Why doesn't this work?
-        emit m_part->browserExtension()->moveTopLevelWidget(rect.x(), rect.y());
+        emit d->part->browserExtension()->moveTopLevelWidget(rect.x(), rect.y());
     }
 
     int height = rect.height();
@@ -113,7 +380,7 @@
 
     if (WebKitSettings::self()->windowResizePolicy(host) == WebKitSettings::KJSWindowResizeAllow) {
         kDebug() << "resizing to " << width << "x" << height;
-        emit m_part->browserExtension()->resizeTopLevelWidget(width, height);
+        emit d->part->browserExtension()->resizeTopLevelWidget(width, height);
     }
 
     // If the window is out of the desktop, move it up/left
@@ -127,41 +394,208 @@
     if (bottom > sg.bottom())
         moveByY = - bottom + sg.bottom(); // always <0
     if ((moveByX || moveByY) &&
-      WebKitSettings::self()->windowMovePolicy(host) == WebKitSettings::KJSWindowMoveAllow) {
-        emit m_part->browserExtension()->moveTopLevelWidget(view()->x() + moveByX, view()->y() + moveByY);
+        WebKitSettings::self()->windowMovePolicy(host) == WebKitSettings::KJSWindowMoveAllow) {
+
+        emit d->part->browserExtension()->moveTopLevelWidget(view()->x() + moveByX, view()->y() + moveByY);
     }
 }
 
 void WebPage::slotWindowCloseRequested()
 {
-    emit m_part->browserExtension()->requestFocus(m_part);
+    emit d->part->browserExtension()->requestFocus(d->part);
     if (KMessageBox::questionYesNo(view(),
-                                   i18n("Close window?"), i18n("Confirmation Required"),
+                                   i18n("Close window ?"), i18n("Confirmation Required"),
                                    KStandardGuiItem::close(), KStandardGuiItem::cancel())
-      == KMessageBox::Yes) {
-        m_part->deleteLater();
-        m_part = 0;
+        == KMessageBox::Yes) {
+        d->part->deleteLater();
+        d->part = 0;
     }
 }
 
 void WebPage::slotStatusBarMessage(const QString &message)
 {
     if (WebKitSettings::self()->windowStatusPolicy(mainFrame()->url().host()) == WebKitSettings::KJSWindowStatusAllow) {
-        m_part->setStatusBarTextProxy(message);
+        d->part->setStatusBarTextProxy(message);
     }
 }
 
-void WebPage::slotHandleUnsupportedContent(QNetworkReply *reply)
+void WebPage::slotRequestFinished(QNetworkReply *reply)
 {
-    const KUrl url(reply->request().url());
-    KParts::OpenUrlArguments args;
-    Q_FOREACH (const QByteArray &headerName, reply->rawHeaderList()) {
-        args.metaData().insert(QString(headerName), QString(reply->rawHeader(headerName)));
+    Q_ASSERT(reply);
+    QUrl url (reply->request().url());
+
+    if (d->requestMap.contains(url)) {
+
+        kDebug() << url;
+        const QString frameName = d->requestMap.take(url);
+        const int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+
+        if (statusCode > 300 && statusCode < 304) {            
+            kDebug() << "Redirected to " << reply->url();
+        } else {
+            // TODO: Perhaps look into supporting mixed mode, part secure and
+            // part not, sites at some point. For now we only deal with SSL
+            // information for the main page like most browsers.
+            if (frameName.isEmpty() && d->sslInfo.isValid() && !domainSchemeMatch(reply->url(), d->sslInfo.url())) {
+                kDebug() << "Reseting cached SSL info...";
+                d->sslInfo = WebSslInfo();
+            }
+
+            // Handle any error...
+            const int code = convertErrorCode(reply);
+            switch (code) {
+                case 0:
+                    break;
+                case KIO::ERR_ABORTED:
+                case KIO::ERR_USER_CANCELED: // Do nothing if request is cancelled/aborted
+                    kDebug() << "User aborted request!";
+                    emit loadAborted(QUrl());
+                    return;
+                // Handle the user clicking on a link that refers to a directory
+                // Since KIO cannot automatically convert a GET request to a LISTDIR one.
+                case KIO::ERR_IS_DIRECTORY:
+                    emit loadAborted(reply->url());
+                    return;
+                default:
+                    emit loadError(code, reply->errorString(), frameName);
+                    return;
+            }
+
+            if (frameName.isEmpty()) {
+                // Obtain and set the SSL information if any...
+                if (!d->sslInfo.isValid()) {
+                    d->sslInfo.fromMetaData(reply->attribute(static_cast<QNetworkRequest::Attribute>(KIO::AccessManager::MetaData)));
+                    d->sslInfo.setUrl(reply->url());
+                }
+
+                setPageJScriptPolicy(reply->url());
+            }
+
+            emit navigationRequestFinished();
+        }
     }
-    emit m_part->browserExtension()->openUrlRequest(url, args, KParts::BrowserArguments());
 }
 
-void WebPage::saveUrl(const KUrl &url)
+bool WebPage::checkLinkSecurity(const QNetworkRequest &req, NavigationType type) const
 {
-    slotDownloadRequested(QNetworkRequest(url));
+    // Check whether the request is authorized or not...
+    if (!KAuthorized::authorizeUrlAction("redirect", mainFrame()->url(), req.url())) {
+        QString buttonText, title, message;
+
+        int response = KMessageBox::Cancel;
+        KUrl linkUrl (req.url());
+
+        if (type == QWebPage::NavigationTypeLinkClicked) {
+            message = i18n("<qt>This untrusted page links to<br/><b>%1</b>."
+                           "<br/>Do you want to follow the link?</qt>", linkUrl.url());
+            title = i18n("Security Warning");
+            buttonText = i18n("Follow");
+        } else {
+            title = i18n("Security Alert");
+            message = i18n("<qt>Access by untrusted page to<br/><b>%1</b><br/> denied.</qt>",
+                           Qt::escape(linkUrl.prettyUrl()));
+        }
+
+        if (buttonText.isEmpty()) {
+            KMessageBox::error( 0, message, title);
+        } else {
+            // Dangerous flag makes the Cancel button the default
+            response = KMessageBox::warningContinueCancel(0, message, title,
+                                                          KGuiItem(buttonText),
+                                                          KStandardGuiItem::cancel(),
+                                                          QString(), // no don't ask again info
+                                                          KMessageBox::Notify | KMessageBox::Dangerous);
+        }
+
+        return (response == KMessageBox::Continue);
+    }
+
+    return true;
 }
+
+bool WebPage::checkFormData(const QNetworkRequest &req) const
+{
+    const QString scheme (req.url().scheme().toLower());
+
+    if (d->sslInfo.isValid() && scheme != "https" && scheme != "mailto" &&
+        (KMessageBox::warningContinueCancel(0,
+                                           i18n("Warning: This is a secure form "
+                                                "but it is attempting to send "
+                                                "your data back unencrypted.\n"
+                                                "A third party may be able to "
+                                                "intercept and view this "
+                                                "information.\nAre you sure you "
+                                                "wish to continue?"),
+                                           i18n("Network Transmission"),
+                                           KGuiItem(i18n("&Send Unencrypted")))  == KMessageBox::Cancel)) {
+
+        return false;
+    }
+
+
+    if ((scheme == QL1("mailto")) &&
+        (KMessageBox::warningContinueCancel(0, i18n("This site is attempting to "
+                                                    "submit form data via email.\n"
+                                                    "Do you want to continue?"),
+                                            i18n("Network Transmission"),
+                                            KGuiItem(i18n("&Send Email")),
+                                            KStandardGuiItem::cancel(),
+                                            "WarnTriedEmailSubmit") == KMessageBox::Cancel)) {
+        return false;
+    }
+
+    return true;
+}
+
+bool WebPage::handleMailToUrl (const QUrl& url, NavigationType type) const
+{
+    if (QString::compare(url.scheme(), QL1("mailto"), Qt::CaseInsensitive) == 0) {
+        QStringList files;
+        QUrl mailtoUrl (sanitizeMailToUrl(url, files));
+
+        switch (type) {
+            case QWebPage::NavigationTypeLinkClicked:
+                if (!files.isEmpty() && KMessageBox::warningContinueCancelList(0,
+                                                                               i18n("<qt>Do you want to allow this site to attach "
+                                                                                    "the following files to the email message ?</qt>"),
+                                                                               files, i18n("Email Attachment Confirmation"),
+                                                                               KGuiItem(i18n("&Allow attachements")),
+                                                                               KGuiItem(i18n("&Ignore attachements")), QL1("WarnEmailAttachment")) == KMessageBox::Continue) {
+
+                    Q_FOREACH(const QString& file, files) {
+                        mailtoUrl.addQueryItem(QL1("attach"), file); // Re-add the attachments...
+                    }
+                }
+                break;
+            case QWebPage::NavigationTypeFormSubmitted:
+            case QWebPage::NavigationTypeFormResubmitted:
+                if (!files.isEmpty()) {
+                    KMessageBox::information(0, i18n("This site attempted to attach a file from your "
+                                                     "computer in the form submission. The attachment "
+                                                     "was removed for your protection."),
+                                             i18n("KDE"), "InfoTriedAttach");
+                }
+                break;
+            default:
+                 break;
+        }
+
+        kDebug() << "Emitting openUrlRequest with " << mailtoUrl;
+        emit d->part->browserExtension()->openUrlRequest(mailtoUrl);
+        return true;
+    }
+
+    return false;
+}
+
+void WebPage::setPageJScriptPolicy(const QUrl &url)
+{
+    const QString hostname (url.host());
+    settings()->setAttribute(QWebSettings::JavascriptEnabled,
+                             WebKitSettings::self()->isJavaScriptEnabled(hostname));
+
+    const WebKitSettings::KJSWindowOpenPolicy policy = WebKitSettings::self()->windowOpenPolicy(hostname);
+    settings()->setAttribute(QWebSettings::JavascriptCanOpenWindows,
+                             (policy != WebKitSettings::KJSWindowOpenDeny &&
+                              policy != WebKitSettings::KJSWindowOpenSmart));
+}
Index: part/websslinfo.cpp
===================================================================
--- part/websslinfo.cpp	(revision 0)
+++ part/websslinfo.cpp	(revision 1043437)
@@ -0,0 +1,211 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "websslinfo.h"
+
+#include <QtCore/QVariant>
+
+
+class WebSslInfo::WebSslInfoPrivate
+{
+public:
+  WebSslInfoPrivate()
+      : usedCipherBits(0), supportedCipherBits(0) {}
+
+  QUrl url;
+  QString ciphers;
+  QString protocol;
+  QString certErrors;
+  QHostAddress peerAddress;
+  QHostAddress parentAddress;
+  QList<QSslCertificate> certificateChain;
+
+  int usedCipherBits;
+  int supportedCipherBits;
+};
+
+WebSslInfo::WebSslInfo()
+           :d(new WebSslInfo::WebSslInfoPrivate)
+{
+}
+
+WebSslInfo::WebSslInfo(const WebSslInfo& other)
+           :d(new WebSslInfo::WebSslInfoPrivate)
+{
+  *this = other;
+}
+
+WebSslInfo::~WebSslInfo()
+{
+  delete d;
+  d = 0;
+}
+
+bool WebSslInfo::isValid() const
+{
+  return !d->peerAddress.isNull();
+}
+
+QUrl WebSslInfo::url() const
+{
+  return d->url;
+}
+
+QHostAddress WebSslInfo::parentAddress() const
+{
+  return d->parentAddress;
+}
+
+QHostAddress WebSslInfo::peerAddress() const
+{
+  return d->peerAddress;
+}
+
+QString WebSslInfo::protocol() const
+{
+  return d->protocol;
+}
+
+QString WebSslInfo::ciphers() const
+{
+  return d->ciphers;
+}
+
+QString WebSslInfo::certificateErrors() const
+{
+  return d->certErrors;
+}
+
+int WebSslInfo::supportedChiperBits () const
+{
+  return d->supportedCipherBits;
+}
+
+int WebSslInfo::usedChiperBits () const
+{
+  return d->usedCipherBits;
+}
+
+QList<QSslCertificate> WebSslInfo::certificateChain() const
+{
+  return d->certificateChain;
+}
+
+WebSslInfo& WebSslInfo::operator=(const WebSslInfo& other)
+{
+  d->ciphers = other.d->ciphers;
+  d->protocol = other.d->protocol;
+  d->certErrors = other.d->certErrors;
+  d->peerAddress = other.d->peerAddress;
+  d->parentAddress = other.d->parentAddress;
+  d->certificateChain = other.d->certificateChain;
+
+  d->usedCipherBits = other.d->usedCipherBits;
+  d->supportedCipherBits = other.d->supportedCipherBits;
+  d->url = other.d->url;
+
+  return *this;
+}
+
+QVariant WebSslInfo::toMetaData() const
+{
+  if (isValid()) {
+    QMap<QString, QVariant> data;
+    data.insert("ssl_in_use", true);
+    data.insert("ssl_peer_ip", d->peerAddress.toString());
+    data.insert("ssl_parent_ip", d->parentAddress.toString());
+    data.insert("ssl_protocol_version", d->protocol);
+    data.insert("ssl_cipher", d->ciphers);
+    data.insert("ssl_cert_errors", d->certErrors);
+    data.insert("ssl_cipher_used_bits", d->usedCipherBits);
+    data.insert("ssl_cipher_bits", d->supportedCipherBits);
+    QByteArray certChain;
+    Q_FOREACH(const QSslCertificate& cert, d->certificateChain)
+        certChain += cert.toPem();
+    data.insert("ssl_peer_chain", certChain);
+    return data;
+  }
+
+  return QVariant();
+}
+
+void WebSslInfo::fromMetaData(const QVariant& value)
+{
+  if (value.isValid() && value.type() == QVariant::Map) {
+    QMap<QString,QVariant> metaData = value.toMap();
+    if (metaData.value("ssl_in_use", false).toBool()) {
+        setCertificateChain(metaData.value("ssl_peer_chain").toByteArray());
+        setPeerAddress(metaData.value("ssl_peer_ip").toString());
+        setParentAddress(metaData.value("ssl_parent_ip").toString());
+        setProtocol(metaData.value("ssl_protocol_version").toString());
+        setCiphers(metaData.value("ssl_cipher").toString());
+        setCertificateErrors(metaData.value("ssl_cert_errors").toString());
+        setUsedCipherBits(metaData.value("ssl_cipher_used_bits").toString());
+        setSupportedCipherBits(metaData.value("ssl_cipher_bits").toString());
+    }
+  }
+}
+
+void WebSslInfo::setUrl (const QUrl &url)
+{
+  d->url = url;
+}
+
+void WebSslInfo::setPeerAddress(const QString& address)
+{
+  d->peerAddress = address;
+}
+
+void WebSslInfo::setParentAddress(const QString& address)
+{
+  d->parentAddress = address;
+}
+
+void WebSslInfo::setProtocol(const QString& protocol)
+{
+  d->protocol = protocol;
+}
+
+void WebSslInfo::setCertificateChain(const QByteArray& chain)
+{
+  d->certificateChain = QSslCertificate::fromData(chain);
+}
+
+void WebSslInfo::setCiphers(const QString& ciphers)
+{
+  d->ciphers = ciphers;
+}
+
+void WebSslInfo::setUsedCipherBits(const QString& bits)
+{
+  d->usedCipherBits = bits.toInt();
+}
+
+void WebSslInfo::setSupportedCipherBits(const QString& bits)
+{
+  d->supportedCipherBits = bits.toInt();
+}
+
+void WebSslInfo::setCertificateErrors(const QString& certErrors)
+{
+  d->certErrors = certErrors;
+}
Index: part/webkitpart.cpp
===================================================================
--- part/webkitpart.cpp	(revision 957817)
+++ part/webkitpart.cpp	(revision 1043437)
@@ -4,6 +4,7 @@
  * Copyright (C) 2007 Trolltech ASA
  * Copyright (C) 2008 - 2009 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Laurent Montel <montel@kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,119 +24,291 @@
  */
 
 #include "webkitpart.h"
+#include "webkitpart_ext.h"
 
 #include "webview.h"
 #include "webpage.h"
+#include "websslinfo.h"
 
+#include "sslinfodialog_p.h"
+
+#include <ui/searchbar.h>
+
 #include <KDE/KParts/GenericFactory>
 #include <KDE/KParts/Plugin>
 #include <KDE/KAboutData>
-#include <KDE/KUriFilterData>
-#include <KDE/KDesktopFile>
 #include <KDE/KConfigGroup>
 #include <KDE/KAction>
 #include <KDE/KActionCollection>
-#include <KDE/KRun>
-#include <KDE/KTemporaryFile>
-#include <KDE/KToolInvocation>
-#include <KDE/KIO/NetAccess>
-#include <KDE/KFileDialog>
+#include <KDE/KMessageBox>
+#include <KDE/KStandardDirs>
+#include <KDE/KIconLoader>
+#include <KDE/KGlobal>
+#include <KDE/KStringHandler>
+#include <kio/global.h>
 
-#include <QHttpRequestHeader>
-#include <QtWebKit/QWebHistory>
-#include <QtWebKit/QWebHitTestResult>
-#include <QClipboard>
-#include <QApplication>
-#include <QPlainTextEdit>
-#include <QVBoxLayout>
-#include <QPrintPreviewDialog>
+#include <QtCore/QUrl>
+#include <QtCore/QFile>
+#include <QtCore/QPair>
+#include <QtGui/QApplication>
+#include <QtGui/QPlainTextEdit>
+#include <QtGui/QVBoxLayout>
+#include <QtGui/QPrintPreviewDialog>
+#include <QtWebKit/QWebFrame>
+#include <QWebHistory>
 
+
+#define QL1(x)    QLatin1String(x)
+
+
+static QString htmlError (int code, const QString& text, const KUrl& reqUrl)
+{
+  // kDebug() << "errorCode" << code << "text" << text;
+
+  QString errorName, techName, description;
+  QStringList causes, solutions;
+
+  QByteArray raw = KIO::rawErrorDetail( code, text, &reqUrl );
+  QDataStream stream(raw);
+
+  stream >> errorName >> techName >> description >> causes >> solutions;
+
+  QString url, protocol, datetime;
+  url = Qt::escape( reqUrl.prettyUrl() );
+  protocol = reqUrl.protocol();
+  datetime = KGlobal::locale()->formatDateTime( QDateTime::currentDateTime(),
+                                                KLocale::LongDate );
+
+  QString filename( KStandardDirs::locate( "data", "khtml/error.html" ) );
+  QFile file( filename );
+  bool isOpened = file.open( QIODevice::ReadOnly );
+  if ( !isOpened )
+    kWarning() << "Could not open error html template:" << filename;
+
+  QString html = QString( QL1( file.readAll() ) );
+
+  html.replace( QL1( "TITLE" ), i18n( "Error: %1 - %2", errorName, url ) );
+  html.replace( QL1( "DIRECTION" ), QApplication::isRightToLeft() ? "rtl" : "ltr" );
+  html.replace( QL1( "ICON_PATH" ), KIconLoader::global()->iconPath( "dialog-warning", -KIconLoader::SizeHuge ) );
+
+  QString doc = QL1( "<h1>" );
+  doc += i18n( "The requested operation could not be completed" );
+  doc += QL1( "</h1><h2>" );
+  doc += errorName;
+  doc += QL1( "</h2>" );
+
+  if ( !techName.isNull() ) {
+    doc += QL1( "<h2>" );
+    doc += i18n( "Technical Reason: " );
+    doc += techName;
+    doc += QL1( "</h2>" );
+  }
+
+  doc += QL1( "<h3>" );
+  doc += i18n( "Details of the Request:" );
+  doc += QL1( "</h3><ul><li>" );
+  doc += i18n( "URL: %1" ,  url );
+  doc += QL1( "</li><li>" );
+
+  if ( !protocol.isNull() ) {
+    doc += i18n( "Protocol: %1", protocol );
+    doc += QL1( "</li><li>" );
+  }
+
+  doc += i18n( "Date and Time: %1" ,  datetime );
+  doc += QL1( "</li><li>" );
+  doc += i18n( "Additional Information: %1" ,  text );
+  doc += QL1( "</li></ul><h3>" );
+  doc += i18n( "Description:" );
+  doc += QL1( "</h3><p>" );
+  doc += description;
+  doc += QL1( "</p>" );
+
+  if ( causes.count() ) {
+    doc += QL1( "<h3>" );
+    doc += i18n( "Possible Causes:" );
+    doc += QL1( "</h3><ul><li>" );
+    doc += causes.join( "</li><li>" );
+    doc += QL1( "</li></ul>" );
+  }
+
+  if ( solutions.count() ) {
+    doc += QL1( "<h3>" );
+    doc += i18n( "Possible Solutions:" );
+    doc += QL1( "</h3><ul><li>" );
+    doc += solutions.join( "</li><li>" );
+    doc += QL1( "</li></ul>" );
+  }
+
+  html.replace( QL1("TEXT"), doc );
+
+  return html;
+}
+
+
+class WebKitPart::WebKitPartPrivate
+{
+public:
+  enum PageSecurity { Unencrypted, Encrypted, Mixed };
+  WebKitPartPrivate() : updateHistory(true) {}
+
+  bool updateHistory;
+
+  QPointer<WebView> webView;
+  QPointer<WebPage> webPage;
+  QPointer<KDEPrivate::SearchBar> searchBar;
+  WebKitBrowserExtension *browserExtension;
+};
+
 WebKitPart::WebKitPart(QWidget *parentWidget, QObject *parent, const QStringList &/*args*/)
-    : KParts::ReadOnlyPart(parent)
+           :KParts::ReadOnlyPart(parent), d(new WebKitPart::WebKitPartPrivate())
 {
     KAboutData about = KAboutData("webkitpart", "webkitkde", ki18n("WebKit HTML Component"),
-                           /*version*/ "0.1", /*ki18n("shortDescription")*/ KLocalizedString(),
-                           KAboutData::License_LGPL,
-                           ki18n("(c) 2008 - 2009, Urs Wolfer\n"
-                                 "(c) 2007 Trolltech ASA"));
+                                  /*version*/ "0.2", /*ki18n("shortDescription")*/ KLocalizedString(),
+                                  KAboutData::License_LGPL,
+                                  ki18n("(c) 2009 Dawit Alemayehu\n"
+                                        "(c) 2008-2009 Urs Wolfer\n"
+                                        "(c) 2007 Trolltech ASA"));
 
     about.addAuthor(ki18n("Laurent Montel"), KLocalizedString(), "montel@kde.org");
     about.addAuthor(ki18n("Michael Howell"), KLocalizedString(), "mhowell123@gmail.com");
     about.addAuthor(ki18n("Urs Wolfer"), KLocalizedString(), "uwolfer@kde.org");
     about.addAuthor(ki18n("Dirk Mueller"), KLocalizedString(), "mueller@kde.org");
+    about.addAuthor(ki18n("Dawit Alemayehu"), KLocalizedString(), "adawit@kde.org");
     KComponentData componentData(&about);
     setComponentData(componentData);
 
-    setWidget(new QWidget(parentWidget));
-    QVBoxLayout* lay = new QVBoxLayout(widget());
+    // NOTE: If the application does not set its version number, we automatically
+    // set it to KDE's version number so that the default user-agent string contains
+    // proper application version number information. See QWebPage::userAgentForUrl...
+    if (QCoreApplication::applicationVersion().isEmpty())
+        QCoreApplication::setApplicationVersion(QString("%1.%2.%3")
+                                                .arg(KDE::versionMajor())
+                                                .arg(KDE::versionMinor())
+                                                .arg(KDE::versionRelease()));
+
+    QWidget *mainWidget = new QWidget (parentWidget);
+    mainWidget->setObjectName("webkitpart");
+    setWidget(mainWidget);
+
+    QVBoxLayout* lay = new QVBoxLayout(mainWidget);
     lay->setMargin(0);
     lay->setSpacing(0);
-    m_webView = new WebView(this, widget());
-    lay->addWidget(m_webView);
-    lay->addWidget(m_webView->searchBar());
 
-    connect(m_webView, SIGNAL(loadStarted()),
-            this, SLOT(loadStarted()));
-    connect(m_webView, SIGNAL(loadFinished(bool)),
-            this, SLOT(loadFinished()));
-    connect(m_webView, SIGNAL(titleChanged(const QString &)),
+    // Add the WebView...
+    d->webView = new WebView (this, mainWidget); 
+    lay->addWidget(d->webView);
+    connect(d->webView, SIGNAL(titleChanged(const QString &)),
             this, SIGNAL(setWindowCaption(const QString &)));
+    connect(d->webView, SIGNAL(loadFinished(bool)),
+            this, SLOT(loadFinished(bool)));
+    connect(d->webView, SIGNAL(urlChanged(const QUrl &)),
+            this, SLOT(urlChanged(const QUrl &)));
 
-    connect(m_webView->page(), SIGNAL(linkHovered(const QString &, const QString &, const QString &)),
-            this, SIGNAL(setStatusBarText(const QString &)));
+    // Add the search bar...
+    d->searchBar = new KDEPrivate::SearchBar;
+    lay->addWidget(d->searchBar);
+    connect(d->searchBar, SIGNAL(searchTextChanged(const QString &, bool)),
+            this, SLOT(searchForText(const QString &, bool)));
 
-    m_browserExtension = new WebKitBrowserExtension(this);
+    d->webPage = qobject_cast<WebPage*>(d->webView->page());
+    Q_ASSERT(d->webPage);
 
-    connect(m_webView->page(), SIGNAL(loadProgress(int)),
-            m_browserExtension, SIGNAL(loadingProgress(int)));
-    connect(m_webView, SIGNAL(urlChanged(const QUrl &)),
-            this, SLOT(urlChanged(const QUrl &)));
+    connect(d->webPage, SIGNAL(loadStarted()),
+            this, SLOT(loadStarted()));
+    connect(d->webPage, SIGNAL(loadAborted(const QUrl &)),
+            this, SLOT(loadAborted(const QUrl &)));
+    connect(d->webPage, SIGNAL(loadError(int, const QString &, const QString &)),
+            this, SLOT(loadError(int, const QString &, const QString &)));
+    connect(d->webPage, SIGNAL(linkHovered(const QString &, const QString &, const QString &)),
+            this, SLOT(linkHovered(const QString &, const QString&, const QString &)));
+    connect(d->webPage, SIGNAL(updateHistory()), this, SLOT(updateHistory()));
+    connect(d->webPage, SIGNAL(navigationRequestFinished()),
+            this, SLOT(navigationRequestFinished()));
 
-    initAction();
+    d->browserExtension = new WebKitBrowserExtension(this);
+    connect(d->webPage, SIGNAL(loadProgress(int)),
+            d->browserExtension, SIGNAL(loadingProgress(int)));
+    connect(d->webPage, SIGNAL(selectionChanged()),
+            d->browserExtension, SLOT(updateEditActions()));
+    connect(d->browserExtension, SIGNAL(saveUrl(const KUrl&)),
+            d->webPage, SLOT(saveUrl(const KUrl &)));
 
+    connect(d->webView, SIGNAL(openUrl(const KUrl &)),
+            d->browserExtension, SIGNAL(openUrlRequest(const KUrl &)));
+    connect(d->webView, SIGNAL(openUrlInNewWindow(const KUrl &)),
+            d->browserExtension, SIGNAL(createNewWindow(const KUrl &)));
+
     setXMLFile("webkitpart.rc");
+    initAction();
+    mainWidget->setFocusProxy(d->webView);
 }
 
 WebKitPart::~WebKitPart()
 {
+    delete d;
 }
 
 void WebKitPart::initAction()
 {
     KAction *action = actionCollection()->addAction(KStandardAction::SaveAs, "saveDocument",
-                                                    m_browserExtension, SLOT(slotSaveDocument()));
+                                                    d->browserExtension, SLOT(slotSaveDocument()));
 
     action = new KAction(i18n("Save &Frame As..."), this);
     actionCollection()->addAction("saveFrame", action);
-    connect(action, SIGNAL(triggered(bool)), m_browserExtension, SLOT(slotSaveFrame()));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(slotSaveFrame()));
 
     action = new KAction(KIcon("document-print-frame"), i18n("Print Frame..."), this);
     actionCollection()->addAction("printFrame", action);
-    connect(action, SIGNAL(triggered(bool)), m_browserExtension, SLOT(printFrame()));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(printFrame()));
 
-    action = new KAction(KIcon("format-font-size-more"), i18n("Enlarge Font"), this);
-    actionCollection()->addAction("incFontSizes", action);
+    action = new KAction(KIcon("zoom-in"), i18n("Zoom In"), this);
+    actionCollection()->addAction("zoomIn", action);
     action->setShortcut(KShortcut("CTRL++; CTRL+="));
-    connect(action, SIGNAL(triggered(bool)), m_browserExtension, SLOT(zoomIn()));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(zoomIn()));
 
-    action = new KAction(KIcon("format-font-size-less"), i18n("Shrink Font"), this);
-    actionCollection()->addAction("decFontSizes", action);
-    action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_Minus));
-    connect(action, SIGNAL(triggered(bool)), m_browserExtension, SLOT(zoomOut()));
+    action = new KAction(KIcon("zoom-out"), i18n("Zoom Out"), this);
+    actionCollection()->addAction("zoomOut", action);
+    action->setShortcut(KShortcut("CTRL+-; CTRL+_"));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(zoomOut()));
 
+    action = new KAction(KIcon("zoom-original"), i18n("Actual Size"), this);
+    actionCollection()->addAction("zoomNormal", action);
+    action->setShortcut(KShortcut("CTRL+0"));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(zoomNormal()));
+
+#if QT_VERSION >= 0x040500
+    action = new KAction(i18n("Zoom Text Only"), this);
+    action->setCheckable(true);
+    KConfigGroup cgHtml(KGlobal::config(), "HTML Settings");
+    bool zoomTextOnly = cgHtml.readEntry("ZoomTextOnly", false);
+    action->setChecked(zoomTextOnly);
+    actionCollection()->addAction("zoomTextOnly", action);
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(toogleZoomTextOnly()));
+#endif
+
     action = actionCollection()->addAction(KStandardAction::SelectAll, "selectAll",
-                                           m_browserExtension, SLOT(slotSelectAll()));
+                                           d->browserExtension, SLOT(slotSelectAll()));
     action->setShortcutContext(Qt::WidgetShortcut);
-    m_webView->addAction(action);
+    d->webView->addAction(action);
 
     action = new KAction(i18n("View Do&cument Source"), this);
     actionCollection()->addAction("viewDocumentSource", action);
     action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_U));
-    connect(action, SIGNAL(triggered(bool)), m_browserExtension, SLOT(slotViewDocumentSource()));
+    connect(action, SIGNAL(triggered(bool)), d->browserExtension, SLOT(slotViewDocumentSource()));
 
-    action = actionCollection()->addAction(KStandardAction::Find, "find", m_webView->searchBar(), SLOT(show()));
+    action = new KAction(i18n("SSL"), this);
+    actionCollection()->addAction("security", action);
+    connect(action, SIGNAL(triggered(bool)), this, SLOT(showSecurity()));
+
+    action = actionCollection()->addAction(KStandardAction::Find, "find", this, SLOT(showSearchBar()));
     action->setWhatsThis(i18n("Find text<br /><br />"
                               "Shows a dialog that allows you to find text on the displayed page."));
+
+    action = actionCollection()->addAction(KStandardAction::FindNext, "findnext",
+                                           d->searchBar, SLOT(findNext()));
+    action = actionCollection()->addAction(KStandardAction::FindPrev, "findprev",
+                                           d->searchBar, SLOT(findPrevious()));
 }
 
 void WebKitPart::guiActivateEvent(KParts::GUIActivateEvent *event)
@@ -146,22 +319,123 @@
 
 bool WebKitPart::openUrl(const KUrl &url)
 {
+    kDebug() << url;
+
+    // Ignore empty requests...
+    if (url.isEmpty())
+        return false;
+
+    // Do not update history when url is typed in since konqueror
+    // automatically does that itself.
+    d->updateHistory = false;
+
+    if ( url.protocol() == "error" && url.hasSubUrl() ) {
+        closeUrl();
+
+        /**
+         * The format of the error url is that two variables are passed in the query:
+         * error = int kio error code, errText = QString error text from kio
+         * and the URL where the error happened is passed as a sub URL.
+         */
+        KUrl::List urls = KUrl::split( url );
+        //kDebug() << "Handling error URL. URL count:" << urls.count();
+
+        if ( urls.count() > 1 ) {
+            KUrl mainURL = urls.first();
+            int error = mainURL.queryItem( "error" ).toInt();
+
+            // error=0 isn't a valid error code, so 0 means it's missing from the URL
+            if ( error == 0 )
+                error = KIO::ERR_UNKNOWN;
+
+            if (error == KIO::ERR_USER_CANCELED) {
+                setUrl(d->webView->url());
+                emit d->browserExtension->setLocationBarUrl(KUrl(d->webView->url()).prettyUrl());
+            } else {
+                QString errorText = mainURL.queryItem( "errText" );
+                urls.pop_front();
+                KUrl reqUrl = KUrl::join( urls );
+
+                //kDebug() << "Setting Url back to => " << reqUrl;
+                emit d->browserExtension->setLocationBarUrl(reqUrl.prettyUrl());
+                setUrl(reqUrl);
+
+                emit started(0);
+                showError(htmlError(error, errorText, reqUrl));
+                emit completed();
+            }
+
+            return true;
+        }
+    }
+
+
     setUrl(url);
 
-    m_webView->load(url, arguments(), browserExtension()->browserArguments());
+    if (url.url() == "about:blank") {
+        emit setWindowCaption (url.url());
+    } else {
+        KParts::OpenUrlArguments args (arguments());
+        KIO::MetaData metaData (args.metaData());
 
+        // Get any SSL information already present. This is necessary
+        // because Konqueror always does a lookup on a url to determine
+        // mime-type so that it can embed the proper part. If a site was
+        // SSL protected, the SSL information can be lost unless we set
+        // it here...
+        if (metaData.contains("ssl_in_use")) {
+            WebSslInfo sslinfo;
+            sslinfo.fromMetaData(metaData.toVariant());
+            sslinfo.setUrl(url);
+            d->webPage->setSslInfo(sslinfo);
+        }
+
+        // Check if the request originated from history navigation and
+        // attempt to sync between Konqueror's and QtWebKit's history.
+        // If syncing fails for any reason, fallback to opening the
+        // url as if it is a new request...
+        if (metaData.contains("restore-state")) {
+            QWebHistory *history = d->webPage->history();
+            if (history && history->count()) {
+                QListIterator<QWebHistoryItem> historyIt (history->backItems(history->count()));
+                historyIt.toBack(); // Search backwards (LIFO)...
+                while (historyIt.hasPrevious()) {
+                    QWebHistoryItem item (historyIt.previous());
+                    if (url == item.originalUrl()) {
+                        //kDebug() << "History back => " << url;
+                        history->goToItem(item);
+                        return true;
+                    }
+                }
+
+                // Look in the forward items list next.
+                historyIt = history->forwardItems(history->count());
+                while (historyIt.hasNext()) {
+                    QWebHistoryItem item (historyIt.next());
+                    if (url == item.originalUrl()) {
+                      //kDebug() << "History forward => " << url;
+                      history->goToItem(item);
+                      return true;
+                    }
+                }
+            }
+        }
+
+        d->webView->loadUrl(url, args, browserExtension()->browserArguments());
+    }
+
     return true;
 }
 
 bool WebKitPart::closeUrl()
 {
-    m_webView->stop();
+    d->webView->stop();
     return true;
 }
 
-WebKitBrowserExtension *WebKitPart::browserExtension() const
+KParts::BrowserExtension *WebKitPart::browserExtension() const
 {
-    return m_browserExtension;
+    return d->browserExtension;
 }
 
 bool WebKitPart::openFile()
@@ -172,258 +446,216 @@
 
 void WebKitPart::loadStarted()
 {
+    d->updateHistory = false;
     emit started(0);
 }
 
-void WebKitPart::loadFinished()
+void WebKitPart::loadFinished(bool ok)
 {
-    emit completed();
-}
+    d->updateHistory = true;
 
-void WebKitPart::urlChanged(const QUrl &url)
-{
-    const QList<QWebHistoryItem> backItemsList = view()->history()->backItems(2);
-#ifndef NDEBUG
-    if (backItemsList.count() > 0) {
-        kDebug() << backItemsList.at(0).url() << url;
-    }
-#endif
+    if (ok && d->webView->title().trimmed().isEmpty()) {
+        // If the document title is null, then set it to the current url
+        // squeezed at the center.
+        QString caption (d->webView->url().toString((QUrl::RemoveQuery|QUrl::RemoveFragment)));
+        emit setWindowCaption(KStringHandler::csqueeze(caption));
 
-    if (!(backItemsList.count() > 0 && backItemsList.at(0).url() == url)) {
-        emit m_browserExtension->openUrlNotify();
+        // The urlChanged signal is emitted if and only if the main frame
+        // receives the title of the page so we manually invoke the slot as
+        // a work around here for pages that do not contain it, such as
+        // text documents...
+        urlChanged(d->webView->url());
     }
 
-    setUrl(url);
-    emit m_browserExtension->setLocationBarUrl(KUrl(url).prettyUrl());
-}
+    /*
+      NOTE #1: QtWebKit will not kill a META redirect request even if one
+      triggers the WebPage::Stop action!! As such the code below is useless
+      and disabled for now.
 
-WebView * WebKitPart::view()
-{
-    return m_webView;
+      NOTE #2: QWebFrame::metaData only provides access to META tags that
+      contain a 'name' attribute and completely ignores those that do not.
+      This of course includes yes the meta redirect tag, i.e. the 'http-equiv'
+      attribute. Hence the convoluted code below just to check if we have a
+      redirect request!
+    */
+#if 0
+    bool refresh = false;
+    QMapIterator<QString,QString> it (d->webView->page()->mainFrame()->metaData());
+    while (it.hasNext()) {
+      it.next();
+      //kDebug() << "meta-key: " << it.key() << "meta-value: " << it.value();
+      // HACK: QtWebKit does not parse the value of http-equiv property and
+      // as such uses an empty key with a value when
+      if (it.key().isEmpty() &&
+          it.value().toLower().simplified().contains(QRegExp("[0-9];url"))) {
+        refresh = true;
+        break;
+      }
+    }
+    emit completed(refresh);
+#else
+    emit completed();
+#endif
 }
 
-void WebKitPart::setStatusBarTextProxy(const QString &message)
-{
-    emit setStatusBarText(message);
+void WebKitPart::loadAborted(const QUrl & url)
+{  
+    closeUrl();
+    if (url.isValid())
+      emit d->browserExtension->openUrlRequest(url);
+    else
+      setUrl(d->webView->url());
 }
 
-
-WebKitBrowserExtension::WebKitBrowserExtension(WebKitPart *parent)
-    : KParts::BrowserExtension(parent), part(parent)
+void WebKitPart::loadError(int errCode, const QString &errStr, const QString &frameName)
 {
-    connect(part->view()->page(), SIGNAL(selectionChanged()),
-            this, SLOT(updateEditActions()));
-    connect(part->view(), SIGNAL(openUrl(const KUrl &)), this, SIGNAL(openUrlRequest(const KUrl &)));
-    connect(part->view(), SIGNAL(openUrlInNewTab(const KUrl &)), this, SIGNAL(createNewWindow(const KUrl &)));
-
-    enableAction("cut", false);
-    enableAction("copy", false);
-    enableAction("paste", false);
-    enableAction("print", true);
+    showError(htmlError(errCode, errStr, url()), frameName);
 }
 
-void WebKitBrowserExtension::cut()
+void  WebKitPart::navigationRequestFinished()
 {
-    part->view()->page()->triggerAction(KWebPage::Cut);
+    if (d->webPage->sslInfo().isValid())
+      d->browserExtension->setPageSecurity(WebKitPart::WebKitPartPrivate::Encrypted);
+    else
+      d->browserExtension->setPageSecurity(WebKitPart::WebKitPartPrivate::Unencrypted);
 }
 
-void WebKitBrowserExtension::copy()
-{
-    part->view()->page()->triggerAction(KWebPage::Copy);
+void WebKitPart::urlChanged(const QUrl& _url)
+{  
+    setUrl(_url);
+    emit d->browserExtension->setLocationBarUrl(KUrl(_url).prettyUrl());
 }
 
-void WebKitBrowserExtension::paste()
+void WebKitPart::showSecurity()
 {
-    part->view()->page()->triggerAction(KWebPage::Paste);
-}
+    if (d->webPage->sslInfo().isValid()) {
+        KSslInfoDialog *dlg = new KSslInfoDialog;
+        dlg->setSslInfo(d->webPage->sslInfo().certificateChain(),
+                        d->webPage->sslInfo().peerAddress().toString(),
+                        url().host(),
+                        d->webPage->sslInfo().protocol(),
+                        d->webPage->sslInfo().ciphers(),
+                        d->webPage->sslInfo().usedChiperBits(),
+                        d->webPage->sslInfo().supportedChiperBits(),
+                        KSslInfoDialog::errorsFromString(d->webPage->sslInfo().certificateErrors()));
 
-void WebKitBrowserExtension::slotSaveDocument()
-{
-    qobject_cast<WebPage*>(part->view()->page())->saveUrl(part->view()->url());
+        dlg->exec();
+    } else {
+        KMessageBox::information(0, i18n("The SSL information for this site "
+                                         "appears to be corrupt."), i18n("SSL"));
+    }
 }
 
-void WebKitBrowserExtension::slotSaveFrame()
-{
-    qobject_cast<WebPage*>(part->view()->page())->saveUrl(part->view()->page()->currentFrame()->url());
+void WebKitPart::updateHistory()
+{  
+    kDebug() << d->updateHistory;
+    if (d->updateHistory) {
+        emit d->browserExtension->openUrlNotify();
+    }
 }
 
-void WebKitBrowserExtension::print()
+QWebView * WebKitPart::view()
 {
-    QPrintPreviewDialog dlg(part->view());
-    connect(&dlg, SIGNAL(paintRequested(QPrinter *)),
-            part->view(), SLOT(print(QPrinter *)));
-    dlg.exec();
+    return d->webView;
 }
 
-void WebKitBrowserExtension::printFrame()
+void WebKitPart::setStatusBarTextProxy(const QString &message)
 {
-    QPrintPreviewDialog dlg(part->view());
-    connect(&dlg, SIGNAL(paintRequested(QPrinter *)),
-            part->view()->page()->currentFrame(), SLOT(print(QPrinter *)));
-    dlg.exec();
+    //kDebug() << message;
+    emit setStatusBarText(message);
 }
 
-void WebKitBrowserExtension::updateEditActions()
+void WebKitPart::linkHovered(const QString &link, const QString &, const QString &)
 {
-    KWebPage *page = part->view()->page();
-    enableAction("cut", page->action(KWebPage::Cut));
-    enableAction("copy", page->action(KWebPage::Copy));
-    enableAction("paste", page->action(KWebPage::Paste));
-}
+    QString message;
+    QUrl linkUrl (link);
+    const QString scheme = linkUrl.scheme();
 
-void WebKitBrowserExtension::searchProvider()
-{
-    // action name is of form "previewProvider[<searchproviderprefix>:]"
-    const QString searchProviderPrefix = QString(sender()->objectName()).mid(14);
+    if (QString::compare(scheme, QL1("mailto"), Qt::CaseInsensitive) == 0) {
+        message += i18n("Email: ");
 
-    const QString text = part->view()->page()->selectedText();
-    KUriFilterData data;
-    QStringList list;
-    data.setData(searchProviderPrefix + text);
-    list << "kurisearchfilter" << "kuriikwsfilter";
+        // Workaround: for QUrl's parsing deficiencies of "mailto:foo@bar.com".
+        if (!linkUrl.hasQuery())
+          linkUrl = QUrl(scheme + '?' + linkUrl.path());
 
-    if (!KUriFilter::self()->filterUri(data, list)) {
-        KDesktopFile file("services", "searchproviders/google.desktop");
-        const QString encodedSearchTerm = QUrl::toPercentEncoding(text);
-        KConfigGroup cg(file.desktopGroup());
-        data.setData(cg.readEntry("Query").replace("\\{@}", encodedSearchTerm));
-    }
+        QMap<QString, QStringList> fields;
+        QPair<QString, QString> queryItem;
 
-    KParts::BrowserArguments browserArgs;
-    browserArgs.frameName = "_blank";
+        Q_FOREACH (queryItem, linkUrl.queryItems()) {
+            //kDebug() << "query: " << queryItem.first << queryItem.second;
+            if (queryItem.first.contains(QChar('@')) && queryItem.second.isEmpty())
+                fields["to"] << queryItem.first;
+            if (QString::compare(queryItem.first, QL1("to"), Qt::CaseInsensitive) == 0)
+                fields["to"] << queryItem.second;
+            if (QString::compare(queryItem.first, QL1("cc"), Qt::CaseInsensitive) == 0)
+                fields["cc"] << queryItem.second;
+            if (QString::compare(queryItem.first, QL1("bcc"), Qt::CaseInsensitive) == 0)
+                fields["bcc"] << queryItem.second;
+            if (QString::compare(queryItem.first, QL1("subject"), Qt::CaseInsensitive) == 0)
+                fields["subject"] << queryItem.second;
+        }
 
-    emit openUrlRequest(data.uri(), KParts::OpenUrlArguments(), browserArgs);
-}
+        if (fields.contains(QL1("to")))
+            message += fields.value(QL1("to")).join(QL1(", "));
+        if (fields.contains(QL1("cc")))
+            message += QL1(" - CC: ") + fields.value(QL1("cc")).join(QL1(", "));
+        if (fields.contains(QL1("bcc")))
+            message += QL1(" - BCC: ") + fields.value(QL1("bcc")).join(QL1(", "));
+        if (fields.contains(QL1("subject")))
+            message += QL1(" - Subject: ") + fields.value(QL1("subject")).join(QL1(" "));
+    } else {
+        message = link;
+    }
 
-void WebKitBrowserExtension::zoomIn()
-{
-#if QT_VERSION < 0x040500
-    part->view()->setTextSizeMultiplier(part->view()->textSizeMultiplier() * 2);
-#else
-    part->view()->setZoomFactor(part->view()->zoomFactor() * 1.25);
-#endif
+    emit setStatusBarText(message);
 }
 
-void WebKitBrowserExtension::zoomOut()
+void WebKitPart::showError(const QString &html, const QString &frameName)
 {
-#if QT_VERSION < 0x040500
-    part->view()->setTextSizeMultiplier(part->view()->textSizeMultiplier() * 2);
-#else
-    part->view()->setZoomFactor(part->view()->zoomFactor() * 0.8);
-#endif
-}
+  QWebFrame *frame = 0;
 
-void WebKitBrowserExtension::slotSelectAll()
-{
-#if QT_VERSION >= 0x040500
-    part->view()->page()->triggerAction(KWebPage::SelectAll);
-#endif
-}
+  if (frameName.isEmpty()) {
+      frame = d->webView->page()->mainFrame();
+  } else {
+      QWebFrame *childFrame;
+      QListIterator<QWebFrame*> it (d->webView->page()->mainFrame()->childFrames());
+      while (it.hasNext()) {
+          childFrame = it.next();
+          if (childFrame->frameName() == frameName) {
+              frame = childFrame;
+              break;
+          }
+      }
+  }
 
-void WebKitBrowserExtension::slotFrameInWindow()
-{
-    KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
-    args.metaData()["referrer"] = part->view()->contextMenuResult().linkText();
-    args.metaData()["forcenewwindow"] = "true";
-    emit createNewWindow(part->view()->contextMenuResult().linkUrl(), args);
-}
+  Q_ASSERT (frame);
 
-void WebKitBrowserExtension::slotFrameInTab()
-{
-    KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
-    args.metaData()["referrer"] = part->view()->contextMenuResult().linkText();
-    KParts::BrowserArguments browserArgs;//( d->m_khtml->browserExtension()->browserArguments() );
-    browserArgs.setNewTab(true);
-    emit createNewWindow(part->view()->contextMenuResult().linkUrl(), args, browserArgs);
+  frame->setHtml(html);
 }
 
-void WebKitBrowserExtension::slotFrameInTop()
+void WebKitPart::searchForText(const QString &text, bool backward)
 {
-    KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
-    args.metaData()["referrer"] = part->view()->contextMenuResult().linkText();
-    KParts::BrowserArguments browserArgs;//( d->m_khtml->browserExtension()->browserArguments() );
-    browserArgs.frameName = "_top";
-    emit openUrlRequest(part->view()->contextMenuResult().linkUrl(), args, browserArgs);
-}
+    QWebPage::FindFlags flags;
 
-void WebKitBrowserExtension::slotSaveImageAs()
-{
-    QList<KUrl> urls;
-    urls.append(part->view()->contextMenuResult().imageUrl());
-    for (int i = 0; i != urls.count(); i++) {
-        QString file = KFileDialog::getSaveFileName(KUrl(), QString(), part->widget());
-        KIO::NetAccess::file_copy(urls.at(i), file, part->widget());
-    }
-}
+    if (backward)
+      flags = QWebPage::FindBackward;
 
-void WebKitBrowserExtension::slotSendImage()
-{
-    QStringList urls;
-    urls.append(part->view()->contextMenuResult().imageUrl().path());
-    const QString subject = part->view()->contextMenuResult().imageUrl().path();
-    KToolInvocation::invokeMailer(QString(), QString(), QString(), subject,
-                                  QString(), //body
-                                  QString(),
-                                  urls); // attachments
-}
+    if (d->searchBar->caseSensitive())
+        flags |= QWebPage::FindCaseSensitively;
 
-void WebKitBrowserExtension::slotCopyImage()
-{
-    KUrl safeURL(part->view()->contextMenuResult().imageUrl());
-    safeURL.setPass(QString());
-
-    // Set it in both the mouse selection and in the clipboard
-    QMimeData* mimeData = new QMimeData;
-    mimeData->setImageData(part->view()->contextMenuResult().pixmap());
-    safeURL.populateMimeData(mimeData);
-    QApplication::clipboard()->setMimeData(mimeData, QClipboard::Clipboard);
-
-    mimeData = new QMimeData;
-    mimeData->setImageData(part->view()->contextMenuResult().pixmap());
-    safeURL.populateMimeData(mimeData);
-    QApplication::clipboard()->setMimeData(mimeData, QClipboard::Selection);
+    d->searchBar->setFoundMatch(d->webView->page()->findText(text, flags));
 }
 
-void WebKitBrowserExtension::slotCopyLinkLocation()
+void WebKitPart::showSearchBar()
 {
-    KUrl safeURL(part->view()->contextMenuResult().linkUrl());
-    safeURL.setPass(QString());
-    // Set it in both the mouse selection and in the clipboard
-    QMimeData* mimeData = new QMimeData;
-    safeURL.populateMimeData(mimeData);
-    QApplication::clipboard()->setMimeData(mimeData, QClipboard::Clipboard);
+    const QString text = d->webView->selectedText();
+    
+    if (text.isEmpty())
+        d->webView->pageAction(QWebPage::Undo);
+    else
+        d->searchBar->setSearchText(text.left(150));
 
-    mimeData = new QMimeData;
-    safeURL.populateMimeData(mimeData);
-    QApplication::clipboard()->setMimeData(mimeData, QClipboard::Selection);
+    d->searchBar->show();
 }
 
-void WebKitBrowserExtension::slotSaveLinkAs()
-{
-    qobject_cast<WebPage*>(part->view()->page())->saveUrl(part->view()->contextMenuResult().linkUrl());
-}
-
-void WebKitBrowserExtension::slotViewDocumentSource()
-{
-    //TODO test http requests
-    KUrl currentUrl(part->view()->page()->mainFrame()->url());
-    bool isTempFile = false;
-#if 0
-    if (!(currentUrl.isLocalFile())/* && KHTMLPageCache::self()->isComplete(d->m_cacheId)*/) { //TODO implement
-        KTemporaryFile sourceFile;
-//         sourceFile.setSuffix(defaultExtension());
-        sourceFile.setAutoRemove(false);
-        if (sourceFile.open()) {
-//             QDataStream stream (&sourceFile);
-//             KHTMLPageCache::self()->saveData(d->m_cacheId, &stream);
-            currentUrl = KUrl();
-            currentUrl.setPath(sourceFile.fileName());
-            isTempFile = true;
-        }
-    }
-#endif
-
-    KRun::runUrl(currentUrl, QLatin1String("text/plain"), part->view(), isTempFile);
-}
-
 #include "webkitpart.moc"
Index: part/webview.h
===================================================================
--- part/webview.h	(revision 957817)
+++ part/webview.h	(revision 1043437)
@@ -4,6 +4,7 @@
  * Copyright (C) 2007 Trolltech ASA
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Laurent Montel <montel@kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -24,13 +25,14 @@
 #ifndef WEBVIEW_H
 #define WEBVIEW_H
 
-#include <kdewebkit/kwebview.h>
+#include "webkitkde_export.h"
 
 #include <KDE/KParts/ReadOnlyPart>
 #include <KDE/KParts/BrowserExtension>
 
-#include "webkitkde_export.h"
+#include <kdewebkit/kwebview.h>
 
+class KUrl;
 class WebKitPart;
 class QWebHitTestResult;
 
@@ -38,12 +40,31 @@
 {
     Q_OBJECT
 public:
-    WebView(WebKitPart *wpart, QWidget *parent);
-    ~WebView();
+    WebView(WebKitPart *part, QWidget *parent);
+    ~WebView();   
+
+    /**
+     * Same as QWebPage::load, but with KParts style arguments instead.
+     *
+     * @see KParts::OpenUrlArguments, KParts::BrowserArguments.
+     *
+     * @param url     the url to load.
+     * @param args    reference to a OpenUrlArguments object.
+     * @param bargs   reference to a BrowserArguments object.
+     */
+    void loadUrl(const KUrl &url, const KParts::OpenUrlArguments &args, const KParts::BrowserArguments &bargs);
+
     QWebHitTestResult contextMenuResult() const;
 
 protected:
-    void contextMenuEvent(QContextMenuEvent *e);
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWidget::contextMenuEvent
+     * @internal
+     */
+    virtual void contextMenuEvent(QContextMenuEvent *e);
+
     void selectActionPopupMenu(KParts::BrowserExtension::ActionGroupMap &selectGroupMap);
     void linkActionPopupMenu(KParts::BrowserExtension::ActionGroupMap &linkGroupMap);
     void partActionPopupMenu(KParts::BrowserExtension::ActionGroupMap &partGroupMap);
Index: part/settings/webkitdefaults.h
===================================================================
--- part/settings/webkitdefaults.h	(revision 0)
+++ part/settings/webkitdefaults.h	(revision 1043437)
@@ -0,0 +1,38 @@
+/* This file is part of the KDE project
+   Copyright (C) 1998, 1999 Torben Weis <weis@kde.org>
+   Copyright (C) 1999 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef WEBKITDEFAULTS_H
+#define WEBKITDEFAULTS_H
+
+// browser window color defaults -- Bernd
+#define HTML_DEFAULT_LNK_COLOR Qt::blue
+#define HTML_DEFAULT_TXT_COLOR Qt::black
+#define HTML_DEFAULT_VLNK_COLOR Qt::magenta
+#define HTML_DEFAULT_BASE_COLOR Qt::white
+
+#define HTML_DEFAULT_VIEW_FONT "Sans Serif"
+#define HTML_DEFAULT_VIEW_FIXED_FONT "Monospace"
+#define HTML_DEFAULT_VIEW_SERIF_FONT "Serif"
+#define HTML_DEFAULT_VIEW_SANSSERIF_FONT "Sans Serif"
+#define HTML_DEFAULT_VIEW_CURSIVE_FONT "Sans Serif"
+#define HTML_DEFAULT_VIEW_FANTASY_FONT "Sans Serif"
+#define HTML_DEFAULT_MIN_FONT_SIZE 7 // everything smaller is usually unreadable.
+
+#endif // WEBKITDEFAULTS_H

Property changes on: part/settings/webkitdefaults.h
___________________________________________________________________
Added: svn:mime-type
   + text/x-chdr
Added: svn:keywords
   + Author Date Id Revision
Added: svn:eol-style
   + native

Index: part/settings/khtml_filter.cpp
===================================================================
--- part/settings/khtml_filter.cpp	(revision 0)
+++ part/settings/khtml_filter.cpp	(revision 1043437)
@@ -0,0 +1,266 @@
+/* This file is part of the KDE project
+
+   Copyright (C) 2005 Ivor Hewitt     <ivor@kde.org>
+   Copyright (C) 2008 Maksim Orlovich <maksim@kde.org>
+   Copyright (C) 2008 Vyacheslav Tokarev <tsjoker@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "khtml_filter_p.h"
+#include <QDebug>
+
+// rolling hash parameters
+#define HASH_P (1997)
+#define HASH_Q (17509)
+// HASH_MOD = (HASH_P^7) % HASH_Q
+#define HASH_MOD (523)
+
+namespace khtml {
+
+void FilterSet::addFilter(const QString& filterStr)
+{
+    QString filter = filterStr;
+    
+    if (filter.startsWith(QLatin1Char('!')))
+        return;
+
+    // Strip leading @@
+    int first = 0;
+    int last  = filter.length() - 1;
+    if (filter.startsWith(QLatin1String("@@")))
+        first = 2;
+        
+    // Strip options, we ignore them for now.
+    int dollar = filter.lastIndexOf(QLatin1Char('$'));
+    if (dollar != -1)
+        last = dollar - 1;
+    
+    // Perhaps nothing left?
+    if (first > last)
+        return;
+        
+    filter = filter.mid(first, last - first + 1);
+    
+    // Is it a regexp filter?
+    if (filter.length()>2 && filter.startsWith(QLatin1Char('/')) && filter.endsWith(QLatin1Char('/')))
+    {
+        QString inside = filter.mid(1, filter.length()-2);
+        QRegExp rx(inside);
+        reFilters.append(rx);
+//         qDebug() << "R:" << inside;
+    }
+    else
+    {
+        // Nope, a wildcard one.
+        // Note: For these, we also need to handle |.
+        
+        // Strip wildcards at the ends
+        first = 0;
+        last  = filter.length() - 1;
+        
+        while (first < filter.length() && filter[first] == QLatin1Char('*'))
+            ++first;
+            
+        while (last >= 0 && filter[last] == QLatin1Char('*'))
+            --last;
+            
+        if (first > last)
+            filter = QLatin1String("*"); // erm... Well, they asked for it.
+        else
+            filter = filter.mid(first, last - first + 1);
+            
+        // Now, do we still have any wildcard stuff left?
+        if (filter.contains("*") || filter.contains("?")) 
+        {
+//             qDebug() << "W:" << filter;
+            // check if we can use RK first (and then check full RE for the rest) for better performance
+            int aPos = filter.indexOf('*');
+            if (aPos < 0)
+                aPos = filter.length();
+            int qPos = filter.indexOf('?');
+            if (qPos < 0)
+                qPos = filter.length();
+            int pos = qMin(aPos, qPos);
+            if (pos > 7) {
+                QRegExp rx;
+
+                rx.setPatternSyntax(QRegExp::Wildcard);
+                rx.setPattern(filter.mid(pos));
+
+                stringFiltersMatcher.addWildedString(filter.mid(0, pos), rx);
+
+            } else {
+                QRegExp rx;
+
+                rx.setPatternSyntax(QRegExp::Wildcard);
+                rx.setPattern(filter);
+                reFilters.append(rx);
+            }
+        }
+        else
+        {
+            // Fast path
+            stringFiltersMatcher.addString(filter);
+        }
+    }
+}
+
+bool FilterSet::isUrlMatched(const QString& url)
+{
+    if (stringFiltersMatcher.isMatched(url))
+        return true;
+
+    for (int c = 0; c < reFilters.size(); ++c)
+    {
+        if (url.contains(reFilters[c]))
+            return true;
+    }
+
+    return false;
+}
+
+void FilterSet::clear()
+{
+    reFilters.clear();
+    stringFiltersMatcher.clear();
+}
+
+
+void StringsMatcher::addString(const QString& pattern)
+{
+    if (pattern.length() < 8) {
+        // handle short string differently
+        shortStringFilters.append(pattern);
+    } else {
+        // use modified Rabin-Karp's algorithm with 8-length string hash
+        // i.e. store hash of first 8 chars in the HashMap for fast look-up
+        stringFilters.append(pattern);
+        int ind = stringFilters.size() - 1;
+        int current = 0;
+
+        // compute hash using rolling hash
+        // hash for string: x0,x1,x2...xn-1 will be:
+        // (p^(n-1)*x0 + p^(n-2)*x1 + ... + p * xn-2 + xn-1) % q
+        // where p and q some wisely-chosen integers
+        /*for (int k = 0; k < 8; ++k)*/
+        int len = pattern.length();
+        for (int k = len - 8; k < len; ++k)
+            current = (current * HASH_P + pattern[k].unicode()) % HASH_Q;
+
+        // insert computed hash value into HashMap
+        QHash<int, QVector<int> >::iterator it = stringFiltersHash.find(current + 1);
+        if (it == stringFiltersHash.end()) {
+            QVector<int> list;
+            list.append(ind);
+            stringFiltersHash.insert(current + 1, list);
+            fastLookUp.setBit(current);
+        } else {
+            it.value().append(ind);
+        }
+    }
+}
+
+void StringsMatcher::addWildedString(const QString& prefix, const QRegExp& rx)
+{
+    rePrefixes.append(prefix);
+    reFilters.append(rx);
+    int index = -rePrefixes.size();
+
+    int current = 0;
+    for (int k = 0; k < 8; ++k)
+        current = (current * HASH_P + prefix[k].unicode()) % HASH_Q;
+
+    // insert computed hash value into HashMap
+    QHash<int, QVector<int> >::iterator it = stringFiltersHash.find(current + 1);
+    if (it == stringFiltersHash.end()) {
+        QVector<int> list;
+        list.append(index);
+        stringFiltersHash.insert(current + 1, list);
+        fastLookUp.setBit(current);
+    } else {
+        it.value().append(index);
+    }
+}
+
+bool StringsMatcher::isMatched(const QString& str) const
+{
+    // check short strings first
+    for (int i = 0; i < shortStringFilters.size(); ++i) {
+        if (str.contains(shortStringFilters[i]))
+            return true;
+    }
+
+    int len = str.length();
+    int k;
+
+    int current = 0;
+    int next = 0;
+    // compute hash for first 8 characters
+    for (k = 0; k < 8 && k < len; ++k)
+        current = (current * HASH_P + str[k].unicode()) % HASH_Q;
+
+    QHash<int, QVector<int> >::const_iterator hashEnd = stringFiltersHash.end();
+    // main Rabin-Karp's algorithm loop
+    for (k = 7; k < len; ++k, current = next) {
+        // roll the hash if not at the end
+        // (calculate hash for the next iteration)
+        if (k + 1 < len)
+            next = (HASH_P * ((current + HASH_Q - ((HASH_MOD * str[k - 7].unicode()) % HASH_Q)) % HASH_Q) + str[k + 1].unicode()) % HASH_Q;
+
+        if (!fastLookUp.testBit(current))
+            continue;
+
+        // look-up the hash in the HashMap and check all strings
+        QHash<int, QVector<int> >::const_iterator it = stringFiltersHash.find(current + 1);
+
+        // check possible strings
+        if (it != hashEnd) {
+            for (int j = 0; j < it.value().size(); ++j) {
+                int index = it.value()[j];
+                // check if we got simple string or REs prefix
+                if (index >= 0) {
+                    int flen = stringFilters[index].length();
+                    if (k - flen + 1 >= 0 && stringFilters[index] == str.midRef(k - flen + 1 , flen))
+                        return true;
+                } else {
+                    index = -index - 1;
+                    int flen = rePrefixes[index].length();
+                    if (k - 8 + flen < len && rePrefixes[index] == str.midRef(k - 7, flen) &&
+                            str.indexOf(reFilters[index], k - 7 + flen) == k - 7 + flen)
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+void StringsMatcher::clear()
+{
+    stringFilters.clear();
+    shortStringFilters.clear();
+    reFilters.clear();
+    rePrefixes.clear();
+    stringFiltersHash.clear();
+    fastLookUp.resize(HASH_Q);
+    fastLookUp.fill(0, 0, HASH_Q);
+}
+
+}
+
+// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on;
Index: part/settings/webkitsettings.cpp
===================================================================
--- part/settings/webkitsettings.cpp	(revision 0)
+++ part/settings/webkitsettings.cpp	(revision 1043437)
@@ -0,0 +1,1129 @@
+/* This file is part of the KDE project
+   Copyright (C) 1999 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "webkitsettings.h"
+#include "webkitdefaults.h"
+
+#include "khtml_filter_p.h"
+
+#include <kconfig.h>
+#include <kconfiggroup.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+
+#include <QWebSettings>
+
+#include <QtGui/QFontDatabase>
+
+/**
+ * @internal
+ * Contains all settings which are both available globally and per-domain
+ */
+struct KPerDomainSettings {
+    bool m_bEnableJava : 1;
+    bool m_bEnableJavaScript : 1;
+    bool m_bEnablePlugins : 1;
+    // don't forget to maintain the bitfields as the enums grow
+    WebKitSettings::KJSWindowOpenPolicy m_windowOpenPolicy : 2;
+    WebKitSettings::KJSWindowStatusPolicy m_windowStatusPolicy : 1;
+    WebKitSettings::KJSWindowFocusPolicy m_windowFocusPolicy : 1;
+    WebKitSettings::KJSWindowMovePolicy m_windowMovePolicy : 1;
+    WebKitSettings::KJSWindowResizePolicy m_windowResizePolicy : 1;
+
+#ifdef DEBUG_SETTINGS
+    void dump(const QString &infix = QString()) const {
+      kDebug() << "KPerDomainSettings " << infix << " @" << this << ":";
+      kDebug() << "  m_bEnableJava: " << m_bEnableJava;
+      kDebug() << "  m_bEnableJavaScript: " << m_bEnableJavaScript;
+      kDebug() << "  m_bEnablePlugins: " << m_bEnablePlugins;
+      kDebug() << "  m_windowOpenPolicy: " << m_windowOpenPolicy;
+      kDebug() << "  m_windowStatusPolicy: " << m_windowStatusPolicy;
+      kDebug() << "  m_windowFocusPolicy: " << m_windowFocusPolicy;
+      kDebug() << "  m_windowMovePolicy: " << m_windowMovePolicy;
+      kDebug() << "  m_windowResizePolicy: " << m_windowResizePolicy;
+    }
+#endif
+};
+
+QString *WebKitSettings::avFamilies = 0;
+typedef QMap<QString,KPerDomainSettings> PolicyMap;
+
+class WebKitSettingsPrivate
+{
+public:
+    bool m_bChangeCursor : 1;
+    bool m_bOpenMiddleClick : 1;
+    bool m_bBackRightClick : 1;
+    bool m_underlineLink : 1;
+    bool m_hoverLink : 1;
+    bool m_bEnableJavaScriptDebug : 1;
+    bool m_bEnableJavaScriptErrorReporting : 1;
+    bool enforceCharset : 1;
+    bool m_bAutoLoadImages : 1;
+    bool m_bUnfinishedImageFrame : 1;
+    bool m_formCompletionEnabled : 1;
+    bool m_autoDelayedActionsEnabled : 1;
+    bool m_jsErrorsEnabled : 1;
+    bool m_follow_system_colors : 1;
+    bool m_allowTabulation : 1;
+    bool m_autoSpellCheck : 1;
+    bool m_adFilterEnabled : 1;
+    bool m_hideAdsEnabled : 1;
+    bool m_jsPopupBlockerPassivePopup : 1;
+    bool m_accessKeysEnabled : 1;
+    bool m_zoomTextOnly : 1;
+    bool m_useCookieJar : 1;
+
+    // the virtual global "domain"
+    KPerDomainSettings global;
+
+    int m_fontSize;
+    int m_minFontSize;
+    int m_maxFormCompletionItems;
+    WebKitSettings::KAnimationAdvice m_showAnimations;
+    WebKitSettings::KSmoothScrollingMode m_smoothScrolling;
+
+    QString m_encoding;
+    QString m_userSheet;
+
+    QColor m_textColor;
+    QColor m_baseColor;
+    QColor m_linkColor;
+    QColor m_vLinkColor;
+
+    PolicyMap domainPolicy;
+    QStringList fonts;
+    QStringList defaultFonts;
+
+    khtml::FilterSet adBlackList;
+    khtml::FilterSet adWhiteList;
+    QList< QPair< QString, QChar > > m_fallbackAccessKeysAssignments;
+};
+
+
+/** Returns a writeable per-domains settings instance for the given domain
+  * or a deep copy of the global settings if not existent.
+  */
+static KPerDomainSettings &setup_per_domain_policy(
+				WebKitSettingsPrivate* const d,
+				const QString &domain) {
+  if (domain.isEmpty()) {
+    kWarning() << "setup_per_domain_policy: domain is empty";
+  }
+  const QString ldomain = domain.toLower();
+  PolicyMap::iterator it = d->domainPolicy.find(ldomain);
+  if (it == d->domainPolicy.end()) {
+    // simply copy global domain settings (they should have been initialized
+    // by this time)
+    it = d->domainPolicy.insert(ldomain,d->global);
+  }
+  return *it;
+}
+
+
+WebKitSettings::KJavaScriptAdvice WebKitSettings::strToAdvice(const QString& _str)
+{
+  KJavaScriptAdvice ret = KJavaScriptDunno;
+
+  if (_str.isNull())
+        ret = KJavaScriptDunno;
+
+  if (_str.toLower() == QLatin1String("accept"))
+        ret = KJavaScriptAccept;
+  else if (_str.toLower() == QLatin1String("reject"))
+        ret = KJavaScriptReject;
+
+  return ret;
+}
+
+const char* WebKitSettings::adviceToStr(KJavaScriptAdvice _advice)
+{
+    switch( _advice ) {
+        case KJavaScriptAccept: return I18N_NOOP("Accept");
+        case KJavaScriptReject: return I18N_NOOP("Reject");
+        default: return 0;
+    }
+    return 0;
+}
+
+
+void WebKitSettings::splitDomainAdvice(const QString& configStr, QString &domain,
+                                      KJavaScriptAdvice &javaAdvice, KJavaScriptAdvice& javaScriptAdvice)
+{
+    QString tmp(configStr);
+    int splitIndex = tmp.indexOf(':');
+    if ( splitIndex == -1)
+    {
+        domain = configStr.toLower();
+        javaAdvice = KJavaScriptDunno;
+        javaScriptAdvice = KJavaScriptDunno;
+    }
+    else
+    {
+        domain = tmp.left(splitIndex).toLower();
+        QString adviceString = tmp.mid( splitIndex+1, tmp.length() );
+        int splitIndex2 = adviceString.indexOf( ':' );
+        if( splitIndex2 == -1 ) {
+            // Java advice only
+            javaAdvice = strToAdvice( adviceString );
+            javaScriptAdvice = KJavaScriptDunno;
+        } else {
+            // Java and JavaScript advice
+            javaAdvice = strToAdvice( adviceString.left( splitIndex2 ) );
+            javaScriptAdvice = strToAdvice( adviceString.mid( splitIndex2+1,
+                                                              adviceString.length() ) );
+        }
+    }
+}
+
+void WebKitSettings::readDomainSettings(const KConfigGroup &config, bool reset,
+                                        bool global, KPerDomainSettings &pd_settings)
+{
+  QString jsPrefix = global ? QString()
+  				: QString::fromLatin1("javascript.");
+  QString javaPrefix = global ? QString()
+  				: QString::fromLatin1("java.");
+  QString pluginsPrefix = global ? QString()
+  				: QString::fromLatin1("plugins.");
+
+  // The setting for Java
+  QString key = javaPrefix + QLatin1String("EnableJava");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_bEnableJava = config.readEntry( key, false );
+  else if ( !global )
+    pd_settings.m_bEnableJava = d->global.m_bEnableJava;
+
+  // The setting for Plugins
+  key = pluginsPrefix + QLatin1String("EnablePlugins");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_bEnablePlugins = config.readEntry( key, true );
+  else if ( !global )
+    pd_settings.m_bEnablePlugins = d->global.m_bEnablePlugins;
+
+  // The setting for JavaScript
+  key = jsPrefix + QLatin1String("EnableJavaScript");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_bEnableJavaScript = config.readEntry( key, true );
+  else if ( !global )
+    pd_settings.m_bEnableJavaScript = d->global.m_bEnableJavaScript;
+
+  // window property policies
+  key = jsPrefix + QLatin1String("WindowOpenPolicy");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_windowOpenPolicy = (KJSWindowOpenPolicy)
+    		config.readEntry( key, uint(KJSWindowOpenSmart) );
+  else if ( !global )
+    pd_settings.m_windowOpenPolicy = d->global.m_windowOpenPolicy;
+
+  key = jsPrefix + QLatin1String("WindowMovePolicy");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_windowMovePolicy = (KJSWindowMovePolicy)
+    		config.readEntry( key, uint(KJSWindowMoveAllow) );
+  else if ( !global )
+    pd_settings.m_windowMovePolicy = d->global.m_windowMovePolicy;
+
+  key = jsPrefix + QLatin1String("WindowResizePolicy");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_windowResizePolicy = (KJSWindowResizePolicy)
+    		config.readEntry( key, uint(KJSWindowResizeAllow) );
+  else if ( !global )
+    pd_settings.m_windowResizePolicy = d->global.m_windowResizePolicy;
+
+  key = jsPrefix + QLatin1String("WindowStatusPolicy");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_windowStatusPolicy = (KJSWindowStatusPolicy)
+    		config.readEntry( key, uint(KJSWindowStatusAllow) );
+  else if ( !global )
+    pd_settings.m_windowStatusPolicy = d->global.m_windowStatusPolicy;
+
+  key = jsPrefix + QLatin1String("WindowFocusPolicy");
+  if ( (global && reset) || config.hasKey( key ) )
+    pd_settings.m_windowFocusPolicy = (KJSWindowFocusPolicy)
+    		config.readEntry( key, uint(KJSWindowFocusAllow) );
+  else if ( !global )
+    pd_settings.m_windowFocusPolicy = d->global.m_windowFocusPolicy;
+
+}
+
+
+WebKitSettings::WebKitSettings()
+	:d (new WebKitSettingsPrivate())
+{
+  init();
+}
+
+WebKitSettings::WebKitSettings(const WebKitSettings &other)
+	:d(new WebKitSettingsPrivate())
+{
+  *d = *other.d;
+}
+
+WebKitSettings::~WebKitSettings()
+{
+  delete d;
+}
+
+bool WebKitSettings::changeCursor() const
+{
+  return d->m_bChangeCursor;
+}
+
+bool WebKitSettings::underlineLink() const
+{
+  return d->m_underlineLink;
+}
+
+bool WebKitSettings::hoverLink() const
+{
+  return d->m_hoverLink;
+}
+
+void WebKitSettings::init()
+{
+  KConfig global( "khtmlrc", KConfig::NoGlobals );
+  init( &global, true );
+
+  KSharedConfig::Ptr local = KGlobal::config();
+  if ( !local )
+    return;
+
+  init( local.data(), false );
+
+  KConfig config ( "kcookiejarrc", KConfig::NoGlobals );
+  KConfigGroup cg ( &config, "Cookie Policy");
+  d->m_useCookieJar = cg.readEntry("Cookies", false);
+
+}
+
+void WebKitSettings::init( KConfig * config, bool reset )
+{
+  KConfigGroup cg( config, "MainView Settings" );
+  if (reset || cg.exists() )
+  {
+    if ( reset || cg.hasKey( "OpenMiddleClick" ) )
+        d->m_bOpenMiddleClick = cg.readEntry( "OpenMiddleClick", true );
+
+    if ( reset || cg.hasKey( "BackRightClick" ) )
+        d->m_bBackRightClick = cg.readEntry( "BackRightClick", false );
+  }
+
+  KConfigGroup cgAccess(config,"Access Keys" );
+  if (reset || cgAccess.exists() ) {
+      d->m_accessKeysEnabled = cgAccess.readEntry( "Enabled", true );
+  }
+
+  KConfigGroup cgFilter( config, "Filter Settings" );
+
+  if (reset || cgFilter.exists() )
+  {
+      d->m_adFilterEnabled = cgFilter.readEntry("Enabled", false);
+      d->m_hideAdsEnabled = cgFilter.readEntry("Shrink", false);
+
+      d->adBlackList.clear();
+      d->adWhiteList.clear();
+
+      QMap<QString,QString> entryMap = cgFilter.entryMap();
+      QMap<QString,QString>::ConstIterator it;
+      for( it = entryMap.constBegin(); it != entryMap.constEnd(); ++it )
+      {
+          QString name = it.key();
+          QString url = it.value();
+
+          if (name.startsWith(QLatin1String("Filter")))
+          {
+              if (url.startsWith(QLatin1String("@@")))
+                  d->adWhiteList.addFilter(url);
+              else
+                  d->adBlackList.addFilter(url);
+          }
+      }
+  }
+
+  KConfigGroup cgHtml( config, "HTML Settings" );
+  if (reset || cgHtml.exists() )
+  {
+    // Fonts and colors
+    if( reset ) {
+        d->defaultFonts = QStringList();
+        d->defaultFonts.append( cgHtml.readEntry( "StandardFont", KGlobalSettings::generalFont().family() ) );
+        d->defaultFonts.append( cgHtml.readEntry( "FixedFont", KGlobalSettings::fixedFont().family() ) );
+        d->defaultFonts.append( cgHtml.readEntry( "SerifFont", HTML_DEFAULT_VIEW_SERIF_FONT ) );
+        d->defaultFonts.append( cgHtml.readEntry( "SansSerifFont", HTML_DEFAULT_VIEW_SANSSERIF_FONT ) );
+        d->defaultFonts.append( cgHtml.readEntry( "CursiveFont", HTML_DEFAULT_VIEW_CURSIVE_FONT ) );
+        d->defaultFonts.append( cgHtml.readEntry( "FantasyFont", HTML_DEFAULT_VIEW_FANTASY_FONT ) );
+        d->defaultFonts.append( QString( "0" ) ); // font size adjustment
+    }
+
+    if ( reset || cgHtml.hasKey( "MinimumFontSize" ) )
+        d->m_minFontSize = cgHtml.readEntry( "MinimumFontSize", HTML_DEFAULT_MIN_FONT_SIZE );
+
+    if ( reset || cgHtml.hasKey( "MediumFontSize" ) )
+        d->m_fontSize = cgHtml.readEntry( "MediumFontSize", 12 );
+
+    d->fonts = cgHtml.readEntry( "Fonts", QStringList() );
+
+    if ( reset || cgHtml.hasKey( "DefaultEncoding" ) )
+        d->m_encoding = cgHtml.readEntry( "DefaultEncoding", "" );
+
+    if ( reset || cgHtml.hasKey( "EnforceDefaultCharset" ) )
+        d->enforceCharset = cgHtml.readEntry( "EnforceDefaultCharset", false );
+
+    // Behavior
+    if ( reset || cgHtml.hasKey( "ChangeCursor" ) )
+        d->m_bChangeCursor = cgHtml.readEntry( "ChangeCursor", KDE_DEFAULT_CHANGECURSOR );
+
+    if ( reset || cgHtml.hasKey("UnderlineLinks") )
+        d->m_underlineLink = cgHtml.readEntry( "UnderlineLinks", true );
+
+    if ( reset || cgHtml.hasKey( "HoverLinks" ) )
+    {
+        if ( (d->m_hoverLink = cgHtml.readEntry( "HoverLinks", false )))
+            d->m_underlineLink = false;
+    }
+
+    if ( reset || cgHtml.hasKey( "AllowTabulation" ) )
+        d->m_allowTabulation = cgHtml.readEntry( "AllowTabulation", false );
+
+    if ( reset || cgHtml.hasKey( "AutoSpellCheck" ) )
+        d->m_autoSpellCheck = cgHtml.readEntry( "AutoSpellCheck", true );
+
+    // Other
+    if ( reset || cgHtml.hasKey( "AutoLoadImages" ) )
+      d->m_bAutoLoadImages = cgHtml.readEntry( "AutoLoadImages", true );
+
+    if ( reset || cgHtml.hasKey( "UnfinishedImageFrame" ) )
+      d->m_bUnfinishedImageFrame = cgHtml.readEntry( "UnfinishedImageFrame", true );
+
+    if ( reset || cgHtml.hasKey( "ShowAnimations" ) )
+    {
+      QString value = cgHtml.readEntry( "ShowAnimations").toLower();
+      if (value == "disabled")
+         d->m_showAnimations = KAnimationDisabled;
+      else if (value == "looponce")
+         d->m_showAnimations = KAnimationLoopOnce;
+      else
+         d->m_showAnimations = KAnimationEnabled;
+    }
+
+    if ( reset || cgHtml.hasKey( "SmoothScrolling" ) )
+    {
+      QString value = cgHtml.readEntry( "SmoothScrolling", "whenefficient" ).toLower();
+      if (value == "disabled")
+         d->m_smoothScrolling = KSmoothScrollingDisabled;
+      else if (value == "whenefficient")
+         d->m_smoothScrolling = KSmoothScrollingWhenEfficient;
+      else
+         d->m_smoothScrolling = KSmoothScrollingEnabled;
+    }
+
+    if ( reset || cgHtml.hasKey( "ZoomTextOnly" ) ) {
+        d->m_zoomTextOnly = cgHtml.readEntry( "ZoomTextOnly", false );
+    }
+
+    if ( cgHtml.readEntry( "UserStyleSheetEnabled", false ) == true ) {
+        if ( reset || cgHtml.hasKey( "UserStyleSheet" ) )
+            d->m_userSheet = cgHtml.readEntry( "UserStyleSheet", "" );
+    }
+
+    d->m_formCompletionEnabled = cgHtml.readEntry("FormCompletion", true);
+    d->m_maxFormCompletionItems = cgHtml.readEntry("MaxFormCompletionItems", 10);
+    d->m_autoDelayedActionsEnabled = cgHtml.readEntry ("AutoDelayedActions", true);
+    d->m_jsErrorsEnabled = cgHtml.readEntry("ReportJSErrors", true);
+    const QStringList accesskeys = cgHtml.readEntry("FallbackAccessKeysAssignments", QStringList());
+    d->m_fallbackAccessKeysAssignments.clear();
+    for( QStringList::ConstIterator it = accesskeys.begin(); it != accesskeys.end(); ++it )
+        if( (*it).length() > 2 && (*it)[ 1 ] == ':' )
+            d->m_fallbackAccessKeysAssignments.append( qMakePair( (*it).mid( 2 ), (*it)[ 0 ] ));
+  }
+
+  // Colors
+  //In which group ?????
+  if ( reset || cg.hasKey( "FollowSystemColors" ) )
+      d->m_follow_system_colors = cg.readEntry( "FollowSystemColors", false );
+
+  KConfigGroup cgGeneral( config, "General" );
+  if ( reset || cgGeneral.exists( ) )
+  {
+    if ( reset || cgGeneral.hasKey( "foreground" ) ) {
+      QColor def(HTML_DEFAULT_TXT_COLOR);
+      d->m_textColor = cgGeneral.readEntry( "foreground", def );
+    }
+
+    if ( reset || cgGeneral.hasKey( "linkColor" ) ) {
+      QColor def(HTML_DEFAULT_LNK_COLOR);
+      d->m_linkColor = cgGeneral.readEntry( "linkColor", def );
+    }
+
+    if ( reset || cgGeneral.hasKey( "visitedLinkColor" ) ) {
+      QColor def(HTML_DEFAULT_VLNK_COLOR);
+      d->m_vLinkColor = cgGeneral.readEntry( "visitedLinkColor", def);
+    }
+
+    if ( reset || cgGeneral.hasKey( "background" ) ) {
+      QColor def(HTML_DEFAULT_BASE_COLOR);
+      d->m_baseColor = cgGeneral.readEntry( "background", def);
+    }
+  }
+
+  KConfigGroup cgJava( config, "Java/JavaScript Settings" );
+  if( reset || cgJava.exists() )
+  {
+    // The global setting for JavaScript debugging
+    // This is currently always enabled by default
+    if ( reset || cgJava.hasKey( "EnableJavaScriptDebug" ) )
+      d->m_bEnableJavaScriptDebug = cgJava.readEntry( "EnableJavaScriptDebug", false );
+
+    // The global setting for JavaScript error reporting
+    if ( reset || cgJava.hasKey( "ReportJavaScriptErrors" ) )
+      d->m_bEnableJavaScriptErrorReporting = cgJava.readEntry( "ReportJavaScriptErrors", false );
+
+    // The global setting for popup block passive popup
+    if ( reset || cgJava.hasKey( "PopupBlockerPassivePopup" ) )
+      d->m_jsPopupBlockerPassivePopup = cgJava.readEntry("PopupBlockerPassivePopup", true );
+
+    // Read options from the global "domain"
+    readDomainSettings(cgJava,reset,true,d->global);
+#ifdef DEBUG_SETTINGS
+    d->global.dump("init global");
+#endif
+
+    // The domain-specific settings.
+
+    static const char *const domain_keys[] = {	// always keep order of keys
+    	"ECMADomains", "JavaDomains", "PluginDomains"
+    };
+    bool check_old_ecma_settings = true;
+    bool check_old_java_settings = true;
+    // merge all domains into one list
+    QSet<QString> domainList;
+    for (unsigned i = 0; i < sizeof domain_keys/sizeof domain_keys[0]; ++i) {
+        if (reset || cgJava.hasKey(domain_keys[i])) {
+            if (i == 0) check_old_ecma_settings = false;
+            else if (i == 1) check_old_java_settings = false;
+            const QStringList dl = cgJava.readEntry( domain_keys[i], QStringList() );
+            const QSet<QString>::Iterator notfound = domainList.end();
+            QStringList::ConstIterator it = dl.begin();
+            const QStringList::ConstIterator itEnd = dl.end();
+            for (; it != itEnd; ++it) {
+                const QString domain = (*it).toLower();
+                QSet<QString>::Iterator pos = domainList.find(domain);
+                if (pos == notfound) domainList.insert(domain);
+            }/*next it*/
+        }
+    }/*next i*/
+
+    if (reset)
+      d->domainPolicy.clear();
+
+    {
+      QSet<QString>::ConstIterator it = domainList.constBegin();
+      const QSet<QString>::ConstIterator itEnd = domainList.constEnd();
+      for ( ; it != itEnd; ++it)
+      {
+        const QString domain = *it;
+        KConfigGroup cg( config, domain );
+        readDomainSettings(cg,reset,false,d->domainPolicy[domain]);
+#ifdef DEBUG_SETTINGS
+        d->domainPolicy[domain].dump("init "+domain);
+#endif
+      }
+    }
+
+    bool check_old_java = true;
+    if( ( reset || cgJava.hasKey( "JavaDomainSettings" ) )
+    	&& check_old_java_settings )
+    {
+      check_old_java = false;
+      const QStringList domainList = cgJava.readEntry( "JavaDomainSettings", QStringList() );
+      QStringList::ConstIterator it = domainList.constBegin();
+      const QStringList::ConstIterator itEnd = domainList.constEnd();
+      for ( ; it != itEnd; ++it)
+      {
+        QString domain;
+        KJavaScriptAdvice javaAdvice;
+        KJavaScriptAdvice javaScriptAdvice;
+        splitDomainAdvice(*it, domain, javaAdvice, javaScriptAdvice);
+        setup_per_domain_policy(d,domain).m_bEnableJava =
+		javaAdvice == KJavaScriptAccept;
+#ifdef DEBUG_SETTINGS
+	setup_per_domain_policy(d,domain).dump("JavaDomainSettings 4 "+domain);
+#endif
+      }
+    }
+
+    bool check_old_ecma = true;
+    if( ( reset || cgJava.hasKey( "ECMADomainSettings" ) )
+	&& check_old_ecma_settings )
+    {
+      check_old_ecma = false;
+      const QStringList domainList = cgJava.readEntry( "ECMADomainSettings", QStringList() );
+      QStringList::ConstIterator it = domainList.constBegin();
+      const QStringList::ConstIterator itEnd = domainList.constEnd();
+      for ( ; it != itEnd; ++it)
+      {
+        QString domain;
+        KJavaScriptAdvice javaAdvice;
+        KJavaScriptAdvice javaScriptAdvice;
+        splitDomainAdvice(*it, domain, javaAdvice, javaScriptAdvice);
+        setup_per_domain_policy(d,domain).m_bEnableJavaScript =
+			javaScriptAdvice == KJavaScriptAccept;
+#ifdef DEBUG_SETTINGS
+	setup_per_domain_policy(d,domain).dump("ECMADomainSettings 4 "+domain);
+#endif
+      }
+    }
+
+    if( ( reset || cgJava.hasKey( "JavaScriptDomainAdvice" ) )
+             && ( check_old_java || check_old_ecma )
+	     && ( check_old_ecma_settings || check_old_java_settings ) )
+    {
+      const QStringList domainList = cgJava.readEntry( "JavaScriptDomainAdvice", QStringList() );
+      QStringList::ConstIterator it = domainList.constBegin();
+      const QStringList::ConstIterator itEnd = domainList.constEnd();
+      for ( ; it != itEnd; ++it)
+      {
+        QString domain;
+        KJavaScriptAdvice javaAdvice;
+        KJavaScriptAdvice javaScriptAdvice;
+        splitDomainAdvice(*it, domain, javaAdvice, javaScriptAdvice);
+        if( check_old_java )
+          setup_per_domain_policy(d,domain).m_bEnableJava =
+	  		javaAdvice == KJavaScriptAccept;
+        if( check_old_ecma )
+          setup_per_domain_policy(d,domain).m_bEnableJavaScript =
+	  		javaScriptAdvice == KJavaScriptAccept;
+#ifdef DEBUG_SETTINGS
+	setup_per_domain_policy(d,domain).dump("JavaScriptDomainAdvice 4 "+domain);
+#endif
+      }
+
+      //save all the settings into the new keywords if they don't exist
+#if 0
+      if( check_old_java )
+      {
+        QStringList domainConfig;
+        PolicyMap::Iterator it;
+        for( it = d->javaDomainPolicy.begin(); it != d->javaDomainPolicy.end(); ++it )
+        {
+          QByteArray javaPolicy = adviceToStr( it.value() );
+          QByteArray javaScriptPolicy = adviceToStr( KJavaScriptDunno );
+          domainConfig.append(QString::fromLatin1("%1:%2:%3").arg(it.key()).arg(javaPolicy).arg(javaScriptPolicy));
+        }
+        cg.writeEntry( "JavaDomainSettings", domainConfig );
+      }
+
+      if( check_old_ecma )
+      {
+        QStringList domainConfig;
+        PolicyMap::Iterator it;
+        for( it = d->javaScriptDomainPolicy.begin(); it != d->javaScriptDomainPolicy.end(); ++it )
+        {
+          QByteArray javaPolicy = adviceToStr( KJavaScriptDunno );
+          QByteArray javaScriptPolicy = adviceToStr( it.value() );
+          domainConfig.append(QString::fromLatin1("%1:%2:%3").arg(it.key()).arg(javaPolicy).arg(javaScriptPolicy));
+        }
+        cg.writeEntry( "ECMADomainSettings", domainConfig );
+      }
+#endif
+    }
+  }
+
+  // Sync with QWebSettings.
+  if (!userStyleSheet().isEmpty()) {
+      QWebSettings::globalSettings()->setUserStyleSheetUrl(QUrl(userStyleSheet()));
+  }
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::AutoLoadImages, autoLoadImages());
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::JavascriptEnabled, isJavaScriptEnabled());
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::JavaEnabled, isJavaEnabled());
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::PluginsEnabled, isPluginsEnabled());
+
+  // By default disable JS window.open when policy is deny or smart.
+  const KJSWindowOpenPolicy policy = windowOpenPolicy();
+  if (policy == WebKitSettings::KJSWindowOpenDeny || policy == WebKitSettings::KJSWindowOpenSmart)
+      QWebSettings::globalSettings()->setAttribute(QWebSettings::JavascriptCanOpenWindows, false);
+  else
+      QWebSettings::globalSettings()->setAttribute(QWebSettings::JavascriptCanOpenWindows, true);
+
+#if QT_VERSION >= 0x040500
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::ZoomTextOnly, zoomTextOnly());
+#endif
+  QWebSettings::globalSettings()->setAttribute(QWebSettings::DeveloperExtrasEnabled, isJavaScriptDebugEnabled());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::StandardFont, stdFontName());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::FixedFont, fixedFontName());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::SerifFont, serifFontName());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::SansSerifFont, sansSerifFontName());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::CursiveFont, cursiveFontName());
+  QWebSettings::globalSettings()->setFontFamily(QWebSettings::FantasyFont, fantasyFontName());
+
+  // These numbers should be calculated from real "logical" DPI/72, using a default dpi of 96 for now
+  QWebSettings::globalSettings()->setFontSize(QWebSettings::MinimumFontSize, minFontSize() * 96.0/72.0);
+  QWebSettings::globalSettings()->setFontSize(QWebSettings::DefaultFontSize, mediumFontSize() * 96.0/72.0);
+}
+
+
+void WebKitSettings::computeFontSizes( int logicalDpi )
+{
+  float toPix = logicalDpi/72.0;
+  if (toPix < 96.0/72.0) toPix = 96.0/72.0;
+  QWebSettings::globalSettings()->setFontSize(QWebSettings::MinimumFontSize, minFontSize() * toPix);
+  QWebSettings::globalSettings()->setFontSize(QWebSettings::DefaultFontSize, mediumFontSize() * toPix);
+}
+
+/** Local helper for retrieving per-domain settings.
+  *
+  * In case of doubt, the global domain is returned.
+  */
+static const KPerDomainSettings &lookup_hostname_policy(
+			const WebKitSettingsPrivate* const d,
+			const QString& hostname)
+{
+#ifdef DEBUG_SETTINGS
+  kDebug() << "lookup_hostname_policy(" << hostname << ")";
+#endif
+  if (hostname.isEmpty()) {
+#ifdef DEBUG_SETTINGS
+    d->global.dump("global");
+#endif
+    return d->global;
+  }
+
+  const PolicyMap::const_iterator notfound = d->domainPolicy.constEnd();
+
+  // First check whether there is a perfect match.
+  PolicyMap::const_iterator it = d->domainPolicy.find(hostname);
+  if( it != notfound ) {
+#ifdef DEBUG_SETTINGS
+    kDebug() << "perfect match";
+    (*it).dump(hostname);
+#endif
+    // yes, use it (unless dunno)
+    return *it;
+  }
+
+  // Now, check for partial match.  Chop host from the left until
+  // there's no dots left.
+  QString host_part = hostname;
+  int dot_idx = -1;
+  while( (dot_idx = host_part.indexOf(QChar('.'))) >= 0 ) {
+    host_part.remove(0,dot_idx);
+    it = d->domainPolicy.find(host_part);
+    Q_ASSERT(notfound == d->domainPolicy.end());
+    if( it != notfound ) {
+#ifdef DEBUG_SETTINGS
+      kDebug() << "partial match";
+      (*it).dump(host_part);
+#endif
+      return *it;
+    }
+    // assert(host_part[0] == QChar('.'));
+    host_part.remove(0,1); // Chop off the dot.
+  }
+
+  // No domain-specific entry: use global domain
+#ifdef DEBUG_SETTINGS
+  kDebug() << "no match";
+  d->global.dump("global");
+#endif
+  return d->global;
+}
+
+bool WebKitSettings::isOpenMiddleClickEnabled()
+{
+  return d->m_bOpenMiddleClick;
+}
+
+bool WebKitSettings::isBackRightClickEnabled()
+{
+  return d->m_bBackRightClick;
+}
+
+bool WebKitSettings::accessKeysEnabled() const
+{
+    return d->m_accessKeysEnabled;
+}
+
+bool WebKitSettings::isAdFilterEnabled() const
+{
+    return d->m_adFilterEnabled;
+}
+
+bool WebKitSettings::isHideAdsEnabled() const
+{
+    return d->m_hideAdsEnabled;
+}
+
+bool WebKitSettings::isAdFiltered( const QString &url ) const
+{
+    if (d->m_adFilterEnabled)
+    {
+        if (!url.startsWith(QLatin1String("data:")))
+        {
+            // Check the blacklist, and only if that matches, the whitelist
+            return d->adBlackList.isUrlMatched(url) && !d->adWhiteList.isUrlMatched(url);
+        }
+    }
+    return false;
+}
+
+void WebKitSettings::addAdFilter( const QString &url )
+{
+    KConfigGroup config = KSharedConfig::openConfig( "khtmlrc", KConfig::NoGlobals )->group( "Filter Settings" );
+
+    QRegExp rx;
+    
+    // Try compiling to avoid invalid stuff. Only support the basic syntax here...
+    // ### refactor somewhat
+    if (url.length()>2 && url[0]=='/' && url[url.length()-1] == '/')
+    {
+        const QString inside = url.mid(1, url.length()-2);
+        rx.setPattern(inside);
+    }
+    else
+    {
+        rx.setPatternSyntax(QRegExp::Wildcard);
+        rx.setPattern(url);
+    }
+
+    if (rx.isValid())
+    {
+        int last=config.readEntry("Count", 0);
+        const QString key = "Filter-" + QString::number(last);
+        config.writeEntry(key, url);
+        config.writeEntry("Count",last+1);
+        config.sync();
+
+        if (url.startsWith(QLatin1String("@@")))
+            d->adWhiteList.addFilter(url);
+        else
+            d->adBlackList.addFilter(url);
+    }
+    else
+    {
+        KMessageBox::error(0,
+                           rx.errorString(),
+                           i18n("Filter error"));
+    }
+}
+
+bool WebKitSettings::isJavaEnabled( const QString& hostname ) const
+{
+  return lookup_hostname_policy(d,hostname.toLower()).m_bEnableJava;
+}
+
+bool WebKitSettings::isJavaScriptEnabled( const QString& hostname ) const
+{
+  return lookup_hostname_policy(d,hostname.toLower()).m_bEnableJavaScript;
+}
+
+bool WebKitSettings::isJavaScriptDebugEnabled( const QString& /*hostname*/ ) const
+{
+  // debug setting is global for now, but could change in the future
+  return d->m_bEnableJavaScriptDebug;
+}
+
+bool WebKitSettings::isJavaScriptErrorReportingEnabled( const QString& /*hostname*/ ) const
+{
+  // error reporting setting is global for now, but could change in the future
+  return d->m_bEnableJavaScriptErrorReporting;
+}
+
+bool WebKitSettings::isPluginsEnabled( const QString& hostname ) const
+{
+  return lookup_hostname_policy(d,hostname.toLower()).m_bEnablePlugins;
+}
+
+WebKitSettings::KJSWindowOpenPolicy WebKitSettings::windowOpenPolicy(
+				const QString& hostname) const {
+  return lookup_hostname_policy(d,hostname.toLower()).m_windowOpenPolicy;
+}
+
+WebKitSettings::KJSWindowMovePolicy WebKitSettings::windowMovePolicy(
+				const QString& hostname) const {
+  return lookup_hostname_policy(d,hostname.toLower()).m_windowMovePolicy;
+}
+
+WebKitSettings::KJSWindowResizePolicy WebKitSettings::windowResizePolicy(
+				const QString& hostname) const {
+  return lookup_hostname_policy(d,hostname.toLower()).m_windowResizePolicy;
+}
+
+WebKitSettings::KJSWindowStatusPolicy WebKitSettings::windowStatusPolicy(
+				const QString& hostname) const {
+  return lookup_hostname_policy(d,hostname.toLower()).m_windowStatusPolicy;
+}
+
+WebKitSettings::KJSWindowFocusPolicy WebKitSettings::windowFocusPolicy(
+				const QString& hostname) const {
+  return lookup_hostname_policy(d,hostname.toLower()).m_windowFocusPolicy;
+}
+
+int WebKitSettings::mediumFontSize() const
+{
+    return d->m_fontSize;
+}
+
+int WebKitSettings::minFontSize() const
+{
+  return d->m_minFontSize;
+}
+
+QString WebKitSettings::settingsToCSS() const
+{
+    // lets start with the link properties
+    QString str = "a:link {\ncolor: ";
+    str += d->m_linkColor.name();
+    str += ';';
+    if(d->m_underlineLink)
+        str += "\ntext-decoration: underline;";
+
+    if( d->m_bChangeCursor )
+    {
+        str += "\ncursor: pointer;";
+        str += "\n}\ninput[type=image] { cursor: pointer;";
+    }
+    str += "\n}\n";
+    str += "a:visited {\ncolor: ";
+    str += d->m_vLinkColor.name();
+    str += ';';
+    if(d->m_underlineLink)
+        str += "\ntext-decoration: underline;";
+
+    if( d->m_bChangeCursor )
+        str += "\ncursor: pointer;";
+    str += "\n}\n";
+
+    if(d->m_hoverLink)
+        str += "a:link:hover, a:visited:hover { text-decoration: underline; }\n";
+
+    return str;
+}
+
+const QString &WebKitSettings::availableFamilies()
+{
+    if ( !avFamilies ) {
+        avFamilies = new QString;
+        QFontDatabase db;
+        QStringList families = db.families();
+        QStringList s;
+        QRegExp foundryExp(" \\[.+\\]");
+
+        //remove foundry info
+        QStringList::Iterator f = families.begin();
+        const QStringList::Iterator fEnd = families.end();
+
+        for ( ; f != fEnd; ++f ) {
+                (*f).remove(foundryExp);
+                if (!s.contains(*f))
+                        s << *f;
+        }
+        s.sort();
+
+        *avFamilies = ',' + s.join(",") + ',';
+    }
+
+  return *avFamilies;
+}
+
+QString WebKitSettings::lookupFont(int i) const
+{
+    QString font;
+    if (d->fonts.count() > i)
+       font = d->fonts[i];
+    if (font.isEmpty())
+        font = d->defaultFonts[i];
+    return font;
+}
+
+QString WebKitSettings::stdFontName() const
+{
+    return lookupFont(0);
+}
+
+QString WebKitSettings::fixedFontName() const
+{
+    return lookupFont(1);
+}
+
+QString WebKitSettings::serifFontName() const
+{
+    return lookupFont(2);
+}
+
+QString WebKitSettings::sansSerifFontName() const
+{
+    return lookupFont(3);
+}
+
+QString WebKitSettings::cursiveFontName() const
+{
+    return lookupFont(4);
+}
+
+QString WebKitSettings::fantasyFontName() const
+{
+    return lookupFont(5);
+}
+
+void WebKitSettings::setStdFontName(const QString &n)
+{
+    while(d->fonts.count() <= 0)
+        d->fonts.append(QString());
+    d->fonts[0] = n;
+}
+
+void WebKitSettings::setFixedFontName(const QString &n)
+{
+    while(d->fonts.count() <= 1)
+        d->fonts.append(QString());
+    d->fonts[1] = n;
+}
+
+QString WebKitSettings::userStyleSheet() const
+{
+    return d->m_userSheet;
+}
+
+bool WebKitSettings::isFormCompletionEnabled() const
+{
+  return d->m_formCompletionEnabled;
+}
+
+int WebKitSettings::maxFormCompletionItems() const
+{
+  return d->m_maxFormCompletionItems;
+}
+
+const QString &WebKitSettings::encoding() const
+{
+  return d->m_encoding;
+}
+
+bool WebKitSettings::followSystemColors() const
+{
+    return d->m_follow_system_colors;
+}
+
+const QColor& WebKitSettings::textColor() const
+{
+  return d->m_textColor;
+}
+
+const QColor& WebKitSettings::baseColor() const
+{
+  return d->m_baseColor;
+}
+
+const QColor& WebKitSettings::linkColor() const
+{
+  return d->m_linkColor;
+}
+
+const QColor& WebKitSettings::vLinkColor() const
+{
+  return d->m_vLinkColor;
+}
+
+bool WebKitSettings::autoLoadImages() const
+{
+  return d->m_bAutoLoadImages;
+}
+
+bool WebKitSettings::unfinishedImageFrame() const
+{
+  return d->m_bUnfinishedImageFrame;
+}
+
+WebKitSettings::KAnimationAdvice WebKitSettings::showAnimations() const
+{
+  return d->m_showAnimations;
+}
+
+WebKitSettings::KSmoothScrollingMode WebKitSettings::smoothScrolling() const
+{
+  return d->m_smoothScrolling;
+}
+
+bool WebKitSettings::zoomTextOnly() const
+{
+  return d->m_zoomTextOnly;
+}
+
+bool WebKitSettings::isAutoDelayedActionsEnabled() const
+{
+  return d->m_autoDelayedActionsEnabled;
+}
+
+bool WebKitSettings::jsErrorsEnabled() const
+{
+  return d->m_jsErrorsEnabled;
+}
+
+void WebKitSettings::setJSErrorsEnabled(bool enabled)
+{
+  d->m_jsErrorsEnabled = enabled;
+  // save it
+  KConfigGroup cg( KGlobal::config(), "HTML Settings");
+  cg.writeEntry("ReportJSErrors", enabled);
+  cg.sync();
+}
+
+bool WebKitSettings::allowTabulation() const
+{
+    return d->m_allowTabulation;
+}
+
+bool WebKitSettings::autoSpellCheck() const
+{
+    return d->m_autoSpellCheck;
+}
+
+QList< QPair< QString, QChar > > WebKitSettings::fallbackAccessKeysAssignments() const
+{
+    return d->m_fallbackAccessKeysAssignments;
+}
+
+void WebKitSettings::setJSPopupBlockerPassivePopup(bool enabled)
+{
+    d->m_jsPopupBlockerPassivePopup = enabled;
+    // save it
+    KConfigGroup cg( KGlobal::config(), "Java/JavaScript Settings");
+    cg.writeEntry("PopupBlockerPassivePopup", enabled);
+    cg.sync();
+}
+
+bool WebKitSettings::jsPopupBlockerPassivePopup() const
+{
+    return d->m_jsPopupBlockerPassivePopup;
+}
+
+bool WebKitSettings::isCookieJarEnabled() const
+{
+    return d->m_useCookieJar;
+}
+
+K_GLOBAL_STATIC(WebKitSettings, s_webKitSettings)
+
+WebKitSettings* WebKitSettings::self()
+{
+    return s_webKitSettings;
+}
+

Property changes on: part/settings/webkitsettings.cpp
___________________________________________________________________
Added: svn:mime-type
   + text/x-c++src
Added: svn:keywords
   + Author Date Id Revision
Added: svn:mergeinfo
Added: svn:eol-style
   + native

Index: part/settings/khtml_filter_p.h
===================================================================
--- part/settings/khtml_filter_p.h	(revision 0)
+++ part/settings/khtml_filter_p.h	(revision 1043437)
@@ -0,0 +1,79 @@
+/* This file is part of the KDE project
+
+   Copyright (C) 2005 Ivor Hewitt     <ivor@kde.org>
+   Copyright (C) 2008 Maksim Orlovich <maksim@kde.org>
+   Copyright (C) 2008 Vyacheslav Tokarev <tsjoker@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KHTML_FILTER_P_H
+#define KHTML_FILTER_P_H
+
+#include <QString>
+#include <QRegExp>
+#include <QVector>
+#include <QHash>
+#include <QBitArray>
+
+namespace khtml {
+
+// Updateable Multi-String Matcher based on Rabin-Karp's algorithm
+class StringsMatcher {
+public:
+    // add filter to matching set
+    void addString(const QString& pattern);
+
+    // check if string match at least one string from matching set
+    bool isMatched(const QString& str) const;
+
+    // add filter to matching set with wildcards (*,?) in it
+    void addWildedString(const QString& prefix, const QRegExp& rx);
+
+    void clear();
+
+private:
+    QVector<QString> stringFilters;
+    QVector<QString> shortStringFilters;
+    QVector<QRegExp> reFilters;
+    QVector<QString> rePrefixes;
+    QBitArray fastLookUp;
+
+    QHash<int, QVector<int> > stringFiltersHash;
+};
+
+// This represents a set of filters that may match URLs.
+// Currently it supports a subset of AddBlock Plus functionality.
+class FilterSet {
+public:
+    // Parses and registers a filter. This will also strip @@ for exclusion rules, skip comments, etc.
+    // The user does have to split black and white lists into separate sets, however
+    void addFilter(const QString& filter);
+    
+    bool isUrlMatched(const QString& url);
+    
+    void clear();
+
+private:
+    QVector<QRegExp> reFilters;
+    StringsMatcher stringFiltersMatcher;
+};
+
+}
+
+#endif // KHTML_FILTER_P_H
+
+// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on;
Index: part/settings/webkitsettings.h
===================================================================
--- part/settings/webkitsettings.h	(revision 0)
+++ part/settings/webkitsettings.h	(revision 1043437)
@@ -0,0 +1,243 @@
+/* This file is part of the KDE project
+   Copyright (C) 1999 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef WEBKITSETTINGS_H
+#define WEBKITSETTINGS_H
+
+class KConfig;
+class KConfigGroup;
+
+#include <QtGui/QColor>
+#include <QtCore/QStringList>
+#include <QtCore/QPair>
+#include <kdewebkit_export.h>
+
+struct KPerDomainSettings;
+class WebKitSettingsPrivate;
+
+/**
+ * Settings for the HTML view.
+ */
+class KDEWEBKIT_EXPORT WebKitSettings
+{
+public:
+
+    /**
+     * This enum specifies whether Java/JavaScript execution is allowed.
+     */
+    enum KJavaScriptAdvice {
+      KJavaScriptDunno=0,
+      KJavaScriptAccept,
+      KJavaScriptReject
+    };
+
+    enum KAnimationAdvice {
+      KAnimationDisabled=0,
+      KAnimationLoopOnce,
+      KAnimationEnabled
+    };
+
+    enum KSmoothScrollingMode {
+      KSmoothScrollingDisabled=0,
+      KSmoothScrollingWhenEfficient,
+      KSmoothScrollingEnabled
+    };
+
+    /**
+     * This enum specifies the policy for window.open
+     */
+    enum KJSWindowOpenPolicy {
+    	KJSWindowOpenAllow=0,
+    	KJSWindowOpenAsk,
+    	KJSWindowOpenDeny,
+    	KJSWindowOpenSmart
+    };
+
+    /**
+     * This enum specifies the policy for window.status and .defaultStatus
+     */
+    enum KJSWindowStatusPolicy {
+    	KJSWindowStatusAllow=0,
+    	KJSWindowStatusIgnore
+    };
+
+    /**
+     * This enum specifies the policy for window.moveBy and .moveTo
+     */
+    enum KJSWindowMovePolicy {
+    	KJSWindowMoveAllow=0,
+    	KJSWindowMoveIgnore
+    };
+
+    /**
+     * This enum specifies the policy for window.resizeBy and .resizeTo
+     */
+    enum KJSWindowResizePolicy {
+    	KJSWindowResizeAllow=0,
+    	KJSWindowResizeIgnore
+    };
+
+    /**
+     * This enum specifies the policy for window.focus
+     */
+    enum KJSWindowFocusPolicy {
+    	KJSWindowFocusAllow=0,
+    	KJSWindowFocusIgnore
+    };
+
+    /**
+     * Called by constructor and reparseConfiguration
+     */
+    void init();
+
+    /** Read settings from @p config.
+     * @param config is a pointer to KConfig object.
+     * @param reset if true, settings are always set; if false,
+     *  settings are only set if the config file has a corresponding key.
+     */
+    void init( KConfig * config, bool reset = true );
+
+    /**
+     * Destructor. Don't delete any instance by yourself.
+     */
+    virtual ~WebKitSettings();
+
+    // Behavior settings
+    bool changeCursor() const;
+    bool underlineLink() const;
+    bool hoverLink() const;
+    bool allowTabulation() const;
+    bool autoSpellCheck() const;
+    KAnimationAdvice showAnimations() const;
+    KSmoothScrollingMode smoothScrolling() const;
+    bool zoomTextOnly() const;
+
+    // Font settings
+    QString stdFontName() const;
+    QString fixedFontName() const;
+    QString serifFontName() const;
+    QString sansSerifFontName() const;
+    QString cursiveFontName() const;
+    QString fantasyFontName() const;
+
+    // these two can be set. Mainly for historical reasons (the method in KHTMLPart exists...)
+    void setStdFontName(const QString &n);
+    void setFixedFontName(const QString &n);
+
+    int minFontSize() const;
+    int mediumFontSize() const;
+
+    void computeFontSizes(int logicalDpi);
+
+    bool jsErrorsEnabled() const;
+    void setJSErrorsEnabled(bool enabled);
+
+    const QString &encoding() const;
+
+    bool followSystemColors() const;
+
+    // Color settings
+    const QColor& textColor() const;
+    const QColor& baseColor() const;
+    const QColor& linkColor() const;
+    const QColor& vLinkColor() const;
+
+    // Autoload images
+    bool autoLoadImages() const;
+    bool unfinishedImageFrame() const;
+
+    bool isOpenMiddleClickEnabled();
+    bool isBackRightClickEnabled();
+
+    // Java and JavaScript
+    bool isJavaEnabled( const QString& hostname = QString() ) const;
+    bool isJavaScriptEnabled( const QString& hostname = QString() ) const;
+    bool isJavaScriptDebugEnabled( const QString& hostname = QString() ) const;
+    bool isJavaScriptErrorReportingEnabled( const QString& hostname = QString() ) const;
+    bool isPluginsEnabled( const QString& hostname = QString() ) const;
+
+    // AdBlocK Filtering
+    bool isAdFiltered( const QString &url ) const;
+    bool isAdFilterEnabled() const;
+    bool isHideAdsEnabled() const;
+    void addAdFilter( const QString &url );
+
+    // Access Keys
+    bool accessKeysEnabled() const;
+
+    KJSWindowOpenPolicy windowOpenPolicy( const QString& hostname = QString() ) const;
+    KJSWindowMovePolicy windowMovePolicy( const QString& hostname = QString() ) const;
+    KJSWindowResizePolicy windowResizePolicy( const QString& hostname = QString() ) const;
+    KJSWindowStatusPolicy windowStatusPolicy( const QString& hostname = QString() ) const;
+    KJSWindowFocusPolicy windowFocusPolicy( const QString& hostname = QString() ) const;
+
+    // helpers for parsing domain-specific configuration, used in KControl module as well
+    static KJavaScriptAdvice strToAdvice(const QString& _str);
+    static void splitDomainAdvice(const QString& configStr, QString &domain,
+				  KJavaScriptAdvice &javaAdvice, KJavaScriptAdvice& javaScriptAdvice);
+    static const char* adviceToStr(KJavaScriptAdvice _advice);
+
+    /** reads from @p config's current group, forcing initialization
+      * if @p reset is true.
+      * @param config is a pointer to KConfig object.
+      * @param reset true if initialization is to be forced.
+      * @param global true if the global domain is to be read.
+      * @param pd_settings will be initialised with the computed (inherited)
+      *		settings.
+      */
+    void readDomainSettings(const KConfigGroup &config, bool reset,
+			bool global, KPerDomainSettings &pd_settings);
+
+    QString settingsToCSS() const;
+    static const QString &availableFamilies();
+
+    QString userStyleSheet() const;
+
+    // Form completion
+    bool isFormCompletionEnabled() const;
+    int maxFormCompletionItems() const;
+
+    // Meta refresh/redirect (http-equiv)
+    bool isAutoDelayedActionsEnabled () const;
+
+    QList< QPair< QString, QChar > > fallbackAccessKeysAssignments() const;
+
+    // Whether to show passive popup when windows are blocked
+    void setJSPopupBlockerPassivePopup(bool enabled);
+    bool jsPopupBlockerPassivePopup() const;
+
+    // CookieJar...
+    bool isCookieJarEnabled() const;
+
+    // Global config object stuff.
+    static WebKitSettings* self();
+    /**
+     * @internal Constructor
+     */
+    WebKitSettings();
+    WebKitSettings(const WebKitSettings &other);
+
+private:
+    QString lookupFont(int i) const;
+
+    WebKitSettingsPrivate* const d;
+    static QString *avFamilies;
+};
+
+#endif

Property changes on: part/settings/webkitsettings.h
___________________________________________________________________
Added: svn:mime-type
   + text/x-chdr
Added: svn:keywords
   + Author Date Id Revision
Added: svn:eol-style
   + native

Index: part/webpage.h
===================================================================
--- part/webpage.h	(revision 957817)
+++ part/webpage.h	(revision 1043437)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2008 Dirk Mueller <mueller@kde.org>
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,35 +24,118 @@
 #ifndef WEBPAGE_H
 #define WEBPAGE_H
 
+#include "webkitkde_export.h"
+
 #include <kdewebkit/kwebpage.h>
 
-#include "webkitkde_export.h"
-
-class QWebFrame;
+class KUrl;
+class WebSslInfo;
 class WebKitPart;
+class QVariant;
 
 class WEBKITKDE_EXPORT WebPage : public KWebPage
 {
     Q_OBJECT
 public:
     WebPage(WebKitPart *wpart, QWidget *parent);
+    ~WebPage();
 
+    /**
+     * Re-implemented for internal reasons. API is unaffected.
+     *
+     * @see KWebPage::authorizedRequest.
+     */
+    bool authorizedRequest(const QUrl &) const;
+
+    /**
+     * Returns the SSL information for the current page.
+     *
+     * @see WebSslInfo.
+     */
+    const WebSslInfo& sslInfo() const;
+
+    /**
+     * Sets the cached page SSL information to @p info.
+     *
+     * @see WebSslInfo
+     */
+    void setSslInfo (const WebSslInfo& info);
+
+Q_SIGNALS:
+    /**
+     * This signal is emitted whenever a navigation request is accepted except
+     * for Reload and Back/Forward navigation requests.
+     *
+     * If the navigation request is rejected for whatever reason, this signal will
+     * not be emitted.
+     */
+    void updateHistory();
+
+     /**
+      * This signal is emitted whenever a navigation request by the main frame completes.
+      */
+    void navigationRequestFinished();
+
+    /**
+     * This signal is emitted under the same condition as QWebPage::loadStarted()
+     * except it also sends the url being loaded.
+     */
+    void loadStarted(const QUrl& url);
+
+    /**
+     * This signal is emitted whenever a user cancels/aborts a load resource request.
+     */
+    void loadAborted(const QUrl& newUrl);
+
+    /**
+     * This signal is emitted whenever an error is encoutered while loading the requested resource.
+     */
+    void loadError(int, const QString&, const QString& frameName = QString());
+
+public Q_SLOTS:
+    /**
+     * Prompts the user to saves the contents of the specified @p url.
+     */
     void saveUrl(const KUrl &url);
 
+
 protected:
-    virtual bool acceptNavigationRequest(QWebFrame *frame, const QNetworkRequest &request,
-                                         NavigationType type);
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     * @internal
+     */
+    virtual QWebPage* createWindow(WebWindowType type);
 
-    virtual KWebPage *newWindow(WebWindowType type);
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     * @internal
+     */
+    virtual bool acceptNavigationRequest(QWebFrame * frame, const QNetworkRequest & request, NavigationType type);
 
 protected Q_SLOTS:
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see KWebPage::slotUnsupportedContent
+     * @internal
+     */
+    void slotUnsupportedContent(QNetworkReply *reply);
+    void slotDownloadRequest(const QNetworkRequest &request);
+
+    void slotRequestFinished(QNetworkReply *reply);
     void slotGeometryChangeRequested(const QRect &rect);
     void slotWindowCloseRequested();
     void slotStatusBarMessage(const QString &message);
-    void slotHandleUnsupportedContent(QNetworkReply *reply);
 
 private:
-    WebKitPart *m_part;
+    bool checkLinkSecurity(const QNetworkRequest &req, NavigationType type) const;
+    bool checkFormData(const QNetworkRequest &req) const;
+    bool handleMailToUrl (const QUrl& , NavigationType type) const;
+    void setPageJScriptPolicy(const QUrl &url);
+
+private:
+    class WebPagePrivate;
+    WebPagePrivate* const d;
 };
 
 #endif // WEBPAGE_H
Index: part/websslinfo.h
===================================================================
--- part/websslinfo.h	(revision 0)
+++ part/websslinfo.h	(revision 1043437)
@@ -0,0 +1,72 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef WEBSSLINFO_H
+#define WEBSSLINFO_H
+
+#include <kdemacros.h>
+
+#include <QtCore/QUrl>
+#include <QtCore/QList>
+#include <QtCore/QString>
+#include <QtNetwork/QHostAddress>
+#include <QtNetwork/QSslCertificate>
+
+class WebSslInfo
+{
+public:
+  WebSslInfo();
+  WebSslInfo(const WebSslInfo&);
+  virtual ~WebSslInfo();
+
+  bool isValid() const;
+  QUrl url() const;
+  QHostAddress peerAddress() const;
+  QHostAddress parentAddress() const;
+  QString ciphers() const;
+  QString protocol() const;
+  QString certificateErrors() const;
+  int supportedChiperBits () const;
+  int usedChiperBits () const;
+  QList<QSslCertificate> certificateChain() const;
+
+  QVariant toMetaData() const;
+  void fromMetaData (const QVariant &);
+
+  void setUrl (const QUrl &url);
+  WebSslInfo& operator = (const WebSslInfo&);
+
+protected:
+  void setCiphers(const QString& ciphers);
+  void setProtocol(const QString& protocol);
+  void setPeerAddress(const QString& address);
+  void setParentAddress(const QString& address);
+  void setCertificateChain(const QByteArray& chain);
+  void setCertificateErrors(const QString& certErrors);
+  void setUsedCipherBits(const QString& bits);
+  void setSupportedCipherBits(const QString& bits);
+
+private:
+  class WebSslInfoPrivate;
+  WebSslInfoPrivate* d;
+};
+
+#endif // WEBSSLINFO_H
Index: part/webkitpart.h
===================================================================
--- part/webkitpart.h	(revision 957817)
+++ part/webkitpart.h	(revision 1043437)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2007 Trolltech ASA
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,14 +24,16 @@
 #ifndef WEBKITPART_H
 #define WEBKITPART_H
 
-#include <KDE/KParts/ReadOnlyPart>
-#include <KDE/KParts/BrowserExtension>
-
 #include "webkitkde_export.h"
 
-class WebView;
-class WebKitBrowserExtension;
+#include <KDE/KParts/ReadOnlyPart>
 
+namespace KParts {
+  class BrowserExtension;
+}
+class QNetworkReply;
+class QWebView;
+
 class WEBKITKDE_EXPORT WebKitPart : public KParts::ReadOnlyPart
 {
     Q_OBJECT
@@ -38,70 +41,40 @@
     explicit WebKitPart(QWidget *parentWidget = 0, QObject *parent = 0, const QStringList &/*args*/ = QStringList());
     ~WebKitPart();
 
-    virtual bool openUrl(const KUrl &url);
+    virtual bool openUrl(const KUrl &);
     virtual bool closeUrl();
 
-//     KWebPage::NavigationRequestResponse navigationRequested(const QWebNetworkRequest &request);
+    QWebView *view();
+    KParts::BrowserExtension *browserExtension() const;
 
-    WebView *view();
-    WebKitBrowserExtension *browserExtension() const;
-
     /** required because KPart::setStatusBarText(..) is protected **/
-    void setStatusBarTextProxy(const QString &message);
+    void setStatusBarTextProxy(const QString &);
 
 protected:
-    void guiActivateEvent(KParts::GUIActivateEvent *event);
+    void guiActivateEvent(KParts::GUIActivateEvent *);
     virtual bool openFile();
     void initAction();
+    void showError(const QString &, const QString & frameName = QString());
+    void setSslInfo(const QVariant &);
 
 private Q_SLOTS:
+    void showSecurity();
+    void updateHistory();
+    void showSearchBar();
     void loadStarted();
-    void loadFinished();
-    void urlChanged(const QUrl &url);
+    void loadFinished(bool);
+    void loadAborted(const QUrl &);
+    void loadError(int, const QString &, const QString &);
 
-private:
-    WebView *m_webView;
-    WebKitBrowserExtension *m_browserExtension;
-};
+    void navigationRequestFinished();    
+    void searchForText(const QString &text, bool backward);
+    void linkHovered(const QString &, const QString&, const QString &);
 
-class WebKitBrowserExtension : public KParts::BrowserExtension
-{
-    Q_OBJECT
-public:
-    WebKitBrowserExtension(WebKitPart *parent);
+    void urlChanged(const QUrl &);
 
-public Q_SLOTS:
-    void cut();
-    void copy();
-    void paste();
-    void slotSaveDocument();
-    void slotSaveFrame();
-    void print();
-    void printFrame();
-    void searchProvider();
-
-    void zoomIn();
-    void zoomOut();
-    void slotSelectAll();
-
-    void slotFrameInWindow();
-    void slotFrameInTab();
-    void slotFrameInTop();
-
-    void slotSaveImageAs();
-    void slotSendImage();
-    void slotCopyImage();
-
-    void slotCopyLinkLocation();
-    void slotSaveLinkAs();
-
-    void slotViewDocumentSource();
-
-private Q_SLOTS:
-    void updateEditActions();
-
-private:
-    WebKitPart *part;
+  private:
+    class WebKitPartPrivate;
+    WebKitPartPrivate* d;
 };
 
 #endif // WEBKITPART_H
Index: part/sslinfodialog_p.h
===================================================================
--- part/sslinfodialog_p.h	(revision 0)
+++ part/sslinfodialog_p.h	(revision 1043437)
@@ -0,0 +1,104 @@
+/* This file is part of the KDE project
+ *
+ * Copyright (C) 2000-2003 George Staikos <staikos@kde.org>
+ * Copyright (C) 2000 Malte Starostik <malte@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef SSLINFODIALOG_P_H
+#define SSLINFODIALOG_P_H
+
+#include <kdemacros.h>
+
+#include <KDE/KDialog>
+#include <ktcpsocket.h>
+
+// NOTE: We need a copy of this header file is needed here because it
+// is never installed by default by KIO.
+
+/**
+ * KDE SSL Information Dialog
+ *
+ * This class creates a dialog that can be used to display information about
+ * an SSL session.
+ *
+ * There are NO GUARANTEES that KSslInfoDialog will remain binary compatible/
+ * Contact staikos@kde.org for details if needed.
+ *
+ * @author George Staikos <staikos@kde.org>
+ * @see KSSL
+ * @short KDE SSL Information Dialog
+ */
+class KDE_EXPORT KSslInfoDialog : public KDialog {
+	Q_OBJECT
+public:
+	/**
+	 *  Construct a KSSL Information Dialog
+	 *
+	 *  @param parent the parent widget
+	 */
+	explicit KSslInfoDialog(QWidget *parent = 0);
+
+	/**
+	 *  Destroy this dialog
+	 */
+	virtual ~KSslInfoDialog();
+
+	/**
+	 *  Tell the dialog if the connection has portions that may not be
+	 *  secure (ie. a mixture of secure and insecure frames)
+	 *
+	 *  @param isIt true if security is in question
+	 */
+	void setSecurityInQuestion(bool isIt);
+
+	/**
+	 *  Set information to display about the SSL connection.
+	 *
+	 *  @param certificateChain the certificate chain leading from the certificate
+     *         authority to the peer.
+	 *  @param ip the ip of the remote host
+	 *  @param host the remote hostname
+     *  @param sslProtocol the version of SSL in use (SSLv2, SSLv3, TLSv1)
+	 *  @param cipher the cipher in use
+	 *  @param usedBits the used bits of the key
+	 *  @param bits the key size of the cipher in use
+	 *  @param validationErrors errors validating the certificates, if any
+	 */
+	void setSslInfo(const QList<QSslCertificate> &certificateChain,
+			        const QString &ip, const QString &host,
+			        const QString &sslProtocol, const QString &cipher,
+                    int usedBits, int bits,
+			        const QList<QList<KSslError::Error> > &validationErrors);
+
+    void setMainPartEncrypted(bool);
+    void setAuxiliaryPartsEncrypted(bool);
+
+    static QList<QList<KSslError::Error> > errorsFromString(const QString &s);
+
+private Q_SLOTS:
+	void launchConfig();
+	void displayFromChain(int);
+
+private:
+    void updateWhichPartsEncrypted();
+
+    class KSslInfoDialogPrivate;
+    KSslInfoDialogPrivate* const d;
+};
+
+#endif // SSLINFODIALOG_P_H
Index: part/includes/CMakeLists.txt
===================================================================
--- part/includes/CMakeLists.txt	(revision 957817)
+++ part/includes/CMakeLists.txt	(revision 1043437)
@@ -1,4 +1,3 @@
 install(FILES
     WebKitPart
-    WebView
     DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/WebKitPart COMPONENT Devel)
Index: part/webkitpart_ext.cpp
===================================================================
--- part/webkitpart_ext.cpp	(revision 0)
+++ part/webkitpart_ext.cpp	(revision 1043437)
@@ -0,0 +1,370 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "webkitpart_ext.h"
+
+#include "webview.h"
+#include "webkitpart.h"
+#include "settings/webkitsettings.h"
+
+#include <KDE/KUriFilterData>
+#include <KDE/KDesktopFile>
+#include <KDE/KConfigGroup>
+#include <KDE/KTemporaryFile>
+#include <KDE/KToolInvocation>
+#include <KDE/KFileDialog>
+#include <KDE/KIO/NetAccess>
+#include <KDE/KGlobal>
+#include <KDE/KSharedConfig>
+#include <KDE/KRun>
+#include <KDE/KDebug>
+
+#include <QtCore/QPointer>
+#include <QtGui/QClipboard>
+#include <QtGui/QApplication>
+#include <QtGui/QPrintPreviewDialog>
+#include <QtWebKit/QWebFrame>
+
+
+class WebKitBrowserExtension::WebKitBrowserExtensionPrivate
+{
+ public:
+    QPointer<WebKitPart> part;
+    QPointer<WebView> view;
+};
+
+WebKitBrowserExtension::WebKitBrowserExtension(WebKitPart *parent)
+                       :KParts::BrowserExtension(parent),
+                        d (new WebKitBrowserExtensionPrivate)
+{
+    d->part = parent;
+    d->view = qobject_cast<WebView*>(parent->view());
+
+    enableAction("cut", false);
+    enableAction("copy", false);
+    enableAction("paste", false);
+    enableAction("print", true);
+}
+
+WebKitBrowserExtension::~WebKitBrowserExtension()
+{
+    delete d;
+}
+
+void WebKitBrowserExtension::saveState(QDataStream &stream)
+{
+    stream << d->part->url() << (qint32)xOffset() << (qint32)yOffset();
+}
+
+void WebKitBrowserExtension::restoreState(QDataStream &stream)
+{  
+    KUrl u;
+    qint32 xOfs, yOfs;
+    stream >> u >> xOfs >> yOfs;
+
+    KParts::OpenUrlArguments args;
+    args.setXOffset(xOfs);
+    args.setYOffset(yOfs);
+    args.metaData().insert("restore-state", QString());
+
+    d->part->setArguments(args);
+    d->part->openUrl(u);
+}
+
+void WebKitBrowserExtension::cut()
+{
+    if (d->view)
+        d->view->page()->triggerAction(QWebPage::Cut);
+}
+
+void WebKitBrowserExtension::copy()
+{
+    if (d->view)
+        d->view->page()->triggerAction(QWebPage::Copy);
+}
+
+void WebKitBrowserExtension::paste()
+{
+    if (d->view)
+        d->view->page()->triggerAction(QWebPage::Paste);
+}
+
+void WebKitBrowserExtension::slotSaveDocument()
+{
+    if (d->view)
+        emit saveUrl(d->view->url());
+}
+
+void WebKitBrowserExtension::slotSaveFrame()
+{
+    if (d->view)
+        emit saveUrl(d->view->page()->currentFrame()->url());
+}
+
+void WebKitBrowserExtension::print()
+{
+    if (d->view) {
+        QPrintPreviewDialog dlg(d->view);
+        connect(&dlg, SIGNAL(paintRequested(QPrinter *)),
+                d->view, SLOT(print(QPrinter *)));
+        dlg.exec();
+    }
+}
+
+void WebKitBrowserExtension::printFrame()
+{
+    if (d->view) {
+        QPrintPreviewDialog dlg(d->view);
+        connect(&dlg, SIGNAL(paintRequested(QPrinter *)),
+                d->view->page()->currentFrame(), SLOT(print(QPrinter *)));
+        dlg.exec();
+    }
+}
+
+void WebKitBrowserExtension::updateEditActions()
+{
+    if (d->view) {
+        QWebPage *page = d->view->page();
+        enableAction("cut", page->action(QWebPage::Cut));
+        enableAction("copy", page->action(QWebPage::Copy));
+        enableAction("paste", page->action(QWebPage::Paste));
+    }
+}
+
+void WebKitBrowserExtension::searchProvider()
+{
+    if (d->view) {
+        // action name is of form "previewProvider[<searchproviderprefix>:]"
+        const QString searchProviderPrefix = QString(sender()->objectName()).mid(14);
+
+        const QString text = d->view->page()->selectedText();
+        KUriFilterData data;
+        QStringList list;
+        data.setData(searchProviderPrefix + text);
+        list << "kurisearchfilter" << "kuriikwsfilter";
+
+        if (!KUriFilter::self()->filterUri(data, list)) {
+            KDesktopFile file("services", "searchproviders/google.desktop");
+            const QString encodedSearchTerm = QUrl::toPercentEncoding(text);
+            KConfigGroup cg(file.desktopGroup());
+            data.setData(cg.readEntry("Query").replace("\\{@}", encodedSearchTerm));
+        }
+
+        KParts::BrowserArguments browserArgs;
+        browserArgs.frameName = "_blank";
+
+        emit openUrlRequest(data.uri(), KParts::OpenUrlArguments(), browserArgs);
+    }
+}
+
+void WebKitBrowserExtension::reparseConfiguration()
+{
+    // Force the configuration stuff to repase...
+    WebKitSettings::self()->init();
+}
+
+void WebKitBrowserExtension::zoomIn()
+{  
+    if (d->view)
+#if QT_VERSION >= 0x040500
+        d->view->setZoomFactor(d->view->zoomFactor() + 0.1);
+#else
+        d->view->setTextSizeMultiplier(d->view->textSizeMultiplier() + 0.1);
+#endif
+}
+
+void WebKitBrowserExtension::zoomOut()
+{
+    if (d->view)
+#if QT_VERSION >= 0x040500
+        d->view->setZoomFactor(d->view->zoomFactor() - 0.1);
+#else
+        d->view->setTextSizeMultiplier(d->view->textSizeMultiplier() - 0.1);
+#endif
+}
+
+void WebKitBrowserExtension::zoomNormal()
+{
+    if (d->view)
+#if QT_VERSION >= 0x040500
+        d->view->setZoomFactor(1);
+#else
+        d->view->setTextSizeMultiplier(1);
+#endif
+}
+
+void WebKitBrowserExtension::toogleZoomTextOnly()
+{
+#if QT_VERSION >= 0x040500
+    if (d->view) {
+        KConfigGroup cgHtml(KGlobal::config(), "HTML Settings");
+        bool zoomTextOnly = cgHtml.readEntry( "ZoomTextOnly", false );
+        cgHtml.writeEntry("ZoomTextOnly", !zoomTextOnly);
+        KGlobal::config()->reparseConfiguration();
+
+        d->view->settings()->setAttribute(QWebSettings::ZoomTextOnly, !zoomTextOnly);
+    }
+#endif
+}
+
+void WebKitBrowserExtension::slotSelectAll()
+{
+#if QT_VERSION >= 0x040500
+    if (d->view)
+        d->view->page()->triggerAction(QWebPage::SelectAll);
+#endif
+}
+
+void WebKitBrowserExtension::slotFrameInWindow()
+{
+    if (d->view) {
+        KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
+        args.metaData()["referrer"] = d->view->contextMenuResult().linkText();
+        args.metaData()["forcenewwindow"] = "true";
+        emit createNewWindow(d->view->contextMenuResult().linkUrl(), args);
+    }
+}
+
+void WebKitBrowserExtension::slotFrameInTab()
+{
+    if (d->view) {
+        KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
+        args.metaData()["referrer"] = d->view->contextMenuResult().linkText();
+        KParts::BrowserArguments browserArgs;//( d->m_khtml->browserExtension()->browserArguments() );
+        browserArgs.setNewTab(true);
+        emit createNewWindow(d->view->contextMenuResult().linkUrl(), args, browserArgs);
+    }
+}
+
+void WebKitBrowserExtension::slotFrameInTop()
+{
+    if (d->view) {
+        KParts::OpenUrlArguments args;// = d->m_khtml->arguments();
+        args.metaData()["referrer"] = d->view->contextMenuResult().linkText();
+        KParts::BrowserArguments browserArgs;//( d->m_khtml->browserExtension()->browserArguments() );
+        browserArgs.frameName = "_top";
+        emit openUrlRequest(d->view->contextMenuResult().linkUrl(), args, browserArgs);
+    }
+}
+
+void WebKitBrowserExtension::slotSaveImageAs()
+{
+    if (d->view) {
+        QList<KUrl> urls;
+        urls.append(d->view->contextMenuResult().imageUrl());
+        const int nbUrls = urls.count();
+        for (int i = 0; i != nbUrls; i++) {
+            QString file = KFileDialog::getSaveFileName(KUrl(), QString(), d->part->widget());
+            KIO::NetAccess::file_copy(urls.at(i), file, d->part->widget());
+        }
+    }
+}
+
+void WebKitBrowserExtension::slotSendImage()
+{
+    if (d->view) {
+        QStringList urls;
+        urls.append(d->view->contextMenuResult().imageUrl().path());
+        const QString subject = d->view->contextMenuResult().imageUrl().path();
+        KToolInvocation::invokeMailer(QString(), QString(), QString(), subject,
+                                      QString(), //body
+                                      QString(),
+                                      urls); // attachments
+    }
+}
+
+void WebKitBrowserExtension::slotCopyImage()
+{
+    if (d->view) {
+        KUrl safeURL(d->view->contextMenuResult().imageUrl());
+        safeURL.setPass(QString());
+
+        // Set it in both the mouse selection and in the clipboard
+        QMimeData* mimeData = new QMimeData;
+        mimeData->setImageData(d->view->contextMenuResult().pixmap());
+        safeURL.populateMimeData(mimeData);
+        QApplication::clipboard()->setMimeData(mimeData, QClipboard::Clipboard);
+
+        mimeData = new QMimeData;
+        mimeData->setImageData(d->view->contextMenuResult().pixmap());
+        safeURL.populateMimeData(mimeData);
+        QApplication::clipboard()->setMimeData(mimeData, QClipboard::Selection);
+    }
+}
+
+void WebKitBrowserExtension::slotViewImage()
+{
+    if (d->view) {
+        KParts::OpenUrlArguments args;
+        args.metaData()["referrer"] = d->view->contextMenuResult().linkText();
+        emit createNewWindow(d->view->contextMenuResult().imageUrl(), args);
+    }
+}
+
+void WebKitBrowserExtension::slotCopyLinkLocation()
+{
+    if (d->view) {
+        KUrl safeURL(d->view->contextMenuResult().linkUrl());
+        safeURL.setPass(QString());
+        // Set it in both the mouse selection and in the clipboard
+        QMimeData* mimeData = new QMimeData;
+        safeURL.populateMimeData(mimeData);
+        QApplication::clipboard()->setMimeData(mimeData, QClipboard::Clipboard);
+
+        mimeData = new QMimeData;
+        safeURL.populateMimeData(mimeData);
+        QApplication::clipboard()->setMimeData(mimeData, QClipboard::Selection);
+    }
+}
+
+void WebKitBrowserExtension::slotSaveLinkAs()
+{
+    if (d->view)
+        emit saveUrl(d->view->contextMenuResult().linkUrl());
+}
+
+void WebKitBrowserExtension::slotViewDocumentSource()
+{
+    if (d->view) {
+        //TODO test http requests
+        KUrl currentUrl(d->view->page()->mainFrame()->url());
+        bool isTempFile = false;
+    #if 0
+        if (!(currentUrl.isLocalFile())/* && KHTMLPageCache::self()->isComplete(d->m_cacheId)*/) { //TODO implement
+            KTemporaryFile sourceFile;
+    //         sourceFile.setSuffix(defaultExtension());
+            sourceFile.setAutoRemove(false);
+            if (sourceFile.open()) {
+    //             QDataStream stream (&sourceFile);
+    //             KHTMLPageCache::self()->saveData(d->m_cacheId, &stream);
+                currentUrl = KUrl();
+                currentUrl.setPath(sourceFile.fileName());
+                isTempFile = true;
+            }
+        }
+    #endif
+
+        KRun::runUrl(currentUrl, QLatin1String("text/plain"), d->view, isTempFile);
+    }
+}
+
+#include "webkitpart_ext.moc"
Index: part/ui/searchbar.h
===================================================================
--- part/ui/searchbar.h	(revision 0)
+++ part/ui/searchbar.h	(revision 1043437)
@@ -0,0 +1,70 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2008 Laurent Montel <montel@kde.org>
+ * Copyright 2008 Benjamin C. Meyer <ben@meyerhome.net>
+ * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef SEARCHBAR_P_H
+#define SEARCHBAR_P_H
+
+#include <QWidget>
+
+#include "ui_searchbar.h"
+
+
+namespace KDEPrivate {
+
+/**
+ * This is the widget that shows up when the search is initiated.
+ */
+class SearchBar : public QWidget
+{
+    Q_OBJECT
+
+public:
+    SearchBar(QWidget *parent = 0);
+    ~SearchBar();
+
+    QString searchText() const;
+    bool caseSensitive() const;
+    void setFoundMatch(bool match);
+    void setSearchText(const QString&);
+
+public Q_SLOTS:
+    void show();
+    void hide();
+    void clear();
+    void findNext();
+    void findPrevious();
+
+Q_SIGNALS:
+    void searchTextChanged(const QString& text, bool backward = false);
+
+private Q_SLOTS:
+    void searchAsYouTypeChanged(bool);
+
+private:
+    class SearchBarPrivate;
+    SearchBarPrivate* d;
+};
+
+}
+
+#endif // SEARCHBAR_P_H

Property changes on: part/ui/searchbar.h
___________________________________________________________________
Added: svn:mergeinfo

Index: part/ui/searchbar.ui
===================================================================
--- part/ui/searchbar.ui	(revision 0)
+++ part/ui/searchbar.ui	(revision 1043437)
@@ -0,0 +1,143 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>SearchBar</class>
+ <widget class="QWidget" name="SearchBar">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>582</width>
+    <height>34</height>
+   </rect>
+  </property>
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Preferred" vsizetype="Maximum">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <layout class="QHBoxLayout" name="horizontalLayout">
+   <item>
+    <widget class="QToolButton" name="closeButton">
+     <property name="toolTip">
+      <string>Close the search bar</string>
+     </property>
+     <property name="shortcut">
+      <string>Esc</string>
+     </property>
+     <property name="autoRaise">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QLabel" name="searchInfo">
+     <property name="text">
+      <string>&amp;Find:</string>
+     </property>
+     <property name="buddy">
+      <cstring>searchLineEdit</cstring>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="KLineEdit" name="searchLineEdit">
+     <property name="toolTip">
+      <string>Enter the text to search for here</string>
+     </property>
+     <property name="showClearButton" stdset="0">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QToolButton" name="nextButton">
+     <property name="toolTip">
+      <string>Find the next match for the current search phrase</string>
+     </property>
+     <property name="text">
+      <string>&amp;Next</string>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QToolButton" name="previousButton">
+     <property name="toolTip">
+      <string>Find the previous match for the current search phrase</string>
+     </property>
+     <property name="text">
+      <string>&amp;Previous</string>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QToolButton" name="optionsButton">
+     <property name="toolTip">
+      <string>Find the previous match for the current search phrase</string>
+     </property>
+     <property name="text">
+      <string>&amp;Options</string>
+     </property>
+     <property name="popupMode">
+      <enum>QToolButton::InstantPopup</enum>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <spacer name="horizontalSpacer">
+     <property name="orientation">
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>26</width>
+       <height>20</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+  <action name="actionMatchCase">
+   <property name="text">
+    <string>&amp;Match Case</string>
+   </property>
+  </action>
+  <action name="actionSearchAutomatically">
+   <property name="checkable">
+    <bool>true</bool>
+   </property>
+   <property name="checked">
+    <bool>true</bool>
+   </property>
+   <property name="text">
+    <string>&amp;Search As You Type</string>
+   </property>
+  </action>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KLineEdit</class>
+   <extends>QLineEdit</extends>
+   <header>klineedit.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>closeButton</sender>
+   <signal>clicked()</signal>
+   <receiver>SearchBar</receiver>
+   <slot>hide()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>16</x>
+     <y>16</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>290</x>
+     <y>16</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Property changes on: part/ui/searchbar.ui
___________________________________________________________________
Added: svn:mergeinfo

Index: part/ui/searchbar.cpp
===================================================================
--- part/ui/searchbar.cpp	(revision 0)
+++ part/ui/searchbar.cpp	(revision 1043437)
@@ -0,0 +1,179 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2008 Laurent Montel <montel@kde.org>
+ * Copyright (C) 2008 Benjamin C. Meyer <ben@meyerhome.net>
+ * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "ui_searchbar.h"
+#include "searchbar.h"
+
+#include <QResizeEvent>
+#include <QShortcut>
+
+#include <KDE/KColorScheme>
+#include <KDE/KDebug>
+#include <KDE/KIcon>
+#include <KDE/KLocalizedString>
+
+namespace KDEPrivate {
+
+class SearchBar::SearchBarPrivate
+{
+public:
+    SearchBarPrivate() {}
+
+    void init (SearchBar* searchBar)
+    {
+        ui.setupUi(searchBar);
+        ui.optionsButton->addAction(ui.actionMatchCase);
+        ui.optionsButton->addAction(ui.actionSearchAutomatically);
+        ui.closeButton->setIcon(KIcon("dialog-close"));
+        ui.previousButton->setIcon(KIcon("go-up-search"));
+        ui.previousButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
+        ui.nextButton->setIcon(KIcon("go-down-search"));
+        ui.nextButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
+        ui.searchInfo->setText(i18n("&Find:"));
+
+        connect(ui.actionSearchAutomatically, SIGNAL(triggered(bool)),
+                searchBar, SLOT(searchAsYouTypeChanged(bool)));
+        connect(ui.nextButton, SIGNAL(clicked()),
+                searchBar, SLOT(findNext()));
+        connect(ui.previousButton, SIGNAL(clicked()),
+                searchBar, SLOT(findPrevious()));
+        connect(ui.searchLineEdit, SIGNAL(returnPressed()),
+                searchBar, SLOT(findNext()));
+
+        //searchBar->setMinimumWidth(widget->minimumWidth());
+        //searchBar->setMaximumWidth(widget->maximumWidth());
+        //searchBar->setMinimumHeight(widget->minimumHeight());
+
+        // Update the state of the searchAsYouType option
+        searchBar->searchAsYouTypeChanged (ui.actionSearchAutomatically->isChecked());
+    }
+
+    Ui::SearchBar ui;
+};
+
+SearchBar::SearchBar(QWidget *parent)
+          :QWidget(parent)
+{
+    d = new SearchBarPrivate;
+    d->init(this);
+
+    // Start off hidden by default...
+    setVisible(false);
+}
+
+SearchBar::~SearchBar()
+{
+    delete d;
+}
+
+void SearchBar::clear()
+{
+    d->ui.searchLineEdit->clear();
+}
+
+void SearchBar::show()
+{
+    if (!isVisible()) {
+        QWidget::show();
+    }
+
+    if (!d->ui.searchLineEdit->hasFocus()) {
+        d->ui.searchLineEdit->selectAll();
+        d->ui.searchLineEdit->setFocus();
+    }
+}
+
+void SearchBar::hide()
+{
+    clear();
+    setFoundMatch(false);
+    QWidget::hide();
+}
+
+QString SearchBar::searchText() const
+{
+    return d->ui.searchLineEdit->text();
+}
+
+bool SearchBar::caseSensitive() const
+{
+    return d->ui.actionMatchCase->isChecked();
+}
+
+void SearchBar::setSearchText(const QString& text)
+{
+    d->ui.searchLineEdit->setText(text);
+}
+
+void SearchBar::setFoundMatch(bool match)
+{
+    QString styleSheet;
+
+    if (!d->ui.searchLineEdit->text().isEmpty()) {
+        KColorScheme::BackgroundRole bgColorScheme;
+
+        if (match)
+          bgColorScheme = KColorScheme::PositiveBackground;
+        else
+          bgColorScheme = KColorScheme::NegativeBackground;
+
+        KStatefulBrush bgBrush(KColorScheme::View, bgColorScheme);
+
+        styleSheet = QString("QLineEdit{ background-color:%1 }")
+                     .arg(bgBrush.brush(d->ui.searchLineEdit).color().name());
+    }
+
+    d->ui.searchLineEdit->setStyleSheet(styleSheet);
+}
+
+void SearchBar::searchAsYouTypeChanged(bool checked)
+{
+    if (checked) {
+        connect(d->ui.searchLineEdit, SIGNAL(textEdited(const QString&)),
+                this, SIGNAL(searchTextChanged(const QString&)));
+    } else {
+        disconnect(d->ui.searchLineEdit, SIGNAL(textEdited(const QString&)),
+                   this, SIGNAL(searchTextChanged(const QString&)));
+    }
+}
+
+void SearchBar::findNext()
+{
+    if (!isVisible())
+        return;
+
+    emit searchTextChanged(d->ui.searchLineEdit->text());
+}
+
+void SearchBar::findPrevious()
+{
+    if (!isVisible())
+        return;
+
+    emit searchTextChanged(d->ui.searchLineEdit->text(), true);
+}
+
+}
+
+#include "searchbar.moc"

Property changes on: part/ui/searchbar.cpp
___________________________________________________________________
Added: svn:mergeinfo

Index: part/CMakeLists.txt
===================================================================
--- part/CMakeLists.txt	(revision 957817)
+++ part/CMakeLists.txt	(revision 1043437)
@@ -15,13 +15,22 @@
 
 set(webkitkde_LIB_SRCS
     webkitpart.cpp
+    webkitpart_ext.cpp
     webview.cpp
     webpage.cpp
+    websslinfo.cpp
+    ui/searchbar.cpp
+    settings/webkitsettings.cpp
+    settings/khtml_filter.cpp
 )
 
+kde4_add_ui_files(webkitkde_LIB_SRCS
+    ui/searchbar.ui
+)
+
 kde4_add_library(webkitkde SHARED ${webkitkde_LIB_SRCS})
 
-target_link_libraries(webkitkde ${KDEWEBKIT_LIBRARIES} ${KDE4_KPARTS_LIBS} ${QT_QTWEBKIT_LIBRARY})
+target_link_libraries(webkitkde ${KDEWEBKIT_LIBRARIES} ${KDE4_KPARTS_LIBS} ${QT_QTWEBKIT_LIBRARY} ${QT_QTUITOOLS_LIBRARY})
 
 set_target_properties(webkitkde PROPERTIES VERSION 1.0.0 SOVERSION 1)
 
@@ -35,7 +44,6 @@
 install(FILES
     webkitkde_export.h
     webkitpart.h
-    webview.h
     DESTINATION ${INCLUDE_INSTALL_DIR}/webkitkde/ COMPONENT Devel)
 
 install(TARGETS webkitkdepart DESTINATION ${PLUGIN_INSTALL_DIR})
Index: scripts/codingstyle.sh
===================================================================
--- scripts/codingstyle.sh	(revision 0)
+++ scripts/codingstyle.sh	(revision 1043437)
@@ -0,0 +1,19 @@
+#!/bin/sh
+#
+# Kdelibs coding style is defined in http://techbase.kde.org/Policies/Kdelibs_Coding_Style 
+#
+
+PWD=$(pwd)
+cd $PWD
+
+echo "Applying astyle rules..."
+astyle -v --indent=spaces=4 \
+       --brackets=linux \
+       --indent-labels \
+       --pad=oper --unpad=paren \
+       --one-line=keep-statements \
+       --convert-tabs --indent-preprocessor \
+       `find -type f -name '*.cpp' -or -name '*.h' -or -name '*.cc' | grep -Ev "\./.+/settings/"`
+
+echo "Done!"
+

Property changes on: scripts/codingstyle.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: kdewebkit/searchbar_p.h
===================================================================
--- kdewebkit/searchbar_p.h	(revision 957817)
+++ kdewebkit/searchbar_p.h	(revision 1043437)
@@ -1,79 +0,0 @@
-/*
- * This file is part of the KDE project.
- *
- * Copyright (C) 2008 Laurent Montel <montel@kde.org>
- * Copyright 2008 Benjamin C. Meyer <ben@meyerhome.net>
- * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- */
-
-#ifndef SEARCHBAR_P_H
-#define SEARCHBAR_P_H
-
-#include <QWidget>
-
-#include "ui_searchbar_p.h"
-
-class QTimeLine;
-class KWebView;
-
-namespace KDEPrivate {
-
-/**
- * This is the widget that shows up when the search is initiated.
- */
-class SearchBar : public QWidget
-{
-    Q_OBJECT
-
-public:
-    SearchBar(QWidget *parent = 0);
-    ~SearchBar();
-
-    QString searchText() const;
-    bool caseSensitive() const;
-    void setFoundMatch(bool match);
-
-public Q_SLOTS:
-    void clear();
-    void show();
-    void hide();
-
-protected:
-    void resizeEvent(QResizeEvent *event);
-
-Q_SIGNALS:
-    void searchChanged(const QString& text);
-    void closeClicked();
-    void findNextClicked();
-    void findPreviousClicked();
-
-private:
-    class SearchBarPrivate;
-    SearchBarPrivate* d;
-
-private Q_SLOTS:
-    void frameChanged(int frame);
-    void notifySearchChanged();
-    void slotHide();
-    void searchAsYouTypeChanged(int state);
-
-};
-
-}
-
-#endif // SEARCHBAR_P_H
Index: kdewebkit/searchbar_p.ui
===================================================================
--- kdewebkit/searchbar_p.ui	(revision 957817)
+++ kdewebkit/searchbar_p.ui	(revision 1043437)
@@ -1,117 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>SearchBar</class>
- <widget class="QWidget" name="SearchBar">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>464</width>
-    <height>31</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Preferred" vsizetype="Minimum">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <layout class="QHBoxLayout" name="horizontalLayout">
-   <property name="leftMargin">
-    <number>6</number>
-   </property>
-   <property name="topMargin">
-    <number>0</number>
-   </property>
-   <property name="rightMargin">
-    <number>6</number>
-   </property>
-   <property name="bottomMargin">
-    <number>0</number>
-   </property>
-   <item>
-    <widget class="QToolButton" name="closeButton">
-     <property name="toolTip">
-      <string>Close the search bar</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QLabel" name="searchInfo">
-     <property name="text">
-      <string>Text to find:</string>
-     </property>
-     <property name="buddy">
-      <cstring>searchLineEdit</cstring>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="KLineEdit" name="searchLineEdit">
-     <property name="toolTip">
-      <string>Enter the text to search for here</string>
-     </property>
-     <property name="showClearButton" stdset="0">
-      <bool>true</bool>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QToolButton" name="nextButton">
-     <property name="toolTip">
-      <string>Find the next match for the current search phrase</string>
-     </property>
-     <property name="text">
-      <string>&amp;Next</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QToolButton" name="previousButton">
-     <property name="toolTip">
-      <string>Find the previous match for the current search phrase</string>
-     </property>
-     <property name="text">
-      <string>&amp;Previous</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QCheckBox" name="matchCaseCheckBox">
-     <property name="text">
-      <string>Match Case</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QCheckBox" name="searchAsYouType">
-     <property name="text">
-      <string>Search Automatically</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <spacer name="horizontalSpacer">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>26</width>
-       <height>20</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-  </layout>
- </widget>
- <customwidgets>
-  <customwidget>
-   <class>KLineEdit</class>
-   <extends>QLineEdit</extends>
-   <header>klineedit.h</header>
-  </customwidget>
- </customwidgets>
- <resources/>
- <connections/>
-</ui>
Index: kdewebkit/searchbar_p.cpp
===================================================================
--- kdewebkit/searchbar_p.cpp	(revision 957817)
+++ kdewebkit/searchbar_p.cpp	(revision 1043437)
@@ -1,188 +0,0 @@
-/*
- * This file is part of the KDE project.
- *
- * Copyright (C) 2008 Laurent Montel <montel@kde.org>
- * Copyright 2008 Benjamin C. Meyer <ben@meyerhome.net>
- * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#include "searchbar_p.h"
-
-#include <QResizeEvent>
-#include <QShortcut>
-#include <QTimeLine>
-
-#include <KColorScheme>
-
-namespace KDEPrivate {
-
-class SearchBar::SearchBarPrivate {
-public:
-      SearchBarPrivate(SearchBar* searchBar, QWidget* widget, QTimeLine* timeLine)
-      : widget(widget), timeLine(timeLine), m_searchBar(searchBar) {}
-    void initializeSearchWidget() {
-        widget = new QWidget(m_searchBar);
-        widget->setContentsMargins(0, 0, 0, 0);
-        ui.setupUi(widget);
-        ui.closeButton->setIcon(KIcon("dialog-close"));
-        ui.previousButton->setIcon(KIcon("go-up-search"));
-        ui.previousButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
-        ui.nextButton->setIcon(KIcon("go-down-search"));
-        ui.nextButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
-        ui.searchInfo->setText(QString());
-        if (ui.searchAsYouType->checkState() == Qt::Checked) {
-        connect(ui.searchLineEdit, SIGNAL(textChanged(const QString&)),
-                m_searchBar, SIGNAL(searchChanged(const QString&)));
-        }
-        connect(ui.searchAsYouType, SIGNAL(stateChanged(int)), m_searchBar, SLOT(searchAsYouTypeChanged(int)));
-        connect(ui.nextButton, SIGNAL(clicked()),
-                m_searchBar, SIGNAL(findNextClicked()));
-        connect(ui.previousButton, SIGNAL(clicked()),
-                m_searchBar, SIGNAL(findPreviousClicked()));
-        connect(ui.searchLineEdit, SIGNAL(returnPressed()),
-                m_searchBar, SIGNAL(findNextClicked()));
-        connect(ui.closeButton, SIGNAL(clicked()),
-                m_searchBar, SLOT(hide()));
-        m_searchBar->setMinimumWidth(widget->minimumWidth());
-        m_searchBar->setMaximumWidth(widget->maximumWidth());
-        m_searchBar->setMinimumHeight(widget->minimumHeight());
-    }
-    Ui::SearchBar ui;
-    QWidget *widget;
-    QTimeLine *timeLine;
-private:
-    SearchBar* m_searchBar;
-};
-
-SearchBar::SearchBar(QWidget *parent)
-    : QWidget(parent)
-{
-    d = new SearchBarPrivate(this, 0, new QTimeLine(150, this));
-    d->initializeSearchWidget();
-
-    // we start off hidden
-    setMaximumHeight(0);
-    d->widget->setGeometry(0, -1 * d->widget->height(),
-                          d->widget->width(), d->widget->height());
-    QWidget::hide();
-
-    connect(d->timeLine, SIGNAL(frameChanged(int)),
-            this, SLOT(frameChanged(int)));
-    connect(this, SIGNAL(closeClicked()), this, SLOT(hide()));
-
-    new QShortcut(QKeySequence(Qt::Key_Escape), this, SLOT(hide()));
-}
-
-SearchBar::~SearchBar()
-{
-    delete d;
-}
-
-void SearchBar::clear()
-{
-    d->ui.searchLineEdit->setText(QString());
-}
-
-void SearchBar::show()
-{
-    if (isVisible())
-        return;
-
-    QWidget::show();
-    d->ui.searchLineEdit->setFocus();
-    d->ui.searchLineEdit->selectAll();
-
-    d->timeLine->setFrameRange(-1 * d->widget->height(), 0);
-    d->timeLine->setDirection(QTimeLine::Forward);
-    disconnect(d->timeLine, SIGNAL(finished()),
-               this, SLOT(slotHide()));
-    d->timeLine->start();
-}
-
-void SearchBar::resizeEvent(QResizeEvent *event)
-{
-    if (event->size().width() != d->widget->width())
-        d->widget->resize(event->size().width(), d->widget->height());
-    QWidget::resizeEvent(event);
-}
-
-void SearchBar::hide()
-{
-    d->timeLine->setDirection(QTimeLine::Backward);
-    d->timeLine->start();
-    connect(d->timeLine, SIGNAL(finished()), this, SLOT(slotHide()));
-}
-
-void SearchBar::slotHide()
-{
-    QWidget::hide();
-}
-
-void SearchBar::frameChanged(int frame)
-{
-    if (!d->widget)
-        return;
-    d->widget->move(0, frame);
-    const int height = qMax(0, d->widget->y() + d->widget->height());
-    setMinimumHeight(height);
-    setMaximumHeight(height);
-}
-
-void SearchBar::notifySearchChanged()
-{
-    emit searchChanged(searchText());
-}
-
-QString SearchBar::searchText() const
-{
-    return d->ui.searchLineEdit->text();
-}
-
-bool SearchBar::caseSensitive() const
-{
-    return d->ui.matchCaseCheckBox->isChecked();
-}
-
-void SearchBar::setFoundMatch(bool match)
-{
-    if (!match && !searchText().isEmpty()) {
-        KStatefulBrush backgroundBrush(KColorScheme::View, KColorScheme::NegativeBackground);
-
-        QString styleSheet = QString("QLineEdit{ background-color:%1 }")
-                             .arg(backgroundBrush.brush(d->ui.searchLineEdit).color().name());
-
-        d->ui.searchLineEdit->setStyleSheet(styleSheet);
-    } else {
-        d->ui.searchLineEdit->setStyleSheet(QString());
-    }
-}
-void SearchBar::searchAsYouTypeChanged(int state)
-{
-    if (state == 0) {
-        disconnect(d->ui.searchLineEdit, SIGNAL(textChanged(const QString&)),
-                   this, SIGNAL(searchChanged(const QString&)));
-    } else {
-        connect(d->ui.searchLineEdit, SIGNAL(textChanged(const QString&)),
-               this, SIGNAL(searchChanged(const QString&)));
-    }
-}
-
-}
-
-#include "searchbar_p.moc"
Index: kdewebkit/kdewebkit_export.h
===================================================================
--- kdewebkit/kdewebkit_export.h	(revision 0)
+++ kdewebkit/kdewebkit_export.h	(revision 1043437)
@@ -0,0 +1,43 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Urs Wolfer <uwolfer @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef KDEWEBKIT_EXPORT_H
+#define KDEWEBKIT_EXPORT_H
+
+/* needed for KDE_EXPORT and KDE_IMPORT macros */
+#include <kdemacros.h>
+
+#ifndef KDEWEBKIT_EXPORT
+# if defined(MAKE_KDEWEBKIT_LIB)
+   /* We are building this library */ 
+#  define KDEWEBKIT_EXPORT KDE_EXPORT
+# else
+   /* We are using this library */ 
+#  define KDEWEBKIT_EXPORT KDE_IMPORT
+# endif
+#endif
+
+# ifndef KDEWEBKIT_EXPORT_DEPRECATED
+#  define KDEWEBKIT_EXPORT_DEPRECATED KDE_DEPRECATED KDEWEBKIT_EXPORT
+# endif
+
+#endif // KDEWEBKIT_EXPORT_H
Index: kdewebkit/kwebpluginfactory.cpp
===================================================================
--- kdewebkit/kwebpluginfactory.cpp	(revision 957817)
+++ kdewebkit/kwebpluginfactory.cpp	(revision 1043437)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2008 Michael Howell <mhowell123@gmail.com>
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -24,95 +25,136 @@
 #include "kwebpluginfactory.h"
 #include "kwebpage.h"
 
+#include <kparts/part.h>
+#include <kmimetypetrader.h>
+#include <kservicetypetrader.h>
+#include <kmimetype.h>
+#include <kdebug.h>
+
 #include <QWebPluginFactory>
 #include <QWebView>
+#include <QWebFrame>
 #include <QStringList>
+#include <QList>
+#include <QListIterator>
 
-#include <KParts/ReadOnlyPart>
-#include <KMimeTypeTrader>
-#include <KServiceTypeTrader>
-#include <KMimeType>
-#include <KDebug>
+#define QL1(x)  QLatin1String(x)
 
+
 class KWebPluginFactory::KWebPluginFactoryPrivate
 {
 public:
-    KWebPluginFactoryPrivate(QWebPluginFactory *del) : delegate(del) {}
+    QStringList supportedMimeTypes;
     QList<KWebPluginFactory::Plugin> plugins;
-    QWebPluginFactory *delegate;
 };
 
 KWebPluginFactory::KWebPluginFactory(QObject *parent)
-  : QWebPluginFactory(parent)
-    , d(new KWebPluginFactory::KWebPluginFactoryPrivate(0))
+                  :QWebPluginFactory(parent),
+                   d(new KWebPluginFactory::KWebPluginFactoryPrivate)
 {
 }
 
-KWebPluginFactory::KWebPluginFactory(QWebPluginFactory *delegate, QObject *parent)
-  : QWebPluginFactory(parent)
-    , d(new KWebPluginFactory::KWebPluginFactoryPrivate(delegate))
+KWebPluginFactory::~KWebPluginFactory()
 {
+  delete d;
 }
 
-KWebPluginFactory::~KWebPluginFactory()
+QObject* KWebPluginFactory::create(const QString& _mimeType, const QUrl& url, const QStringList& argumentNames, const QStringList& argumentValues) const
 {
-    delete d;
-}
+    QString mimeType (_mimeType.trimmed());
 
-QObject* KWebPluginFactory::create(const QString& mimeType, const QUrl& url, const QStringList& argumentNames, const QStringList& argumentValues) const
-{
-    if (d->delegate) {
-        QObject* q = d->delegate->create(mimeType, url, argumentNames, argumentValues);
-        if (q) return q;
+    /*
+       HACK: This is a big time hack to determine the mime-type from the url
+       when no mime-type is provided. Since we do not want to make async calls,
+       (e.g. KIO::mimeType) here, we resort to the hack below to determine the
+       mime-type it from the request's filename.
+
+       NOTE: This hack is not full proof and might not always work. See the
+       KMimeType::findByPath docs for details. It is however the best option
+       to properly handle documents, images, and other resources embedded
+       into html content with the <embed> tag when they lack the "type"
+       attribute that specifies their mime-type.
+
+       See the sample file "embed_tag_test.html" in the tests folder.
+    */
+    if (mimeType.isEmpty()) {
+       KMimeType::Ptr ptr = KMimeType::findByPath(url.path());
+       mimeType = ptr->name();
+       kDebug() << "Changed mimetype from " << _mimeType << " to " << mimeType;
     }
-    QVariantList arguments;
-    int i = 0;
-    Q_FOREACH(const QString &key, argumentNames) {
-        arguments << key + "=\"" + argumentValues.at(i) + '\"';
-        ++i;
-    }
-//     arguments << "__KHTML__PLUGINEMBED=\"YES\""; //### following arguments are also set by khtml
-//     arguments << "__KHTML__PLUGINBASEURL=\"" + url.scheme() + "://" + url.host() + "/\"";
-//     arguments << "Browser/View";
 
-    KParts::ReadOnlyPart* part = KMimeTypeTrader::createPartInstanceFromQuery<KParts::ReadOnlyPart>(mimeType, qobject_cast<KWebPage*>(parent())->view(), parent(), QString(), arguments);
-    if (part) {
-        QMap<QString, QString> metaData = part->arguments().metaData();
-        metaData.insert("PropagateHttpHeader", "true");
-        metaData.insert("cross-domain", url.scheme() + "://" + url.host() + "/");
-        metaData.insert("main_frame_request", "TRUE");
-//         metaData.insert("referrer", url.scheme() + "://" + url.host() + "/"); //### following metadata is also set by khtml
-//         metaData.insert("ssl_activate_warnings", "TRUE");
-//         metaData.insert("ssl_parent_cert", "");
-//         metaData.insert("ssl_parent_ip", "");
-//         metaData.insert("ssl_was_in_use", "FALSE");
+    KParts::ReadOnlyPart* part = 0;
 
-        KParts::OpenUrlArguments openUrlArgs = part->arguments();
-        openUrlArgs.metaData() = metaData;
-        openUrlArgs.setMimeType(mimeType);
-        part->setArguments(openUrlArgs);
-        kDebug()<< part->arguments().metaData();
-        part->openUrl(url);
+    // Only attempt to find a KPart for the supported mime types...
+    if (d->supportedMimeTypes.contains(mimeType)) {
+
+        QVariantList arguments;
+        const int count = argumentNames.count();
+
+        for(int i = 0; i < count; ++i) {
+            arguments << argumentNames.at(i) + "=\"" + argumentValues.at(i) + '\"';
+            ++i;
+        }
+
+        KWebPage *page = qobject_cast<KWebPage*>(parent());
+        QWidget *view = 0;
+        if (page)
+          view = page->view();
+
+        part = KMimeTypeTrader::createPartInstanceFromQuery<KParts::ReadOnlyPart>(mimeType, view, parent(), QString(), arguments);
+
+        if (part) {
+            QMap<QString, QString> metaData = part->arguments().metaData();
+            QString urlStr = url.toString(QUrl::RemovePath | QUrl::RemoveQuery | QUrl::RemoveFragment);
+            metaData.insert("PropagateHttpHeader", "true");
+            metaData.insert("referrer", urlStr);
+            metaData.insert("cross-domain", urlStr);
+            metaData.insert("main_frame_request", "TRUE");
+            metaData.insert("ssl_activate_warnings", "TRUE");
+
+            const QString scheme = page->mainFrame()->url().scheme();
+            if (page && (QString::compare(scheme, QL1("https"), Qt::CaseInsensitive) == 0 ||
+                         QString::compare(scheme, QL1("webdavs"), Qt::CaseInsensitive) == 0))
+              metaData.insert("ssl_was_in_use", "TRUE");
+            else
+              metaData.insert("ssl_was_in_use", "FALSE");
+
+            KParts::OpenUrlArguments openUrlArgs = part->arguments();
+            openUrlArgs.metaData() = metaData;
+            openUrlArgs.setMimeType(mimeType);
+            part->setArguments(openUrlArgs);
+
+            kDebug() << part->arguments().metaData();
+            part->openUrl(url);
+        }
     }
+
     kDebug() << "Asked for" << mimeType << "plugin, got" << part;
-    if (!part) {
-        kDebug() << "No plugins found for" << mimeType;
-        kDebug() << "Trying a QWebView (known work-around for QtWebKit's built-in flash support).";
-        QWebView* webView = new QWebView;
-        webView->load(url);
-        return webView;
-    }
-    return part->widget();
+
+    if (part)
+      return part->widget();
+
+    return part;
 }
 
 QList<KWebPluginFactory::Plugin> KWebPluginFactory::plugins() const
 {
-    if (!d->plugins.isEmpty()) return d->plugins;
+    if (!d->plugins.isEmpty())
+      return d->plugins;
+
     QList<Plugin> plugins;
-    if (d->delegate) plugins = d->delegate->plugins();
+    QStringList supportedMimeTypes;
     KService::List services = KServiceTypeTrader::self()->query("KParts/ReadOnlyPart");
+
     for (int i = 0; i < services.size(); i++) {
         KService::Ptr s = services.at(i);
+        /*
+          NOTE: We skip over the part that handles Adobe Flash (nspluginpart)
+          here because it has issues when embeded into QtWebKit. Hence we defer
+          the handling of flash content to QtWebKit's own builtin flash viewer.
+        */
+        if (s->hasMimeType(KMimeType::mimeType("application/x-shockwave-flash").data()))
+          continue;
         Plugin plugin;
         plugin.name = s->desktopEntryName();
         plugin.description = s->comment();
@@ -123,13 +165,18 @@
             mime.name = servicetypes.at(z);
             KMimeType::Ptr kmime = KMimeType::mimeType(mime.name);
             if (kmime) {
-                mime.fileExtensions = kmime->patterns().replaceInStrings("*.","");
+                mime.fileExtensions = kmime->patterns().replaceInStrings("*.", "");
             }
             mimes.append(mime);
+            supportedMimeTypes << mime.name;
         }
+        //kDebug() << "Adding plugin: " << s->desktopEntryName() << servicetypes;
         plugins.append(plugin);
     }
+
     d->plugins = plugins;
+    d->supportedMimeTypes = supportedMimeTypes;
+
     return plugins;
 }
 
Index: kdewebkit/networkcookiejar_p.cpp
===================================================================
--- kdewebkit/networkcookiejar_p.cpp	(revision 0)
+++ kdewebkit/networkcookiejar_p.cpp	(revision 1043437)
@@ -0,0 +1,107 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "networkcookiejar_p.h"
+
+#include <kconfiggroup.h>
+#include <ksharedconfig.h>
+#include <kdebug.h>
+
+#include <QtCore/QUrl>
+#include <QtDBus/QDBusInterface>
+#include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusReply>
+
+
+namespace KDEPrivate {
+
+class NetworkCookieJar::CookieJarPrivate
+{
+public:
+  CookieJarPrivate(): windowId(-1), enabled(true) {}
+
+  qlonglong windowId;
+  bool enabled;
+};
+
+
+NetworkCookieJar::NetworkCookieJar(QObject* parent)
+                 :QNetworkCookieJar(parent), d(new NetworkCookieJar::CookieJarPrivate) {
+    reparseConfiguration();
+}
+
+NetworkCookieJar::~NetworkCookieJar() {
+    delete d;
+}
+
+qlonglong NetworkCookieJar::windowId() const {
+    return d->windowId;
+}
+
+QList<QNetworkCookie> NetworkCookieJar::cookiesForUrl(const QUrl &url) const {
+    QList<QNetworkCookie> cookieList;
+
+    if (d->enabled) {
+        QDBusInterface kcookiejar("org.kde.kded", "/modules/kcookiejar", "org.kde.KCookieServer");
+        QDBusReply<QString> reply = kcookiejar.call("findDOMCookies", url.toString(), d->windowId);
+
+        if (reply.isValid()) {
+            cookieList << reply.value().toUtf8();
+            //kDebug() << url.host() << reply.value();
+        } else {
+            kWarning() << "Unable to communicate with the cookiejar!";
+        }
+    }
+
+    return cookieList;
+}
+
+bool NetworkCookieJar::setCookiesFromUrl(const QList<QNetworkCookie> &cookieList, const QUrl &url) {
+    if (d->enabled) {
+        QDBusInterface kcookiejar("org.kde.kded", "/modules/kcookiejar", "org.kde.KCookieServer");
+
+        QByteArray cookieHeader;
+        Q_FOREACH(const QNetworkCookie &cookie, cookieList) {
+            cookieHeader = "Set-Cookie: ";
+            cookieHeader += cookie.toRawForm();
+            kcookiejar.call("addCookies", url.toString(), cookieHeader, d->windowId);
+            //kDebug() << "[" << d->windowId << "] Got Cookie: " << cookieHeader << " from " << url;
+        }
+
+        return !kcookiejar.lastError().isValid();
+    }
+
+    return false;
+}
+
+void NetworkCookieJar::setWindowId(qlonglong id) {
+    d->windowId = id;
+}
+
+void NetworkCookieJar::reparseConfiguration() {
+    KConfigGroup cfg = KSharedConfig::openConfig("kcookiejarrc", KConfig::NoGlobals)->group("Cookie Policy");
+    d->enabled = cfg.readEntry("Cookies", true);
+}
+
+}
+
+#include "networkcookiejar_p.moc"
Index: kdewebkit/kwebview.cpp
===================================================================
--- kdewebkit/kwebview.cpp	(revision 957817)
+++ kdewebkit/kwebview.cpp	(revision 1043437)
@@ -5,6 +5,7 @@
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Laurent Montel <montel@kde.org>
  * Copyright (C) 2008 Michael Howell <mhowell123@gmail.com>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -25,12 +26,14 @@
 
 #include "kwebview.h"
 #include "kwebpage.h"
-#include "searchbar_p.h"
 
-#include <KDE/KUrl>
-#include <KDE/KDebug>
-#include <kparts/part.h> // Where's the Qt includes?
+#include <kurl.h>
+#include <kdebug.h>
+#include <kio/global.h>
+#include <kparts/part.h>
 #include <kparts/browserextension.h>
+#include <kdeversion.h>
+#include <kurifilter.h>
 
 #include <QtGui/QApplication>
 #include <QtGui/QClipboard>
@@ -42,20 +45,15 @@
 {
 public:
     KWebViewPrivate()
-    : customContextMenu(false)
-    , keyboardModifiers(Qt::NoModifier)
-    , pressedButtons(Qt::NoButton)
-    , searchBar(0)
-    {}
-    bool customContextMenu;
+    : keyboardModifiers(Qt::NoModifier) , pressedButtons(Qt::NoButton) {}
+
     Qt::KeyboardModifiers keyboardModifiers;
     Qt::MouseButtons pressedButtons;
-    KDEPrivate::SearchBar *searchBar;
 };
 
 
 KWebView::KWebView(QWidget *parent)
-    : QWebView(parent), d(new KWebView::KWebViewPrivate())
+         :QWebView(parent), d(new KWebView::KWebViewPrivate())
 {
     setPage(new KWebPage(this));
 }
@@ -65,39 +63,27 @@
     delete d;
 }
 
-void KWebView::contextMenuEvent(QContextMenuEvent *event)
+bool KWebView::isExternalContentAllowed() const
 {
-    if (!d->customContextMenu) {
-        QWebView::contextMenuEvent(event);
-    } else {
-        emit showContextMenu(event);
-    }
+    KWebPage *webPage = qobject_cast<KWebPage*>(page());
+    if (webPage)
+        return webPage->isExternalContentAllowed();
+    return false;
 }
 
-void KWebView::setCustomContextMenu(bool show)
+void KWebView::setAllowExternalContent(bool allow)
 {
-    d->customContextMenu = show;
+    KWebPage *webPage = qobject_cast<KWebPage*>(page());
+    if (webPage)
+      webPage->setAllowExternalContent(allow);
 }
 
-KWebPage *KWebView::page()
-{
-    KWebPage *webPage = qobject_cast<KWebPage*>(QWebView::page());
-    if (!webPage) {
-        return 0;
-    }
-    return webPage;
-}
-
 void KWebView::wheelEvent(QWheelEvent *event)
 {
     if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
         const int numDegrees = event->delta() / 8;
         const int numSteps = numDegrees / 15;
-#if QT_VERSION < 0x040500
-        setTextSizeMultiplier(textSizeMultiplier() + numSteps * 0.1);
-#else
         setZoomFactor(zoomFactor() + numSteps * 0.1);
-#endif
         event->accept();
         return;
     }
@@ -113,83 +99,38 @@
 }
 
 void KWebView::mouseReleaseEvent(QMouseEvent *event)
-{
+{  
+
     const QWebHitTestResult result = page()->mainFrame()->hitTestContent(event->pos());
     const QUrl url = result.linkUrl();
-    if (!url.isEmpty() && ((d->pressedButtons & Qt::MidButton) || 
-        ((d->pressedButtons & Qt::LeftButton) && (d->keyboardModifiers & Qt::ControlModifier)))) {
-        kDebug() << "middle clicked or ctrl-clicked url" << url;
-        emit openUrlInNewTab(url);
-        return;
-    }
 
-    QWebView::mouseReleaseEvent(event);
+    if (url.isValid() && !url.isEmpty() && !url.scheme().isEmpty()) {
+        if ((d->pressedButtons & Qt::MidButton) ||
+            ((d->pressedButtons & Qt::LeftButton) && (d->keyboardModifiers & Qt::ControlModifier))) {
+          emit openUrlInNewWindow(url);
+          return;
+        }
 
-    // just leave if the site has not modified by the user (for example pasted text with mouse middle click)
-    if (!isModified() && d->pressedButtons & Qt::MidButton) {
-        const QString clipboardText(QApplication::clipboard()->text(QClipboard::Selection));
-        KUrl url(clipboardText);
-        if (!url.isEmpty() && url.isValid() && clipboardText.contains('.')) { // contains '.' -> domain
-            if (url.scheme().isEmpty()) {
-                url = "http://" + clipboardText;
-            }
-            emit openUrl(url);
+       if ((d->pressedButtons & Qt::LeftButton) && (d->keyboardModifiers & Qt::ShiftModifier)) {
+          emit saveUrl(url);
+          return;
         }
     }
-}
 
-QWidget *KWebView::searchBar()
-{
-    if (!d->searchBar) {
-        d->searchBar = new KDEPrivate::SearchBar;
-        kDebug() << "Created new SearchBar" << d->searchBar;
-        d->searchBar->setVisible(false);
+    const bool isAccepted = event->isAccepted();
+    page()->event(event);
 
-        connect(d->searchBar, SIGNAL(findNextClicked()), this, SLOT(slotFindNextClicked()));
-        connect(d->searchBar, SIGNAL(findPreviousClicked()),  this, SLOT(slotFindPreviousClicked()));
-        connect(d->searchBar, SIGNAL(searchChanged(const QString&)), this, SLOT(slotSearchChanged(const QString &)));
-        connect(this, SIGNAL(destroyed()), d->searchBar, SLOT(deleteLater()));
+    if (!event->isAccepted()) {
+        // Navigate to url in clipboard on middle mouse button click on the page...
+        if (!isModified() && (d->pressedButtons & Qt::MidButton)) {
+            QString clipboardText(QApplication::clipboard()->text(QClipboard::Selection).trimmed());
+            if (KUriFilter::self()->filterUri(clipboardText, QStringList() << "kshorturifilter")) {
+                kDebug() << "Navigating to" << clipboardText;
+                emit openUrl(KUrl(clipboardText));
+            }
+        }
     }
-    return d->searchBar;
-}
 
-void KWebView::slotFindPreviousClicked()
-{
-    resultSearch(KWebPage::FindBackward);
+    event->setAccepted(isAccepted);
+    QWebView::mouseReleaseEvent(event);
 }
-
-void KWebView::slotFindNextClicked()
-{
-    KWebPage::FindFlags flags;
-    resultSearch(flags);
-}
-
-void KWebView::slotSearchChanged(const QString & text)
-{
-    Q_UNUSED(text);
-    KWebPage::FindFlags flags;
-    resultSearch(flags);
-}
-
-void KWebView::resultSearch(KWebPage::FindFlags flags)
-{
-    if (d->searchBar->caseSensitive())
-        flags |= KWebPage::FindCaseSensitively;
-    const bool status = page()->findText(d->searchBar->searchText(), flags);
-    d->searchBar->setFoundMatch(status);
-}
-
-void KWebView::load(const KUrl &url, const KParts::OpenUrlArguments &args, const KParts::BrowserArguments &bargs) {
-    QNetworkRequest req;
-
-    req.setUrl(url);
-    if (args.reload()) pageAction(KWebPage::Reload)->trigger();
-    req.setRawHeader("Referer", args.metaData()["referrer"].toUtf8());
-
-    if (bargs.postData.isEmpty()) {
-        QWebView::load(req);
-    } else {
-        QWebView::load(req, QNetworkAccessManager::PostOperation, bargs.postData);
-    }
-}
-
Index: kdewebkit/kwebpluginfactory.h
===================================================================
--- kdewebkit/kwebpluginfactory.h	(revision 957817)
+++ kdewebkit/kwebpluginfactory.h	(revision 1043437)
@@ -22,25 +22,48 @@
 #ifndef KWEBPLUGINFACTORY_H
 #define KWEBPLUGINFACTORY_H
 
-#include <kdemacros.h>
+#include <kdewebkit_export.h>
 
 #include <QtWebKit/QWebPluginFactory>
-#include <QtCore/QList>
-#include <QtGui/QWidget>
 
-class QStringList;
+/**
+ * @short An enhanced QWebPluginFactory with integration into the KDE environment.
+ *
+ * @author Michael Howell <mhowell123@gmail.com>
+ * @since 4.4
+ */
 
-class KDE_EXPORT KWebPluginFactory : public QWebPluginFactory
+class KDEWEBKIT_EXPORT KWebPluginFactory : public QWebPluginFactory
 {
     Q_OBJECT
 public:
+    /**
+     * Constructs a KWebPluginFactory with parent @p parent.
+     */
     KWebPluginFactory(QObject *parent);
-    KWebPluginFactory(QWebPluginFactory *delegate, QObject *parent);
+
+    /**
+     * Destroys the KWebPage.
+     */
     ~KWebPluginFactory();
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWebPluginFactory::create
+     * @internal
+     */
     virtual QObject *create(const QString &mimeType,
                             const QUrl &url,
                             const QStringList &argumentNames,
                             const QStringList &argumentValues) const;
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWebPluginFactory::plugins
+     * @internal
+     */
     virtual QList<Plugin> plugins() const;
 
 private:
Index: kdewebkit/networkcookiejar_p.h
===================================================================
--- kdewebkit/networkcookiejar_p.h	(revision 0)
+++ kdewebkit/networkcookiejar_p.h	(revision 1043437)
@@ -0,0 +1,121 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef NETWORKCOOKIEJAR_H
+#define NETWORKCOOKIEJAR_H
+
+#include <QtNetwork/QNetworkCookieJar>
+
+
+namespace KDEPrivate {
+/**
+ * @short A KDE implementation of QNetworkCookieJar.
+ *
+ * Use this class in place of QNetworkCookieJar if you want to integrate with
+ * KDE's cookiejar instead of the one that comes with Qt.
+ *
+ * Here is a simple example that shows how to switch QtWebKit to use KDE's
+ * cookiejar:
+ * @code
+ *   QWebView *view = new QWebView(this);
+ *   KDEPrivate::NetworkCookieJar *cookieJar = new KDEPrivate::NetworkCookieJar;
+ *   cookieJar->setWindowId(view->window()->winId());
+ *   view->page()->networkAccessManager()->setCookieJar(cookieJar);
+ * @endcode
+ *
+ * To access member functions in the cookiejar class at a later point in your
+ * code simply downcast the pointer returned by QNetworkAccessManager::cookieJar
+ * as follows:
+ * @code
+ *   KDEPrivate::NetworkCookieJar *cookieJar = qobject_cast<KDEPrivate::NetworkCookieJar*>(view->page()->accessManager()->cookieJar());
+ * @endcode
+ *
+ * <b>NOTE:</b> This class is not a replacement for the standard KDE API. It should
+ * ONLY be used to to provide KDE integration in applications that cannot use
+ * the standard KDE API directly.
+ *
+ * @see QNetworkAccessManager::setCookieJar for details.
+ *
+ * @author Dawit Alemayehu <adawit @ kde.org>
+ * @since 4.4
+ */
+class NetworkCookieJar : public QNetworkCookieJar
+{
+    Q_OBJECT
+public:
+    /**
+     * Constructs a NetworkCookieJar with parent @p parent.
+     */
+    explicit NetworkCookieJar(QObject *parent = 0);
+
+    /**
+     * Destroys the NetworkCookieJar.
+     */
+    ~NetworkCookieJar();
+
+   /**
+    * Returns the currently set window id. The default value is -1.
+    */
+    qlonglong windowId() const;
+
+    /**
+     * Sets the window id of the application.
+     *
+     * This value is used by KDE's cookiejar to manage session cookies, namely
+     * to delete them when the last application refering to such cookies is
+     * closed by the end user.
+     *
+     * @see QWidget::window()
+     * @see QWidget::winId()
+     *
+     * @param id the value of @ref QWidget::winId() from the window that contains your widget.
+     */
+    void setWindowId(qlonglong id);
+
+    /**
+     * Reparse the KDE cookiejar configuration file.
+     */
+    void reparseConfiguration();
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QNetworkCookieJar::cookiesForUrl
+     * @internal
+     */
+    QList<QNetworkCookie> cookiesForUrl(const QUrl &url) const;
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QNetworkCookieJar::setCookiesFromUrl
+     * @internal
+     */
+    bool setCookiesFromUrl(const QList<QNetworkCookie> &cookieList, const QUrl &url);
+
+private:
+    class CookieJarPrivate;
+    CookieJarPrivate* const d;
+};
+
+}
+#endif // NETWORKCOOKIEJAR_H
Index: kdewebkit/includes/KWebPluginFactory
===================================================================
--- kdewebkit/includes/KWebPluginFactory	(revision 957817)
+++ kdewebkit/includes/KWebPluginFactory	(revision 1043437)
@@ -1,2 +1,2 @@
-#include "../../webkitkde/kwebpluginfactory.h"
+#include "../../kdewebkit/kwebpluginfactory.h"
 
Index: kdewebkit/includes/KWebView
===================================================================
--- kdewebkit/includes/KWebView	(revision 957817)
+++ kdewebkit/includes/KWebView	(revision 1043437)
@@ -1,2 +1,2 @@
-#include "../../webkitkde/kwebview.h"
+#include "../../kdewebkit/kwebview.h"
 
Index: kdewebkit/kwebpage.cpp
===================================================================
--- kdewebkit/kwebpage.cpp	(revision 957817)
+++ kdewebkit/kwebpage.cpp	(revision 1043437)
@@ -4,6 +4,7 @@
  * Copyright (C) 2008 Dirk Mueller <mueller@kde.org>
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Michael Howell <mhowell123@gmail.com>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -22,142 +23,106 @@
  *
  */
 
+// Own
 #include "kwebpage.h"
 
+// Local
+#include "networkaccessmanager_p.h"
+#include "networkcookiejar_p.h"
 #include "kwebpluginfactory.h"
-#include "settings/webkitsettings.h"
 
-#include <KDE/KParts/GenericFactory>
-#include <KDE/KParts/BrowserRun>
-#include <KDE/KAction>
-#include <KDE/KFileDialog>
-#include <KDE/KInputDialog>
-#include <KDE/KMessageBox>
-#include <KDE/KProtocolManager>
-#include <KDE/KJobUiDelegate>
-#include <KDE/KRun>
-#include <KDE/KShell>
-#include <KDE/KStandardDirs>
-#include <KDE/KStandardShortcut>
-#include <KIO/Job>
-#if KDE_IS_VERSION(4, 2, 70)
-#include <KIO/AccessManager>
-#else
-#include <kdenetwork/knetworkaccessmanager.h>
-#include <kdenetwork/knetworkreply.h>
-#endif
+// KDE
+#include <kaction.h>
+#include <kfiledialog.h>
+#include <kinputdialog.h>
+#include <kmessagebox.h>
+#include <kprotocolmanager.h>
+#include <kjobuidelegate.h>
+#include <krun.h>
+#include <kshell.h>
+#include <kstandarddirs.h>
+#include <kstandardshortcut.h>
+#include <kurl.h>
+#include <kdebug.h>
+#include <klocalizedstring.h>
+#include <kio/accessmanager.h>
+#include <kio/job.h>
 
-#include <QWebFrame>
-#include <QUiLoader>
+// Qt
+#include <QtGui/QTextDocument>
+#include <QtGui/QPaintEngine>
+#include <QtWebKit/QWebFrame>
+#include <QtUiTools/QUiLoader>
 #include <QtNetwork/QNetworkReply>
+#include <QtNetwork/QNetworkCookieJar>
+#include <QtDBus/QDBusInterface>
+#include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusReply>
 
-#if KDE_IS_VERSION(4, 2, 70)
-class NullNetworkReply : public QNetworkReply
-{
-public:
-    NullNetworkReply() { QTimer::singleShot(0, this, SIGNAL(finished())); }
-    virtual void abort() {};
-    virtual qint64 bytesAvailable() const { return -1; };
-protected:
-    virtual qint64 readData(char*, qint64) { return -1; };
-};
+#define QL1(x)    QLatin1String(x)
 
-class NetworkAccessManager : public KIO::AccessManager
-{
-public:
-    NetworkAccessManager(QObject *parent) : KIO::AccessManager(parent) {}
-protected:
-    virtual QNetworkReply *createRequest(Operation op, const QNetworkRequest &req, QIODevice *outgoingData = 0)
-    {
-        if (WebKitSettings::self()->isAdFilterEnabled() && WebKitSettings::self()->isAdFiltered(req.url().toString())) {
-            return new NullNetworkReply();
-        }
-        return KIO::AccessManager::createRequest(op, req, outgoingData);
-    }
-};
-#else
-class NetworkAccessManager : public KNetworkAccessManager
-{
-public:
-    NetworkAccessManager(QObject *parent) : KNetworkAccessManager(parent) {}
-protected:
-    virtual QNetworkReply *createRequest(Operation op, const QNetworkRequest &req, QIODevice *outgoingData = 0)
-    {
-        if (WebKitSettings::self()->isAdFilterEnabled() && WebKitSettings::self()->isAdFiltered(req.url().toString())) {
-            return new KNetworkReply(KNetworkAccessManager::Operation(), req, 0, this);
-        }
-        return KNetworkAccessManager::createRequest(op, req, outgoingData);
-    }
-};
-#endif
+KWebPage::KWebPage(QObject *parent, qlonglong windowId)
+         :QWebPage(parent), d(0)
+{  
+    // KDE KParts integration for <embed> tag...
+    setPluginFactory(new KWebPluginFactory(this));
 
-class KWebPage::KWebPagePrivate
-{
-public:
-    KWebPagePrivate() {}
+    // KDE IO (KIO) integration...
+    setNetworkAccessManager(new KDEPrivate::NetworkAccessManager(this));
 
-    QString getFileNameForDownload(const QNetworkRequest &request, QNetworkReply *reply) const;
-#if KDE_IS_VERSION(4, 2, 70)
-    KIO::AccessManager* accessManager;
-#else
-    KNetworkAccessManager* accessManager;
-#endif
-};
+    // KDE Cookiejar (KCookieJar) integration...
+    KDEPrivate::NetworkCookieJar *cookiejar = new KDEPrivate::NetworkCookieJar;
 
-QString KWebPage::KWebPagePrivate::getFileNameForDownload(const QNetworkRequest &request, QNetworkReply *reply) const
-{
-    QString fileName = KUrl(request.url()).fileName();
-    if (reply && reply->hasRawHeader("Content-Disposition")) { // based on code from arora, downloadmanger.cpp
-        const QString value = QLatin1String(reply->rawHeader("Content-Disposition"));
-        const int pos = value.indexOf(QLatin1String("filename="));
-        if (pos != -1) {
-            QString name = value.mid(pos + 9);
-            if (name.startsWith(QLatin1Char('"')) && name.endsWith(QLatin1Char('"')))
-                name = name.mid(1, name.size() - 2);
-            fileName = name;
-        }
+    // If windowid is 0, the default, make a best effort attempt to try and
+    // determine that value from the parent object.
+    if (!windowId) {
+        QWidget *widget = qobject_cast<QWidget*>(parent);
+        if (widget)
+            windowId = widget->window()->winId();
     }
-    return fileName;
-}
 
-KWebPage::KWebPage(QObject *parent)
-    : QWebPage(parent), d(new KWebPage::KWebPagePrivate())
-{
-#if KDE_IS_VERSION(4, 2, 70)
-    d->accessManager = new KIO::AccessManager(this);
-#else
-    d->accessManager = new KNetworkAccessManager(this);
-#endif
-    setNetworkAccessManager(d->accessManager);
-    setPluginFactory(new KWebPluginFactory(pluginFactory(), this));
+    if (windowId) {
+      cookiejar->setWindowId(windowId);
+      setSessionMetaData(QL1("window-id"), QString::number(windowId));
+    }
 
-    action(Back)->setIcon(KIcon("go-previous"));
-    action(Back)->setShortcut(KStandardShortcut::back().primary());
+    networkAccessManager()->setCookieJar(cookiejar);
 
-    action(Forward)->setIcon(KIcon("go-next"));
-    action(Forward)->setShortcut(KStandardShortcut::forward().primary());
+#if QT_VERSION >= 0x040600
+    action(Back)->setIcon(QIcon::fromTheme("go-previous"));
+    action(Forward)->setIcon(QIcon::fromTheme("go-next"));
+    action(Reload)->setIcon(QIcon::fromTheme("view-refresh"));
+    action(Stop)->setIcon(QIcon::fromTheme("process-stop"));
+    action(Cut)->setIcon(QIcon::fromTheme("edit-cut"));
+    action(Copy)->setIcon(QIcon::fromTheme("edit-copy"));
+    action(Paste)->setIcon(QIcon::fromTheme("edit-paste"));
+    action(Undo)->setIcon(QIcon::fromTheme("edit-undo"));
+    action(Redo)->setIcon(QIcon::fromTheme("edit-redo"));
+    action(InspectElement)->setIcon(QIcon::fromTheme("view-process-all"));
+    action(OpenLinkInNewWindow)->setIcon(QIcon::fromTheme("window-new"));
+    action(OpenFrameInNewWindow)->setIcon(QIcon::fromTheme("window-new"));
+    action(OpenImageInNewWindow)->setIcon(QIcon::fromTheme("window-new"));
+    action(CopyLinkToClipboard)->setIcon(QIcon::fromTheme("edit-copy"));
+    action(CopyImageToClipboard)->setIcon(QIcon::fromTheme("edit-copy"));
+    action(ToggleBold)->setIcon(QIcon::fromTheme("format-text-bold"));
+    action(ToggleItalic)->setIcon(QIcon::fromTheme("format-text-italic"));
+    action(ToggleUnderline)->setIcon(QIcon::fromTheme("format-text-underline"));
+    action(DownloadLinkToDisk)->setIcon(QIcon::fromTheme("document-save"));
+    action(DownloadImageToDisk)->setIcon(QIcon::fromTheme("document-save"));
 
+    settings()->setWebGraphic(QWebSettings::MissingPluginGraphic, QIcon::fromTheme("preferences-plugin").pixmap(32, 32));
+    settings()->setWebGraphic(QWebSettings::MissingImageGraphic, QIcon::fromTheme("image-missing").pixmap(32, 32));
+    settings()->setWebGraphic(QWebSettings::DefaultFrameIconGraphic, QIcon::fromTheme("applications-internet").pixmap(32, 32));
+#else
+    action(Back)->setIcon(KIcon("go-previous"));
+    action(Forward)->setIcon(KIcon("go-next"));
     action(Reload)->setIcon(KIcon("view-refresh"));
-    action(Reload)->setShortcut(KStandardShortcut::reload().primary());
-
     action(Stop)->setIcon(KIcon("process-stop"));
-    action(Stop)->setShortcut(Qt::Key_Escape);
-
     action(Cut)->setIcon(KIcon("edit-cut"));
-    action(Cut)->setShortcut(KStandardShortcut::cut().primary());
-
     action(Copy)->setIcon(KIcon("edit-copy"));
-    action(Copy)->setShortcut(KStandardShortcut::copy().primary());
-
     action(Paste)->setIcon(KIcon("edit-paste"));
-    action(Paste)->setShortcut(KStandardShortcut::paste().primary());
-
     action(Undo)->setIcon(KIcon("edit-undo"));
-    action(Undo)->setShortcut(KStandardShortcut::undo().primary());
-
     action(Redo)->setIcon(KIcon("edit-redo"));
-    action(Redo)->setShortcut(KStandardShortcut::redo().primary());
-
     action(InspectElement)->setIcon(KIcon("view-process-all"));
     action(OpenLinkInNewWindow)->setIcon(KIcon("window-new"));
     action(OpenFrameInNewWindow)->setIcon(KIcon("window-new"));
@@ -173,170 +138,134 @@
     settings()->setWebGraphic(QWebSettings::MissingPluginGraphic, KIcon("preferences-plugin").pixmap(32, 32));
     settings()->setWebGraphic(QWebSettings::MissingImageGraphic, KIcon("image-missing").pixmap(32, 32));
     settings()->setWebGraphic(QWebSettings::DefaultFrameIconGraphic, KIcon("applications-internet").pixmap(32, 32));
+#endif
 
-    const QString host = mainFrame()->url().host();
-
-    connect(this, SIGNAL(downloadRequested(const QNetworkRequest &)),
-            this, SLOT(slotDownloadRequested(const QNetworkRequest &)));
-    setForwardUnsupportedContent(true);
-    connect(this, SIGNAL(unsupportedContent(QNetworkReply *)),
-            this, SLOT(slotHandleUnsupportedContent(QNetworkReply *)));
+    action(Back)->setShortcut(KStandardShortcut::back().primary());
+    action(Forward)->setShortcut(KStandardShortcut::forward().primary());
+    action(Reload)->setShortcut(KStandardShortcut::reload().primary());
+    action(Stop)->setShortcut(Qt::Key_Escape);
+    action(Cut)->setShortcut(KStandardShortcut::cut().primary());
+    action(Copy)->setShortcut(KStandardShortcut::copy().primary());
+    action(Paste)->setShortcut(KStandardShortcut::paste().primary());
+    action(Undo)->setShortcut(KStandardShortcut::undo().primary());
+    action(Redo)->setShortcut(KStandardShortcut::redo().primary());
 }
 
 KWebPage::~KWebPage()
 {
-    delete d;
 }
 
 void KWebPage::setAllowExternalContent(bool allow)
 {
-    d->accessManager->setExternalContentAllowed(allow);
+    KIO::AccessManager *manager = qobject_cast<KIO::AccessManager*>(networkAccessManager());
+    if (manager)
+        manager->setExternalContentAllowed(allow);
 }
 
 bool KWebPage::isExternalContentAllowed() const
 {
-    return d->accessManager->isExternalContentAllowed();
+    KIO::AccessManager *manager = qobject_cast<KIO::AccessManager*>(networkAccessManager());
+    if (manager)
+        return manager->isExternalContentAllowed();
+    return true;
 }
 
-QString KWebPage::chooseFile(QWebFrame *frame, const QString &suggestedFile)
+QString KWebPage::sessionMetaData(const QString &key) const
 {
-    return KFileDialog::getOpenFileName(suggestedFile, QString(), frame->page()->view());
+    QString value;
+
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        value = manager->sessionMetaData().value(key);
+
+    return value;
 }
 
-void KWebPage::javaScriptAlert(QWebFrame *frame, const QString &msg)
+QString KWebPage::requestMetaData(const QString &key) const
 {
-    KMessageBox::error(frame->page()->view(), msg, i18n("JavaScript"));
+    QString value;
+
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        value = manager->requestMetaData().value(key);
+
+    return value;
 }
 
-bool KWebPage::javaScriptConfirm(QWebFrame *frame, const QString &msg)
+void KWebPage::setSessionMetaData(const QString &key, const QString &value)
 {
-    return (KMessageBox::warningYesNo(frame->page()->view(), msg, i18n("JavaScript"), KStandardGuiItem::ok(), KStandardGuiItem::cancel())
-            == KMessageBox::Yes);
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        manager->sessionMetaData()[key] = value;
 }
 
-bool KWebPage::javaScriptPrompt(QWebFrame *frame, const QString &msg, const QString &defaultValue, QString *result)
+void KWebPage::setRequestMetaData(const QString &key, const QString &value)
 {
-    bool ok = false;
-    *result = KInputDialog::getText(i18n("JavaScript"), msg, defaultValue, &ok, frame->page()->view());
-    return ok;
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        manager->requestMetaData()[key] = value;
 }
 
 QString KWebPage::userAgentForUrl(const QUrl& _url) const
 {
     const KUrl url(_url);
-    const QString host = url.isLocalFile() ? "localhost" : url.host();
+    QString userAgent = KProtocolManager::userAgentForHost((url.isLocalFile() ? "localhost" : url.host()));
 
-    QString userAgent = KProtocolManager::userAgentForHost(host);
-    const int indexOfKhtml = userAgent.indexOf("KHTML/");
-    if (indexOfKhtml == -1) // not a KHTML user agent, so no need to "update" it
-        return userAgent;
+    if (userAgent == KProtocolManager::defaultUserAgent())
+        return QWebPage::userAgentForUrl(_url);
 
-    userAgent = userAgent.left(indexOfKhtml);
-
-    QString webKitUserAgent = QWebPage::userAgentForUrl(url);
-    webKitUserAgent = webKitUserAgent.mid(webKitUserAgent.indexOf("AppleWebKit/"));
-    webKitUserAgent = webKitUserAgent.left(webKitUserAgent.indexOf(')') + 1);
-    userAgent += webKitUserAgent;
-
-    userAgent.remove("compatible; ");
-
     return userAgent;
 }
 
-void KWebPage::slotHandleUnsupportedContent(QNetworkReply *reply)
+void KWebPage::removeSessionMetaData(const QString &key)
 {
-    const KUrl url(reply->request().url());
-    kDebug() << "title:" << url;
-    kDebug() << "error:" << reply->errorString();
-
-    KParts::BrowserRun::AskSaveResult res = KParts::BrowserRun::askEmbedOrSave(
-                                                url,
-                                                reply->header(QNetworkRequest::ContentTypeHeader).toString(),
-                                                d->getFileNameForDownload(reply->request(), reply));
-    switch (res) {
-    case KParts::BrowserRun::Save:
-        slotDownloadRequested(reply->request(), reply);
-        return;
-    case KParts::BrowserRun::Cancel:
-        return;
-    default: // Open
-        break;
-    }
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        manager->sessionMetaData().remove(key);
 }
 
-QObject *KWebPage::createPlugin(const QString &classId, const QUrl &url, const QStringList &paramNames, const QStringList &paramValues)
+void KWebPage::removeRequestMetaData(const QString &key)
 {
-    kDebug() << "create Plugin requested:";
-    kDebug() << "classid:" << classId;
-    kDebug() << "url:" << url;
-    kDebug() << "paramNames:" << paramNames << " paramValues:" << paramValues;
-
-    QUiLoader loader;
-    return loader.createWidget(classId, view());
+    KDEPrivate::NetworkAccessManager *manager = qobject_cast<KDEPrivate::NetworkAccessManager*>(networkAccessManager());
+    if (manager)
+        manager->requestMetaData().remove(key);
 }
 
-
-void KWebPage::slotDownloadRequested(const QNetworkRequest &request)
+bool KWebPage::acceptNavigationRequest(QWebFrame * frame, const QNetworkRequest & request, NavigationType type)
 {
-    slotDownloadRequested(request, 0);
+    kDebug() << "url: " << request.url() << ", type: " << type << ", frame: " << frame;   
+
+    /*
+      If the navigation request is from the main frame, set the cross-domain
+      meta-data value to the current url for proper integration with KCookieJar...
+    */
+    if (frame == mainFrame() && type != QWebPage::NavigationTypeReload) {
+        setSessionMetaData(QL1("cross-domain"), request.url().toString());
+    }
+
+    return QWebPage::acceptNavigationRequest(frame, request, type);
 }
 
-void KWebPage::slotDownloadRequested(const QNetworkRequest &request, QNetworkReply *reply)
+void KWebPage::downloadRequest(const QNetworkRequest &request) const
 {
-    const KUrl url(request.url());
-    kDebug() << url;
+    KUrl url (request.url());
+    const QString destUrl = KFileDialog::getSaveFileName(url.fileName(), QString(), view());
 
-    const QString fileName = d->getFileNameForDownload(request, reply);
+    if (destUrl.isEmpty())
+        return;
 
-    // parts of following code are based on khtml_ext.cpp
-    // DownloadManager <-> konqueror integration
-    // find if the integration is enabled
-    // the empty key  means no integration
-    // only use download manager for non-local urls!
-    bool downloadViaKIO = true;
-    if (!url.isLocalFile()) {
-        KConfigGroup cfg = KSharedConfig::openConfig("konquerorrc", KConfig::NoGlobals)->group("HTML Settings");
-        const QString downloadManger = cfg.readPathEntry("DownloadManager", QString());
-        if (!downloadManger.isEmpty()) {
-            // then find the download manager location
-            kDebug() << "Using: " << downloadManger << " as Download Manager";
-            QString cmd = KStandardDirs::findExe(downloadManger);
-            if (cmd.isEmpty()) {
-                QString errMsg = i18n("The Download Manager (%1) could not be found in your $PATH.", downloadManger);
-                QString errMsgEx = i18n("Try to reinstall it. \n\nThe integration with Konqueror will be disabled.");
-                KMessageBox::detailedSorry(view(), errMsg, errMsgEx);
-                cfg.writePathEntry("DownloadManager", QString());
-                cfg.sync ();
-            } else {
-                downloadViaKIO = false;
-                cmd += ' ' + KShell::quoteArg(url.url());
-                kDebug() << "Calling command" << cmd;
-                KRun::runCommand(cmd, view());
-            }
-        }
-    }
+    KIO::Job *job = KIO::file_copy(url, KUrl(destUrl), -1, KIO::Overwrite);
+    QVariant attr = request.attribute(static_cast<QNetworkRequest::Attribute>(KIO::AccessManager::MetaData));
+    if (attr.isValid() && attr.type() == QVariant::Map)
+        job->setMetaData(KIO::MetaData(attr.toMap()));
 
-    if (downloadViaKIO) {
-        const QString destUrl = KFileDialog::getSaveFileName(url.fileName(), QString(), view());
-        if (destUrl.isEmpty()) return;
-        KIO::Job *job = KIO::file_copy(url, KUrl(destUrl), -1, KIO::Overwrite);
-        //job->setMetaData(metadata); //TODO: add metadata from request
-        job->addMetaData("MaxCacheSize", "0"); // Don't store in http cache.
-        job->addMetaData("cache", "cache"); // Use entry from cache if available.
-        job->uiDelegate()->setAutoErrorHandlingEnabled(true);
-    }
+    job->addMetaData(QL1("MaxCacheSize"), QL1("0")); // Don't store in http cache.
+    job->addMetaData(QL1("cache"), QL1("cache")); // Use entry from cache if available.
+    job->uiDelegate()->setAutoErrorHandlingEnabled(true);
 }
 
-KWebPage *KWebPage::createWindow(WebWindowType type)
+bool KWebPage::authorizedRequest(const QUrl &url) const
 {
-    if (WebKitSettings::self()->windowOpenPolicy(mainFrame()->url().host()) == WebKitSettings::KJSWindowOpenDeny)
-        return 0;
-    return newWindow(type);
+    Q_UNUSED(url);
+    return true;
 }
-
-KWebPage *KWebPage::newWindow(WebWindowType type)
-{
-    Q_UNUSED(type);
-    return 0;
-}
-
Index: kdewebkit/networkaccessmanager_p.cpp
===================================================================
--- kdewebkit/networkaccessmanager_p.cpp	(revision 0)
+++ kdewebkit/networkaccessmanager_p.cpp	(revision 1043437)
@@ -0,0 +1,114 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "kwebpage.h"
+#include "networkaccessmanager_p.h"
+
+#include <kdebug.h>
+#include <kio/accessmanager.h>
+
+#include <QtCore/QTimer>
+#include <QtCore/QPointer>
+#include <QtNetwork/QNetworkReply>
+
+/* Null network reply */
+class NullNetworkReply : public QNetworkReply
+{
+public:
+    NullNetworkReply() {
+        setHeader(QNetworkRequest::ContentLengthHeader, 0);
+        setHeader(QNetworkRequest::ContentTypeHeader, "text/plain");
+        QTimer::singleShot(0, this, SIGNAL(finished()));
+    }
+    virtual void abort() {}
+    virtual qint64 bytesAvailable() const {
+        return 0;
+    }
+protected:
+    virtual qint64 readData(char* data, qint64) {
+        qMemCopy(data, "\0", 1); return 0;
+    }
+};
+
+namespace KDEPrivate {
+
+class NetworkAccessManager::NetworkAccessManagerPrivate
+{
+ public:
+    KIO::MetaData requestMetaData;
+    KIO::MetaData sessionMetaData;
+};
+
+NetworkAccessManager::NetworkAccessManager(QObject *parent)
+                                 :KIO::AccessManager(parent),
+                                  d(new KDEPrivate::NetworkAccessManager::NetworkAccessManagerPrivate)
+{
+}
+
+KIO::MetaData& NetworkAccessManager::requestMetaData()
+{
+    return d->requestMetaData;
+}
+
+KIO::MetaData& NetworkAccessManager::sessionMetaData()
+{
+    return d->sessionMetaData;
+}
+
+QNetworkReply *NetworkAccessManager::createRequest(Operation op, const QNetworkRequest &req, QIODevice *outgoingData)
+{
+    KWebPage* page = qobject_cast<KWebPage*>(parent());
+    if (page && !page->authorizedRequest(req.url())) {
+        kDebug() << "*** BLOCKED UNAUTHORIZED REQUEST => " << req.url();
+        return new NullNetworkReply();
+    }
+
+    QNetworkRequest request(req);
+    KIO::MetaData metaData;
+
+    const QNetworkRequest::Attribute attr = static_cast<QNetworkRequest::Attribute>(KIO::AccessManager::MetaData);
+    const QVariant value = req.attribute(attr);
+
+    // Preserve the meta-data already set, if any...
+    if (value.isValid() && value.type() == QVariant::Map)
+        metaData += value.toMap();
+
+    // Append per request meta data, if any...
+    if (!d->requestMetaData.isEmpty())
+        metaData += d->requestMetaData;
+
+    // Append per session meta data, if any...
+    if (!d->sessionMetaData.isEmpty())
+        metaData += d->sessionMetaData;
+
+    // Re-set meta data to be sent, if any...
+    if (!metaData.isEmpty())
+        request.setAttribute(attr, metaData.toVariant());
+
+    // Clear per request meta data...
+    d->requestMetaData.clear();
+
+    return KIO::AccessManager::createRequest(op, request, outgoingData);
+}
+}
+
+#include "networkaccessmanager_p.moc"
Index: kdewebkit/kwebview.h
===================================================================
--- kdewebkit/kwebview.h	(revision 957817)
+++ kdewebkit/kwebview.h	(revision 1043437)
@@ -5,6 +5,7 @@
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Laurent Montel <montel@kde.org>
  * Copyright (C) 2008 Michael Howell <mhowell123@gmail.com>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -25,55 +26,111 @@
 #ifndef KWEBVIEW_H
 #define KWEBVIEW_H
 
-#include <kdemacros.h>
+#include <kdewebkit_export.h>
 
 #include <QtWebKit/QWebView>
-#include "kwebpage.h"
 
-class QWebHitTestResult;
 class KUrl;
-class QMouseEvent;
-class QWheelEvent;
+
 namespace KParts
 {
-class OpenUrlArguments;
-class BrowserArguments;
+    class OpenUrlArguments;
+    class BrowserArguments;
 }
 
-class KDE_EXPORT KWebView : public QWebView
+/**
+ * @short A re-implementation of QWebView to provide KDE integration.
+ *
+ * This is a convenience class that provides an implementation of QWebView with
+ * full integration with KDE technologies for networking (KIO), cookie handling
+ * (KCookieJar) and embeded non-html content (&lt;embed&gt;) handling (KPart apps).
+ *
+ * @author Urs Wolfer <uwolfer @ kde.org>
+ * @since 4.4
+ */
+class KDEWEBKIT_EXPORT KWebView : public QWebView
 {
     Q_OBJECT
 public:
-    KWebView(QWidget *parent = 0);
+    /**
+     * Constructs an empty KWebView with parent @p parent.
+     */
+    explicit KWebView(QWidget *parent = 0);
+
+    /**
+     * Destroys the KWebView.
+     */
     ~KWebView();
-    KWebPage *page();
-    QWidget *searchBar();
 
-public Q_SLOTS:
-    void setCustomContextMenu(bool show);
+    /**
+     * Returns true if access to remote content is allowed.
+     *
+     * By default access to remote content is allowed.
+     *
+     * @see setAllowExternalContent()
+     * @see KWebPage::isExternalContentAllowed()
+     */
+    bool isExternalContentAllowed() const;
 
     /**
-     * similar to load(const QNetworkRequest&, QNetworkAccessManager::Operation), but for KParts-style arguments instead.
+     * Set @p allow to false if you want to prevent access to remote content.
+     *
+     * If this function is set to false only resources on the local system
+     * can be accessed through this class. By default fetching external content
+     * is allowed.
+     *
+     * @see isExternalContentAllowed()
+     * @see KWebPage::setAllowExternalContent(bool)
      */
-    void load(const KUrl &url, const KParts::OpenUrlArguments &args, const KParts::BrowserArguments &bargs);
+    void setAllowExternalContent(bool allow);
 
 Q_SIGNALS:
-    void showContextMenu(QContextMenuEvent *event);
+    /**
+     * This signal is emitted when the user wants to navigate to @p url.
+     */
     void openUrl(const KUrl &url);
-    void openUrlInNewTab(const KUrl &url);
 
+    /**
+     * This signal is emitted when the user wants to save @p url.
+     *
+     * It is activated as a result of a shift-click on a link with the left
+     * mouse button.
+     */
+    void saveUrl(const KUrl &url);
+
+    /**
+     * This signal is emitted when the user wants to open @p url in a new window.
+     *
+     * It is activated as a result of a click on a link with the middle mouse
+     * button or a ctrl-click with the left mouse button.
+     */
+    void openUrlInNewWindow(const KUrl &url);
+
 protected:
-    void contextMenuEvent(QContextMenuEvent *event);
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWidget::wheelEvent
+     * @internal
+     */
     void wheelEvent(QWheelEvent *event);
-    void mousePressEvent(QMouseEvent *event);
-    void mouseReleaseEvent(QMouseEvent *event);
 
-protected Q_SLOTS:
-    virtual void slotFindNextClicked();
-    virtual void slotFindPreviousClicked();
-    virtual void slotSearchChanged(const QString &);
-    virtual void resultSearch(KWebPage::FindFlags flags);
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWidget::mousePressEvent
+     * @internal
+     */
+    virtual void mousePressEvent(QMouseEvent *event);
 
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWidget::mouseReleaseEvent
+     * @internal
+     */
+    virtual void mouseReleaseEvent(QMouseEvent *event);
+
 private:
     class KWebViewPrivate;
     KWebViewPrivate* const d;
Index: kdewebkit/Mainpage.dox
===================================================================
--- kdewebkit/Mainpage.dox	(revision 0)
+++ kdewebkit/Mainpage.dox	(revision 1043437)
@@ -0,0 +1,21 @@
+/**
+ * @mainpage The KDE WebKit Library
+ *
+ * This library provides KDE integration of the QtWebKit library. If you are using QtWebKit in your KDE
+ * application, you are encouraged to use this layer instead of using the QtWebKit classes directly.
+ * 
+ * @authors
+ * Various: see the copyright headers of the individual files.
+ * 
+ * @maintainers
+ * For support please use the webkit@kde.org mailing list.
+ * 
+ * @licenses
+ * @lgpl
+ * 
+ */
+
+// DOXYGEN_SET_INTERNAL_DOCS = YES
+// DOXYGEN_SET_PROJECT_NAME = KDEWEBKIT
+// DOXYGEN_SET_RECURSIVE = YES
+// vim:ts=4:sw=4:expandtab:filetype=doxygen
Index: kdewebkit/kwebpage.h
===================================================================
--- kdewebkit/kwebpage.h	(revision 957817)
+++ kdewebkit/kwebpage.h	(revision 1043437)
@@ -4,6 +4,7 @@
  * Copyright (C) 2008 Dirk Mueller <mueller@kde.org>
  * Copyright (C) 2008 Urs Wolfer <uwolfer @ kde.org>
  * Copyright (C) 2008 Michael Howell <mhowell123@gmail.com>
+ * Copyright (C) 2009 Dawit Alemayehu <adawit@kde.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -24,46 +25,146 @@
 #ifndef KWEBPAGE_H
 #define KWEBPAGE_H
 
-#include <kdemacros.h>
-#include <KDE/KUrl>
+#include <kdewebkit_export.h>
 
 #include <QtWebKit/QWebPage>
 
-class QWebFrame;
+/**
+ * @short An enhanced QWebPage with integration into the KDE environment.
+ *
+ * @author Urs Wolfer <uwolfer @ kde.org>
+ * @since 4.4
+ */
 
-class KDE_EXPORT KWebPage : public QWebPage
+class KDEWEBKIT_EXPORT KWebPage : public QWebPage
 {
     Q_OBJECT
 public:
-    KWebPage(QObject *parent);
+    /**
+     * Constructs an empty KWebPage with parent @p parent.
+     *
+     * @param parent    the parent object.
+     * @param windowId  the id of the window that contains this object.
+     *
+     * @see KIO::Intergation::CookieJar
+     */
+    explicit KWebPage(QObject *parent = 0, qlonglong windowId = 0);
+
+    /**
+     * Destroys the KWebPage.
+     */
     ~KWebPage();
+
     /**
-     * Set @p allow to false if you don't want to allow showing external content,
-     * so no external images for example. By default external content is fetched.
+     * Returns true if access to remote content is allowed.
+     *
+     * By default access to remote content is allowed.
+     *
+     * @see setAllowExternalContent()
+     * @see KIO::AccessManager::isExternalContentAllowed()
      */
+    bool isExternalContentAllowed() const;
+
+    /**
+     * Set @p allow to false if you want to prevent access to remote content.
+     *
+     * If this function is set to false, only resources on the local system
+     * can be accessed through this class. By default fetching external content
+     * is allowed.
+     *
+     * @see isExternalContentAllowed()
+     * @see KIO::AccessManager::setAllowExternalContent(bool)
+     */
     void setAllowExternalContent(bool allow);
 
     /**
-     * returns if external content is fetched, see setAllowExternalContent().
+     * Downloads the resource requested by @p request.
+     *
+     * This function first prompts the user for the destination
+     * location for the requested resource and then downloads it
+     * using KIO.
+     *
+     * For example, you can call this function when you receive
+     * @ref QWebPage::downloadRequested signal to download the
+     * the request through KIO.
+     *
+     * @param request the request to download.
      */
-    bool isExternalContentAllowed() const;
+    void downloadRequest(const QNetworkRequest &request) const;
 
+    /**
+     * Returns true if access to the requested @p url is authorized.
+     *
+     * You should reimplement this function if you want to add features such as
+     * content filtering or ad blocking. The default implementation simply
+     * returns true.
+     *
+     * @param url the url to be authorized.
+     * @return true in this default implementation.
+     */
+    virtual bool authorizedRequest(const QUrl &url) const;
+
 protected:
-    virtual KWebPage *createWindow(WebWindowType type);
-    virtual KWebPage *newWindow(WebWindowType type);
-    QString chooseFile(QWebFrame *frame, const QString &suggestedFile);
-    void javaScriptAlert(QWebFrame *frame, const QString &msg);
-    bool javaScriptConfirm(QWebFrame *frame, const QString &msg);
-    bool javaScriptPrompt(QWebFrame *frame, const QString &msg, const QString &defaultValue, QString *result);
-    QString userAgentForUrl(const QUrl& url) const;
+    /**
+     * Returns the value of the permanent (per session) meta data for the given @p key.
+     *
+     * @see KIO::MetaData
+     */
+    QString sessionMetaData(const QString &key) const;
 
-    QObject *createPlugin(const QString &classId, const QUrl &url, const QStringList &paramNames, const QStringList &paramValues);
+    /**
+     * Returns the value of the temporary (per request) meta data for the given @p key.
+     *
+     * @see KIO::MetaData
+     */
+    QString requestMetaData(const QString &key) const;
 
-protected Q_SLOTS:
-    virtual void slotHandleUnsupportedContent(QNetworkReply *reply);
-    virtual void slotDownloadRequested(const QNetworkRequest &request);
-    virtual void slotDownloadRequested(const QNetworkRequest &request, QNetworkReply *reply);
+    /**
+     * Set meta data that will be sent to KIO slave with every request.
+     *
+     * Note that meta data set using this function will be sent with
+     * every request.
+     *
+     * @see KIO::MetaData
+     */
+    void setSessionMetaData(const QString &key, const QString &value);
 
+    /**
+     * Set meta data that will be sent to KIO slave with the first request.
+     *
+     * Note that a meta data set using this function will be deleted after
+     * it has been sent the first time.
+     *
+     * @see KIO::MetaData
+     */
+    void setRequestMetaData(const QString &key, const QString &value);
+
+    /**
+     * Remove session meta data associated with @p key.
+     */
+    void removeSessionMetaData(const QString &key);
+
+    /**
+     * Remove request meta data associated with @p key.
+     */
+    void removeRequestMetaData(const QString &key);
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWebPage::userAgentForUrl.
+     * @internal
+     */
+    virtual QString userAgentForUrl(const QUrl& url) const;
+
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see QWebPage::acceptNavigationRequest.
+     * @internal
+     */
+    virtual bool acceptNavigationRequest(QWebFrame * frame, const QNetworkRequest & request, NavigationType type);
+
 private:
     class KWebPagePrivate;
     KWebPagePrivate* const d;
Index: kdewebkit/networkaccessmanager_p.h
===================================================================
--- kdewebkit/networkaccessmanager_p.h	(revision 0)
+++ kdewebkit/networkaccessmanager_p.h	(revision 1043437)
@@ -0,0 +1,82 @@
+/*
+ * This file is part of the KDE project.
+ *
+ * Copyright (C) 2009 Dawit Alemayehu <adawit @ kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef NETWORKACCESSMANAGER_P_H
+#define NETWORKACCESSMANAGER_P_H
+
+#include <kio/accessmanager.h>
+
+namespace KDEPrivate {
+
+ /**
+  * Reimplementation of KIO::AccessManager to provide content filtering support
+  * and a convenience function for storing persistent and temporary KIO meta data.
+  *
+  * @author Dawit Alemayehu <adawit @ kde.org>
+  */
+class NetworkAccessManager : public KIO::AccessManager
+{
+  Q_OBJECT
+
+public:
+    NetworkAccessManager(QObject *parent);
+    ~NetworkAccessManager() {}
+
+    /**
+     * Returns a reference to the temporary meta data container.
+     *
+     * See kdelibs/kio/DESIGN.metadata for list of supported KIO meta data.
+     *
+     * This convenience function allows you to set per request KIO meta data
+     * that will be removed after it has been sent once.
+     */
+    KIO::MetaData& requestMetaData();
+
+    /**
+     * Returns a reference to the persistent meta data container.
+     *
+     * See kdelibs/kio/DESIGN.metadata for list of supported KIO meta data.
+     *
+     * This convenience function allows you to set per session KIO meta data
+     * that will be sent with every request.
+     *
+     * Unlike the above method the meta data values set using the reference
+     * returned by this function are not deleted after they have been sent once.
+     */
+    KIO::MetaData& sessionMetaData();
+
+protected:
+    /**
+     * Reimplemented for internal reasons, the API is not affected.
+     *
+     * @see KIO::AccessManager::createRequest.
+     * @internal
+     */
+    virtual QNetworkReply *createRequest(Operation op, const QNetworkRequest &req, QIODevice *outgoingData = 0);
+
+private:
+    class NetworkAccessManagerPrivate;
+    NetworkAccessManagerPrivate* d;
+};
+
+}
+
+#endif // NETWORKACCESSMANAGER_P_H
Index: kdewebkit/CMakeLists.txt
===================================================================
--- kdewebkit/CMakeLists.txt	(revision 957817)
+++ kdewebkit/CMakeLists.txt	(revision 1043437)
@@ -5,33 +5,20 @@
 include(KDE4Defaults)
 include(MacroLibrary)
 
-if(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-else(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-    # QtWebKit uses QtNetwork, to KdeWebKit uses....
-    # Starting from kdelibs 4.2.70, KIO does contain the network part.
-    find_package(KdeNetwork REQUIRED)
-    include_directories(${KDENETWORK_INCLUDE_DIR})
-endif(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-
-include_directories(${KDE4_INCLUDES} ${CMAKE_SOURCE_DIR})
+include_directories(${KDE4_INCLUDES} ${CMAKE_CURRENT_SOURCE_DIR}/kdewebkit)
 add_definitions(${QT_DEFINITIONS} ${KDE4_DEFINITIONS})
 
 add_subdirectory(includes)
 add_subdirectory(cmake)
 
 set(kdewebkit_LIB_SRCS
-    kwebview.cpp
     kwebpage.cpp
+    kwebview.cpp
     kwebpluginfactory.cpp
-    searchbar_p.cpp
-    settings/webkitsettings.cpp
-    settings/khtml_filter.cpp
+    networkcookiejar_p.cpp
+    networkaccessmanager_p.cpp
 )
 
-kde4_add_ui_files(kdewebkit_LIB_SRCS
-    searchbar_p.ui
-)
-
 kde4_add_library(kdewebkit SHARED ${kdewebkit_LIB_SRCS})
 
 target_link_libraries(kdewebkit
@@ -41,18 +28,16 @@
     ${QT_QTXML_LIBRARY}
 )
 
-if(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-else(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-    target_link_libraries(kdewebkit ${KDENETWORK_LIBRARIES})
-endif(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-
-#set_target_properties(kdewebkit PROPERTIES VERSION ${GENERIC_LIB_VERSION} SOVERSION ${GENERIC_LIB_SOVERSION})
+#set_target_properties(kdewebkit PROPERTIES VERSION ${KDE_NON_GENERIC_LIB_VERSION} SOVERSION ${KDE_NON_GENERIC_LIB_SOVERSION}) ### for kdelibs
 set_target_properties(kdewebkit PROPERTIES VERSION 1.0.0 SOVERSION 1) # for the moment keep something low...
 
+#install(TARGETS kdewebkit EXPORT kdelibsLibraryTargets ${INSTALL_TARGETS_DEFAULT_ARGS}) ### for kdelibs
 install(TARGETS kdewebkit ${INSTALL_TARGETS_DEFAULT_ARGS})
 
 install(FILES
+    kdewebkit_export.h
+    kwebpluginfactory.h
     kwebpage.h
     kwebview.h
-    kwebpluginfactory.h
     DESTINATION ${INCLUDE_INSTALL_DIR}/kdewebkit/ COMPONENT Devel)
+#     DESTINATION ${INCLUDE_INSTALL_DIR} COMPONENT Devel) ### for kdelibs
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 957817)
+++ CMakeLists.txt	(revision 1043437)
@@ -5,16 +5,13 @@
 include(KDE4Defaults)
 include(MacroLibrary)
 
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/kdewebkit) # required; otherwise kdewebkit_export.h cannot be found when building from toplevel (just temporary until kdewebkit is in kdelibs) -uwolfer
+
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH}
     ${CMAKE_SOURCE_DIR}/kdewebkit/cmake/modules
     ${CMAKE_SOURCE_DIR}/part/cmake/modules)
 
-if(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-else(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")	
-    set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_SOURCE_DIR}/kdenetwork/cmake/modules)
-    add_subdirectory(kdenetwork)
-endif(${KDE_VERSION_MINOR} EQUAL "2" AND ${KDE_VERSION_RELEASE} GREATER "69")
-
 add_subdirectory(icons)
 add_subdirectory(kdewebkit)
 add_subdirectory(part)
+add_subdirectory(kdelauncher)
