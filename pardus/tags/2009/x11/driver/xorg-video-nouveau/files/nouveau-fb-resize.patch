From 9210a9e26271bab7a77ff1346383b9732a33f43b Mon Sep 17 00:00:00 2001
From: Ben Skeggs <skeggsb@caspar.localdomain>
Date: Tue, 14 Apr 2009 09:23:07 +1000
Subject: [PATCH 6/8] f11: support framebuffer resize without driver pixmaps

---
 src/drmmode_display.c |   75 +++++++++++++++++++++++++++++++--
 src/nouveau_exa.c     |   21 +++++-----
 src/nv50_randr.c      |   13 +++++-
 src/nv_crtc.c         |   31 +++++++++-----
 src/nv_driver.c       |  108 ++++++++++++++++++++++++++++++++++++++++++++++---
 src/nv_type.h         |   10 ++++-
 6 files changed, 224 insertions(+), 34 deletions(-)

diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index deed5d6..e987a85 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -1071,6 +1071,59 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 }
 
 static Bool
+nv_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
+{
+	ScreenPtr pScreen = pScrn->pScreen;
+	NVPtr pNv = NVPTR(pScrn);
+	const int cpp = pScrn->bitsPerPixel >> 3;
+	int pitch = NOUVEAU_ALIGN(width * cpp, 256);
+	int ret = 0;
+	PixmapPtr ppix;
+
+	if (pScrn->virtualX == width && pScrn->virtualY == height &&
+	    (pNv->NoAccel || pNv->exa_onscreen))
+		return TRUE;
+
+	if (!pNv->dev)
+		goto out_done;
+
+	nouveau_fb_free(pScrn);
+
+	ret = nouveau_fb_alloc(pScrn, pitch, height, cpp);
+	if (ret) {
+		width = pScrn->virtualX;
+		height = pScrn->virtualY;
+		pitch = (*pScreen->GetScreenPixmap)(pScreen)->devKind;
+
+		ret = nouveau_fb_alloc(pScrn, pitch, height, cpp);
+		/* famous last words: "this should never happen!" */
+		if (ret)
+			FatalError("couldn't allocate framebuffer!\n");
+
+		ret = -ENOMEM;
+	}
+
+out_done:
+	if (!ret && pNv->ShadowFB) {
+		xfree(pNv->ShadowPtr);
+		pNv->ShadowPtr = xalloc(pitch * height);
+		pNv->ShadowPitch = pitch;
+	}
+
+	ppix = (*pScreen->GetScreenPixmap)(pScreen);
+
+	(*pScreen->ModifyPixmapHeader)(ppix, width, height, -1, -1, pitch,
+				       (!pNv->NoAccel || pNv->ShadowFB) ?
+				       pNv->ShadowPtr : pNv->FBMap);
+	pScrn->pixmapPrivate.ptr = ppix->devPrivate.ptr;
+
+	pScrn->virtualX = width;
+	pScrn->virtualY = height;
+	pScrn->displayWidth = pitch / cpp;
+	return ret == 0;
+}
+
+static Bool
 drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
 {
 	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
@@ -1085,10 +1138,23 @@ drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
 	ErrorF("resize called %d %d\n", width, height);
 
 	if (!pNv->exa_driver_pixmaps) {
-		if (width > scrn->virtualX || height > scrn->virtualY)
+		if (!nv_xf86crtc_resize(scrn, width, height))
 			return FALSE;
 
-		scrn->displayWidth = NOUVEAU_ALIGN(width, 64);
+		if (drmmode->fb_id)
+			drmModeRmFB(drmmode->fd, drmmode->fb_id);
+		drmmode->fb_id = 0;
+
+		for (i = 0; i < config->num_crtc; i++) {
+			xf86CrtcPtr crtc = config->crtc[i];
+
+			if (!crtc->enabled)
+				continue;
+			
+			xf86CrtcSetMode(crtc, &crtc->mode, crtc->rotation,
+					crtc->x, crtc->y);
+		}
+
 		return TRUE;
 	}
 
@@ -1151,7 +1217,7 @@ static const xf86CrtcConfigFuncsRec drmmode_xf86crtc_config_funcs = {
 
 Bool drmmode_pre_init(ScrnInfoPtr pScrn, int fd, int cpp)
 {
-	xf86CrtcConfigPtr   xf86_config;
+	xf86CrtcConfigPtr xf86_config;
 	drmmode_ptr drmmode;
 	int i;
 
@@ -1175,8 +1241,7 @@ Bool drmmode_pre_init(ScrnInfoPtr pScrn, int fd, int cpp)
 	for (i = 0; i < drmmode->mode_res->count_connectors; i++)
 		drmmode_output_init(pScrn, drmmode, i);
 
-	xf86InitialConfiguration(pScrn, NVPTR(pScrn)->exa_driver_pixmaps);
-
+	xf86InitialConfiguration(pScrn, TRUE);
 	return TRUE;
 }
 
diff --git a/src/nouveau_exa.c b/src/nouveau_exa.c
index 437ded5..190be7b 100644
--- a/src/nouveau_exa.c
+++ b/src/nouveau_exa.c
@@ -279,7 +279,10 @@ nouveau_exa_prepare_access(PixmapPtr ppix, int index)
 	} else
 	if (ppix == pScreen->GetScreenPixmap(pScreen)) {
 		nouveau_bo_map(pNv->scanout, NOUVEAU_BO_RDWR);
-		ppix->devPrivate.ptr = pNv->scanout->map;
+		if (pNv->scanout != pNv->FB)
+			ppix->devPrivate.ptr = pNv->scanout->map;
+		else
+			ppix->devPrivate.ptr = pNv->FB->map + pNv->exa_onscreen->offset; 
 	} else {
 		/* force migration */
 		return FALSE;
@@ -301,7 +304,8 @@ nouveau_exa_finish_access(PixmapPtr ppix, int index)
 	if (ppix == pScreen->GetScreenPixmap(pScreen)) {
 		ppix->devPrivate.ptr = NULL;
 		nouveau_bo_unmap(pNv->scanout);
-		nv50_shadow_damage_frontbuffer_fallback(pScrn);
+		if (pNv->Architecture == NV_ARCH_50)
+			nv50_shadow_damage_frontbuffer_fallback(pScrn);
 	}
 }
 
@@ -543,10 +547,9 @@ Bool
 nouveau_exa_pixmap_is_onscreen(PixmapPtr ppix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[ppix->drawable.pScreen->myNum];
-	NVPtr pNv = NVPTR(pScrn);
 	unsigned long offset = exaGetPixmapOffset(ppix);
 
-	if (offset < pNv->EXADriverPtr->offScreenBase)
+	if (offset == 0)
 		return TRUE;
 
 	return FALSE;
@@ -588,9 +591,7 @@ nouveau_exa_init(ScreenPtr pScreen)
 		nouveau_bo_map(pNv->FB, NOUVEAU_BO_RDWR);
 		exa->memoryBase = pNv->FB->map;
 		nouveau_bo_unmap(pNv->FB);
-		exa->offScreenBase = NOUVEAU_ALIGN(pScrn->virtualX, 64) *
-				     NOUVEAU_ALIGN(pScrn->virtualY, 64) *
-				     (pScrn->bitsPerPixel / 8);
+		exa->offScreenBase = 0x1000; /* just a little to keep "0" special */
 		exa->memorySize = pNv->FB->size; 
 
 		if (pNv->Architecture < NV_ARCH_50) {
@@ -631,10 +632,8 @@ nouveau_exa_init(ScreenPtr pScreen)
 	}
 
 	/* Needed for frontbuffer fallbacks (to ensure it accesses the linear fb). */
-	if (pNv->Architecture >= NV_ARCH_50) {
-		exa->PrepareAccess = nouveau_exa_prepare_access;
-		exa->FinishAccess = nouveau_exa_finish_access;
-	}
+	exa->PrepareAccess = nouveau_exa_prepare_access;
+	exa->FinishAccess = nouveau_exa_finish_access;
 
 	exa->MarkSync = nouveau_exa_mark_sync;
 	exa->WaitMarker = nouveau_exa_wait_marker;
diff --git a/src/nv50_randr.c b/src/nv50_randr.c
index e006b38..64c6794 100644
--- a/src/nv50_randr.c
+++ b/src/nv50_randr.c
@@ -308,8 +308,19 @@ nv50_crtc_set_origin(xf86CrtcPtr crtc, int x, int y)
 {
 	ScrnInfoPtr pScrn = crtc->scrn;
 	NV50CrtcPrivatePtr nv_crtc = crtc->driver_private;
+	nouveauCrtcPtr nvcrtc = nv_crtc->crtc; /* sigh.. */
+	NVPtr pNv = NVPTR(pScrn);
+	uint32_t fb;
+
+	nvcrtc->SetFB(nvcrtc, pNv->scanout);
+	nvcrtc->SetFBOffset(nvcrtc, x, y);
+	nvcrtc->fb_pitch = pScrn->displayWidth * (pScrn->bitsPerPixel >> 3);
+	fb = nvcrtc->front_buffer->offset - pNv->dev->vm_vram_base;
 
-	nv_crtc->crtc->SetFBOffset(nv_crtc->crtc, x, y);
+	NV50CrtcCommand(nvcrtc, NV50_CRTC0_FB_OFFSET, fb >> 8);
+	NV50CrtcCommand(nvcrtc, NV50_CRTC0_FB_PITCH, nvcrtc->fb_pitch | (1<<20));
+	NV50CrtcCommand(nvcrtc, NV50_CRTC0_FB_SIZE, (pScrn->virtualY << 16) |
+						     pScrn->virtualX);
 
 	NV50DisplayCommand(pScrn, NV50_UPDATE_DISPLAY, 0);
 }
diff --git a/src/nv_crtc.c b/src/nv_crtc.c
index 2cdef8c..1983943 100644
--- a/src/nv_crtc.c
+++ b/src/nv_crtc.c
@@ -954,7 +954,7 @@ nv_crtc_shadow_allocate (xf86CrtcPtr crtc, int width, int height)
 	unsigned long rotate_pitch;
 	int size, align = 64;
 
-	rotate_pitch = pScrn->displayWidth * (pScrn->bitsPerPixel/8);
+	rotate_pitch = NOUVEAU_ALIGN(width, align) * (pScrn->bitsPerPixel/8);
 	size = rotate_pitch * height;
 
 	assert(nv_crtc->shadow == NULL);
@@ -987,6 +987,7 @@ nv_crtc_shadow_allocate (xf86CrtcPtr crtc, int width, int height)
 	offset = pNv->FBMap + nv_crtc->shadow->offset;
 #endif /* NOUVEAU_EXA_PIXMAPS */
 
+	nv_crtc->shadow_pitch = rotate_pitch;
 	return offset;
 }
 
@@ -997,11 +998,10 @@ static PixmapPtr
 nv_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 {
 	ScrnInfoPtr pScrn = crtc->scrn;
+	struct nouveau_crtc *nv_crtc = to_nouveau_crtc(crtc);
 #if NOUVEAU_EXA_PIXMAPS
 	ScreenPtr pScreen = pScrn->pScreen;
-	struct nouveau_crtc *nv_crtc = to_nouveau_crtc(crtc);
 #endif /* NOUVEAU_EXA_PIXMAPS */
-	unsigned long rotate_pitch;
 	PixmapPtr rotate_pixmap;
 #if NOUVEAU_EXA_PIXMAPS
 	struct nouveau_pixmap *nvpix;
@@ -1010,8 +1010,6 @@ nv_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 	if (!data)
 		data = crtc->funcs->shadow_allocate (crtc, width, height);
 
-	rotate_pitch = pScrn->displayWidth * (pScrn->bitsPerPixel/8);
-
 #if NOUVEAU_EXA_PIXMAPS
 	/* Create a dummy pixmap, to get a private that will be accepted by the system.*/
 	rotate_pixmap = pScreen->CreatePixmap(pScreen, 
@@ -1028,7 +1026,7 @@ nv_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 								width, height,
 								pScrn->depth,
 								pScrn->bitsPerPixel,
-								rotate_pitch,
+								nv_crtc->shadow_pitch,
 								data);
 #endif /* NOUVEAU_EXA_PIXMAPS */
 
@@ -1052,7 +1050,7 @@ nv_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 					height,
 					pScrn->depth,
 					pScrn->bitsPerPixel,
-					rotate_pitch,
+					nv_crtc->rotate_pitch,
 					data);
 
 	nvpix = exaGetPixmapDriverPrivate(rotate_pixmap);
@@ -1155,16 +1153,29 @@ void NVCrtcSetBase(xf86CrtcPtr crtc, int x, int y)
 	ScrnInfoPtr pScrn = crtc->scrn;
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_crtc *nv_crtc = to_nouveau_crtc(crtc);
-	uint32_t start = (y * pScrn->displayWidth + x) * pScrn->bitsPerPixel / 8;
+	uint32_t cpp = pScrn->bitsPerPixel / 8;
+	uint32_t start = (y * pScrn->displayWidth + x) * cpp;
+	uint32_t pitch = pScrn->displayWidth * cpp;
+	NVCrtcRegPtr regp = &pNv->ModeReg.crtc_reg[nv_crtc->head];
 
-	if (crtc->rotatedData != NULL) /* we do not exist on the real framebuffer */
+	if (crtc->rotatedData != NULL) { /* we do not exist on the real framebuffer */
 #if NOUVEAU_EXA_PIXMAPS
 		start = nv_crtc->shadow->offset;
 #else
 		start = pNv->FB->offset + nv_crtc->shadow->offset; /* We do exist relative to the framebuffer */
 #endif
-	else
+		pitch = nv_crtc->shadow_pitch;
+	} else {
+		if (pNv->exa_onscreen)
+			start += pNv->exa_onscreen->offset;
 		start += pNv->FB->offset;
+	}
+
+	regp->CRTC[NV_CIO_CR_OFFSET_INDEX] = pitch >> 3;
+	regp->CRTC[NV_CIO_CRE_RPC0_INDEX] =
+		XLATE(pitch >> 3, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);
+	crtc_wr_cio_state(crtc, regp, NV_CIO_CRE_RPC0_INDEX);
+	crtc_wr_cio_state(crtc, regp, NV_CIO_CR_OFFSET_INDEX);
 
 	start &= ~3;
 	pNv->ModeReg.crtc_reg[nv_crtc->head].fb_start = start;
diff --git a/src/nv_driver.c b/src/nv_driver.c
index 5cc44d8..64632c1 100644
--- a/src/nv_driver.c
+++ b/src/nv_driver.c
@@ -775,16 +775,112 @@ Bool NVI2CInit(ScrnInfoPtr pScrn)
 	return TRUE;
 }
 
+void
+nouveau_fb_free(ScrnInfoPtr pScrn)
+{
+	ScreenPtr pScreen = pScrn->pScreen;
+	NVPtr pNv = NVPTR(pScrn);
+
+	if (!pNv->NoAccel && pNv->exa_onscreen) {
+		exaOffscreenFree(pScreen, pNv->exa_onscreen);
+		pNv->exa_onscreen = NULL;
+	}
+
+	if (pNv->scanout && pNv->FB != pNv->scanout)
+		nouveau_bo_ref(NULL, &pNv->scanout);
+}
+
+int
+nouveau_fb_alloc(ScrnInfoPtr pScrn, int pitch, int height, int cpp)
+{
+	ScreenPtr pScreen = pScrn->pScreen;
+	NVPtr pNv = NVPTR(pScrn);
+	int ret;
+
+	if (!pNv->NoAccel) {
+		pNv->exa_onscreen = exaOffscreenAlloc(pScreen, pitch * height,
+						      256, TRUE, NULL, NULL);
+		if (!pNv->exa_onscreen)
+			return -ENOMEM;
+	}
+
+	if (!pNv->scanout) {
+		ret = nouveau_bo_new(pNv->dev, NOUVEAU_BO_VRAM | NOUVEAU_BO_PIN,
+				     256, pitch * height, &pNv->scanout);
+		if (ret) {
+			nouveau_fb_free(pScrn);
+			return ret;
+		}
+	}
+
+
+	return 0;
+}
+
 static Bool
 nv_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
 {
-#if 0
-	do not change virtual* for now, as it breaks multihead server regeneration
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "nv_xf86crtc_resize is called with %dx%d resolution.\n", width, height);
+	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
+	ScreenPtr pScreen = pScrn->pScreen;
+	NVPtr pNv = NVPTR(pScrn);
+	const int cpp = pScrn->bitsPerPixel >> 3;
+	int pitch = NOUVEAU_ALIGN(width * cpp, 256);
+	int ret = 0, i;
+	PixmapPtr ppix;
+
+	if (pScrn->virtualX == width && pScrn->virtualY == height &&
+	    (pNv->NoAccel || pNv->exa_onscreen))
+		return TRUE;
+
+	if (!pNv->dev)
+		goto out_done;
+
+	nouveau_fb_free(pScrn);
+
+	ret = nouveau_fb_alloc(pScrn, pitch, height, cpp);
+	if (ret) {
+		width = pScrn->virtualX;
+		height = pScrn->virtualY;
+		pitch = (*pScreen->GetScreenPixmap)(pScreen)->devKind;
+
+		ret = nouveau_fb_alloc(pScrn, pitch, height, cpp);
+		/* famous last words: "this should never happen!" */
+		if (ret)
+			FatalError("couldn't allocate framebuffer!\n");
+
+		ret = -ENOMEM;
+	}
+
+out_done:
+
+	if (!ret && pNv->ShadowFB) {
+		xfree(pNv->ShadowPtr);
+		pNv->ShadowPtr = xalloc(pitch * height);
+		pNv->ShadowPitch = pitch;
+	}
+
+	ppix = pScreen->GetScreenPixmap(pScreen);
+
+	(*pScreen->ModifyPixmapHeader)(ppix, width, height, -1, -1, pitch,
+				       (!pNv->NoAccel || pNv->ShadowFB) ?
+				       pNv->ShadowPtr : pNv->FBMap);
+	pScrn->pixmapPrivate.ptr = ppix->devPrivate.ptr;
+
 	pScrn->virtualX = width;
 	pScrn->virtualY = height;
-#endif
-	return TRUE;
+	pScrn->displayWidth = pitch / cpp;
+
+	for (i = 0; i < config->num_crtc; i++) {
+		xf86CrtcPtr crtc = config->crtc[i];
+
+		if (!crtc->enabled)
+			continue;
+		
+		xf86CrtcSetMode(crtc, &crtc->mode, crtc->rotation,
+				crtc->x, crtc->y);
+	}
+
+	return ret == 0;
 }
 
 static const xf86CrtcConfigFuncsRec nv_xf86crtc_config_funcs = {
@@ -1295,7 +1391,7 @@ NVPreInit(ScrnInfoPtr pScrn, int flags)
 		} else
 			nv50_output_create(pScrn); /* create randr-1.2 "outputs". */
 
-		if (!xf86InitialConfiguration(pScrn, FALSE))
+		if (!xf86InitialConfiguration(pScrn, TRUE))
 			NVPreInitFail("No valid modes.\n");
 	}
 
diff --git a/src/nv_type.h b/src/nv_type.h
index b96d8cb..c448bff 100644
--- a/src/nv_type.h
+++ b/src/nv_type.h
@@ -217,6 +217,7 @@ struct nouveau_crtc {
 
 	uint32_t cursor_fg, cursor_bg;
 	ExaOffscreenArea *shadow;
+	unsigned shadow_pitch;
 };
 
 struct nouveau_encoder {
@@ -307,8 +308,11 @@ typedef struct _NVRec {
     volatile CARD8 *PDIO1;
 
     uint8_t cur_head;
+
     ExaDriverPtr	EXADriverPtr;
     Bool		exa_driver_pixmaps;
+    ExaOffscreenArea *  exa_onscreen;
+
     ScreenBlockHandlerProcPtr BlockHandler;
     CloseScreenProcPtr  CloseScreen;
     /* Cursor */
@@ -496,11 +500,15 @@ nouveau_pixmap_offset(PixmapPtr ppix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[ppix->drawable.pScreen->myNum];
 	NVPtr pNv = NVPTR(pScrn);
+	unsigned offset;
 
 	if (pNv->exa_driver_pixmaps)
 		return 0;
 
-	return exaGetPixmapOffset(ppix);
+	offset = exaGetPixmapOffset(ppix);
+	if (offset == 0)
+		offset = pNv->exa_onscreen->offset;
+	return offset;
 }
 
 #endif /* __NV_STRUCT_H__ */
-- 
1.6.2.2

