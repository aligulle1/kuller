From d501dc111d23e1f65f58b4f23ca55506343ca8a0 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <skeggsb@gmail.com>
Date: Mon, 13 Apr 2009 19:25:25 +1000
Subject: [PATCH 3/8] f11: hack to support multiple xserver instances

---
 src/nv_driver.c |  127 ++++++++++++++++++++++++++++++++++++++++++-------------
 1 files changed, 98 insertions(+), 29 deletions(-)

diff --git a/src/nv_driver.c b/src/nv_driver.c
index 36ac7e5..f7cfd3e 100644
--- a/src/nv_driver.c
+++ b/src/nv_driver.c
@@ -21,6 +21,7 @@
  */
 
 #include <stdio.h>
+#include <sys/ioctl.h>
 
 #include "nv_include.h"
 
@@ -532,14 +533,27 @@ NV50ReleaseDisplay(ScrnInfoPtr pScrn)
  */
 
 /* Mandatory */
+static void NVMapMemGART(ScrnInfoPtr);
 static Bool
 NVEnterVT(int scrnIndex, int flags)
 {
 	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
 	NVPtr pNv = NVPTR(pScrn);
+	int ret;
 
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVEnterVT is called.\n");
 
+	if (pNv->dev) {
+		ret = ioctl(nouveau_device(pNv->dev)->fd,
+			    DRM_IOCTL_SET_MASTER, NULL);
+		if (ret) {
+			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+				   "Unable to set master\n");
+		}
+
+		NVMapMemGART(pScrn);
+	}
+
 	if (!pNv->NoAccel)
 		NVAccelCommonInit(pScrn);
 
@@ -596,6 +610,12 @@ NVLeaveVT(int scrnIndex, int flags)
 
 	NVSync(pScrn);
 
+	if (pNv->dev) {
+		nouveau_bo_ref(NULL, &pNv->GART);
+
+		ioctl(nouveau_device(pNv->dev)->fd, DRM_IOCTL_DROP_MASTER, NULL);
+	}
+
 	if (!pNv->kms_enable) {
 		if (pNv->Architecture < NV_ARCH_50)
 			NVRestore(pScrn);
@@ -1497,11 +1517,81 @@ NVMapMemSW(ScrnInfoPtr pScrn)
 }
 
 static Bool
+NVMapMemSharedFB(ScrnInfoPtr pScrn)
+{
+	NVPtr pNv = NVPTR(pScrn);
+	uint64_t handle, size;
+	void *map;
+	int ret;
+
+	ret = nouveau_device_get_param(pNv->dev, 0xdeadcafe00000001, &handle);
+	if (ret)
+		return FALSE;
+
+	ret = nouveau_device_get_param(pNv->dev, 0xdeadcafe00000002, &size);
+	if (ret)
+		return FALSE;
+
+	if (nouveau_device(pNv->dev)->mm_enabled) {
+		ret = nouveau_bo_handle_ref(pNv->dev, handle, &pNv->FB);
+		if (ret) {
+			ErrorF("%d\n", ret);
+			return FALSE;
+		}
+
+		pNv->FB->size = size;
+		pNv->FB->tiled = (pNv->Architecture == NV_ARCH_50);
+		return TRUE;
+	}
+
+	ret = drmMap(nouveau_device(pNv->dev)->fd, handle >> 32, size, &map);
+	if (ret)
+		return FALSE;
+
+	ret = nouveau_bo_fake(pNv->dev, handle & 0xffffffff, NOUVEAU_BO_VRAM |
+			      NOUVEAU_BO_PIN, size, map, &pNv->FB);
+	if (ret)
+		return FALSE;
+
+	pNv->FB->tiled = (pNv->Architecture == NV_ARCH_50);
+	return TRUE;
+}
+
+static void
+NVMapMemGART(ScrnInfoPtr pScrn) {
+	NVPtr pNv = NVPTR(pScrn);
+	int size;
+
+	if (pNv->AGPSize) {
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			   "AGPGART: %dMiB available\n",
+			   (unsigned int)(pNv->AGPSize >> 20));
+		if (pNv->AGPSize > (16*1024*1024))
+			size = 16*1024*1024;
+		else
+			/* always leave 512kb for other things like the fifos */
+			size = pNv->AGPSize - 512*1024;
+	} else {
+		size = (4 << 20) - (1 << 18) ;
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			   "GART: PCI DMA - using %dKiB\n",
+			   size >> 10);
+	}
+
+	if (nouveau_bo_new(pNv->dev, NOUVEAU_BO_GART | NOUVEAU_BO_PIN |
+			   NOUVEAU_BO_MAP, 0, size, &pNv->GART)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			   "Unable to allocate GART memory\n");
+	}
+}
+
+static Bool
 NVMapMem(ScrnInfoPtr pScrn)
 {
 	NVPtr pNv = NVPTR(pScrn);
 	uint64_t res;
 	int size;
+	uint32_t flags;
 
 	if (!pNv->dev)
 		return NVMapMemSW(pScrn);
@@ -1518,47 +1608,26 @@ NVMapMem(ScrnInfoPtr pScrn)
 		size = size * (pScrn->bitsPerPixel >> 3);
 		size = size * pScrn->virtualY;
 	} else {
+		if (NVMapMemSharedFB(pScrn))
+			goto skip_fb;
 		size = pNv->VRAMPhysicalSize / 2;
 	}
 
-	if (nouveau_bo_new(pNv->dev, NOUVEAU_BO_VRAM | NOUVEAU_BO_PIN |
-			   NOUVEAU_BO_MAP, 0, size, &pNv->FB)) {
+	flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_PIN | NOUVEAU_BO_MAP;
+	if (pNv->Architecture >= NV_ARCH_50)
+		flags |= NOUVEAU_BO_TILED;
+
+	if (nouveau_bo_new(pNv->dev, flags, 0, size, &pNv->FB)) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "Failed to allocate framebuffer memory\n");
 		return FALSE;
 	}
+skip_fb:
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Allocated %dMiB VRAM for framebuffer + offscreen pixmaps, "
 		   "at offset 0x%X\n",
 		   (uint32_t)(pNv->FB->size >> 20), (uint32_t) pNv->FB->offset);
 
-	if (pNv->AGPSize) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			   "AGPGART: %dMiB available\n",
-			   (unsigned int)(pNv->AGPSize >> 20));
-		if (pNv->AGPSize > (16*1024*1024))
-			size = 16*1024*1024;
-		else
-			/* always leave 512kb for other things like the fifos */
-			size = pNv->AGPSize - 512*1024;
-	} else {
-		size = (4 << 20) - (1 << 18) ;
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			   "GART: PCI DMA - using %dKiB\n",
-			   size >> 10);
-	}
-
-	if (nouveau_bo_new(pNv->dev, NOUVEAU_BO_GART | NOUVEAU_BO_PIN |
-			   NOUVEAU_BO_MAP, 0, size, &pNv->GART)) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "Unable to allocate GART memory\n");
-	}
-	if (pNv->GART) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			   "GART: Allocated %dMiB as a scratch buffer\n",
-			   (unsigned int)(pNv->GART->size >> 20));
-	}
-
 	/* We don't need to allocate cursors / lut here if we're using
 	 * kernel modesetting
 	 **/
-- 
1.6.2.2

