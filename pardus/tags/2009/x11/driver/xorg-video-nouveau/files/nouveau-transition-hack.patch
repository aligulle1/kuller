From 78ae88d3b353b9a65aae8494a70d455b20a1304a Mon Sep 17 00:00:00 2001
From: Ben Skeggs <skeggsb@gmail.com>
Date: Mon, 13 Apr 2009 19:12:25 +1000
Subject: [PATCH 1/8] kms/f11: hack in transition support without driver pixmaps

---
 src/drmmode_display.c |  144 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 142 insertions(+), 2 deletions(-)

diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index 77b9015..b05771a 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -187,6 +187,139 @@ drmmode_fb_pixmap(ScrnInfoPtr pScrn, int id, unsigned *w, unsigned *h)
 }
 
 static void
+drmmode_fb_copy_sw(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int dst_id,
+		   int src_id, int x, int y)
+{
+	drmModeFBPtr fb;
+	NVPtr pNv = NVPTR(pScrn);
+	char *dst = NULL, *src = NULL;
+	struct drm_nouveau_gem_mmap req;
+	int ret, h;
+
+	/* This is not what this should look like.  Until we can do driver
+	 * pixmaps, this will be a nasty hack!
+	 */
+
+	fb = drmModeGetFB(nouveau_device(pNv->dev)->fd, src_id);
+	if (!fb) {
+		ErrorF("src fb\n");
+		return;
+	}
+
+	req.handle = fb->handle;
+	ret = drmCommandWriteRead(nouveau_device(pNv->dev)->fd,
+				  DRM_NOUVEAU_GEM_MMAP, &req, sizeof(req));
+	if (ret) {
+		ErrorF("src bo map: %d\n", ret);
+		drmFree(fb);
+		return;
+	}
+	src = (void *)req.vaddr;
+	
+	nouveau_bo_map(pNv->FB, NOUVEAU_BO_WR);
+	dst = pNv->FB->map;
+	dst += (y * fb->pitch) + (x * (fb->bpp >> 3));
+
+	h = fb->height;
+	while (h--) {
+		memcpy(dst, src, fb->width * (fb->bpp >> 3));
+		src += fb->pitch;
+		dst += pScrn->displayWidth * (pScrn->bitsPerPixel / 8);
+	}
+
+	nouveau_bo_unmap(pNv->FB);
+	drmFree(fb);
+}
+
+static void
+drmmode_fb_copy_nv50(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int dst_id,
+		     int src_id, int x, int y)
+{
+	drmModeFBPtr fb;
+	NVPtr pNv = NVPTR(pScrn);
+	struct nouveau_channel *chan = pNv->chan;
+	struct nouveau_grobj *eng2d = pNv->Nv2D;
+	struct nouveau_bo *src = NULL, *dst = NULL;
+	struct drm_gem_flink req;
+	int ret;
+
+	/* This is not what this should look like.  Until we can do driver
+	 * pixmaps, this will be a nasty hack!
+	 */
+
+	fb = drmModeGetFB(nouveau_device(pNv->dev)->fd, src_id);
+	if (!fb) {
+		ErrorF("src fb\n");
+		return;
+	}
+
+	req.handle = fb->handle;
+	ret = ioctl(nouveau_device(pNv->dev)->fd, DRM_IOCTL_GEM_FLINK, &req);
+	if (ret) {
+		ErrorF("name bo: %d\n", ret);
+		drmFree(fb);
+		return;
+	}
+
+	ret = nouveau_bo_handle_ref(pNv->dev, req.name, &src);
+	if (ret) {
+		ErrorF("src bo: %d\n", ret);
+		drmFree(fb);
+		return;
+	}
+
+	nouveau_bo_ref(pNv->scanout, &dst);
+
+	BEGIN_RING(chan, eng2d, 0x02ac, 1);
+	OUT_RING  (chan, 3);
+	BEGIN_RING(chan, eng2d, 0x0200, 2);
+	OUT_RING  (chan, pScrn->bitsPerPixel == 16 ? 0xe8 : 0xcf);
+	OUT_RING  (chan, 1);
+	BEGIN_RING(chan, eng2d, 0x0214, 5);
+	OUT_RING  (chan, pScrn->displayWidth * (pScrn->bitsPerPixel >> 3));
+	OUT_RING  (chan, pScrn->virtualX);
+	OUT_RING  (chan, pScrn->virtualY);
+	OUT_RELOCh(chan, dst, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
+	OUT_RELOCl(chan, dst, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
+	BEGIN_RING(chan, eng2d, 0x0280, 4);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, pScrn->virtualX);
+	OUT_RING  (chan, pScrn->virtualY);
+	BEGIN_RING(chan, eng2d, 0x0230, 2);
+	OUT_RING  (chan, fb->bpp == 16 ? 0xe8 : 0xcf);
+	OUT_RING  (chan, 1);
+	BEGIN_RING(chan, eng2d, 0x0244, 5);
+	OUT_RING  (chan, fb->pitch);
+	OUT_RING  (chan, fb->width);
+	OUT_RING  (chan, fb->height);
+	OUT_RELOCh(chan, src, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
+	OUT_RELOCl(chan, src, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
+	BEGIN_RING(chan, eng2d, 0x0110, 1);
+	OUT_RING  (chan, 0);
+	BEGIN_RING(chan, eng2d, 0x08b0, 12);
+	OUT_RING  (chan, x);
+	OUT_RING  (chan, y);
+	OUT_RING  (chan, fb->width);
+	OUT_RING  (chan, fb->height);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 1);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 1);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 0);
+	OUT_RING  (chan, 0);
+	FIRE_RING (chan);
+
+	nouveau_bo_map(dst, NOUVEAU_BO_RD);
+	nouveau_bo_unmap(dst);
+	nouveau_bo_ref(NULL, &dst);
+	nouveau_bo_ref(NULL, &src);
+	drmFree(fb);
+}
+
+static void
 drmmode_fb_copy(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int dst_id, int src_id,
 		int x, int y)
 {
@@ -196,6 +329,14 @@ drmmode_fb_copy(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int dst_id, int src_id,
 	PixmapPtr pspix, pdpix;
 	unsigned w = -1, h = -1;
 
+	if (!pNv->exa_driver_pixmaps) {
+		if (pNv->NoAccel || pNv->Architecture < NV_ARCH_50)
+		drmmode_fb_copy_sw(pScrn, drmmode, dst_id, src_id, x, y);
+		else
+		drmmode_fb_copy_nv50(pScrn, drmmode, dst_id, src_id, x, y);
+		return;
+	}
+
 	pspix = drmmode_fb_pixmap(pScrn, src_id, &w, &h);
 	if (!pspix)
 		return;
@@ -294,8 +435,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 	if (drmmode_crtc->rotate_fb_id)
 		fb_id = drmmode_crtc->rotate_fb_id;
 	else
-	if (fb_id != drmmode_crtc->mode_crtc->buffer_id &&
-	    pNv->exa_driver_pixmaps) {
+	if (fb_id != drmmode_crtc->mode_crtc->buffer_id) {
 		drmmode_fb_copy(pScrn, drmmode, fb_id,
 				drmmode_crtc->mode_crtc->buffer_id, x, y);
 	}
-- 
1.6.2.2

