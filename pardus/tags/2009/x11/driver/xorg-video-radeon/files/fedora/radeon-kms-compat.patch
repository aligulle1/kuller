diff -up xf86-video-ati-6.12.2/configure.ac.dave xf86-video-ati-6.12.2/configure.ac
--- xf86-video-ati-6.12.2/configure.ac.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/configure.ac	2009-06-25 15:55:27.000000000 +1000
@@ -117,7 +117,7 @@ if test "$DRI" = yes; then
 	fi
 
         save_CFLAGS="$CFLAGS"
-        CFLAGS="$XORG_CFLAGS $DRI_CFLAGS"
+        CFLAGS="$XORG_CFLAGS $DRI_CFLAGS $CFLAGS"
         AC_CHECK_HEADER(xf86drmMode.h,[DRM_MODE=yes],[DRM_MODE=no],[#include <stdint.h>
 #include <stdlib.h>])
         if test "x$DRM_MODE" = xyes; then
@@ -348,3 +348,25 @@ AC_OUTPUT([
 	src/Makefile
 	man/Makefile
 ])
+
+dnl
+dnl Output some configuration info for the user
+dnl
+echo ""
+echo "        prefix:              $prefix"
+echo "        exec_prefix:         $exec_prefix"
+echo "        libdir:              $libdir"
+echo "        includedir:          $includedir"
+
+
+echo ""
+echo "        Kernel modesetting:  $DRM_MODE"
+
+echo ""
+echo "        CFLAGS:              $CFLAGS"
+echo "        CXXFLAGS:            $CXXFLAGS"
+echo "        Macros:              $DEFINES"
+
+echo ""
+echo "        Run '${MAKE-make}' to build xf86-video-ati"
+echo ""
diff -up xf86-video-ati-6.12.2/src/radeon_accel.c.dave xf86-video-ati-6.12.2/src/radeon_accel.c
--- xf86-video-ati-6.12.2/src/radeon_accel.c.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/src/radeon_accel.c	2009-06-25 15:55:27.000000000 +1000
@@ -425,6 +425,24 @@ void RADEONEngineRestore(ScrnInfoPtr pSc
     info->accel_state->XInited3D = FALSE;
 }
 
+static int RADEONDRMGetNumPipes(ScrnInfoPtr pScrn, int *num_pipes)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    if (info->dri->pKernelDRMVersion->version_major < 2) {
+        drm_radeon_getparam_t np;
+
+        memset(&np, 0, sizeof(np));
+        np.param = RADEON_PARAM_NUM_GB_PIPES;
+        np.value = num_pipes;
+        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np, sizeof(np));
+    } else {
+        struct drm_radeon_info np2;
+        np2.value = (uint64_t)num_pipes;
+        np2.request = RADEON_INFO_NUM_GB_PIPES;
+        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &np2, sizeof(np2));
+    }
+}
+
 /* Initialize the acceleration hardware */
 void RADEONEngineInit(ScrnInfoPtr pScrn)
 {
@@ -440,15 +458,9 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     if ((info->directRenderingEnabled || info->drm_mode_setting) && (IS_R300_3D || IS_R500_3D)) {
-        drm_radeon_getparam_t np;
 	int num_pipes;
 
-	memset(&np, 0, sizeof(np));
-	np.param = RADEON_PARAM_NUM_GB_PIPES;
-	np.value = &num_pipes;
-
-	if (drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np,
-				sizeof(np)) < 0) {
+	if(RADEONDRMGetNumPipes(pScrn, &num_pipes) < 0) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		       "Failed to determine num pipes from DRM, falling back to "
 		       "manual look-up!\n");
diff -up xf86-video-ati-6.12.2/src/radeon_commonfuncs.c.dave xf86-video-ati-6.12.2/src/radeon_commonfuncs.c
--- xf86-video-ati-6.12.2/src/radeon_commonfuncs.c.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/src/radeon_commonfuncs.c	2009-06-25 15:55:27.000000000 +1000
@@ -82,6 +82,7 @@ static void FUNC_NAME(RADEONInit3DEngine
 	case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
 	}
 
+    if (info->dri->pKernelDRMVersion->version_major < 2) {
 	size = (info->ChipFamily >= CHIP_FAMILY_R420) ? 5 : 4;
 	BEGIN_ACCEL(size);
 	OUT_ACCEL_REG(R300_GB_TILE_CONFIG, gb_tile_config);
@@ -91,13 +92,16 @@ static void FUNC_NAME(RADEONInit3DEngine
 	OUT_ACCEL_REG(R300_GB_SELECT, 0);
 	OUT_ACCEL_REG(R300_GB_ENABLE, 0);
 	FINISH_ACCEL();
+    }
 
 	if (IS_R500_3D) {
 	    su_reg_dest = ((1 << info->accel_state->num_gb_pipes) - 1);
+        if (info->dri->pKernelDRMVersion->version_major < 2) {
 	    BEGIN_ACCEL(2);
 	    OUT_ACCEL_REG(R500_SU_REG_DEST, su_reg_dest);
 	    OUT_ACCEL_REG(R500_VAP_INDEX_OFFSET, 0);
 	    FINISH_ACCEL();
+        }
 	}
 
 	BEGIN_ACCEL(3);
@@ -106,10 +110,13 @@ static void FUNC_NAME(RADEONInit3DEngine
 	OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
 	FINISH_ACCEL();
 
-	BEGIN_ACCEL(5);
+	BEGIN_ACCEL(3);
 	OUT_ACCEL_REG(R300_GB_AA_CONFIG, 0);
 	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D | R300_DC_FREE_3D);
 	OUT_ACCEL_REG(R300_RB3D_ZCACHE_CTLSTAT, R300_ZC_FLUSH | R300_ZC_FREE);
+	FINISH_ACCEL();
+    if (info->dri->pKernelDRMVersion->version_major < 2) {
+	BEGIN_ACCEL(3);
 	OUT_ACCEL_REG(R300_GB_MSPOS0, ((6 << R300_MS_X0_SHIFT) |
 				       (6 << R300_MS_Y0_SHIFT) |
 				       (6 << R300_MS_X1_SHIFT) |
@@ -125,10 +132,11 @@ static void FUNC_NAME(RADEONInit3DEngine
 				       (6 << R300_MS_X5_SHIFT) |
 				       (6 << R300_MS_Y5_SHIFT) |
 				       (6 << R300_MSBD1_SHIFT)));
+	OUT_ACCEL_REG(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);
 	FINISH_ACCEL();
+    }
 
-	BEGIN_ACCEL(5);
-	OUT_ACCEL_REG(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);
+	BEGIN_ACCEL(4);
 	OUT_ACCEL_REG(R300_GA_POLY_MODE, R300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);
 	OUT_ACCEL_REG(R300_GA_ROUND_MODE, (R300_GEOMETRY_ROUND_NEAREST |
 					   R300_COLOR_ROUND_NEAREST));
diff -up xf86-video-ati-6.12.2/src/radeon_dri2.c.dave xf86-video-ati-6.12.2/src/radeon_dri2.c
--- xf86-video-ati-6.12.2/src/radeon_dri2.c.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/src/radeon_dri2.c	2009-06-25 15:55:27.000000000 +1000
@@ -36,15 +36,22 @@
 
 #include "radeon.h"
 #include "radeon_dri2.h"
+#include "radeon_bufmgr_gem.h"
 #include "radeon_version.h"
 
 #ifdef DRI2
 
+#if DRI2INFOREC_VERSION >= 1
+#define USE_DRI2_1_1_0
+#endif
+
 struct dri2_buffer_priv {
     PixmapPtr   pixmap;
+    unsigned int attachment;
 };
 
 
+#ifndef USE_DRI2_1_1_0
 static DRI2BufferPtr
 radeon_dri2_create_buffers(DrawablePtr drawable,
                            unsigned int *attachments,
@@ -103,12 +110,81 @@ radeon_dri2_create_buffers(DrawablePtr d
         buffers[i].pitch = pixmap->devKind;
         buffers[i].cpp = pixmap->drawable.bitsPerPixel / 8;
         buffers[i].driverPrivate = &privates[i];
-        buffers[i].flags = 0; /* not tiled */
+        buffers[i].flags = 0;
         privates[i].pixmap = pixmap;
+        privates[i].attachment = attachments[i];
     }
     return buffers;
 }
+#else
+static DRI2BufferPtr
+radeon_dri2_create_buffer(DrawablePtr drawable,
+                          unsigned int attachment,
+                          unsigned int format)
+{
+    ScreenPtr pScreen = drawable->pScreen;
+    DRI2BufferPtr buffers;
+    struct dri2_buffer_priv *privates;
+    PixmapPtr pixmap, depth_pixmap;
+    struct radeon_exa_pixmap_priv *driver_priv;
+    int r;
 
+    buffers = xcalloc(1, sizeof *buffers);
+    if (buffers == NULL) {
+        return NULL;
+    }
+    privates = xcalloc(1, sizeof(struct dri2_buffer_priv));
+    if (privates == NULL) {
+        xfree(buffers);
+        return NULL;
+    }
+
+    depth_pixmap = NULL;
+
+    if (attachment == DRI2BufferFrontLeft) {
+        if (drawable->type == DRAWABLE_PIXMAP) {
+            pixmap = (PixmapPtr)drawable;
+        } else {
+            pixmap = (*pScreen->GetWindowPixmap)((WindowPtr)drawable);
+        }
+        pixmap->refcnt++;
+    } else if (attachment == DRI2BufferStencil && depth_pixmap) {
+        pixmap = depth_pixmap;
+        pixmap->refcnt++;
+    } else {
+        pixmap = (*pScreen->CreatePixmap)(pScreen,
+                drawable->width,
+                drawable->height,
+                (format != 0)?format:drawable->depth,
+                0);
+    }
+
+    if (attachment == DRI2BufferDepth) {
+        depth_pixmap = pixmap;
+    }
+    driver_priv = exaGetPixmapDriverPrivate(pixmap);
+    r = radeon_bo_gem_name_buffer(driver_priv->bo, &buffers->name);
+    if (r) {
+        /* FIXME: cleanup */
+        fprintf(stderr, "flink error: %d %s\n", r, strerror(r));
+        xfree(buffers);
+        xfree(privates);
+        return NULL;
+    }
+    buffers->attachment = attachment;
+    buffers->pitch = pixmap->devKind;
+    buffers->cpp = pixmap->drawable.bitsPerPixel / 8;
+    buffers->driverPrivate = privates;
+    buffers->format = format;
+    buffers->flags = 0; /* not tiled */
+    privates->pixmap = pixmap;
+    privates->attachment = attachment;
+
+    return buffers;
+}
+#endif
+
+#ifndef USE_DRI2_1_1_0
 static void
 radeon_dri2_destroy_buffers(DrawablePtr drawable,
                             DRI2BufferPtr buffers,
@@ -127,6 +203,23 @@ radeon_dri2_destroy_buffers(DrawablePtr 
         xfree(buffers);
     }
 }
+#else
+static void
+radeon_dri2_destroy_buffer(DrawablePtr drawable, DRI2BufferPtr buffers)
+{
+    if(buffers)
+    {
+        ScreenPtr pScreen = drawable->pScreen;
+        struct dri2_buffer_priv *private;
+
+        private = buffers->driverPrivate;
+        (*pScreen->DestroyPixmap)(private->pixmap);
+
+        xfree(buffers->driverPrivate);
+        xfree(buffers);
+    }
+}
+#endif
 
 static void
 radeon_dri2_copy_region(DrawablePtr drawable,
@@ -134,19 +227,29 @@ radeon_dri2_copy_region(DrawablePtr draw
                         DRI2BufferPtr dest_buffer,
                         DRI2BufferPtr src_buffer)
 {
-    struct dri2_buffer_priv *private = src_buffer->driverPrivate;
+    struct dri2_buffer_priv *src_private = src_buffer->driverPrivate;
+    struct dri2_buffer_priv *dst_private = dest_buffer->driverPrivate;
     ScreenPtr pScreen = drawable->pScreen;
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    PixmapPtr pixmap = private->pixmap;
+    PixmapPtr src_pixmap;
+    PixmapPtr dst_pixmap;
     RegionPtr copy_clip;
     GCPtr gc;
 
+    src_pixmap = src_private->pixmap;
+    dst_pixmap = dst_private->pixmap;
+    if (src_private->attachment == DRI2BufferFrontLeft) {
+        src_pixmap = (PixmapPtr)drawable;
+    }
+    if (dst_private->attachment == DRI2BufferFrontLeft) {
+        dst_pixmap = (PixmapPtr)drawable;
+    }
     gc = GetScratchGC(drawable->depth, pScreen);
     copy_clip = REGION_CREATE(pScreen, NULL, 0);
     REGION_COPY(pScreen, copy_clip, region);
     (*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
-    ValidateGC(drawable, gc);
-    (*gc->ops->CopyArea)(&pixmap->drawable, drawable, gc,
+    ValidateGC(&dst_pixmap->drawable, gc);
+    (*gc->ops->CopyArea)(&src_pixmap->drawable, &dst_pixmap->drawable, gc,
                          0, 0, drawable->width, drawable->height, 0, 0);
     FreeScratchGC(gc);
     RADEONCPReleaseIndirect(pScrn);
@@ -207,16 +310,21 @@ radeon_dri2_screen_init(ScreenPtr pScree
     }
     dri2_info.fd = info->dri2.drm_fd;
     dri2_info.deviceName = info->dri2.device_name;
+#ifndef USE_DRI2_1_1_0
     dri2_info.version = 1;
     dri2_info.CreateBuffers = radeon_dri2_create_buffers;
     dri2_info.DestroyBuffers = radeon_dri2_destroy_buffers;
+#else
+    dri2_info.version = 2;
+    dri2_info.CreateBuffer = radeon_dri2_create_buffer;
+    dri2_info.DestroyBuffer = radeon_dri2_destroy_buffer;
+#endif
     dri2_info.CopyRegion = radeon_dri2_copy_region;
     info->dri2.enabled = DRI2ScreenInit(pScreen, &dri2_info);
     return info->dri2.enabled;
 }
 
-void
-radeon_dri2_close_screen(ScreenPtr pScreen)
+void radeon_dri2_close_screen(ScreenPtr pScreen)
 {
     DRI2CloseScreen(pScreen);
 }
diff -up xf86-video-ati-6.12.2/src/radeon_driver.c.dave xf86-video-ati-6.12.2/src/radeon_driver.c
--- xf86-video-ati-6.12.2/src/radeon_driver.c.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/src/radeon_driver.c	2009-06-25 15:55:27.000000000 +1000
@@ -2816,15 +2816,23 @@ static Bool radeon_kernel_mode_enabled(S
     pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
     PciInfo = xf86GetPciInfoForEntity(pEnt->index);
 
-    if (!xf86LoaderCheckSymbol("DRICreatePCIBusID"))
+    if (!xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
+		   "[KMS] No DRICreatePCIBusID symbol, no kernel modesetting.\n");
 	return FALSE;
+    }
 
     busIdString = DRICreatePCIBusID(PciInfo);
     ret = drmCheckModesettingSupported(busIdString);
     xfree(busIdString);
-    if (ret)
+    if (ret) {
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
+		   "[KMS] drm report modesetting isn't supported.\n");
 	return FALSE;
+    }
 
+    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
+		   "[KMS] Kernel modesetting enabled.\n");
     return TRUE;
 }
 #else
@@ -3116,6 +3124,12 @@ Bool RADEONPreInit(ScrnInfoPtr pScrn, in
     info->dri2.drm_fd = info->drmmode.fd;
     info->dri2.enabled = FALSE;
 	xfree(bus_id);
+	info->dri->pKernelDRMVersion = drmGetVersion(info->dri->drmFD);
+	if (info->dri->pKernelDRMVersion == NULL) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			"RADEONDRIGetVersion failed to get the DRM version\n");
+		goto fail;
+	}
 	 
         {
 	    struct drm_radeon_gem_info mminfo;
@@ -3127,6 +3141,7 @@ Bool RADEONPreInit(ScrnInfoPtr pScrn, in
 		ErrorF("initing gart:%llx vram: s:%llx v:%llx\n",
 		       mminfo.gart_size, mminfo.vram_size, mminfo.vram_visible);
 	    }
+        if (info->dri == NULL || info->dri->pKernelDRMVersion->version_major < 2)
 	    {
 	        struct drm_radeon_getparam gp;
 		int value;
diff -up xf86-video-ati-6.12.2/src/radeon_exa_render.c.dave xf86-video-ati-6.12.2/src/radeon_exa_render.c
--- xf86-video-ati-6.12.2/src/radeon_exa_render.c.dave	2009-06-25 15:55:13.000000000 +1000
+++ xf86-video-ati-6.12.2/src/radeon_exa_render.c	2009-06-25 15:55:27.000000000 +1000
@@ -2163,16 +2163,23 @@ static Bool FUNC_NAME(R300PrepareComposi
     }
 
     /* Clear out scissoring */
+    if (IS_R300_3D) {
     BEGIN_ACCEL(2);
-    if (IS_R300_3D)
-	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((1440 << R300_SCISSOR_X_SHIFT) |
-					 (1440 << R300_SCISSOR_Y_SHIFT)));
-    else
-	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
-					 (0 << R300_SCISSOR_Y_SHIFT)));
-    OUT_ACCEL_REG(R300_SC_SCISSOR1, ((8191 << R300_SCISSOR_X_SHIFT) |
-				     (8191 << R300_SCISSOR_Y_SHIFT)));
+    OUT_ACCEL_REG(R300_SC_SCISSOR0, ((1440 << R300_SCISSOR_X_SHIFT) |
+				  (1440 << R300_SCISSOR_Y_SHIFT)));
+    OUT_ACCEL_REG(R300_SC_SCISSOR1,
+                  (((pDst->drawable.width + 1440 - 1) << R300_SCISSOR_X_SHIFT) |
+				   ((pDst->drawable.height + 1440 - 1) << R300_SCISSOR_Y_SHIFT)));
     FINISH_ACCEL();
+    } else {
+    BEGIN_ACCEL(2);
+    OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
+ 				     (0 << R300_SCISSOR_Y_SHIFT)));
+    OUT_ACCEL_REG(R300_SC_SCISSOR1,
+                  (((pDst->drawable.width - 1) << R300_SCISSOR_X_SHIFT) |
+				   ((pDst->drawable.height - 1) << R300_SCISSOR_Y_SHIFT)));
+    FINISH_ACCEL();
+    }
 
     qwords = info->new_cs ? 4 : 3;
     BEGIN_ACCEL(qwords);
