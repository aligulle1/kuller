diff --git b/libdrm/nouveau/libdrm_nouveau.pc.in a/libdrm/nouveau/libdrm_nouveau.pc.in
index 7ef49e5..9e67a23 100644
--- b/libdrm/nouveau/libdrm_nouveau.pc.in
+++ a/libdrm/nouveau/libdrm_nouveau.pc.in
@@ -5,6 +5,6 @@ includedir=@includedir@
 
 Name: libdrm_nouveau
 Description: Userspace interface to nouveau kernel DRM services
-Version: 0.6
+Version: 0.5
 Libs: -L${libdir} -ldrm_nouveau
 Cflags: -I${includedir} -I${includedir}/drm -I${includedir}/nouveau
diff --git b/libdrm/nouveau/nouveau_bo.c a/libdrm/nouveau/nouveau_bo.c
index e68533b..66466e3 100644
--- b/libdrm/nouveau/nouveau_bo.c
+++ a/libdrm/nouveau/nouveau_bo.c
@@ -20,9 +20,6 @@
  * SOFTWARE.
  */
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
 #include <stdint.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -45,19 +42,6 @@ nouveau_bo_takedown(struct nouveau_device *dev)
 }
 
 static int
-nouveau_bo_info(struct nouveau_bo_priv *nvbo, struct drm_nouveau_gem_info *arg)
-{
-	nvbo->handle = nvbo->base.handle = arg->handle;
-	nvbo->domain = arg->domain;
-	nvbo->size = nvbo->base.size = arg->size;
-	nvbo->offset = arg->offset;
-	nvbo->map_handle = arg->map_handle;
-	nvbo->base.tile_mode = arg->tile_mode;
-	nvbo->base.tile_flags = arg->tile_flags;
-	return 0;
-}
-
-static int
 nouveau_bo_allocated(struct nouveau_bo_priv *nvbo)
 {
 	if (nvbo->sysmem || nvbo->handle || (nvbo->flags & NOUVEAU_BO_PIN))
@@ -168,8 +152,7 @@ nouveau_bo_kalloc_nomm(struct nouveau_bo_priv *nvbo)
 	if (ret)
 		return ret;
 
-	nvbo->handle =
-	nvbo->map_handle = req.map_handle;
+	nvbo->handle = req.map_handle;
 	nvbo->size = req.size;
 	nvbo->offset = req.offset;
 	if (req.flags & (NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI))
@@ -186,7 +169,6 @@ nouveau_bo_kalloc(struct nouveau_bo_priv *nvbo, struct nouveau_channel *chan)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
 	struct drm_nouveau_gem_new req;
-	struct drm_nouveau_gem_info *info = &req.info;
 	int ret;
 
 	if (nvbo->handle || (nvbo->flags & NOUVEAU_BO_PIN))
@@ -196,33 +178,38 @@ nouveau_bo_kalloc(struct nouveau_bo_priv *nvbo, struct nouveau_channel *chan)
 		return nouveau_bo_kalloc_nomm(nvbo);
 
 	req.channel_hint = chan ? chan->id : 0;
-	req.align = nvbo->align;
 
+	req.size = nvbo->size;
+	req.align = nvbo->align;
 
-	info->size = nvbo->size;
-	info->domain = 0;
+	req.domain = 0;
 
 	if (nvbo->flags & NOUVEAU_BO_VRAM)
-		info->domain |= NOUVEAU_GEM_DOMAIN_VRAM;
+		req.domain |= NOUVEAU_GEM_DOMAIN_VRAM;
+
 	if (nvbo->flags & NOUVEAU_BO_GART)
-		info->domain |= NOUVEAU_GEM_DOMAIN_GART;
-	if (!info->domain) {
-		info->domain |= (NOUVEAU_GEM_DOMAIN_VRAM |
-				 NOUVEAU_GEM_DOMAIN_GART);
-	}
+		req.domain |= NOUVEAU_GEM_DOMAIN_GART;
 
-	if (nvbo->flags & NOUVEAU_BO_MAP)
-		info->domain |= NOUVEAU_GEM_DOMAIN_MAPPABLE;
+	if (nvbo->flags & NOUVEAU_BO_TILED) {
+		req.domain |= NOUVEAU_GEM_DOMAIN_TILE;
+		if (nvbo->flags & NOUVEAU_BO_ZTILE)
+			req.domain |= NOUVEAU_GEM_DOMAIN_TILE_ZETA;
+	}
 
-	info->tile_mode = nvbo->base.tile_mode;
-	info->tile_flags = nvbo->base.tile_flags;
+	if (!req.domain) {
+		req.domain |= (NOUVEAU_GEM_DOMAIN_VRAM |
+			       NOUVEAU_GEM_DOMAIN_GART);
+	}
 
 	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_NEW,
 				  &req, sizeof(req));
 	if (ret)
 		return ret;
+	nvbo->handle = nvbo->base.handle = req.handle;
+	nvbo->size = req.size;
+	nvbo->domain = req.domain;
+	nvbo->offset = req.offset;
 
-	nouveau_bo_info(nvbo, &req.info);
 	return 0;
 }
 
@@ -245,30 +232,31 @@ static int
 nouveau_bo_kmap(struct nouveau_bo_priv *nvbo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
+	struct drm_nouveau_gem_mmap req;
+	int ret;
 
 	if (nvbo->map)
 		return 0;
 
-	if (!nvbo->map_handle)
+	if (!nvbo->handle)
 		return -EINVAL;
 
 	if (!nvdev->mm_enabled)
 		return nouveau_bo_kmap_nomm(nvbo);
 
-	nvbo->map = mmap(0, nvbo->size, PROT_READ | PROT_WRITE,
-			 MAP_SHARED, nvdev->fd, nvbo->map_handle);
-	if (nvbo->map == MAP_FAILED) {
-		nvbo->map = NULL;
-		return -errno;
-	}
+	req.handle = nvbo->handle;
+	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_MMAP,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
 
+	nvbo->map = (void *)(unsigned long)req.vaddr;
 	return 0;
 }
 
 int
-nouveau_bo_new_tile(struct nouveau_device *dev, uint32_t flags, int align,
-		    int size, uint32_t tile_mode, uint32_t tile_flags,
-		    struct nouveau_bo **bo)
+nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, int align,
+	       int size, struct nouveau_bo **bo)
 {
 	struct nouveau_bo_priv *nvbo;
 	int ret;
@@ -281,8 +269,6 @@ nouveau_bo_new_tile(struct nouveau_device *dev, uint32_t flags, int align,
 		return -ENOMEM;
 	nvbo->base.device = dev;
 	nvbo->base.size = size;
-	nvbo->base.tile_mode = tile_mode;
-	nvbo->base.tile_flags = tile_flags;
 
 	nvbo->refcount = 1;
 	/* Don't set NOUVEAU_BO_PIN here, or nouveau_bo_allocated() will
@@ -293,6 +279,13 @@ nouveau_bo_new_tile(struct nouveau_device *dev, uint32_t flags, int align,
 	nvbo->size = size;
 	nvbo->align = align;
 
+	/*XXX: murder me violently */
+	if (flags & NOUVEAU_BO_TILED) {
+		nvbo->base.tiled = 1;
+		if (flags & NOUVEAU_BO_ZTILE)
+			nvbo->base.tiled |= 2;
+	}
+
 	if (flags & NOUVEAU_BO_PIN) {
 		ret = nouveau_bo_pin((void *)nvbo, nvbo->flags);
 		if (ret) {
@@ -306,22 +299,6 @@ nouveau_bo_new_tile(struct nouveau_device *dev, uint32_t flags, int align,
 }
 
 int
-nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, int align,
-	       int size, struct nouveau_bo **bo)
-{
-	uint32_t tile_flags = 0;
-
-	if (flags & NOUVEAU_BO_TILED) {
-		if (flags & NOUVEAU_BO_ZTILE)
-			tile_flags = 0x2800;
-		else
-			tile_flags = 0x7000;
-	}
-
-	return nouveau_bo_new_tile(dev, flags, align, size, 0, tile_flags, bo);
-}
-
-int
 nouveau_bo_user(struct nouveau_device *dev, void *ptr, int size,
 		struct nouveau_bo **bo)
 {
@@ -361,35 +338,6 @@ nouveau_bo_fake(struct nouveau_device *dev, uint64_t offset, uint32_t flags,
 }
 
 int
-nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
-		struct nouveau_bo **bo)
-{
-	struct nouveau_device_priv *nvdev = nouveau_device(dev);
-	struct drm_nouveau_gem_info req;
-	struct nouveau_bo_priv *nvbo;
-	int ret;
-
-	if (!nvdev->mm_enabled)
-		return -ENODEV;
-
-	ret = nouveau_bo_new(dev, 0, 0, 0, bo);
-	if (ret)
-		return ret;
-	nvbo = nouveau_bo(*bo);
-
-	req.handle = handle;
-	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_INFO,
-				  &req, sizeof(req));
-	if (ret) {
-		nouveau_bo_ref(NULL, bo);
-		return ret;
-	}
-
-	nouveau_bo_info(nvbo, &req);
-	return 0;
-}
-
-int
 nouveau_bo_handle_get(struct nouveau_bo *bo, uint32_t *handle)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
@@ -433,12 +381,12 @@ nouveau_bo_handle_ref(struct nouveau_device *dev, uint32_t handle,
 	struct drm_gem_open req;
 	int ret;
 
-	if (!nvdev->mm_enabled) {
-		ret = nouveau_bo_new(dev, 0, 0, 0, bo);
-		if (ret)
-			return ret;
-		nvbo = nouveau_bo(*bo);
+	ret = nouveau_bo_new(dev, 0, 0, 0, bo);
+	if (ret)
+		return ret;
+	nvbo = nouveau_bo(*bo);
 
+	if (!nvdev->mm_enabled) {
 		nvbo->handle = 0;
 		nvbo->offset =  handle;
 		nvbo->domain = NOUVEAU_BO_VRAM;
@@ -453,13 +401,8 @@ nouveau_bo_handle_ref(struct nouveau_device *dev, uint32_t handle,
 			return ret;
 		}
 
-		ret = nouveau_bo_wrap(dev, req.handle, bo);
-		if (ret) {
-			nouveau_bo_ref(NULL, bo);
-			return ret;
-		}
-
-		nvbo = nouveau_bo(*bo);
+		nvbo->size = req.size;
+		nvbo->handle = req.handle;
 	}
 
 	nvbo->base.handle = nvbo->handle;
@@ -564,21 +507,17 @@ nouveau_bo_wait(struct nouveau_bo *bo, int cpu_write)
 		return nouveau_bo_wait_nomm(bo, cpu_write);
 
 	req.handle = nvbo->handle;
-	do {
-		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_CPU_PREP,
-				      &req, sizeof(req));
-	} while (ret == -EAGAIN);
+	ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_CPU_PREP,
+			      &req, sizeof(req));
 	if (ret)
 		return ret;
 
-	if (ret == 0)
-		nvbo->write_marker = 0;
+	nvbo->write_marker = 0;
 	return 0;
 }
 
 int
-nouveau_bo_map_range(struct nouveau_bo *bo, uint32_t delta, uint32_t size,
-		     uint32_t flags)
+nouveau_bo_map(struct nouveau_bo *bo, uint32_t flags)
 {
 	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
 	int ret;
@@ -601,36 +540,23 @@ nouveau_bo_map_range(struct nouveau_bo *bo, uint32_t delta, uint32_t size,
 	}
 
 	if (nvbo->sysmem) {
-		bo->map = (char *)nvbo->sysmem + delta;
+		bo->map = nvbo->sysmem;
 	} else {
 		ret = nouveau_bo_kmap(nvbo);
 		if (ret)
 			return ret;
 
-		if (!(flags & NOUVEAU_BO_NOSYNC)) {
-			ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR));
-			if (ret)
-				return ret;
-		}
+		ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR));
+		if (ret)
+			return ret;
 
-		bo->map = (char *)nvbo->map + delta;
+		bo->map = nvbo->map;
 	}
 
 	return 0;
 }
 
 void
-nouveau_bo_map_flush(struct nouveau_bo *bo, uint32_t delta, uint32_t size)
-{
-}
-
-int
-nouveau_bo_map(struct nouveau_bo *bo, uint32_t flags)
-{
-	return nouveau_bo_map_range(bo, 0, bo->size, flags);
-}
-
-void
 nouveau_bo_unmap(struct nouveau_bo *bo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
@@ -652,7 +578,7 @@ int
 nouveau_bo_validate_nomm(struct nouveau_bo_priv *nvbo, uint32_t flags)
 {
 	struct nouveau_bo *new = NULL;
-	uint32_t t_handle, t_domain, t_offset, t_size, t_maph;
+	uint32_t t_handle, t_domain, t_offset, t_size;
 	void *t_map;
 	int ret;
 
@@ -688,21 +614,18 @@ nouveau_bo_validate_nomm(struct nouveau_bo_priv *nvbo, uint32_t flags)
 	}
 
 	t_handle = nvbo->handle;
-	t_maph = nvbo->map_handle;
 	t_domain = nvbo->domain;
 	t_offset = nvbo->offset;
 	t_size = nvbo->size;
 	t_map = nvbo->map;
 
 	nvbo->handle = nouveau_bo(new)->handle;
-	nvbo->map_handle = nouveau_bo(new)->map_handle;
 	nvbo->domain = nouveau_bo(new)->domain;
 	nvbo->offset = nouveau_bo(new)->offset;
 	nvbo->size = nouveau_bo(new)->size;
 	nvbo->map = nouveau_bo(new)->map;
 
 	nouveau_bo(new)->handle = t_handle;
-	nouveau_bo(new)->map_handle = t_maph;
 	nouveau_bo(new)->domain = t_domain;
 	nouveau_bo(new)->offset = t_offset;
 	nouveau_bo(new)->size = t_size;
diff --git b/libdrm/nouveau/nouveau_bo.h a/libdrm/nouveau/nouveau_bo.h
index 9b1feff..84a4348 100644
--- b/libdrm/nouveau/nouveau_bo.h
+++ a/libdrm/nouveau/nouveau_bo.h
@@ -37,10 +37,6 @@
 #define NOUVEAU_BO_LOCAL  (1 << 9)
 #define NOUVEAU_BO_TILED  (1 << 10)
 #define NOUVEAU_BO_ZTILE  (1 << 11)
-#define NOUVEAU_BO_INVAL  (1 << 12)
-#define NOUVEAU_BO_NOSYNC (1 << 13)
-#define NOUVEAU_BO_NOWAIT (1 << 14)
-#define NOUVEAU_BO_IFLUSH (1 << 15)
 #define NOUVEAU_BO_DUMMY  (1 << 31)
 
 struct nouveau_bo {
@@ -50,8 +46,7 @@ struct nouveau_bo {
 	uint64_t size;
 	void *map;
 
-	uint32_t tile_mode;
-	uint32_t tile_flags;
+	int tiled;
 
 	/* Available when buffer is pinned *only* */
 	uint32_t flags;
@@ -63,11 +58,6 @@ nouveau_bo_new(struct nouveau_device *, uint32_t flags, int align, int size,
 	       struct nouveau_bo **);
 
 int
-nouveau_bo_new_tile(struct nouveau_device *, uint32_t flags, int align,
-		    int size, uint32_t tile_mode, uint32_t tile_flags,
-		    struct nouveau_bo **);
-
-int
 nouveau_bo_user(struct nouveau_device *, void *ptr, int size,
 		struct nouveau_bo **);
 
@@ -76,9 +66,6 @@ nouveau_bo_fake(struct nouveau_device *dev, uint64_t offset, uint32_t flags,
 		uint32_t size, void *map, struct nouveau_bo **);
 
 int
-nouveau_bo_wrap(struct nouveau_device *, uint32_t handle, struct nouveau_bo **);
-
-int
 nouveau_bo_handle_get(struct nouveau_bo *, uint32_t *);
 
 int
@@ -89,13 +76,6 @@ int
 nouveau_bo_ref(struct nouveau_bo *, struct nouveau_bo **);
 
 int
-nouveau_bo_map_range(struct nouveau_bo *, uint32_t delta, uint32_t size,
-		     uint32_t flags);
-
-void
-nouveau_bo_map_flush(struct nouveau_bo *, uint32_t delta, uint32_t size);
-
-int
 nouveau_bo_map(struct nouveau_bo *, uint32_t flags);
 
 void
diff --git b/libdrm/nouveau/nouveau_device.c a/libdrm/nouveau/nouveau_device.c
index 6b99e36..a61abb4 100644
--- b/libdrm/nouveau/nouveau_device.c
+++ a/libdrm/nouveau/nouveau_device.c
@@ -26,7 +26,7 @@
 
 #include "nouveau_private.h"
 
-#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 14
+#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 12
 #error nouveau_drm.h does not match expected patchlevel, update libdrm.
 #endif
 
@@ -82,7 +82,7 @@ nouveau_device_open_existing(struct nouveau_device **dev, int close,
 		nouveau_device_close((void *)&nvdev);
 		return ret;
 	}
-	nvdev->base.vm_vram_size = value;
+	nvdev->vram_aper_size = value;
 
 	ret = nouveau_device_get_param(&nvdev->base,
 				       NOUVEAU_GETPARAM_AGP_SIZE, &value);
@@ -90,7 +90,7 @@ nouveau_device_open_existing(struct nouveau_device **dev, int close,
 		nouveau_device_close((void *)&nvdev);
 		return ret;
 	}
-	nvdev->base.vm_gart_size = value;
+	nvdev->gart_aper_size = value;
 
 	ret = nouveau_bo_init(&nvdev->base);
 	if (ret) {
diff --git b/libdrm/nouveau/nouveau_device.h a/libdrm/nouveau/nouveau_device.h
index c0d9333..76b7b95 100644
--- b/libdrm/nouveau/nouveau_device.h
+++ a/libdrm/nouveau/nouveau_device.h
@@ -26,8 +26,6 @@
 struct nouveau_device {
 	unsigned chipset;
 	uint64_t vm_vram_base;
-	uint64_t vm_vram_size;
-	uint64_t vm_gart_size;
 };
 
 #endif
diff --git b/libdrm/nouveau/nouveau_drmif.h a/libdrm/nouveau/nouveau_drmif.h
index c21fba2..3791325 100644
--- b/libdrm/nouveau/nouveau_drmif.h
+++ a/libdrm/nouveau/nouveau_drmif.h
@@ -37,6 +37,9 @@ struct nouveau_device_priv {
 	int needs_close;
 
 	int mm_enabled;
+/*XXX: move to nouveau_device when interface gets bumped */
+	uint64_t vram_aper_size;
+	uint64_t gart_aper_size;
 };
 #define nouveau_device(n) ((struct nouveau_device_priv *)(n))
 
diff --git b/libdrm/nouveau/nouveau_private.h a/libdrm/nouveau/nouveau_private.h
index e92cb1f..32a9052 100644
--- b/libdrm/nouveau/nouveau_private.h
+++ a/libdrm/nouveau/nouveau_private.h
@@ -174,7 +174,6 @@ struct nouveau_bo_priv {
 	/* Kernel object */
 	uint32_t global_handle;
 	drm_handle_t handle;
-	uint64_t map_handle;
 	void *map;
 
 	/* Last known information from kernel on buffer status */
diff --git b/libdrm/nouveau/nouveau_pushbuf.c a/libdrm/nouveau/nouveau_pushbuf.c
index fded21b..5b8d18b 100644
--- b/libdrm/nouveau/nouveau_pushbuf.c
+++ a/libdrm/nouveau/nouveau_pushbuf.c
@@ -60,8 +60,8 @@ nouveau_pushbuf_calc_reloc(struct drm_nouveau_gem_pushbuf_bo *pbbo,
 
 int
 nouveau_pushbuf_emit_reloc(struct nouveau_channel *chan, void *ptr,
-			   struct nouveau_bo *bo, uint32_t data, uint32_t data2,
-			   uint32_t flags, uint32_t vor, uint32_t tor)
+			   struct nouveau_bo *bo, uint32_t data, uint32_t flags,
+			   uint32_t vor, uint32_t tor)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(chan->device);
 	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(chan->pushbuf);
diff --git b/libdrm/nouveau/nouveau_pushbuf.h a/libdrm/nouveau/nouveau_pushbuf.h
index 3c746ed..414ad2d 100644
--- b/libdrm/nouveau/nouveau_pushbuf.h
+++ a/libdrm/nouveau/nouveau_pushbuf.h
@@ -41,8 +41,8 @@ nouveau_pushbuf_flush(struct nouveau_channel *, unsigned min);
 
 int
 nouveau_pushbuf_emit_reloc(struct nouveau_channel *, void *ptr,
-			   struct nouveau_bo *, uint32_t data, uint32_t data2,
-			   uint32_t flags, uint32_t vor, uint32_t tor);
+			   struct nouveau_bo *, uint32_t data, uint32_t flags,
+			   uint32_t vor, uint32_t tor);
 
 /* Push buffer access macros */
 static __inline__ void
@@ -121,16 +121,7 @@ OUT_RELOC(struct nouveau_channel *chan, struct nouveau_bo *bo,
 	  unsigned data, unsigned flags, unsigned vor, unsigned tor)
 {
 	nouveau_pushbuf_emit_reloc(chan, chan->pushbuf->cur++, bo,
-				   data, 0, flags, vor, tor);
-}
-
-static __inline__ void
-OUT_RELOC2(struct nouveau_channel *chan, struct nouveau_bo *bo,
-	   unsigned data, unsigned data2, unsigned flags,
-	   unsigned vor, unsigned tor)
-{
-	nouveau_pushbuf_emit_reloc(chan, chan->pushbuf->cur++, bo,
-				   data, data2, flags, vor, tor);
+				   data, flags, vor, tor);
 }
 
 /* Raw data + flags depending on FB/TT buffer */
@@ -158,14 +149,6 @@ OUT_RELOCl(struct nouveau_channel *chan, struct nouveau_bo *bo,
 	OUT_RELOC(chan, bo, delta, flags | NOUVEAU_BO_LOW, 0, 0);
 }
 
-/* Low 32-bits of offset + GPU linear access range info */
-static __inline__ void
-OUT_RELOCr(struct nouveau_channel *chan, struct nouveau_bo *bo,
-	   unsigned delta, unsigned size, unsigned flags)
-{
-	OUT_RELOC2(chan, bo, delta, size, flags | NOUVEAU_BO_LOW, 0, 0);
-}
-
 /* High 32-bits of offset */
 static __inline__ void
 OUT_RELOCh(struct nouveau_channel *chan, struct nouveau_bo *bo,
diff --git b/shared-core/nouveau_drm.h a/shared-core/nouveau_drm.h
index dc6a194..4147f35 100644
--- b/shared-core/nouveau_drm.h
+++ a/shared-core/nouveau_drm.h
@@ -25,7 +25,7 @@
 #ifndef __NOUVEAU_DRM_H__
 #define __NOUVEAU_DRM_H__
 
-#define NOUVEAU_DRM_HEADER_PATCHLEVEL 14
+#define NOUVEAU_DRM_HEADER_PATCHLEVEL 12
 
 struct drm_nouveau_channel_alloc {
 	uint32_t     fb_ctxdma_handle;
@@ -153,22 +153,17 @@ struct drm_nouveau_setparam {
 #define NOUVEAU_GEM_DOMAIN_CPU       (1 << 0)
 #define NOUVEAU_GEM_DOMAIN_VRAM      (1 << 1)
 #define NOUVEAU_GEM_DOMAIN_GART      (1 << 2)
-#define NOUVEAU_GEM_DOMAIN_MAPPABLE  (1 << 3)
-
-struct drm_nouveau_gem_info {
-	uint32_t handle;
-	uint32_t domain;
-	uint64_t size;
-	uint64_t offset;
-	uint64_t map_handle;
-	uint32_t tile_mode;
-	uint32_t tile_flags;
-};
+#define NOUVEAU_GEM_DOMAIN_NOMAP     (1 << 3)
+#define NOUVEAU_GEM_DOMAIN_TILE      (1 << 30)
+#define NOUVEAU_GEM_DOMAIN_TILE_ZETA (1 << 31)
 
 struct drm_nouveau_gem_new {
-	struct drm_nouveau_gem_info info;
+	uint64_t size;
 	uint32_t channel_hint;
 	uint32_t align;
+	uint32_t handle;
+	uint32_t domain;
+	uint32_t offset;
 };
 
 struct drm_nouveau_gem_pushbuf_bo {
@@ -228,6 +223,12 @@ struct drm_nouveau_gem_unpin {
 	uint32_t handle;
 };
 
+struct drm_nouveau_gem_mmap {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t vaddr;
+};
+
 struct drm_nouveau_gem_cpu_prep {
 	uint32_t handle;
 };
@@ -290,9 +291,9 @@ struct drm_nouveau_sarea {
 #define DRM_NOUVEAU_GEM_PUSHBUF_CALL   0x42
 #define DRM_NOUVEAU_GEM_PIN            0x43
 #define DRM_NOUVEAU_GEM_UNPIN          0x44
-#define DRM_NOUVEAU_GEM_CPU_PREP       0x45
-#define DRM_NOUVEAU_GEM_CPU_FINI       0x46
-#define DRM_NOUVEAU_GEM_TILE           0x47
-#define DRM_NOUVEAU_GEM_INFO           0x48
+#define DRM_NOUVEAU_GEM_MMAP           0x45
+#define DRM_NOUVEAU_GEM_CPU_PREP       0x46
+#define DRM_NOUVEAU_GEM_CPU_FINI       0x47
+#define DRM_NOUVEAU_GEM_TILE           0x48
 
 #endif /* __NOUVEAU_DRM_H__ */
