Index: solid/networkmanager-0.7/networkinterface_p.h
===================================================================
--- solid/networkmanager-0.7/networkinterface_p.h	(revision 1145886)
+++ solid/networkmanager-0.7/networkinterface_p.h	(revision 1145887)
@@ -34,6 +34,7 @@
     Solid::Control::NetworkInterface::Capabilities capabilities;
     //bool isLinkUp;
     QString uni;
+    QString udi;
     int designSpeed;
     Solid::Control::NetworkInterface::ConnectionState connectionState;
     bool managed;
Index: solid/networkmanager-0.7/networkinterface.h
===================================================================
--- solid/networkmanager-0.7/networkinterface.h	(revision 1145886)
+++ solid/networkmanager-0.7/networkinterface.h	(revision 1145887)
@@ -40,6 +40,7 @@
 Q_PROPERTY(QVariant genericCapabilities READ capabilitiesV WRITE setCapabilitiesV)
 Q_PROPERTY(int ipV4Address READ ipV4Address)
 Q_PROPERTY(bool managed READ managed WRITE setManaged)
+Q_PROPERTY(QString udi READ udi)
 
 //Q_PROPERTY(Solid::Control::IPv4Config ipV4Config READ ipV4Config WRITE setIpV4Config)
 Q_PROPERTY(Solid::Control::NetworkInterface::ConnectionState connectionState READ connectionState WRITE setConnectionState)
@@ -68,6 +69,7 @@
     void setCapabilitiesV(const QVariant&);
     bool managed() const;
     void setManaged(const QVariant&);
+    QString udi() const;
 
 Q_SIGNALS:
     void ipDetailsChanged();
Index: solid/networkmanager-0.7/manager.h
===================================================================
--- solid/networkmanager-0.7/manager.h	(revision 1145886)
+++ solid/networkmanager-0.7/manager.h	(revision 1145887)
@@ -72,7 +72,6 @@
     void nameOwnerChanged(QString, QString, QString);
 private:
     static Solid::Networking::Status convertNMState(uint state);
-private:
     NMNetworkManagerPrivate * d_ptr;
 };
 
Index: solid/networkmanager-0.7/networkgsminterface.h
===================================================================
--- solid/networkmanager-0.7/networkgsminterface.h	(revision 1145886)
+++ solid/networkmanager-0.7/networkgsminterface.h	(revision 1145887)
@@ -20,6 +20,7 @@
 
 #include "networkserialinterface.h"
 #include "solid/control/ifaces/networkgsminterface.h"
+#include "solid/control/modemgsmnetworkinterface.h"
 
 #include "dbus/generic-types.h"
 
@@ -37,8 +38,16 @@
 public:
     NMGsmNetworkInterface(const QString & path, NMNetworkManager * manager, QObject * parent);
     virtual ~NMGsmNetworkInterface();
+    Solid::Control::ModemGsmCardInterface * getModemCardIface();
+    void setModemCardIface(Solid::Control::ModemGsmCardInterface * iface);
+    Solid::Control::ModemGsmNetworkInterface * getModemNetworkIface();
+    void setModemNetworkIface(Solid::Control::ModemGsmNetworkInterface * iface);
 public Q_SLOTS:
     void gsmPropertiesChanged(const QVariantMap & changedProperties);
+    void modemRemoved(const QString & modemUdi);
+private:
+    Solid::Control::ModemGsmCardInterface *modemGsmCardIface;
+    Solid::Control::ModemGsmNetworkInterface *modemGsmNetworkIface;
 };
 
 #endif
Index: solid/networkmanager-0.7/networkinterface.cpp
===================================================================
--- solid/networkmanager-0.7/networkinterface.cpp	(revision 1145886)
+++ solid/networkmanager-0.7/networkinterface.cpp	(revision 1145887)
@@ -48,6 +48,7 @@
     interfaceName = deviceIface.interface();
     ipV4Address = deviceIface.ip4Address();    
     managed = deviceIface.managed();
+    udi = deviceIface.udi();
 
     //TODO set active connections based on active connection list on the manager; find out if
     //signal needed
@@ -121,6 +122,12 @@
     d->driver = driver.toString();
 }
 
+QString NMNetworkInterface::udi() const
+{
+    Q_D(const NMNetworkInterface);
+    return d->udi;
+}
+
 int NMNetworkInterface::ipV4Address() const
 {
     Q_D(const NMNetworkInterface);
Index: solid/networkmanager-0.7/accesspoint.h
===================================================================
--- solid/networkmanager-0.7/accesspoint.h	(revision 1145886)
+++ solid/networkmanager-0.7/accesspoint.h	(revision 1145887)
@@ -37,6 +37,7 @@
     virtual ~NMAccessPoint();
 
     QString uni() const;
+    QString udi() const;
     Solid::Control::AccessPoint::Capabilities capabilities() const;
     Solid::Control::AccessPoint::WpaFlags wpaFlags() const;
     Solid::Control::AccessPoint::WpaFlags rsnFlags() const;
Index: solid/networkmanager-0.7/networkgsminterface.cpp
===================================================================
--- solid/networkmanager-0.7/networkgsminterface.cpp	(revision 1145886)
+++ solid/networkmanager-0.7/networkgsminterface.cpp	(revision 1145887)
@@ -25,13 +25,16 @@
 #include "networkgsminterface_p.h"
 #include "manager.h"
 
+#include "solid/control/modemmanager.h"
+
 NMGsmNetworkInterfacePrivate::NMGsmNetworkInterfacePrivate(const QString & path, QObject * owner)
     : NMSerialNetworkInterfacePrivate(path, owner), gsmIface(NMNetworkManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
 {
 }
 
 NMGsmNetworkInterface::NMGsmNetworkInterface(const QString & path, NMNetworkManager * manager, QObject * parent)
-    : NMSerialNetworkInterface(*new NMGsmNetworkInterfacePrivate(path, this), manager, parent)
+    : NMSerialNetworkInterface(*new NMGsmNetworkInterfacePrivate(path, this), manager, parent),
+      modemGsmCardIface(0), modemGsmNetworkIface(0)
 {
     Q_D(NMGsmNetworkInterface);
     connect( &d->gsmIface, SIGNAL(PropertiesChanged(const QVariantMap &)),
@@ -48,6 +51,44 @@
     kDebug(1441) << changedProperties.keys();
 }
 
+Solid::Control::ModemGsmCardInterface * NMGsmNetworkInterface::getModemCardIface()
+{
+    if (modemGsmCardIface == 0) {
+        modemGsmCardIface = qobject_cast<Solid::Control::ModemGsmCardInterface*> (Solid::Control::ModemManager::findModemInterface(udi(), Solid::Control::ModemInterface::GsmCard));
+        connect(Solid::Control::ModemManager::notifier(), SIGNAL(modemInterfaceRemoved(const QString &)), this, SLOT(modemRemoved(const QString &)));
+    }
+
+    return modemGsmCardIface;
+}
+
+Solid::Control::ModemGsmNetworkInterface * NMGsmNetworkInterface::getModemNetworkIface()
+{
+    if (modemGsmNetworkIface == 0) {
+        modemGsmNetworkIface = qobject_cast<Solid::Control::ModemGsmNetworkInterface*> (Solid::Control::ModemManager::findModemInterface(udi(), Solid::Control::ModemInterface::GsmNetwork));
+        connect(Solid::Control::ModemManager::notifier(), SIGNAL(modemInterfaceRemoved(const QString &)), this, SLOT(modemRemoved(const QString &)));
+    }
+
+    return modemGsmNetworkIface;
+}
+
+void NMGsmNetworkInterface::modemRemoved(const QString & modemUdi)
+{
+    if (modemUdi == udi()) {
+        modemGsmNetworkIface = 0;
+        modemGsmCardIface = 0;
+    }
+}
+
+void NMGsmNetworkInterface::setModemCardIface(Solid::Control::ModemGsmCardInterface * iface)
+{
+    modemGsmCardIface = iface;
+}
+
+void NMGsmNetworkInterface::setModemNetworkIface(Solid::Control::ModemGsmNetworkInterface * iface)
+{
+    modemGsmNetworkIface = iface;
+}
+
 #include "networkgsminterface.moc"
 
 // vim: sw=4 sts=4 et tw=100
Index: solid/wicd/networkinterface.h
===================================================================
--- solid/wicd/networkinterface.h	(revision 1145886)
+++ solid/wicd/networkinterface.h	(revision 1145887)
@@ -40,6 +40,7 @@
     virtual QString driver() const = 0;
     Solid::Control::IPv4Config ipV4Config() const;
     QString uni() const;
+    QString udi() const;
     virtual bool isActive() const = 0;
     virtual Solid::Control::NetworkInterface::Type type() const = 0;
     virtual Solid::Control::NetworkInterface::ConnectionState connectionState() const = 0;
Index: solid/kcm/kcmsolid.cpp
===================================================================
--- solid/kcm/kcmsolid.cpp	(revision 1145886)
+++ solid/kcm/kcmsolid.cpp	(revision 1145887)
@@ -57,11 +57,13 @@
     m_networkChooser = new BackendChooser(this, "SolidNetworkManager");
     m_bluetoothChooser = new BackendChooser(this, "SolidBluetoothManager");
     m_remoteControlChooser = new BackendChooser(this, "SolidRemoteControlManager");
+    m_modemChooser = new BackendChooser(this, "SolidModemManager");
 
     layout()->addWidget(m_powerChooser);
     layout()->addWidget(m_networkChooser);
     layout()->addWidget(m_bluetoothChooser);
     layout()->addWidget(m_remoteControlChooser);
+    layout()->addWidget(m_modemChooser);
 
     load();
 
@@ -71,6 +73,8 @@
              this, SLOT(slotChooserChanged(bool)));
     connect(m_bluetoothChooser, SIGNAL(changed(bool)),
              this, SLOT(slotChooserChanged(bool)));
+    connect(m_modemChooser, SIGNAL(changed(bool)),
+             this, SLOT(slotChooserChanged(bool)));
 
 }
 
@@ -80,6 +84,7 @@
     m_networkChooser->load();
     m_bluetoothChooser->load();
     m_remoteControlChooser->load();
+    m_modemChooser->load();
 }
 
 void KcmSolid::save()
@@ -87,6 +92,7 @@
     m_powerChooser->save();
     m_networkChooser->save();
     m_bluetoothChooser->save();
+    m_modemChooser->save();
 }
 
 void KcmSolid::defaults()
@@ -94,6 +100,7 @@
     m_powerChooser->defaults();
     m_networkChooser->defaults();
     m_bluetoothChooser->defaults();
+    m_modemChooser->defaults();
 }
 
 void KcmSolid::slotChooserChanged(bool state)
Index: solid/kcm/kcmsolid.h
===================================================================
--- solid/kcm/kcmsolid.h	(revision 1145886)
+++ solid/kcm/kcmsolid.h	(revision 1145887)
@@ -45,6 +45,7 @@
     BackendChooser *m_networkChooser;
     BackendChooser *m_bluetoothChooser;
     BackendChooser *m_remoteControlChooser;
+    BackendChooser *m_modemChooser;
 };
 
 #endif
Index: solid/modemmanager-0.4/manager_p.h
===================================================================
--- solid/modemmanager-0.4/manager_p.h	(revision 0)
+++ solid/modemmanager-0.4/manager_p.h	(revision 1145887)
@@ -0,0 +1,43 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMMANAGER_P_H
+#define MM04_MODEMMANAGER_P_H
+
+#include <QMap>
+
+#include <solid/networking.h>
+
+#include "dbus/mm-modeminterface.h"
+#include "dbus/mm-manager-clientinterface.h"
+#include "dbus/mm-modem-gsm-networkinterface.h"
+
+class MMModemManagerPrivate
+{
+public:
+    MMModemManagerPrivate();
+    OrgFreedesktopModemManagerInterface iface;
+    Solid::Networking::Status mmState;
+    QStringList modemInterfaces;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemlocationinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemlocationinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemlocationinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMLOCATIONINTERFACE_P_H
+#define MM04_MODEMLOCATIONINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-locationinterface.h"
+
+class MMModemLocationInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemLocationInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemLocationInterface modemLocationIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmsmsinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmsmsinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmsmsinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMSMSINTERFACE_P_H
+#define MM04_MODEMGSMSMSINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-smsinterface.h"
+
+class MMModemGsmSmsInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmSmsInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmSMSInterface modemGsmSmsIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmhsointerface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmhsointerface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmhsointerface.cpp	(revision 1145887)
@@ -0,0 +1,53 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmhsointerface.h"
+#include "modemgsmhsointerface_p.h"
+
+#include <KDebug>
+
+MMModemGsmHsoInterfacePrivate::MMModemGsmHsoInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmHsoIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmHsoInterface::MMModemGsmHsoInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmHsoInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(const MMModemGsmHsoInterface);
+    connect( &d->modemGsmHsoIface, SIGNAL(smsReceived(uint, bool)),
+                this, SIGNAL(smsReceived(int, bool)));
+    connect( &d->modemGsmHsoIface, SIGNAL(completed(uint, bool)),
+                this, SIGNAL(completed(int, bool)));
+}
+
+MMModemGsmHsoInterface::~MMModemGsmHsoInterface()
+{
+}
+
+void MMModemGsmHsoInterface::authenticate(const QString & username, const QString & password)
+{
+    Q_D(MMModemGsmHsoInterface);
+    d->modemGsmHsoIface.Authenticate(username, password);
+}
+
+#include "modemgsmhsointerface.moc"
+
Index: solid/modemmanager-0.4/modeminterface_p.h
===================================================================
--- solid/modemmanager-0.4/modeminterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modeminterface_p.h	(revision 1145887)
@@ -0,0 +1,48 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMINTERFACE_P_H
+#define MM04_MODEMINTERFACE_P_H
+
+#include "dbus/mm-modeminterface.h"
+#include "dbus/mm-modem-simpleinterface.h"
+
+class MMModemManager;
+
+class MMModemInterfacePrivate
+{
+public:
+    MMModemInterfacePrivate( const QString & path, QObject * owner );
+    OrgFreedesktopModemManagerModemInterface modemIface;
+    OrgFreedesktopModemManagerModemSimpleInterface modemSimpleIface;
+    QString udi;
+    QString device;
+    QString masterDevice;
+    QString driver;
+    Solid::Control::ModemInterface::Type type;
+    bool enabled;
+    QString unlockRequired;
+    Solid::Control::ModemInterface::Method ipMethod;
+    MMModemManager * manager;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmcardinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmcardinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcardinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMCARDINTERFACE_P_H
+#define MM04_MODEMGSMCARDINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-cardinterface.h"
+
+class MMModemGsmCardInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmCardInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmCardInterface modemGsmCardIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmnetworkinterface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmnetworkinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmnetworkinterface.h	(revision 1145887)
@@ -0,0 +1,64 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMNETWORKINTERFACE_H
+#define MM04_MODEMGSMNETWORKINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmnetworkinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmNetworkInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmNetworkInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmNetworkInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmNetworkInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmNetworkInterface)
+
+public:
+    MMModemGsmNetworkInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmNetworkInterface();
+
+    void registerToNetwork(const QString & networkId);
+    ScanResultsType scan();
+    void setApn(const QString & apn);
+    uint getSignalQuality();
+    void setBand(const Solid::Control::ModemInterface::Band band);
+    Solid::Control::ModemInterface::Band getBand();
+    RegistrationInfoType getRegistrationInfo();
+    void setAllowedMode(const Solid::Control::ModemInterface::AllowedMode mode);
+    // properties
+    Solid::Control::ModemInterface::AllowedMode getAllowedMode() const;
+    Solid::Control::ModemInterface::AccessTechnology getAccessTechnology() const;
+public Q_SLOTS:
+    void slotRegistrationInfoChanged(uint status, const QString & operatorCode, const QString &operatorName);
+    void propertiesChanged(const QString & interface, const QVariantMap & properties);
+Q_SIGNALS:
+    void signalQualityChanged(uint signalQuality);
+    void registrationInfoChanged(const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &registrationInfo);
+    // properties
+    void allowedModeChanged(const Solid::Control::ModemInterface::AllowedMode mode);
+    void accessTechnologyChanged(const Solid::Control::ModemInterface::AccessTechnology tech);
+};
+
+#endif
+
Index: solid/modemmanager-0.4/dbus/mm-modeminterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modeminterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modeminterface.h	(revision 1145887)
@@ -0,0 +1,104 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modeminterface introspection/mm-modem.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEMINTERFACE_H
+#define MM_MODEMINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem
+ */
+class OrgFreedesktopModemManagerModemInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem"; }
+
+public:
+    OrgFreedesktopModemManagerModemInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemInterface();
+
+    Q_PROPERTY(QString Device READ device)
+    inline QString device() const
+    { return qvariant_cast< QString >(property("Device")); }
+
+    Q_PROPERTY(QString Driver READ driver)
+    inline QString driver() const
+    { return qvariant_cast< QString >(property("Driver")); }
+
+    Q_PROPERTY(bool Enabled READ enabled)
+    inline bool enabled() const
+    { return qvariant_cast< bool >(property("Enabled")); }
+
+    Q_PROPERTY(uint IpMethod READ ipMethod)
+    inline uint ipMethod() const
+    { return qvariant_cast< uint >(property("IpMethod")); }
+
+    Q_PROPERTY(QString MasterDevice READ masterDevice)
+    inline QString masterDevice() const
+    { return qvariant_cast< QString >(property("MasterDevice")); }
+
+    Q_PROPERTY(uint Type READ type)
+    inline uint type() const
+    { return qvariant_cast< uint >(property("Type")); }
+
+    Q_PROPERTY(QString UnlockRequired READ unlockRequired)
+    inline QString unlockRequired() const
+    { return qvariant_cast< QString >(property("UnlockRequired")); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Connect(const QString &number)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(number);
+        return asyncCallWithArgumentList(QLatin1String("Connect"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Disconnect()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Disconnect"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Enable(bool enable)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(enable);
+        return asyncCallWithArgumentList(QLatin1String("Enable"), argumentList);
+    }
+
+    inline QDBusPendingReply<Ip4ConfigType> GetIP4Config()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetIP4Config"), argumentList);
+    }
+
+    inline QDBusPendingReply<InfoType> GetInfo()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetInfo"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.h	(revision 1145887)
@@ -0,0 +1,74 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-ussdinterface introspection/mm-modem-gsm-ussd.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_USSDINTERFACE_H
+#define MM_MODEM_GSM_USSDINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Ussd
+ */
+class OrgFreedesktopModemManagerModemGsmUssdInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.Ussd"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmUssdInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmUssdInterface();
+
+    Q_PROPERTY(QString NetworkNotification READ networkNotification)
+    inline QString networkNotification() const
+    { return qvariant_cast< QString >(property("NetworkNotification")); }
+
+    Q_PROPERTY(QString NetworkRequest READ networkRequest)
+    inline QString networkRequest() const
+    { return qvariant_cast< QString >(property("NetworkRequest")); }
+
+    Q_PROPERTY(QString State READ state)
+    inline QString state() const
+    { return qvariant_cast< QString >(property("State")); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Cancel()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Cancel"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> Initiate(const QString &command)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(command);
+        return asyncCallWithArgumentList(QLatin1String("Initiate"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Respond(const QString &response)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(response);
+        return asyncCallWithArgumentList(QLatin1String("Respond"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.h	(revision 1145887)
@@ -0,0 +1,84 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-contactsinterface introspection/mm-modem-gsm-contacts.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_CONTACTSINTERFACE_H
+#define MM_MODEM_GSM_CONTACTSINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Contacts
+ */
+class OrgFreedesktopModemManagerModemGsmContactsInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.Contacts"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmContactsInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmContactsInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<uint> Add(const QString &name, const QString &number)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(name) << qVariantFromValue(number);
+        return asyncCallWithArgumentList(QLatin1String("Add"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Delete(uint index)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(index);
+        return asyncCallWithArgumentList(QLatin1String("Delete"), argumentList);
+    }
+
+    inline QDBusPendingReply<ContactTypeList> Find(const QString &pattern)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(pattern);
+        return asyncCallWithArgumentList(QLatin1String("Find"), argumentList);
+    }
+
+    inline QDBusPendingReply<ContactType> Get(uint index)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(index);
+        return asyncCallWithArgumentList(QLatin1String("Get"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> GetCount()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetCount"), argumentList);
+    }
+
+    inline QDBusPendingReply<ContactTypeList> List()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("List"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-locationinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-locationinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-locationinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-locationinterface introspection/mm-modem-location.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-locationinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemLocationInterface
+ */
+
+OrgFreedesktopModemManagerModemLocationInterface::OrgFreedesktopModemManagerModemLocationInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemLocationInterface::~OrgFreedesktopModemManagerModemLocationInterface()
+{
+}
+
+
+#include "mm-modem-locationinterface.moc"
Index: solid/modemmanager-0.4/dbus/do-hand-edits
===================================================================
--- solid/modemmanager-0.4/dbus/do-hand-edits	(revision 0)
+++ solid/modemmanager-0.4/dbus/do-hand-edits	(revision 1145887)
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+if [ -e hand-edits.diff ]
+then
+  rm hand-edits.diff
+fi
+
+BUILD_DIR=/space/kde/builds/trunk/KDE/kdebase/workspace/solid/modemkmanager-0.4/dbus
+for i in *.h *.cpp
+
+do
+  other="$BUILD_DIR/$i"
+  if [ -e $other ]
+  then
+    diff -u $other $i >> hand-edits.diff
+  fi
+done
+
+
Index: solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.h	(revision 1145887)
@@ -0,0 +1,79 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-cdmainterface introspection/mm-modem-cdma.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_CDMAINTERFACE_H
+#define MM_MODEM_CDMAINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Cdma
+ */
+class OrgFreedesktopModemManagerModemCdmaInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Cdma"; }
+
+public:
+    OrgFreedesktopModemManagerModemCdmaInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemCdmaInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<QString> GetEsn()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetEsn"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint, uint> GetRegistrationState()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetRegistrationState"), argumentList);
+    }
+    inline QDBusReply<uint> GetRegistrationState(uint &evdo_state)
+    {
+        QList<QVariant> argumentList;
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("GetRegistrationState"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 2) {
+            evdo_state = qdbus_cast<uint>(reply.arguments().at(1));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<ServingSystemType> GetServingSystem()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetServingSystem"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> GetSignalQuality()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetSignalQuality"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void RegistrationStateChanged(uint cdma_1x_state, uint evdo_state);
+    void SignalQuality(uint quality);
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-locationinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-locationinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-locationinterface.h	(revision 1145887)
@@ -0,0 +1,73 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-locationinterface introspection/mm-modem-location.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_LOCATIONINTERFACE_H
+#define MM_MODEM_LOCATIONINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Location
+ */
+class OrgFreedesktopModemManagerModemLocationInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Location"; }
+
+public:
+    OrgFreedesktopModemManagerModemLocationInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemLocationInterface();
+
+    Q_PROPERTY(uint Capabilities READ capabilities)
+    inline uint capabilities() const
+    { return qvariant_cast< uint >(property("Capabilities")); }
+
+    Q_PROPERTY(bool Enabled READ enabled)
+    inline bool enabled() const
+    { return qvariant_cast< bool >(property("Enabled")); }
+
+    Q_PROPERTY(LocationInformationMap Location READ location)
+    inline LocationInformationMap location() const
+    { return qvariant_cast< LocationInformationMap >(property("Location")); }
+
+    Q_PROPERTY(bool SignalsLocation READ signalsLocation)
+    inline bool signalsLocation() const
+    { return qvariant_cast< bool >(property("SignalsLocation")); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Enable(bool enable, bool signal_location)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(enable) << qVariantFromValue(signal_location);
+        return asyncCallWithArgumentList(QLatin1String("Enable"), argumentList);
+    }
+
+    inline QDBusPendingReply<LocationInformationMap> GetLocation()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetLocation"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-networkinterface introspection/mm-modem-gsm-network.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-networkinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmNetworkInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmNetworkInterface::OrgFreedesktopModemManagerModemGsmNetworkInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmNetworkInterface::~OrgFreedesktopModemManagerModemGsmNetworkInterface()
+{
+}
+
+
+#include "mm-modem-gsm-networkinterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-hsointerface introspection/mm-modem-gsm-hso.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-hsointerface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmHsoInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmHsoInterface::OrgFreedesktopModemManagerModemGsmHsoInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmHsoInterface::~OrgFreedesktopModemManagerModemGsmHsoInterface()
+{
+}
+
+
+#include "mm-modem-gsm-hsointerface.moc"
Index: solid/modemmanager-0.4/dbus/hand-edits.diff
===================================================================
--- solid/modemmanager-0.4/dbus/hand-edits.diff	(revision 0)
+++ solid/modemmanager-0.4/dbus/hand-edits.diff	(revision 1145887)
@@ -0,0 +1,35 @@
+--- mm-manager-clientinterface.h	2010-05-14 14:34:04.973155819 -0300
++++ ../mm-manager-clientinterface.h	2010-05-12 21:44:48.195535874 -0300
+@@ -8,8 +8,8 @@
+  * Do not edit! All changes made to it will be lost.
+  */
+ 
+-#ifndef MM-MANAGER-CLIENTINTERFACE_H_1273858444
+-#define MM-MANAGER-CLIENTINTERFACE_H_1273858444
++#ifndef MM_MANAGER_CLIENTINTERFACE_H
++#define MM_MANAGER_CLIENTINTERFACE_H
+ 
+ #include <QtCore/QObject>
+ #include <QtCore/QByteArray>
+--- mm-gsm-networkinterface.h	2010-05-14 14:33:50.903149393 -0300
++++ ../mm-gsm-networkinterface.h	2010-05-13 23:26:37.103659238 -0300
+@@ -8,8 +8,8 @@
+  * Do not edit! All changes made to it will be lost.
+  */
+ 
+-#ifndef MM-GSM-NETWORKINTERFACE_H_1273858430
+-#define MM-GSM-NETWORKINTERFACE_H_1273858430
++#ifndef MM_GSM_NETWORKINTERFACE_H
++#define MM_GSM_NETWORKINTERFACE_H
+ 
+ #include <QtCore/QObject>
+ #include <QtCore/QByteArray>
+@@ -20,6 +20,8 @@
+ #include <QtCore/QVariant>
+ #include <QtDBus/QtDBus>
+ 
++#include "generic-types.h"
++
+ /*
+  * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Network
+  */
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-networkinterface.h	(revision 1145887)
@@ -0,0 +1,106 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-networkinterface introspection/mm-modem-gsm-network.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_NETWORKINTERFACE_H
+#define MM_MODEM_GSM_NETWORKINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Network
+ */
+class OrgFreedesktopModemManagerModemGsmNetworkInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.Network"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmNetworkInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmNetworkInterface();
+
+    Q_PROPERTY(uint AccessTechnology READ accessTechnology)
+    inline uint accessTechnology() const
+    { return qvariant_cast< uint >(property("AccessTechnology")); }
+
+    Q_PROPERTY(uint AllowedMode READ allowedMode)
+    inline uint allowedMode() const
+    { return qvariant_cast< uint >(property("AllowedMode")); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<uint> GetBand()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetBand"), argumentList);
+    }
+
+    inline QDBusPendingReply<RegistrationInfoType> GetRegistrationInfo()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetRegistrationInfo"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> GetSignalQuality()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetSignalQuality"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Register(const QString &network_id)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(network_id);
+        return asyncCallWithArgumentList(QLatin1String("Register"), argumentList);
+    }
+
+    inline QDBusPendingReply<ScanResultsType> Scan()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Scan"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetAllowedMode(uint mode)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(mode);
+        return asyncCallWithArgumentList(QLatin1String("SetAllowedMode"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetApn(const QString &apn)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(apn);
+        return asyncCallWithArgumentList(QLatin1String("SetApn"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetBand(uint band)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(band);
+        return asyncCallWithArgumentList(QLatin1String("SetBand"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void RegistrationInfo(uint status, const QString &operator_code, const QString &operator_name);
+    void SignalQuality(uint signal_quality);
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-hsointerface.h	(revision 1145887)
@@ -0,0 +1,49 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-hsointerface introspection/mm-modem-gsm-hso.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_HSOINTERFACE_H
+#define MM_MODEM_GSM_HSOINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Hso
+ */
+class OrgFreedesktopModemManagerModemGsmHsoInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.Hso"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmHsoInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmHsoInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Authenticate(const QString &username, const QString &password)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(username) << qVariantFromValue(password);
+        return asyncCallWithArgumentList(QLatin1String("Authenticate"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-smsinterface introspection/mm-modem-gsm-sms.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-smsinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmSMSInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmSMSInterface::OrgFreedesktopModemManagerModemGsmSMSInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmSMSInterface::~OrgFreedesktopModemManagerModemGsmSMSInterface()
+{
+}
+
+
+#include "mm-modem-gsm-smsinterface.moc"
Index: solid/modemmanager-0.4/dbus/generic-types.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/generic-types.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/generic-types.cpp	(revision 1145887)
@@ -0,0 +1,130 @@
+/* This file is part of the KDE project
+   Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License or (at your option) version 3 or any later version
+   accepted by the membership of KDE e.V. (or its successor approved
+   by the membership of KDE e.V.), which shall act as a proxy
+   defined in Section 14 of version 3 of the license.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "generic-types.h"
+
+// Marshall the Solid::Control::Ip4ConfigType data into a D-BUS argument
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemInterface::Ip4ConfigType &config)
+{
+    arg.beginStructure();
+    arg << config.ip4Address << config.dns1 << config.dns2 << config.dns3;
+    arg.endStructure();
+    return arg;
+}
+
+// Retrieve the Solid::Control::Ip4ConfigType data from the D-BUS argument
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemInterface::Ip4ConfigType &config)
+{
+    arg.beginStructure();
+    arg >> config.ip4Address >> config.dns1 >> config.dns2 >> config.dns3;
+    arg.endStructure();
+
+    return arg;
+}
+
+// Marshall the Solid::Control::ModemManager::Modem::InfoType data into a D-BUS argument
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemInterface::InfoType &info)
+{
+    arg.beginStructure();
+    arg << info.manufacturer << info.model << info.version;
+    arg.endStructure();
+    return arg;
+}
+
+// Retrieve the Solid::Control::ModemManager::Modem::InfoType data from the D-BUS argument
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemInterface::InfoType &info)
+{
+    arg.beginStructure();
+    arg >> info.manufacturer >> info.model >> info.version;
+    arg.endStructure();
+    return arg;
+}
+
+// Marshall the Solid::Control::ModemCdmaInterface::ServingSystemType data into a D-BUS argument
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemCdmaInterface::ServingSystemType &servingSystem)
+{
+    arg.beginStructure();
+    arg << servingSystem.bandClass << servingSystem.band << servingSystem.systemId;
+    arg.endStructure();
+    return arg;
+}
+
+// Retrieve the Solid::Control::ModemCdmaInterface::ServingSystemType data from the D-BUS argument
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemCdmaInterface::ServingSystemType &servingSystem)
+{
+    uint temp;
+    arg.beginStructure();
+    arg >> temp >> servingSystem.band >> servingSystem.systemId;
+    servingSystem.bandClass = (Solid::Control::ModemCdmaInterface::BandClass) temp;
+    arg.endStructure();
+    return arg;
+}
+
+// Marshall the Solid::Control::ModemGsmContactsInterface::ContactType data into a D-BUS argument
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemGsmContactsInterface::ContactType &contact)
+{
+    arg.beginStructure();
+    arg << contact.index << contact.name << contact.number;
+    arg.endStructure();
+    return arg;
+}
+
+// Retrieve the Solid::Control::ModemGsmContactsInterface::ContactType data from the D-BUS argument
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemGsmContactsInterface::ContactType &contact)
+{
+    arg.beginStructure();
+    arg >> contact.index >> contact.name >> contact.number;
+    arg.endStructure();
+    return arg;
+}
+
+// Marshall the RegistrationInfoType data into a D-BUS argument
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &info)
+{
+    uint temp;
+
+    temp = (uint) info.status;
+    arg.beginStructure();
+    arg << temp << info.operatorCode << info.operatorName;
+    arg.endStructure();
+    return arg;
+}
+
+// Retrieve the RegistrationInfoType data from the D-BUS argument
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &info)
+{
+    uint temp;
+
+    arg.beginStructure();
+    arg >> temp >> info.operatorCode >> info.operatorName;
+    info.status = (Solid::Control::ModemGsmNetworkInterface::RegistrationStatus) temp;
+    arg.endStructure();
+    return arg;
+}
Index: solid/modemmanager-0.4/dbus/mm-manager-clientinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-manager-clientinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-manager-clientinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-manager-clientinterface introspection/mm-manager-client.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-manager-clientinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerInterface
+ */
+
+OrgFreedesktopModemManagerInterface::OrgFreedesktopModemManagerInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerInterface::~OrgFreedesktopModemManagerInterface()
+{
+}
+
+
+#include "mm-manager-clientinterface.moc"
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-card.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-card.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-card.xml	(revision 1145887)
@@ -0,0 +1,113 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.Card">
+    <method name="GetImei">
+      <tp:docstring>
+        Get the IMEI of the card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_get_imei"/>
+      <arg name="imei" type="s" direction="out">
+        <tp:docstring>
+          The IMEI.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetImsi">
+      <tp:docstring>
+        Get the IMSI of the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_get_imsi"/>
+      <arg name="imsi" type="s" direction="out">
+        <tp:docstring>
+          The IMSI.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="SendPuk">
+      <tp:docstring>
+        Send the PUK and a new PIN to unlock the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_send_puk"/>
+      <arg name="puk" type="s" direction="in">
+        <tp:docstring>
+          The PUK code.
+        </tp:docstring>
+      </arg>
+      <arg name="pin" type="s" direction="in">
+        <tp:docstring>
+          The PIN code.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="SendPin">
+      <tp:docstring>
+        Send the PIN (or PUK) to unlock the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_send_pin"/>
+      <arg name="pin" type="s" direction="in">
+        <tp:docstring>
+          The PIN code.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="EnablePin">
+      <tp:docstring>
+        Enable or disable the PIN checking.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_enable_pin"/>
+      <arg name="pin" type="s" direction="in">
+        <tp:docstring>
+          The PIN code.
+        </tp:docstring>
+      </arg>
+      <arg name="enabled" type="b" direction="in">
+        <tp:docstring>
+          True to enable PIN checking.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="ChangePin">
+      <tp:docstring>
+        Change the PIN code.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_change_pin"/>
+      <arg name="old_pin" type="s" direction="in">
+        <tp:docstring>
+          The current PIN code.
+        </tp:docstring>
+      </arg>
+      <arg name="new_pin" type="s" direction="in">
+        <tp:docstring>
+          The new PIN code.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <property name="SupportedBands" type="u" access="read" tp:type="Band">
+      <tp:docstring>
+        Bands supported by the card.  (Note for plugin writers:
+        returned value must not contain ANY)
+      </tp:docstring>
+    </property>
+
+    <property name="SupportedModes" type="u" access="read" tp:type="Mode">
+      <tp:docstring>
+        Network selection modes supported by the card. (Note for plugin writers:
+        returned value must not contain ANY)
+      </tp:docstring>
+    </property>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-hso.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-hso.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-hso.xml	(revision 1145887)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.Hso">
+    <method name="Authenticate">
+      <tp:docstring>
+        Authenticate using the passed user name and password.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_hso_authenticate"/>
+      <arg name="username" type="s" direction="in">
+        The user name.
+      </arg>
+      <arg name="password" type="s" direction="in">
+        The password.
+      </arg>
+    </method>
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-network.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-network.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-network.xml	(revision 1145887)
@@ -0,0 +1,225 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.Network">
+    <method name="Register">
+      <tp:docstring>
+        Register the device to network.
+      </tp:docstring>
+      <arg name="network_id" type="s" direction="in">
+        <tp:docstring>
+          The network ID to register. An empty string can be used to register to the home network.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Scan">
+      <tp:docstring>
+        Scan for available networks.
+      </tp:docstring>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="ScanResultsType"/>
+      <arg name="results" type="aa{ss}" direction="out">
+        <tp:docstring>
+          <p>Found networks. It's an array of dictionaries (strings for both
+          keys and values) with each array element describing a mobile network
+          found in the scan.  Each dict may include one or more of the following
+          keys:</p>
+          <ul>
+            <li>
+              "status": a number representing network availability status as
+              defined in 3GPP TS 27.007 section 7.3.  e.g. "0" (unknown), "1"
+              (available), "2" (current), or "3" (forbidden).  This key will
+              always be present.
+            </li>
+            <li>
+              "operator-long": long-format name of operator.  If the name is
+              unknown, this field should not be present.
+            </li>
+            <li>
+              "operator-short": short-format name of operator.  If the name is
+              unknown, this field should not be present.
+            </li>
+            <li>
+              "operator-num": mobile code of the operator.  Returned in the
+              format "MCCMNC", where MCC is the three-digit ITU E.212 Mobile
+              Country Code and MNC is the  two- or three-digit GSM Mobile
+              Network Code.  e.g. "31026" or "310260".
+            </li>
+            <li>
+              "access-tech": a number representing the access technology used by
+              this mobile network as described in 3GPP TS 27.007 section 7.3.
+              e.g. "0" (GSM), "1" (GSM Compact), "2" (UTRAN/UMTS), "3" (EDGE),
+              etc.
+            </li>
+          </ul>
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="SetApn">
+      <tp:docstring>
+        Set the Accesss Point Name (APN).
+      </tp:docstring>
+      <arg name="apn" type="s" direction="in">
+        <tp:docstring>
+          The Access Point Name (APN).
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetSignalQuality">
+      <tp:docstring>
+        Get the current signal quality. The modem/cellular has to be connected.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_get_signal_quality"/>
+      <arg name="signal_quality" type="u" direction="out">
+        <tp:docstring>
+          Signal quality (percent).
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="SetBand">
+      <tp:docstring>
+        Sets the band the device is allowed to use when connecting to a mobile network.
+      </tp:docstring>
+      <arg name="band" type="u" direction="in">
+        <tp:docstring>
+          The desired band. Only one band may be specified, and may not be UNKNOWN.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetBand">
+      <tp:docstring>
+        Returns the current band the device is using. (Note for plugin writers: returned value must not be ANY)
+      </tp:docstring>
+      <arg name="band" type="u" direction="out">
+        <tp:docstring>
+          The current band.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetRegistrationInfo">
+      <tp:docstring>
+        Get the registration status and the current operator (if registered).
+      </tp:docstring>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="RegistrationInfoType"/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_get_registration_info"/>
+      <arg name="registration_info" type="(uss)" tp:type="Uint_String_String_Struct" direction="out">
+        <tp:docstring>
+          The returned information is composed of the following items in the
+          following order:
+          <ul>
+            <li>
+              Mobile registration status as defined in 3GPP TS 27.007 section
+              10.1.19.  See the RegistrationStatus enumeration for
+              possible values.
+            </li>
+            <li>
+              Current operator code of the operator to which the mobile is
+              currently registered.  Returned in the format "MCCMNC", where MCC
+              is the three-digit ITU E.212 Mobile Country Code and MNC is the
+              two- or three-digit GSM Mobile Network Code.  If the MCC and MNC
+              are not known or the mobile is not registered to a mobile network,
+              this value should be a zero-length (blank) string. e.g. "31026"
+              or "310260".
+            </li>
+            <li>
+              Current operator name of the operator to which the mobile is
+              currently registered.  If the operator name is not knowon or the
+              mobile is not registered to a mobile network, this value should
+              be a zero-length (blank) string.
+            </li>
+          </ul>
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="SetAllowedMode">
+      <tp:docstring>
+        Set the access technologies a device is allowed to use when connecting to a mobile network.
+      </tp:docstring>
+      <arg name="mode" type="u" direction="in">
+        <tp:docstring>
+          The allowed mode. The device may not support all modes; see
+          the org.freedesktop.ModemManager.Gsm.Card.SupportedModes property for
+          allowed modes for each device. All devices support the "ANY" flag.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <signal name="SignalQuality">
+      <arg name="signal_quality" type="u">
+        <tp:docstring>
+          The new quality in percent, 0..100.
+        </tp:docstring>
+      </arg>
+      <tp:docstring>
+        Emitted when the signal quality changes.
+      </tp:docstring>
+    </signal>
+
+    <signal name="RegistrationInfo">
+      <arg name="status" type="u">
+        <tp:docstring>
+          "status": Mobile registration status as defined in 3GPP TS 27.007 section
+          10.1.19.
+        </tp:docstring>
+      </arg>
+      <arg name="operator_code" type="s">
+        <tp:docstring>
+          "operator_code": Current operator code of the operator to which the mobile is
+          currently registered.  Returned in the format "MCCMNC", where MCC
+          is the three-digit ITU E.212 Mobile Country Code and MNC is the
+          two- or three-digit GSM Mobile Network Code.  If the MCC and MNC
+          are not known or the mobile is not registered to a mobile network,
+          this value should be a zero-length (blank) string.  e.g. "31026" or
+          "310260".
+        </tp:docstring>
+      </arg>
+      <arg name="operator_name" type="s">
+        <tp:docstring>
+              "operator_name": Current operator name of the operator to which the mobile is
+              currently registered.  If the operator name is not knowon or the
+              mobile is not registered to a mobile network, this value should
+              be a zero-length (blank) string.
+        </tp:docstring>
+      </arg>
+      <tp:docstring>
+        Emitted when registration status changes.
+      </tp:docstring>
+    </signal>
+
+    <property name="AllowedMode" type="u" access="read">
+      <tp:docstring>
+        The allowed access technologies (eg 2G/3G preference) the device is allowed
+        to use when connecting to a mobile network.
+      </tp:docstring>
+    </property>
+
+    <property name="AccessTechnology" type="u" access="read">
+      <tp:docstring>
+        The current network access technology used by the device to communicate
+        with the base station.  (Note to plugin writers: if the device's access
+        technology cannot be determined, use UNKNOWN)
+      </tp:docstring>
+    </property>
+
+    <tp:struct name="Uint_String_String_Struct">
+      <tp:docstring>Struct containing triples (unsigned int, string, string).</tp:docstring>
+      <tp:member type="u" name="Status">
+          <tp:docstring>The GSM network status.</tp:docstring>
+      </tp:member>
+      <tp:member type="s" name="Operator_Code">
+          <tp:docstring>The current operator code.</tp:docstring>
+      </tp:member>
+      <tp:member type="s" name="Operator_Name">
+          <tp:docstring>The current operator name.</tp:docstring>
+      </tp:member>
+    </tp:struct>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/all.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/all.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/all.xml	(revision 1145887)
@@ -0,0 +1,50 @@
+<tp:spec
+  xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0"
+  xmlns:xi="http://www.w3.org/2001/XInclude">
+
+<tp:title>ModemManager D-Bus Interface Specification</tp:title>
+<tp:version>0.4.0</tp:version>
+
+
+<tp:copyright>Copyright (C) 2008 Novell, Inc.</tp:copyright>
+
+<tp:license xmlns="http://www.w3.org/1999/xhtml">
+<p>This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.</p>
+
+<p>This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.</p>
+
+<p>You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
+</tp:license>
+
+<xi:include href="mm-manager-client.xml"/>
+<xi:include href="mm-modem.xml"/>
+<xi:include href="mm-modem-cdma.xml"/>
+<xi:include href="mm-modem-simple.xml"/>
+<xi:include href="mm-modem-location.xml"/>
+<xi:include href="mm-modem-gsm-card.xml"/>
+<xi:include href="mm-modem-gsm-contacts.xml"/>
+<xi:include href="mm-modem-gsm-network.xml"/>
+<xi:include href="mm-modem-gsm-sms.xml"/>
+<xi:include href="mm-modem-gsm-hso.xml"/>
+<xi:include href="mm-modem-gsm-ussd.xml"/>
+
+<xi:include href="errors.xml"/>
+<xi:include href="generic-types.xml"/>
+
+<!--
+<xi:include href="extensions.xml">
+        <xi:fallback>
+                <!- - absence of non-spec extensions is OK - ->
+        </xi:fallback>
+</xi:include>
+-->
+
+</tp:spec>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-contacts.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-contacts.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-contacts.xml	(revision 1145887)
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.Contacts">
+    <method name="Add">
+      <tp:docstring>
+        Add a new contact to the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_add"/>
+      <arg name="name" type="s" direction="in">
+        <tp:docstring>
+          The name of the contact.
+        </tp:docstring>
+      </arg>
+      <arg name="number" type="s" direction="in">
+        <tp:docstring>
+          The phone number of the contact.
+        </tp:docstring>
+      </arg>
+      <arg name="index" type="u" direction="out">
+        <tp:docstring>
+          The index of the new contact.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Delete">
+      <tp:docstring>
+        Delete a contact from the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_delete"/>
+      <arg name="index" type="u" direction="in">
+        <tp:docstring>
+          The index of the contact.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Get">
+      <tp:docstring>
+        Retrieve a contact from the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_get"/>
+      <arg name="index" type="u" direction="in">
+        <tp:docstring>
+          The index of the contact.
+        </tp:docstring>
+      </arg>
+      <arg name="contact" type="(uss)" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="ContactType"/>
+        <tp:docstring>
+          The contact structure containing index, name, and number.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="List">
+      <tp:docstring>
+        List all contacts on the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_list"/>
+      <arg name="results" type="a(uss)" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="ContactTypeList"/>
+        <tp:docstring>
+          The list of contacts where each contact has an index, name, and number.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Find">
+      <tp:docstring>
+        Find a contact from the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_find"/>
+      <arg name="pattern" type="s" direction="in">
+        <tp:docstring>
+          The pattern to search for.
+        </tp:docstring>
+      </arg>
+      <arg name="results" type="a(uss)" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="ContactTypeList"/>
+        <tp:docstring>
+          The list of matching contacts where a contact has an index, name, and number.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetCount">
+      <tp:docstring>
+        Get the number of contacts stored on the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_contacts_count"/>
+      <arg name="count" type="u" direction="out">
+        <tp:docstring>
+          The number of contacts.
+        </tp:docstring>
+      </arg>
+    </method>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-ussd.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-ussd.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-ussd.xml	(revision 1145887)
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.Ussd">
+    <method name="Initiate">
+      <tp:docstring>
+        Sends a USSD command string to the network initiating a USSD session.
+        When the request is handled by the network, the method returns the
+        response or an appropriate error.  The network may be awaiting further
+        response from the ME after returning from this method and no new command
+        can be initiated until this one is cancelled or ended.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_gsm_ussd_initiate"/>
+      <arg name="command" type="s" direction="in">
+        <tp:docstring>
+          The command to start the USSD session with.
+        </tp:docstring>
+      </arg>
+      <arg name="reply" type="s" direction="out">
+        <tp:docstring>
+          The network response to the command which started the USSD session.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Respond">
+      <tp:docstring>
+        Respond to a USSD request that is either initiated by the mobile network,
+        or that is awaiting further input after Initiate() was called.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_gsm_ussd_respond"/>
+      <arg name="response" type="s" direction="in">
+        <tp:docstring>
+          The response to network-initiated USSD command, or a response to a
+          request for further input.
+      </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Cancel">
+      <tp:docstring>
+        Cancel an ongoing USSD session, either mobile or network initiated.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_gsm_ussd_cancel"/>
+    </method>
+
+    <property name="State" type="s" access="read">
+      <tp:docstring>
+        Indicates the state of any ongoing USSD session.  Values may be one of
+        the following: "idle" (no active session), "active" (a session is active
+        and the mobile is waiting for a response), "user-response" (the network
+        is waiting for the client's response, which must be sent using Respond()).
+      </tp:docstring>
+    </property>
+
+    <property name="NetworkNotification" type="s" access="read">
+      <tp:docstring>
+        Contains any network-initiated request to which no USSD response is
+        required.  When no USSD session is active, or when there is no network-
+        initiated request, this property will be a zero-length string.
+      </tp:docstring>
+    </property>
+
+    <property name="NetworkRequest" type="s" access="read">
+      <tp:docstring>
+        Contains any pending network-initiated request for a response.  Client
+        should call Respond() with the appropriate response to this request.
+        When no USSD session is active, or when there is no pending
+        network-initiated request, this property will be a zero-length string.
+      </tp:docstring>
+    </property>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem.xml	(revision 1145887)
@@ -0,0 +1,150 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+
+  <interface name="org.freedesktop.ModemManager.Modem">
+    <method name="Enable">
+      <tp:docstring>
+        Enable the device. Initializes the modem.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_enable"/>
+      <arg name="enable" type="b" direction="in">
+        <tp:docstring>
+          True to enable the device, False to disable.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Connect">
+      <tp:docstring>
+        Dial in.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_connect"/>
+      <arg name="number" type="s" direction="in">
+        <tp:docstring>
+          The number to use for dialing.
+      </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Disconnect">
+      <tp:docstring>
+        Disconnect modem.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_disconnect"/>
+    </method>
+
+    <method name="GetIP4Config">
+      <tp:docstring>
+        Request the IP4 configuration from the device.
+        Note that it'll only be supported for IPMethod Static.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_get_ip4_config"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="Ip4ConfigType"/>
+      <arg name="address" type="(uuuu)" direction="out" tp:type="Ip4ConfigType">
+        Structure containing IP4 address, DNS1, DNS2, DNS3.
+        The DNS list is padded with 0's if there's less than 3 DNS servers.
+      </arg>
+    </method>
+
+    <method name="GetInfo">
+      <tp:docstring>
+        Get the card information (manufacturer, modem, version).
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_get_info"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="InfoType"/>
+      <arg name="info" type="(sss)" direction="out">
+        <tp:docstring>
+          Structure containing manufacturer, model, and version (revision) of the card.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <property name="Device" type="s" access="read">
+      <tp:docstring>
+        The modem port to use for IP configuration and traffic.
+      </tp:docstring>
+    </property>
+
+    <property name="MasterDevice" type="s" access="read">
+      <tp:docstring>
+        The physical modem device reference (ie, USB, PCI, PCMCIA device), which
+        may be dependent upon the operating system.  In Linux for example, this
+        points to a sysfs path of the usb_device object.
+      </tp:docstring>
+    </property>
+
+    <property name="Driver" type="s" access="read">
+      <tp:docstring>
+        The driver handling the device.
+      </tp:docstring>
+    </property>
+
+    <property name="Type" type="u" access="read" tp:type="Type">
+      <tp:docstring>
+        The modem type.
+      </tp:docstring>
+    </property>
+
+    <property name="Enabled" type="b" access="read">
+      <tp:docstring>
+        TRUE if the modem is enabled (ie, powered and usable), FALSE if it is disabled.
+      </tp:docstring>
+    </property>
+
+    <property name="UnlockRequired" type="s" access="read">
+      <tp:docstring>
+        Empty if the device is usable without an unlock code or has already
+        been unlocked. If the device needs to be unlocked before becoming usable this
+        property contains the specific unlock code required.  Valid unlock code values
+        are "" (blank), "sim-pin", "sim-puk", "ph-sim-pin", "ph-fsim-pin",
+        "ph-fsim-puk", "sim-pin2", "sim-puk2", "ph-net-pin", "ph-net-puk",
+        "ph-netsub-pin", "ph-netsub-puk", "ph-sp-pin", "ph-sp-puk", "ph-corp-pin", and
+        "ph-corp-puk".
+      </tp:docstring>
+    </property>
+
+    <property name="IpMethod" type="u" access="read" tp:type="Method">
+      <tp:docstring>
+        The IP configuration method.
+      </tp:docstring>
+    </property>
+
+    <tp:enum name="Type" type="u">
+      <tp:enumvalue suffix="GSM" value="1">
+        <tp:docstring>
+          A GSM device.
+        </tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="CDMA" value="2">
+        <tp:docstring>
+          A CDMA device.
+        </tp:docstring>
+      </tp:enumvalue>
+    </tp:enum>
+
+    <tp:enum name="Method" type="u">
+      <tp:enumvalue suffix="PPP" value="0">
+        <tp:docstring>
+          Use PPP to get the address.
+        </tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="STATIC" value="1">
+        <tp:docstring>
+          Static configuration, the modem will provide IP information.
+        </tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="DHCP" value="2">
+        <tp:docstring>
+          Use DHCP
+        </tp:docstring>
+      </tp:enumvalue>
+    </tp:enum>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-cdma.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-cdma.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-cdma.xml	(revision 1145887)
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Cdma">
+
+    <method name="GetSignalQuality">
+      <tp:docstring>
+        Get the current signal quality.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_cdma_get_signal_quality"/>
+      <arg name="quality" type="u" direction="out">
+        <tp:docstring>
+          Signal quality (percent).
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetEsn">
+      <tp:docstring>
+        Get the Electronic Serial Number of the card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_cdma_get_esn"/>
+      <arg name="esn" type="s" direction="out">
+        <tp:docstring>
+          The ESN.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetServingSystem">
+      <tp:docstring>
+        Get the Service System details of the current network, if registered.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_cdma_get_serving_system"/>
+      <arg name="info" type="(usu)" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="ServingSystemType"/>
+        <tp:docstring>
+          A structure containing the Band Class (0 = unknown, 1 = 800 MHz, 2 = 1900 MHz), the Band ("A" - "F" as defined by IS707-A), and the System ID of the serving network.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <signal name="SignalQuality">
+      <tp:docstring>
+        The signal quality changed.
+      </tp:docstring>
+      <arg name="quality" type="u">
+        <tp:docstring>
+          The new quality in percent, 0..100.
+        </tp:docstring>
+      </arg>
+    </signal>
+
+    <method name="GetRegistrationState">
+      <tp:docstring>Get device registration state.</tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_cdma_get_registration_state"/>
+      <arg name="cdma_1x_state" type="u" direction="out" tp:type="MM_MODEM_CDMA_REGISTRATION_STATE">
+        <tp:docstring>CDMA 1x registration state.</tp:docstring>
+      </arg>
+      <arg name="evdo_state" type="u" direction="out" tp:type="MM_MODEM_CDMA_REGISTRATION_STATE">
+        <tp:docstring>EVDO registration state.</tp:docstring>
+      </arg>
+    </method>
+
+    <signal name="RegistrationStateChanged">
+      <tp:docstring>
+        The device registration state changed.
+      </tp:docstring>
+      <arg name="cdma_1x_state" type="u" tp:type="MM_MODEM_CDMA_REGISTRATION_STATE">
+        <tp:docstring>CDMA 1x registration state.</tp:docstring>
+      </arg>
+      <arg name="evdo_state" type="u" tp:type="MM_MODEM_CDMA_REGISTRATION_STATE">
+        <tp:docstring>EVDO registration state.</tp:docstring>
+      </arg>
+    </signal>
+
+    <tp:enum name="MM_MODEM_CDMA_REGISTRATION_STATE" type="u">
+      <tp:enumvalue suffix="UNKNOWN" value="0">
+        <tp:docstring>Registration status is unknown or the device is not registered.</tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="REGISTERED" value="1">
+        <tp:docstring>Registered, but roaming status is unknown or cannot be provided by the device.  The device may or may not be roaming.</tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="HOME" value="2">
+        <tp:docstring>Currently registered on the home network.</tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="ROAMING" value="3">
+        <tp:docstring>Currently registered on a roaming network.</tp:docstring>
+      </tp:enumvalue>
+    </tp:enum>
+
+  </interface>
+</node>
+
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-sms.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-sms.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-gsm-sms.xml	(revision 1145887)
@@ -0,0 +1,163 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Gsm.SMS">
+    <method name="Delete">
+      <tp:docstring>
+        Delete an SMS message.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_delete"/>
+      <arg name="index" type="u" direction="in">
+        <tp:docstring>
+          The index of the SMS.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="Get">
+      <tp:docstring>
+        Retrieve an SMS from the SIM card.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_get"/>
+      <arg name="index" type="u" direction="in">
+        <tp:docstring>
+          The index of the SMS.
+        </tp:docstring>
+      </arg>
+      <arg name="sms" type="a{sv}" tp:type="String_Variant_Map" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantMap"/>
+        <tp:docstring>
+          A dictionary containing SMS properties of the SMS specified by the given index.  This dictionary may contain the following key/value pairs:
+
+          number   : string - Phone number (mandatory)
+          text     : string - SMS text (mandatory)
+          smsc     : string - SMS service center number (optional)
+          validity : uint (0..255) - Specifies when the SMS expires in SMSC (optional)
+          class    : uint (0..3) - Message importance and location (optional)
+          completed: boolean - Whether all message parts have been received or not (optional)
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetFormat">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_get_format"/>
+      <arg name="result" type="u" direction="out"/>
+    </method>
+
+    <method name="SetFormat">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_set_format"/>
+      <arg name="format" type="u" direction="in"/>
+    </method>
+
+    <method name="GetSmsc">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_get_smsc"/>
+      <arg name="result" type="s" direction="out"/>
+    </method>
+
+    <method name="SetSmsc">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_set_smsc"/>
+      <arg name="smsc" type="s" direction="in"/>
+    </method>
+
+    <method name="List">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_list"/>
+      <arg name="result" type="aa{sv}" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantMapList"/>
+      </arg>
+    </method>
+
+    <method name="Save">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_save"/>
+      <arg name="properties" type="a{sv}" tp:type="String_Variant_Map" direction="in">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVariantMap"/>
+        <tp:docstring>
+          SMS properties to save with the following key values:
+
+          number   : string - Phone number (mandatory)
+          text     : string - SMS text (mandatory)
+          smsc     : string - SMS service center number (optional)
+          validity : uint (0..255) - Specifies when the SMS expires in SMSC (optional)
+          class    : uint (0..3) - Message importance and location (optional)
+        </tp:docstring>
+      </arg>
+      <arg name="index" type="au" direction="out"/>
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="uint"/>
+    </method>
+
+    <method name="Send">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_send"/>
+      <arg name="properties" type="a{sv}" tp:type="String_Variant_Map" direction="in">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVariantMap"/>
+        <tp:docstring>
+          SMS properties to save with the following key values:
+
+          number   : string - Phone number (mandatory)
+          text     : string - SMS text (mandatory)
+          smsc     : string - SMS service center number (optional)
+          validity : uint (0..255) - Specifies when the SMS expires in SMSC (optional)
+          class    : uint (0..3) - Message importance and location (optional)
+        </tp:docstring>
+      </arg>
+      <arg name="result" type="au" direction="out"/>
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="uint"/>
+    </method>
+
+    <method name="SendFromStorage">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_send_from_storage"/>
+      <arg name="index" type="u" direction="in"/>
+    </method>
+
+    <method name="SetIndication">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_gsm_modem_sms_set_indication"/>
+      <arg name="mode" type="u" direction="in"/>
+      <arg name="mt" type="u" direction="in"/>
+      <arg name="bm" type="u" direction="in"/>
+      <arg name="ds" type="u" direction="in"/>
+      <arg name="bfr" type="u" direction="in"/>
+    </method>
+
+    <signal name="SmsReceived">
+      <tp:docstring>
+        Emitted when any part of a new SMS has been received (but not for subsequent parts, if any).  Not all parts may have been received and the message may not be complete; if it is, the 'complete' argument will be TRUE.
+      </tp:docstring>
+      <arg name="index" type="u">
+        <tp:docstring>
+          Index of the new SMS.
+        </tp:docstring>
+      </arg>
+      <arg name="complete" type="b">
+        <tp:docstring>
+          TRUE if all message parts have been received, otherwise FALSE.
+        </tp:docstring>
+      </arg>
+    </signal>
+
+    <signal name="Completed">
+      <tp:docstring>
+        Emitted when the complete-ness status of an SMS message changes.  An SMS may not necessarily be complete when the first part is received; this signal will be emitted when all parts have been received, even for single-part messages.
+      </tp:docstring>
+      <arg name="index" type="u">
+        <tp:docstring>
+          The index of the SMS.
+        </tp:docstring>
+      </arg>
+      <arg name="completed" type="b">
+        <tp:docstring>
+          TRUE if all message parts have been received, otherwise FALSE.
+        </tp:docstring>
+      </arg>
+    </signal>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-manager-client.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-manager-client.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-manager-client.xml	(revision 1145887)
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager">
+    <method name="EnumerateDevices">
+      <tp:docstring>
+        Get the list of modem devices.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_manager_enumerate_devices"/>
+      <arg name="devices" type="ao" direction="out">
+        <tp:docstring>
+          List of object paths of modem devices known to the system.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <signal name="DeviceAdded">
+      <arg name="device" type="o">
+        <tp:docstring>
+          The object path of the newly added device.
+        </tp:docstring>
+      </arg>
+      <tp:docstring>
+        Emitted when a device was added to the system.
+      </tp:docstring>
+    </signal>
+
+    <signal name="DeviceRemoved">
+      <arg name="device" type="o">
+        <tp:docstring>
+          The object path of the device that was just removed.
+        </tp:docstring>
+      </arg>
+      <tp:docstring>
+        Emitted when a device was removed from the system.
+      </tp:docstring>
+    </signal>
+
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-location.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-location.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-location.xml	(revision 1145887)
@@ -0,0 +1,257 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Location">
+    <tp:docstring>
+      This interface allows devices to provide location information to client
+      applications.  Not all devices can provide this information, or even if
+      they do, they may not be able to provide it while a data session is
+      active.
+    </tp:docstring>
+
+    <property name="Capabilities" type="u" access="read" tp:type="MM_MODEM_LOCATION_CAPABILITIES">
+      <tp:docstring>
+        Location capabilities of the device.
+      </tp:docstring>
+    </property>
+
+    <property name="Enabled" type="b" access="read">
+      <tp:docstring>
+        TRUE if location information gathering is enabled for this device, FALSE
+        if it is disabled. When disabled, the device will not provide location
+        information.
+      </tp:docstring>
+    </property>
+
+    <method name="Enable">
+      <tp:docstring>
+        Enable or disable location information gathering.  This method may
+        require the client to authenticate itself.  This method may also cause
+        any necessary functionality of the mobile be be turned on, including
+        enabling the modem device itself.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_location_enable"/>
+      <arg name="enable" type="b" direction="in">
+        <tp:docstring>
+          TRUE to enable location information gathering, FALSE to disable.
+        </tp:docstring>
+      </arg>
+      <arg name="signal_location" type="b" direction="in">
+        <tp:docstring>
+          When enabling location information gathering, this argument controls
+          whether the device emits signals with new location information or not.
+          When signals are emitted, any client application (including malicious
+          ones!) can listen for location updates unless D-Bus permissions
+          restrict these signals from certain users.  If further security is
+          desired, this argument can be set to FALSE to disable location
+          updates via D-Bus signals and require applications to call
+          authenticated APIs (like GetLocation) to get location information.
+          This argument is ignored when disabling location information
+          gathering.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <method name="GetLocation">
+      <tp:docstring>
+        Return current location information, if any.  This method may require
+        the client to authenticate itself.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_location_get_location"/>
+      <arg name="Location" type="a{uv}" direction="out" tp:type="Location_Information_Map">
+        <annotation name="com.trolltech.QtDBus.QtTypeName" value="LocationInformationMap"/>
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="LocationInformationMap"/>
+        <tp:docstring>
+            Dict of available location information when location information
+            gathering is enabled.  If the modem supports multiple location types
+            it may return more than one here.
+        </tp:docstring>
+      </arg>
+    </method>
+
+    <property name="SignalsLocation" type="b" access="read">
+      <tp:docstring>
+        TRUE if location updates will be emitted via D-Bus signals, FALSE
+        if location updates will not be emitted.  See the Enable method for
+        more information.
+      </tp:docstring>
+    </property>
+
+    <property name="Location" type="a{uv}" access="read" tp:type="Location_Information_Map">
+      <annotation name="com.trolltech.QtDBus.QtTypeName" value="LocationInformationMap"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="LocationInformationMap"/>
+      <tp:docstring>
+          Dict of available location information when location information
+          gathering is enabled.  If the modem supports multiple location types
+          it may return more than one here.  Note that if the device was told
+          not to emit updated location information when location information
+          gathering was initially enabled, this property may not return
+          any location information for security reasons.
+      </tp:docstring>
+    </property>
+
+    <tp:mapping name="Location_Information_Map">
+      <tp:docstring>
+        A mapping from location type to type-specific location information.
+      </tp:docstring>
+      <tp:member type="u" name="Type" tp:type="MM_MODEM_LOCATION_CAPABILITIES">
+        <tp:docstring>
+          Identifies the type and format of the associated location information.
+          Contrary to the value description, this is not a bitfield but uses the
+          same values as the MM_MODEM_LOCATION_CAPABILITIES bitfield.
+        </tp:docstring>
+      </tp:member>
+      <tp:member type="v" name="Data">
+        <tp:docstring>
+          Contains type-specific location information.  See the documentation for
+          each type for a description of its data format.
+        </tp:docstring>
+      </tp:member>
+    </tp:mapping>
+
+    <tp:flags name="MM_MODEM_LOCATION_CAPABILITIES" value-prefix="MM_MODEM_LOCATION_CAPABILITY" type="u">
+      <tp:flag suffix="UNKNOWN" value="0x0">
+        <tp:docstring><p>Unknown or no capabilties.</p></tp:docstring>
+      </tp:flag>
+      <tp:flag suffix="GPS_NMEA" value="0x1">
+        <tp:docstring>
+          <p>For capability reporting, indicates the device is capable of
+          providing GPS NMEA-format location information.</p>
+
+          <p>For location reporting, devices supporting this capability return
+          a string containing one or more NMEA sentences (D-Bus signature 's').
+          The manager will cache the most recent NMEA sentence of each type for
+          a period of time not less than 30 seconds.  When reporting multiple
+          NMEA sentences, sentences shall be separated by an ASCII Carriage
+          Return and Line Feed (&lt;CR&gt;&lt;LF&gt;) sequence.
+          </p>
+          <p>
+          For example, if the device sends a $GPRMC sentence immediately
+          followed by a $GPGGA sentence, the reported location string would be
+          (where of course the &lt;CR&gt;&lt;LF&gt; is replaced with the actual
+          ASCII CR (0x0D) and LF (0x0A) control characters):
+          <pre>
+          $GPRMC,134523.92,V,,,,,,,030136,,,N*73&lt;CR&gt;&lt;LF&gt;$GPGGA,,,,,,0,00,0.5,,M,0.0001999,M,0.0000099,0000*45
+          </pre>
+          If the device sends a new $GPRMC three seconds later, the new $GPRMC
+          replaces the previously received $GPRMC sentence, and the updated
+          string would be:
+          <pre>
+          $GPRMC,134526.92,V,,,,,,,030136,,,N*76&lt;CR&gt;&lt;LF&gt;$GPGGA,,,,,,0,00,0.5,,M,0.0001999,M,0.0000099,0000*45
+          </pre>
+          If the device then sends a $GPGSA sentence about 5 seconds later, the
+          $GPGSA sentence is added to the string (since no $GPGSA sentence was
+          previously received in this session), the updated string would be:
+          <pre>
+          $GPRMC,134526.92,V,,,,,,,030136,,,N*76&lt;CR&gt;&lt;LF&gt;$GPGGA,,,,,,0,00,0.5,,M,0.0001999,M,0.0000099,0000*45&lt;CR&gt;&lt;LF&gt;$GPGSA,A,1,,,,,,,,,,,,,1.1,0.5,1.0*34
+          </pre>
+          The manager may discard any cached sentences older than 30 seconds.
+          </p>
+          <p>This allows clients to read the latest positioning data as soon as
+          possible after they start, even if the device is not providing
+          frequent location data updates.
+          </p>
+        </tp:docstring>
+      </tp:flag>
+      <tp:flag suffix="GSM_LAC_CI" value="0x2">
+        <tp:docstring>
+          <p>For capability reporting, indicates the device is capable of
+          providing GSM Location Area Code/Cell ID location information.</p>
+
+          <p>For location reporting, devices supporting this
+          capability return a string in the format "MCC,MNC,LAC,CI" (without the
+          quotes of course) where the following applies:</p>
+          <ul>
+            <li>
+              MCC is the three-digit ITU E.212 Mobile Country Code of the
+              network provider to which the mobile is currently registered.
+              This value should be the same MCC as reported by the
+              org.freedesktop.Modem.Gsm.Network.GetRegistrationInfo() method's
+              returned "operator code" argument.
+              e.g. "310"
+            </li>
+            <li>
+              MNC is the two- or three-digit GSM Mobile Network Code of the
+              network provider to which the mobile is currently registered.
+              This value should be the same MCC as reported by the
+              org.freedesktop.Modem.Gsm.Network.GetRegistrationInfo() method's
+              returned "operator code" argument.
+              e.g. "26" or "260"
+            </li>
+            <li>
+              LAC is the two-byte Location Area Code of the base station with
+              which the mobile is registered, in upper-case hexadecimal format
+              without leading zeros, as specified in 3GPP TS 27.007 section
+              10.1.19.  e.g. "84CD".
+            </li>
+            <li>
+              CI is the two- or four-byte Cell Identifier with which the mobile
+              is registered, in upper-case hexadecimal format without leading
+              zeros, as specified in 3GPP TS 27.007.  e.g. "2BAF" or "D30156".
+            </li>
+          </ul>
+          <p>The entire string may only be composed of the ASCII digits [0-9],
+          the alphabetical characters [A-F], and the comma (,) character.  No
+          other characters are allowed.  For example: "310,260,8BE3,2BAF" or
+          "250,40,CE00,1CEAD8F0".</p>
+
+          <p>If any of these four items (MCC,MNC,LAC,CI) is unknown or the
+          mobile is not registered with a network, then the GSM_LAC_CI location
+          information item should not be provided as a returned value from the
+          GetLocation() method or in the Location property.</p>
+        </tp:docstring>
+      </tp:flag>
+      <tp:flag suffix="GSM_GPS_RAW" value="0x4">
+        <tp:docstring>
+          <p>For capability reporting, indicates the device is capable of
+          providing raw GPS information using a series of defined key/value
+          pairs.</p>
+
+          <p>For location reporting, devices supporting this
+          capability return a D-Bus dict (signature a{sv}) mapping well-known
+          keys to values with defined formats.  The allowed key/value pairs
+          and their formats are:</p>
+          <table>
+            <tr><th>Key</th><th>Value Type</th><th>Value contents</th><th>Example</th></tr>
+            <tr>
+              <td>latitude</td>
+              <td>d</td>
+              <td>Latitude in Decimal Degrees (positive numbers mean N quadrasphere, negative mean S quadrasphere)</td>
+              <td>38.889722 (ie, 38d 53' 22" N)</td>
+            </tr>
+            <tr>
+              <td>longitude</td>
+              <td>d</td>
+              <td>Longitude in Decimal Degrees (positive numbers mean E quadrasphere, negative mean W quadrasphere)</td>
+              <td>-77.008889 (ie, 77d 0' 32" W)</td>
+            </tr>
+            <tr>
+              <td>altitude</td>
+              <td>d</td>
+              <td>Altitude above sea level in meters</td>
+              <td>33.5</td>
+            </tr>
+            <tr>
+              <td>horiz-velocity</td>
+              <td>d</td>
+              <td>Horizontal velocity in meters-per-second</td>
+              <td>.5</td>
+            </tr>
+            <tr>
+              <td>vert-velocity</td>
+              <td>d</td>
+              <td>Vertical velocity in meters-per-second</td>
+              <td>.01</td>
+            </tr>
+          </table>
+          <p>The 'latitude' and 'longitude' keys are required; other keys are
+          optional.</p>
+        </tp:docstring>
+      </tp:flag>
+    </tp:flags>
+
+  </interface>
+</node>
+
Index: solid/modemmanager-0.4/dbus/introspection/mm-modem-simple.xml
===================================================================
--- solid/modemmanager-0.4/dbus/introspection/mm-modem-simple.xml	(revision 0)
+++ solid/modemmanager-0.4/dbus/introspection/mm-modem-simple.xml	(revision 1145887)
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.ModemManager.Modem.Simple">
+
+    <method name="Connect">
+      <tp:docstring>
+        Do everything needed to connect the modem.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_simple_connect"/>
+      <arg name="properties" type="a{sv}" direction="in">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVariantMap"/>
+        <tp:docstring>
+          Dictionary of properties needed to get the modem connected.
+          Each implementation is free to add it's own specific key-value pairs. The predefined
+          common ones are:
+
+          'pin'          : string
+          'network_id'   : string
+          'band'         : uint
+          'network_mode' : uint
+          'apn'          : string
+          'number'       : string
+        </tp:docstring>
+      </arg>
+    </method>
+    <method name="GetStatus">
+      <tp:docstring>
+        Get the modem status.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_modem_simple_get_status"/>
+      <arg name="properties" type="a{sv}" direction="out">
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantMap"/>
+        <tp:docstring>
+          Dictionary of properties.
+          Each implementation is free to add it's own specific key-value pairs. The predefined
+          common ones are:
+
+          'state'          : uint (always)
+          'signal_quality' : uint  (state >= registered)
+          'operator_code'  : string (state >= registered)
+          'operator_name'  : string (state >= registered)
+          'band'           : uint (state >= registered)
+          'network_mode'   : uint (state >= registered)
+        </tp:docstring>
+      </arg>
+    </method>
+  </interface>
+</node>
Index: solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-simpleinterface introspection/mm-modem-simple.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-simpleinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemSimpleInterface
+ */
+
+OrgFreedesktopModemManagerModemSimpleInterface::OrgFreedesktopModemManagerModemSimpleInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemSimpleInterface::~OrgFreedesktopModemManagerModemSimpleInterface()
+{
+}
+
+
+#include "mm-modem-simpleinterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-smsinterface.h	(revision 1145887)
@@ -0,0 +1,120 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-smsinterface introspection/mm-modem-gsm-sms.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_SMSINTERFACE_H
+#define MM_MODEM_GSM_SMSINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+#include "generic-types.h"
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.SMS
+ */
+class OrgFreedesktopModemManagerModemGsmSMSInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.SMS"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmSMSInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmSMSInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Delete(uint index)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(index);
+        return asyncCallWithArgumentList(QLatin1String("Delete"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVariantMap> Get(uint index)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(index);
+        return asyncCallWithArgumentList(QLatin1String("Get"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> GetFormat()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetFormat"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetSmsc()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetSmsc"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVariantMapList> List()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("List"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> Save(const QVariantMap &properties)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(properties);
+        return asyncCallWithArgumentList(QLatin1String("Save"), argumentList);
+    }
+
+    inline QDBusPendingReply<uint> Send(const QVariantMap &properties)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(properties);
+        return asyncCallWithArgumentList(QLatin1String("Send"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SendFromStorage(uint index)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(index);
+        return asyncCallWithArgumentList(QLatin1String("SendFromStorage"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetFormat(uint format)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(format);
+        return asyncCallWithArgumentList(QLatin1String("SetFormat"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetIndication(uint mode, uint mt, uint bm, uint ds, uint bfr)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(mode) << qVariantFromValue(mt) << qVariantFromValue(bm) << qVariantFromValue(ds) << qVariantFromValue(bfr);
+        return asyncCallWithArgumentList(QLatin1String("SetIndication"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetSmsc(const QString &smsc)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(smsc);
+        return asyncCallWithArgumentList(QLatin1String("SetSmsc"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void Completed(uint index, bool completed);
+    void SmsReceived(uint index, bool complete);
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-manager-clientinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-manager-clientinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-manager-clientinterface.h	(revision 1145887)
@@ -0,0 +1,50 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-manager-clientinterface introspection/mm-manager-client.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MANAGER_CLIENTINTERFACE
+#define MM_MANAGER_CLIENTINTERFACE
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager
+ */
+class OrgFreedesktopModemManagerInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager"; }
+
+public:
+    OrgFreedesktopModemManagerInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<QList<QDBusObjectPath> > EnumerateDevices()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("EnumerateDevices"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void DeviceAdded(const QDBusObjectPath &device);
+    void DeviceRemoved(const QDBusObjectPath &device);
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/generic-types.h
===================================================================
--- solid/modemmanager-0.4/dbus/generic-types.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/generic-types.h	(revision 1145887)
@@ -0,0 +1,101 @@
+/* This file is part of the KDE project
+   Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License or (at your option) version 3 or any later version
+   accepted by the membership of KDE e.V. (or its successor approved
+   by the membership of KDE e.V.), which shall act as a proxy
+   defined in Section 14 of version 3 of the license.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MODEMMANAGER_TYPES_H
+#define MODEMMANAGER_TYPES_H
+
+#include <QMetaType>
+#include <QDBusArgument>
+#include <QtDBus/QtDBus>
+
+#include "libs/solid/control/modemmanager.h"
+#include "libs/solid/control/modemmanagerinterface.h"
+#include "libs/solid/control/modemlocationinterface.h"
+#include "libs/solid/control/modemcdmainterface.h"
+#include "libs/solid/control/modemgsmcontactsinterface.h"
+#include "libs/solid/control/modemgsmnetworkinterface.h"
+#include "libs/solid/control/networkipv4config.h"
+
+typedef Solid::Control::ModemLocationInterface::LocationInformationMap LocationInformationMap;
+typedef Solid::Control::ModemCdmaInterface::ServingSystemType ServingSystemType;
+typedef Solid::Control::ModemCdmaInterface::RegistrationStateResult RegistrationStateResult;
+typedef Solid::Control::ModemInterface::Ip4ConfigType Ip4ConfigType;
+typedef Solid::Control::ModemInterface::InfoType InfoType;
+typedef Solid::Control::ModemGsmContactsInterface::ContactType ContactType;
+typedef Solid::Control::ModemGsmContactsInterface::ContactTypeList ContactTypeList;
+typedef Solid::Control::ModemGsmNetworkInterface::ScanResultsType ScanResultsType;
+typedef Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType RegistrationInfoType;
+typedef QList<QVariantMap> QVariantMapList;
+
+Q_DECLARE_METATYPE(Solid::Control::ModemInterface::Ip4ConfigType)
+Q_DECLARE_METATYPE(Solid::Control::ModemInterface::InfoType)
+Q_DECLARE_METATYPE(Solid::Control::ModemLocationInterface::LocationInformationMap)
+Q_DECLARE_METATYPE(Solid::Control::ModemCdmaInterface::ServingSystemType)
+Q_DECLARE_METATYPE(Solid::Control::ModemCdmaInterface::RegistrationStateResult)
+Q_DECLARE_METATYPE(Solid::Control::ModemGsmContactsInterface::ContactType)
+Q_DECLARE_METATYPE(Solid::Control::ModemGsmContactsInterface::ContactTypeList)
+Q_DECLARE_METATYPE(Solid::Control::ModemGsmNetworkInterface::ScanResultsType)
+Q_DECLARE_METATYPE(Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType)
+Q_DECLARE_METATYPE(QList<QVariantMap>)
+
+// Solid::Control::ModemManager::Modem::Ip4Configtype
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemInterface::Ip4ConfigType &config);
+
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemInterface::Ip4ConfigType &config);
+
+// Solid::Control::ModemManager::Modem::InfoType
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemInterface::InfoType &info);
+
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemInterface::InfoType &info);
+
+// Solid::Control::ModemCdmaInterface::ServingSystemType
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemCdmaInterface::ServingSystemType &servingSystem);
+
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemCdmaInterface::ServingSystemType &servingSystem);
+
+// Solid::Control::ModemGsmContactsInterface::ContactType
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemGsmContactsInterface::ContactType &contact);
+
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemGsmContactsInterface::ContactType &contact);
+
+// Solid::Control::ModemManager::Modem::Gsm::Network::RegistrationInfoType
+QDBusArgument &operator << (QDBusArgument &arg,
+    const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &info);
+
+const QDBusArgument &operator >> (const QDBusArgument &arg,
+    Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &info);
+
+inline void registerModemManagerTypes() {
+        qDBusRegisterMetaType<Solid::Control::ModemInterface::Ip4ConfigType>();
+        qDBusRegisterMetaType<Solid::Control::ModemInterface::InfoType>();
+        qDBusRegisterMetaType<Solid::Control::ModemCdmaInterface::ServingSystemType>();
+        qDBusRegisterMetaType<Solid::Control::ModemGsmContactsInterface::ContactType>();
+        qDBusRegisterMetaType<Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType>();
+}
+
+#endif // MODEMMANAGER_TYPES_H
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-cardinterface introspection/mm-modem-gsm-card.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-cardinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmCardInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmCardInterface::OrgFreedesktopModemManagerModemGsmCardInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmCardInterface::~OrgFreedesktopModemManagerModemGsmCardInterface()
+{
+}
+
+
+#include "mm-modem-gsm-cardinterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-simpleinterface.h	(revision 1145887)
@@ -0,0 +1,55 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-simpleinterface introspection/mm-modem-simple.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_SIMPLEINTERFACE_H
+#define MM_MODEM_SIMPLEINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Simple
+ */
+class OrgFreedesktopModemManagerModemSimpleInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Simple"; }
+
+public:
+    OrgFreedesktopModemManagerModemSimpleInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemSimpleInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Connect(const QVariantMap &properties)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(properties);
+        return asyncCallWithArgumentList(QLatin1String("Connect"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVariantMap> GetStatus()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetStatus"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-contactsinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-contactsinterface introspection/mm-modem-gsm-contacts.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-contactsinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmContactsInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmContactsInterface::OrgFreedesktopModemManagerModemGsmContactsInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmContactsInterface::~OrgFreedesktopModemManagerModemGsmContactsInterface()
+{
+}
+
+
+#include "mm-modem-gsm-contactsinterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.h
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.h	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-cardinterface.h	(revision 1145887)
@@ -0,0 +1,90 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-cardinterface introspection/mm-modem-gsm-card.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef MM_MODEM_GSM_CARD_H
+#define MM_MODEM_GSM_CARD_H
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+
+/*
+ * Proxy class for interface org.freedesktop.ModemManager.Modem.Gsm.Card
+ */
+class OrgFreedesktopModemManagerModemGsmCardInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.ModemManager.Modem.Gsm.Card"; }
+
+public:
+    OrgFreedesktopModemManagerModemGsmCardInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~OrgFreedesktopModemManagerModemGsmCardInterface();
+
+    Q_PROPERTY(uint SupportedBands READ supportedBands)
+    inline uint supportedBands() const
+    { return qvariant_cast< uint >(property("SupportedBands")); }
+
+    Q_PROPERTY(uint SupportedModes READ supportedModes)
+    inline uint supportedModes() const
+    { return qvariant_cast< uint >(property("SupportedModes")); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> ChangePin(const QString &old_pin, const QString &new_pin)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(old_pin) << qVariantFromValue(new_pin);
+        return asyncCallWithArgumentList(QLatin1String("ChangePin"), argumentList);
+    }
+
+    inline QDBusPendingReply<> EnablePin(const QString &pin, bool enabled)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(pin) << qVariantFromValue(enabled);
+        return asyncCallWithArgumentList(QLatin1String("EnablePin"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetImei()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetImei"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetImsi()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetImsi"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SendPin(const QString &pin)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(pin);
+        return asyncCallWithArgumentList(QLatin1String("SendPin"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SendPuk(const QString &puk, const QString &pin)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(puk) << qVariantFromValue(pin);
+        return asyncCallWithArgumentList(QLatin1String("SendPuk"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
Index: solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-gsm-ussdinterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-gsm-ussdinterface introspection/mm-modem-gsm-ussd.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-gsm-ussdinterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemGsmUssdInterface
+ */
+
+OrgFreedesktopModemManagerModemGsmUssdInterface::OrgFreedesktopModemManagerModemGsmUssdInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemGsmUssdInterface::~OrgFreedesktopModemManagerModemGsmUssdInterface()
+{
+}
+
+
+#include "mm-modem-gsm-ussdinterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modeminterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modeminterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modeminterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modeminterface introspection/mm-modem.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modeminterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemInterface
+ */
+
+OrgFreedesktopModemManagerModemInterface::OrgFreedesktopModemManagerModemInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemInterface::~OrgFreedesktopModemManagerModemInterface()
+{
+}
+
+
+#include "mm-modeminterface.moc"
Index: solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.cpp
===================================================================
--- solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/dbus/mm-modem-cdmainterface.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -N -m -p mm-modem-cdmainterface introspection/mm-modem-cdma.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "mm-modem-cdmainterface.h"
+
+/*
+ * Implementation of interface class OrgFreedesktopModemManagerModemCdmaInterface
+ */
+
+OrgFreedesktopModemManagerModemCdmaInterface::OrgFreedesktopModemManagerModemCdmaInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+OrgFreedesktopModemManagerModemCdmaInterface::~OrgFreedesktopModemManagerModemCdmaInterface()
+{
+}
+
+
+#include "mm-modem-cdmainterface.moc"
Index: solid/modemmanager-0.4/dbus/CMakeLists.txt
===================================================================
--- solid/modemmanager-0.4/dbus/CMakeLists.txt	(revision 0)
+++ solid/modemmanager-0.4/dbus/CMakeLists.txt	(revision 1145887)
@@ -0,0 +1,53 @@
+# Steps to generate the dbus interface files
+# 1) Place the ModemManager introspection dbus xml in introspection/
+# 2) Update the list of xml files below that we want to generate interfaces for
+# 3) Enable dbus subdirectory in ../CMakeLists.txt
+#    Make, in order to generate the interface sources
+# 3.1) Add annotations to the xml so qdbusxml2cpp knows what type or typedef to use
+#      Add typedefs as needed to generic-types.h
+# 4)   Add the list of generated files needed for the plugin to FILES_TO_BUILD
+# 6) Copy the working generated interface sources into the source dir
+# 5) Edit the sources as required to get them to build
+# 5.1) Fix the inclusion guards as the compiler ignores anything after a '-' so the compiler thinks
+#      headers have already been included
+# Run do-hand-edits to update the diff of the interfaces vs what is generated; this speeds up regenerating them since you just have to apply the diff to make them compile
+
+
+set( INTERFACE_INTROSPECTION_XML_FILES
+   introspection/mm-manager-client.xml
+   introspection/mm-modem.xml
+   introspection/mm-modem-cdma.xml
+   introspection/mm-modem-location.xml
+   introspection/mm-modem-simple.xml
+   introspection/mm-modem-gsm-card.xml
+   introspection/mm-modem-gsm-contacts.xml
+   introspection/mm-modem-gsm-network.xml
+   introspection/mm-modem-gsm-sms.xml
+   introspection/mm-modem-gsm-hso.xml
+   introspection/mm-modem-gsm-ussd.xml
+   )
+
+set( ADAPTER_INTROSPECTION_XML_FILES
+   )
+
+set_source_files_properties( ${INTERFACE_INTROSPECTION_XML_FILES} ${ADAPTER_INTROSPECTION_XML_FILES} PROPERTIES NO_NAMESPACE TRUE )
+
+set( UNUSED_XML
+)
+
+
+set( FILES_TO_BUILD
+   )
+set ( UNUSED_FILES
+   mm-manager-clientinterface.cpp
+)
+
+set( UNUSED_GENERATED_FILES
+)
+
+QT4_ADD_DBUS_INTERFACES( FILES_TO_BUILD ${INTERFACE_INTROSPECTION_XML_FILES} )
+
+kde4_add_library(modemmanagerdbus ${FILES_TO_BUILD})
+
+TARGET_LINK_LIBRARIES(modemmanagerdbus ${QT_QTCORE_LIBRARY} ${QT_QTDBUS_LIBRARY})
+
Index: solid/modemmanager-0.4/modemcdmainterface.h
===================================================================
--- solid/modemmanager-0.4/modemcdmainterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemcdmainterface.h	(revision 1145887)
@@ -0,0 +1,53 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMCDMAINTERFACE_H
+#define MM04_MODEMCDMAINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemcdmainterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemCdmaInterfacePrivate;
+
+class KDE_EXPORT MMModemCdmaInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemCdmaInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemCdmaInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemCdmaInterface)
+
+public:
+    MMModemCdmaInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemCdmaInterface();
+
+    uint getSignalQuality();
+    QString getEsn();
+    ServingSystemType getServingSystem();
+    RegistrationStateResult getRegistrationState();
+
+Q_SIGNALS:
+    void signalQualityChanged(uint signalQuality);
+    void registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState cdma_1x_state,
+                                  const Solid::Control::ModemCdmaInterface::RegistrationState evdo_state);
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmcontactsinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmcontactsinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcontactsinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMCONTACTSINTERFACE_P_H
+#define MM04_MODEMGSMCONTACTSINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-contactsinterface.h"
+
+class MMModemGsmContactsInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmContactsInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmContactsInterface modemGsmContactsIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/manager.h
===================================================================
--- solid/modemmanager-0.4/manager.h	(revision 0)
+++ solid/modemmanager-0.4/manager.h	(revision 1145887)
@@ -0,0 +1,65 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMMANAGER_H
+#define MM04_MODEMMANAGER_H
+
+#include "solid/control/ifaces/modemmanager.h"
+#include <QDBusObjectPath>
+#include <kdemacros.h>
+
+class MMModemManagerPrivate;
+
+class KDE_EXPORT MMModemManager : public Solid::Control::Ifaces::ModemManager
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemManager)
+Q_INTERFACES(Solid::Control::Ifaces::ModemManager)
+
+public:
+    static const QString DBUS_SERVICE;
+    static const QString DBUS_DAEMON_PATH;
+    static const QString DBUS_USER_SETTINGS_PATH;
+    static const QString DBUS_SYSTEM_SETTINGS_PATH;
+
+    MMModemManager(QObject * parent, const QStringList & args);
+    ~MMModemManager();
+    Solid::Networking::Status status() const;
+    QStringList modemInterfaces() const;
+    QObject *createModemInterface(const QString &udi, const Solid::Control::ModemInterface::GsmInterfaceType ifaceType);
+
+Q_SIGNALS:
+    void statusChanged(Solid::Networking::Status status);
+    void modemInterfaceAdded(const QString & udi);
+    void modemInterfaceRemoved(const QString & udi);
+
+protected Q_SLOTS:
+    void deviceAdded(const QDBusObjectPath & device);
+    void deviceRemoved(const QDBusObjectPath & device);
+    void stateChanged(Solid::Networking::Status state);
+    void nameOwnerChanged(QString, QString, QString);
+
+private:
+    MMModemManagerPrivate * d_ptr;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemlocationinterface.h
===================================================================
--- solid/modemmanager-0.4/modemlocationinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemlocationinterface.h	(revision 1145887)
@@ -0,0 +1,58 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMLOCATIONINTERFACE_H
+#define MM04_MODEMLOCATIONINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemlocationinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemLocationInterfacePrivate;
+
+class KDE_EXPORT MMModemLocationInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemLocationInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemLocationInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemLocationInterface)
+
+public:
+    MMModemLocationInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemLocationInterface();
+
+    void enableLocation(const bool enable, const bool signalLocation);
+    Solid::Control::ModemLocationInterface::LocationInformationMap getLocation();
+    Solid::Control::ModemLocationInterface::Capability getCapability() const;
+    bool enabled() const;
+    bool signalsLocation() const;
+
+public Q_SLOTS:
+   void propertiesChanged(const QString & interface, const QVariantMap & properties);
+
+Q_SIGNALS:
+    void capabilitiesChanged(const Solid::Control::ModemLocationInterface::Capability capability);
+    void enabledChanged(const bool enabled);
+    void signalsLocationChanged(const bool signalsLocation);
+    void locationChanged(const Solid::Control::ModemLocationInterface::LocationInformationMap & location);
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmsmsinterface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmsmsinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmsmsinterface.h	(revision 1145887)
@@ -0,0 +1,58 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMSMSINTERFACE_H
+#define MM04_MODEMGSMSMSINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmsmsinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmSmsInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmSmsInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmSmsInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmSmsInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmSmsInterface)
+
+public:
+    MMModemGsmSmsInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmSmsInterface();
+
+    void deleteSms(const int index);
+    QVariantMap get(const int index);
+    int getFormat();
+    void setFormat(const int format);
+    QString getSmsc();
+    QList<QVariantMap> list();
+    void save(const QVariantMap & properties);
+    void send(const QVariantMap & properties);
+    void sendFromStorage(const int index);
+    void setIndication(const int mode, const int mt, const int bm, const int ds, const int brf);
+
+Q_SIGNALS:
+    void smsReceived(int index, bool complete);
+    void completed(int index, bool completed);
+};
+
+#endif
+
Index: solid/modemmanager-0.4/solid_modemmanager04.desktop
===================================================================
--- solid/modemmanager-0.4/solid_modemmanager04.desktop	(revision 0)
+++ solid/modemmanager-0.4/solid_modemmanager04.desktop	(revision 1145887)
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=SolidModemManager
+X-KDE-Library=solid_modemmanager04
+InitialPreference=100
+Name=ModemManager 0.4
+Name[pt_BR]=ModemManager 0.4
+Comment=Network management using the ModemManager daemon, version 0.4
+Comment[pt_BR]=Gerenciamento de rede usando a versão 0.4 do serviço ModemManager
+Icon=phone
Index: solid/modemmanager-0.4/module.cpp
===================================================================
--- solid/modemmanager-0.4/module.cpp	(revision 0)
+++ solid/modemmanager-0.4/module.cpp	(revision 1145887)
@@ -0,0 +1,28 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Will Stephenson <wstephenson@kde.org>
+    Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "manager.h"
+
+// KDE includes
+#include <kgenericfactory.h>
+
+typedef KGenericFactory<MMModemManager, Solid::Control::Ifaces::ModemManager> ModemManagerBackendFactory;
+K_EXPORT_COMPONENT_FACTORY(solid_modemmanager04, ModemManagerBackendFactory("ModemManagerbackend"))
+
Index: solid/modemmanager-0.4/modemgsmhsointerface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmhsointerface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmhsointerface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMHSOINTERFACE_P_H
+#define MM04_MODEMGSMHSOINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-hsointerface.h"
+
+class MMModemGsmHsoInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmHsoInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmHsoInterface modemGsmHsoIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modeminterface.h
===================================================================
--- solid/modemmanager-0.4/modeminterface.h	(revision 0)
+++ solid/modemmanager-0.4/modeminterface.h	(revision 1145887)
@@ -0,0 +1,83 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a prox
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMINTERFACE_H
+#define MM04_MODEMINTERFACE_H
+
+#include "solid/control/solid_control_export.h"
+#include "solid/control/ifaces/modeminterface.h"
+
+class MMModemInterfacePrivate;
+class MMModemManager;
+
+class KDE_EXPORT MMModemInterface : public QObject, virtual public Solid::Control::Ifaces::ModemInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemInterface)
+Q_PROPERTY(QString udi READ udi)
+
+public:
+    MMModemInterface( const QString & path, MMModemManager * manager, QObject * parent );
+    MMModemInterface( MMModemInterfacePrivate &dd, MMModemManager * manager, QObject * parent );
+    ~MMModemInterface();
+
+    QString udi() const;
+
+    // From org.freedesktop.ModemManager.Modem
+    void enable(const bool enable);
+    void connectModem(const QString & number);
+    void disconnectModem();
+    Solid::Control::ModemInterface::Ip4ConfigType getIp4Config();
+    Solid::Control::ModemInterface::InfoType getInfo();
+
+    QString device() const;
+    QString masterDevice() const;
+    QString driver() const;
+    Solid::Control::ModemInterface::Type type() const;
+    bool enabled() const;
+    QString unlockRequired() const;
+    Solid::Control::ModemInterface::Method ipMethod() const;
+
+    // From org.freedesktop.ModemManager.Modem.Simple
+    void connectModem(const QVariantMap & properties);
+    QVariantMap getStatus();
+public Q_SLOTS:
+    void propertiesChanged(const QString & interface, const QVariantMap & properties);
+
+Q_SIGNALS:
+    void deviceChanged(const QString & device);
+    void masterDeviceChanged(const QString & masterDevice);
+    void driverChanged(const QString & driver);
+    void typeChanged(const Solid::Control::ModemInterface::Type type);
+    void enabledChanged(const bool enabled);
+    void unlockRequiredChanged(const QString & codeRequired);
+    void ipMethodChanged(const Solid::Control::ModemInterface::Method ipMethod);
+
+private:
+    void init();
+
+protected:
+    MMModemInterfacePrivate * d_ptr;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmcardinterface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmcardinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcardinterface.h	(revision 1145887)
@@ -0,0 +1,61 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMCARDINTERFACE_H
+#define MM04_MODEMGSMCARDINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmcardinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmCardInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmCardInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmCardInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmCardInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmCardInterface)
+
+public:
+    MMModemGsmCardInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmCardInterface();
+
+    QString getImei();
+    QString getImsi();
+    void sendPuk(const QString & puk, const QString & pin);
+    void sendPin(const QString & pin);
+    void enablePin(const QString & pin, const bool enabled);
+    void changePin(const QString & oldPin, const QString & newPin);
+
+    // Properties
+    Solid::Control::ModemInterface::Band getSupportedBands() const;
+    Solid::Control::ModemInterface::Mode getSupportedModes() const;
+public Q_SLOTS:
+    void propertiesChanged(const QString & interface, const QVariantMap & properties);
+Q_SIGNALS:
+    // properties
+    void supportedBandsChanged(const Solid::Control::ModemInterface::Band band);
+    void supportedModesChanged(const Solid::Control::ModemInterface::Mode modes);
+
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmussdinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmussdinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmussdinterface.cpp	(revision 1145887)
@@ -0,0 +1,114 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmussdinterface.h"
+#include "modemgsmussdinterface_p.h"
+
+#include <KDebug>
+
+MMModemGsmUssdInterfacePrivate::MMModemGsmUssdInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmUssdIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmUssdInterface::MMModemGsmUssdInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmUssdInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(MMModemGsmUssdInterface);
+
+    d->modemGsmUssdIface.connection().connect(MMModemManager::DBUS_SERVICE,
+        path, QLatin1String("org.freedesktop.DBus.Properties"),
+        QLatin1String("MmPropertiesChanged"), QLatin1String("sa{sv}"),
+        this, SLOT(propertiesChanged(const QString &,const QVariantMap &)));
+}
+
+MMModemGsmUssdInterface::~MMModemGsmUssdInterface()
+{
+
+}
+
+void MMModemGsmUssdInterface::propertiesChanged(const QString & interface, const QVariantMap & properties)
+{
+    kDebug(1441) << interface << properties.keys();
+
+    if (interface == QString("org.freedesktop.ModemManager.Modem.Gsm.Ussd")) {
+        QLatin1String state("State");
+        QLatin1String networkNotification("NetworkNotification");
+        QLatin1String networkRequest("NetworkRequest");
+
+        QVariantMap::const_iterator it = properties.find(state);
+        if ( it != properties.end()) {
+            emit stateChanged(it->toString());
+        }
+        it = properties.find(networkNotification);
+        if ( it != properties.end()) {
+            emit networkNotificationChanged(it->toString());
+        }
+        it = properties.find(networkRequest);
+        if ( it != properties.end()) {
+            emit networkRequestChanged(it->toString());
+        }
+    }
+}
+
+QString MMModemGsmUssdInterface::initiate(const QString & command)
+{
+    Q_D(MMModemGsmUssdInterface);
+    QDBusReply<QString> reply = d->modemGsmUssdIface.Initiate(command);
+
+    if (reply.isValid()) {
+        return reply.value();
+    }
+    return QString();
+}
+
+void MMModemGsmUssdInterface::respond(const QString response)
+{
+    Q_D(MMModemGsmUssdInterface);
+    d->modemGsmUssdIface.Respond(response);
+}
+
+void MMModemGsmUssdInterface::cancel()
+{
+    Q_D(MMModemGsmUssdInterface);
+    d->modemGsmUssdIface.Cancel();
+}
+
+QString MMModemGsmUssdInterface::getState()
+{
+    Q_D(const MMModemGsmUssdInterface);
+    return d->modemGsmUssdIface.state();
+}
+
+QString MMModemGsmUssdInterface::getNetworkNotification()
+{
+    Q_D(const MMModemGsmUssdInterface);
+    return d->modemGsmUssdIface.networkNotification();
+}
+
+QString MMModemGsmUssdInterface::getNetworkRequest()
+{
+    Q_D(const MMModemGsmUssdInterface);
+    return d->modemGsmUssdIface.networkRequest();
+}
+
+#include "modemgsmussdinterface.moc"
+
Index: solid/modemmanager-0.4/CMakeLists.txt
===================================================================
--- solid/modemmanager-0.4/CMakeLists.txt	(revision 0)
+++ solid/modemmanager-0.4/CMakeLists.txt	(revision 1145887)
@@ -0,0 +1,48 @@
+include_directories(
+   ${KDEBASE_WORKSPACE_SOURCE_DIR}/libs
+   ${CMAKE_CURRENT_SOURCE_DIR}/dbus
+   ${CMAKE_CURRENT_BUILD_DIR}
+)
+
+#add_subdirectory(dbus)
+
+set(solid_modemmanager_PART_SRCS
+   manager.cpp
+   modeminterface.cpp
+   modemlocationinterface.cpp
+   modemcdmainterface.cpp
+   modemgsmcardinterface.cpp
+   modemgsmcontactsinterface.cpp
+   modemgsmnetworkinterface.cpp
+   modemgsmsmsinterface.cpp
+   modemgsmhsointerface.cpp
+   modemgsmussdinterface.cpp
+)
+
+set( DBUS_INTERFACES_FILES
+   dbus/generic-types.cpp
+   dbus/mm-manager-clientinterface.cpp
+   dbus/mm-modeminterface.cpp
+   dbus/mm-modem-simpleinterface.cpp
+   dbus/mm-modem-locationinterface.cpp
+   dbus/mm-modem-cdmainterface.cpp
+   dbus/mm-modem-gsm-cardinterface.cpp
+   dbus/mm-modem-gsm-contactsinterface.cpp
+   dbus/mm-modem-gsm-networkinterface.cpp
+   dbus/mm-modem-gsm-smsinterface.cpp
+   dbus/mm-modem-gsm-hsointerface.cpp
+   dbus/mm-modem-gsm-ussdinterface.cpp
+)
+
+
+kde4_add_library(solid_modemmanager04_static STATIC ${solid_modemmanager_PART_SRCS} ${DBUS_INTERFACES_FILES})
+target_link_libraries(solid_modemmanager04_static ${KDE4_KDECORE_LIBS} solidcontrolifaces)
+
+kde4_add_plugin(solid_modemmanager04 module.cpp ${solid_modemmanager_PART_SRCS} ${DBUS_INTERFACES_FILES})
+
+target_link_libraries(solid_modemmanager04 ${KDE4_KDECORE_LIBS} ${KDE4_SOLID_LIBS} solidcontrol solidcontrolifaces)
+install(TARGETS solid_modemmanager04 DESTINATION ${PLUGIN_INSTALL_DIR})
+
+install(FILES solid_modemmanager04.desktop DESTINATION ${SERVICES_INSTALL_DIR}/solidbackends )
+
+kde4_install_icons( ${ICON_INSTALL_DIR} )
Index: solid/modemmanager-0.4/modemgsmcontactsinterface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmcontactsinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcontactsinterface.h	(revision 1145887)
@@ -0,0 +1,50 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMCONTACTSINTERFACE_H
+#define MM04_MODEMGSMCONTACTSINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmcontactsinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmContactsInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmContactsInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmContactsInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmContactsInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmContactsInterface)
+
+public:
+    MMModemGsmContactsInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmContactsInterface();
+
+    int addContact(const QString & name, const QString & number);
+    void deleteContact(const int index);
+    ContactType get(const int index);
+    Solid::Control::ModemGsmContactsInterface::ContactTypeList list();
+    Solid::Control::ModemGsmContactsInterface::ContactTypeList find(const QString & pattern);
+    int getCount();
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmnetworkinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmnetworkinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmnetworkinterface.cpp	(revision 1145887)
@@ -0,0 +1,162 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmnetworkinterface.h"
+#include "modemgsmnetworkinterface_p.h"
+
+#include <KDebug>
+
+MMModemGsmNetworkInterfacePrivate::MMModemGsmNetworkInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmNetworkIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmNetworkInterface::MMModemGsmNetworkInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmNetworkInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(MMModemGsmNetworkInterface);
+
+    d->modemGsmNetworkIface.connection().connect(MMModemManager::DBUS_SERVICE,
+        path, QLatin1String("org.freedesktop.DBus.Properties"),
+        QLatin1String("MmPropertiesChanged"), QLatin1String("sa{sv}"),
+        this, SLOT(propertiesChanged(const QString &,const QVariantMap &)));
+
+    connect( &d->modemGsmNetworkIface, SIGNAL(RegistrationInfo(uint, const QString &, const QString &)),
+                this, SLOT(slotRegistrationInfoChanged(uint, const QString &, const QString &)));
+    connect( &d->modemGsmNetworkIface, SIGNAL(SignalQuality(uint)),
+                this, SIGNAL(signalQualityChanged(uint)));
+}
+
+MMModemGsmNetworkInterface::~MMModemGsmNetworkInterface()
+{
+
+}
+
+void MMModemGsmNetworkInterface::propertiesChanged(const QString & interface, const QVariantMap & properties)
+{
+    kDebug(1441) << interface << properties.keys();
+
+    if (interface == QString("org.freedesktop.ModemManager.Modem.Gsm.Network")) {
+        QLatin1String allowedMode("AllowedMode");
+        QLatin1String accessTechnology("AccessTechnology");
+
+        QVariantMap::const_iterator it = properties.find(allowedMode);
+        if ( it != properties.end()) {
+            emit allowedModeChanged((Solid::Control::ModemInterface::AllowedMode) it->toInt());
+        }
+        it = properties.find(accessTechnology);
+        if ( it != properties.end()) {
+            emit accessTechnologyChanged((Solid::Control::ModemInterface::AccessTechnology) it->toInt());
+        }
+    }
+}
+
+void MMModemGsmNetworkInterface::slotRegistrationInfoChanged(uint status, const QString & operatorCode, const QString &operatorName)
+{
+    RegistrationInfoType r;
+
+    r.status = (Solid::Control::ModemGsmNetworkInterface::RegistrationStatus) status;
+    r.operatorCode = operatorCode;
+    r.operatorName = operatorName;
+
+    emit registrationInfoChanged(r);
+}
+
+Solid::Control::ModemInterface::AllowedMode MMModemGsmNetworkInterface::getAllowedMode() const
+{
+    Q_D(const MMModemGsmNetworkInterface);
+    return (Solid::Control::ModemInterface::AllowedMode) d->modemGsmNetworkIface.allowedMode();
+}
+
+Solid::Control::ModemInterface::AccessTechnology MMModemGsmNetworkInterface::getAccessTechnology() const
+{
+    Q_D(const MMModemGsmNetworkInterface);
+    return (Solid::Control::ModemInterface::AccessTechnology) d->modemGsmNetworkIface.accessTechnology();
+}
+
+void MMModemGsmNetworkInterface::registerToNetwork(const QString & networkId)
+{
+    Q_D(MMModemGsmNetworkInterface);
+    d->modemGsmNetworkIface.Register(networkId);
+}
+
+ScanResultsType MMModemGsmNetworkInterface::scan()
+{
+    Q_D(MMModemGsmNetworkInterface);
+    return d->modemGsmNetworkIface.Scan();
+}
+
+void MMModemGsmNetworkInterface::setApn(const QString & apn)
+{
+    Q_D(MMModemGsmNetworkInterface);
+    d->modemGsmNetworkIface.SetApn(apn);
+}
+
+void MMModemGsmNetworkInterface::setBand(const Solid::Control::ModemInterface::Band band)
+{
+    Q_D(MMModemGsmNetworkInterface);
+    d->modemGsmNetworkIface.SetBand(band);
+}
+
+Solid::Control::ModemInterface::Band MMModemGsmNetworkInterface::getBand()
+{
+    Q_D(MMModemGsmNetworkInterface);
+    QDBusReply< uint > band = d->modemGsmNetworkIface.GetBand();
+
+    if (band.isValid())
+        return (Solid::Control::ModemInterface::Band) band.value();
+
+    kDebug(1441) << "Error getting band setting info: " << band.error().name() << ": " << band.error().message();
+    return Solid::Control::ModemInterface::UnknownBand;
+}
+
+RegistrationInfoType MMModemGsmNetworkInterface::getRegistrationInfo()
+{
+    Q_D(MMModemGsmNetworkInterface);
+    QDBusReply< RegistrationInfoType > registrationInfo = d->modemGsmNetworkIface.GetRegistrationInfo();
+
+    if (registrationInfo.isValid())
+        return registrationInfo.value();
+
+    kDebug(1441) << "Error getting registration info for operator: " << registrationInfo.error().name() << ": " << registrationInfo.error().message();
+    return RegistrationInfoType();
+}
+
+uint MMModemGsmNetworkInterface::getSignalQuality()
+{
+    Q_D(MMModemGsmNetworkInterface);
+    QDBusReply< uint > signalQuality = d->modemGsmNetworkIface.GetSignalQuality();
+
+    if (signalQuality.isValid())
+        return signalQuality.value();
+
+    kDebug(1441) << "Error getting signal quality: " << signalQuality.error().name() << ": " << signalQuality.error().message();
+    return 0;
+}
+
+void MMModemGsmNetworkInterface::setAllowedMode(const Solid::Control::ModemInterface::AllowedMode mode)
+{
+    Q_D(MMModemGsmNetworkInterface);
+    d->modemGsmNetworkIface.SetAllowedMode(mode);
+}
+
+#include "modemgsmnetworkinterface.moc"
+
Index: solid/modemmanager-0.4/modemcdmainterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemcdmainterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemcdmainterface.cpp	(revision 1145887)
@@ -0,0 +1,98 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemcdmainterface.h"
+#include "modemcdmainterface_p.h"
+
+#include <KDebug>
+
+MMModemCdmaInterfacePrivate::MMModemCdmaInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemCdmaIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemCdmaInterface::MMModemCdmaInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemCdmaInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(MMModemCdmaInterface);
+
+    connect( &d->modemCdmaIface, SIGNAL(RegistrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState,
+                                                                 const Solid::Control::ModemCdmaInterface::RegistrationState)),
+                this, SIGNAL(registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState,
+                                                      const Solid::Control::ModemCdmaInterface::RegistrationState)));
+    connect( &d->modemCdmaIface, SIGNAL(SignalQuality(uint)),
+                this, SIGNAL(signalQualityChanged(uint)));
+}
+
+MMModemCdmaInterface::~MMModemCdmaInterface()
+{
+
+}
+
+uint MMModemCdmaInterface::getSignalQuality()
+{
+    Q_D(MMModemCdmaInterface);
+    QDBusReply< uint > signalQuality = d->modemCdmaIface.GetSignalQuality();
+
+    if (signalQuality.isValid())
+        return signalQuality.value();
+
+    kDebug(1441) << "Error getting signal quality: " << signalQuality.error().name() << ": " << signalQuality.error().message();
+    return 0;
+}
+
+QString MMModemCdmaInterface::getEsn()
+{
+    Q_D(MMModemCdmaInterface);
+    QDBusReply<QString> esn = d->modemCdmaIface.GetEsn();
+
+    if (esn.isValid())
+        return esn.value();
+
+    kDebug(1441) << "Error getting ESN: " << esn.error().name() << ": " << esn.error().message();
+    return QString();
+}
+
+ServingSystemType MMModemCdmaInterface::getServingSystem()
+{
+    Q_D(MMModemCdmaInterface);
+    QDBusReply<ServingSystemType> servingSystem = d->modemCdmaIface.GetServingSystem();
+
+    if (servingSystem.isValid())
+        return servingSystem.value();
+
+    kDebug(1441) << "Error getting serving system info: " << servingSystem.error().name() << ": " << servingSystem.error().message();
+    return ServingSystemType();
+}
+
+RegistrationStateResult MMModemCdmaInterface::getRegistrationState()
+{
+    Q_D(MMModemCdmaInterface);
+    QDBusReply<RegistrationStateResult> registrationState = d->modemCdmaIface.GetRegistrationState();
+
+    if (registrationState.isValid())
+        return registrationState.value();
+
+    kDebug(1441) << "Error getting registration state: " << registrationState.error().name() << ": " << registrationState.error().message();
+    return RegistrationStateResult();
+}
+
+#include "modemcdmainterface.moc"
Index: solid/modemmanager-0.4/modemgsmhsointerface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmhsointerface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmhsointerface.h	(revision 1145887)
@@ -0,0 +1,45 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMHSOINTERFACE_H
+#define MM04_MODEMGSMHSOINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmhsointerface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmHsoInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmHsoInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmHsoInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmHsoInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmHsoInterface)
+
+public:
+    MMModemGsmHsoInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmHsoInterface();
+
+    void authenticate(const QString & username, const QString & password);
+};
+
+#endif
+
Index: solid/modemmanager-0.4/manager.cpp
===================================================================
--- solid/modemmanager-0.4/manager.cpp	(revision 0)
+++ solid/modemmanager-0.4/manager.cpp	(revision 1145887)
@@ -0,0 +1,174 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "manager_p.h"
+#include "modemcdmainterface.h"
+#include "modemgsmcardinterface.h"
+#include "modemgsmcontactsinterface.h"
+#include "modemgsmnetworkinterface.h"
+#include "modemgsmsmsinterface.h"
+#include "modemgsmhsointerface.h"
+#include "modemgsmussdinterface.h"
+
+#include <KDebug>
+
+const QString MMModemManager::DBUS_SERVICE(QString::fromLatin1("org.freedesktop.ModemManager"));
+const QString MMModemManager::DBUS_DAEMON_PATH(QString::fromLatin1("/org/freedesktop/ModemManager"));
+
+MMModemManagerPrivate::MMModemManagerPrivate() : iface(MMModemManager::DBUS_SERVICE, "/org/freedesktop/ModemManager", QDBusConnection::systemBus())
+{
+    kDebug(1441) << MMModemManager::DBUS_SERVICE;
+}
+
+MMModemManager::MMModemManager(QObject * parent, const QStringList &)
+{
+    qDBusRegisterMetaType<QList<QDBusObjectPath> >();
+    registerModemManagerTypes();
+    d_ptr = new MMModemManagerPrivate;
+    Q_D(MMModemManager);
+
+    // TODO: determinate ModemManager initial state: Connected (MM running), Unknown (MM not running).
+    d->mmState = Solid::Networking::Connected;
+
+    connect( &d->iface, SIGNAL(DeviceAdded(const QDBusObjectPath &)),
+                  this, SLOT(deviceAdded(const QDBusObjectPath &)));
+    connect( &d->iface, SIGNAL(DeviceRemoved(const QDBusObjectPath &)),
+                  this, SLOT(deviceRemoved(const QDBusObjectPath &)));
+
+    d->iface.connection().connect(QLatin1String("org.freedesktop.DBus"),
+            QLatin1String("/org/freedesktop/DBus"), QLatin1String("org.freedesktop.DBus"),
+            QLatin1String("NameOwnerChanged"), QLatin1String("sss"),
+            this, SLOT(nameOwnerChanged(QString,QString,QString)));
+
+    QDBusReply< QList<QDBusObjectPath> > deviceList = d->iface.EnumerateDevices();
+    if (deviceList.isValid())
+    {
+        QList <QDBusObjectPath> devices = deviceList.value();
+        foreach (const QDBusObjectPath &op, devices)
+        {
+            d->modemInterfaces.append(op.path());
+        }
+    }
+}
+
+MMModemManager::~MMModemManager()
+{
+    delete d_ptr;
+}
+
+Solid::Networking::Status MMModemManager::status() const
+{
+    Q_D(const MMModemManager);
+    return d->mmState;
+}
+
+QStringList MMModemManager::modemInterfaces() const
+{
+    Q_D(const MMModemManager);
+    return d->modemInterfaces;
+}
+
+QObject *MMModemManager::createModemInterface(const QString &udi, const Solid::Control::ModemInterface::GsmInterfaceType ifaceType)
+{
+    kDebug(1441);
+    OrgFreedesktopModemManagerModemInterface modemIface(MMModemManager::DBUS_SERVICE, udi, QDBusConnection::systemBus());
+    uint modemType = modemIface.type();
+    MMModemInterface * createdInterface = 0;
+    switch ( modemType ) {
+        case Solid::Control::ModemInterface::GsmType:
+            switch (ifaceType) {
+                case Solid::Control::ModemInterface::GsmCard:
+                    createdInterface = new MMModemGsmCardInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::GsmContacts:
+                    createdInterface = new MMModemGsmContactsInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::GsmNetwork:
+                    createdInterface = new MMModemGsmNetworkInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::GsmSms:
+                    createdInterface = new MMModemGsmSmsInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::GsmHso:
+                    createdInterface = new MMModemGsmHsoInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::GsmUssd:
+                    createdInterface = new MMModemGsmUssdInterface(udi, this, 0); // these are deleted by the frontend manager
+                break;
+                case Solid::Control::ModemInterface::NotGsm: // to prevent compilation warning
+                break;
+            }
+            break;
+        case Solid::Control::ModemInterface::CdmaType:
+            createdInterface = new MMModemCdmaInterface(udi, this, 0); // these are deleted by the frontend manager
+            break;
+        default:
+            kDebug(1441) << "Can't create object of type " << modemType;
+            break;
+    }
+
+    return createdInterface;
+}
+
+void MMModemManager::deviceAdded(const QDBusObjectPath & objpath)
+{
+    kDebug(1441);
+    Q_D(MMModemManager);
+    d->modemInterfaces.append(objpath.path());
+    emit modemInterfaceAdded(objpath.path());
+}
+
+void MMModemManager::deviceRemoved(const QDBusObjectPath & objpath)
+{
+    kDebug(1441);
+    Q_D(MMModemManager);
+    d->modemInterfaces.removeAll(objpath.path());
+    emit modemInterfaceRemoved(objpath.path());
+}
+
+void MMModemManager::stateChanged(Solid::Networking::Status state)
+{
+    Q_D(MMModemManager);
+    if ( d->mmState != state ) {
+        d->mmState = state;
+        emit statusChanged( state );
+    }
+}
+
+void MMModemManager::nameOwnerChanged(QString name, QString oldOwner, QString newOwner)
+{
+    Q_D(MMModemManager);
+
+    if ( name == QLatin1String("org.freedesktop.ModemManager") ) {
+        kDebug(1441) << "name: " << name << ", old owner: " << oldOwner << ", new owner: " << newOwner;
+        if ( oldOwner.isEmpty() && !newOwner.isEmpty() ) {
+            stateChanged(Solid::Networking::Connected);
+        }
+        if ( !oldOwner.isEmpty() && newOwner.isEmpty() ) {
+            // ModemManager stopped, set status Unknown for safety
+            stateChanged(Solid::Networking::Unknown);
+            d->modemInterfaces.clear();
+        }
+    }
+}
+
+#include "manager.moc"
+
Index: solid/modemmanager-0.4/modemlocationinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemlocationinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemlocationinterface.cpp	(revision 1145887)
@@ -0,0 +1,119 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemlocationinterface.h"
+#include "modemlocationinterface_p.h"
+
+#include <KDebug>
+
+MMModemLocationInterfacePrivate::MMModemLocationInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemLocationIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemLocationInterface::MMModemLocationInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemLocationInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(const MMModemLocationInterface);
+    d->modemLocationIface.connection().connect(MMModemManager::DBUS_SERVICE,
+        path, QLatin1String("org.freedesktop.DBus.Properties"),
+        QLatin1String("MmPropertiesChanged"), QLatin1String("sa{sv}"),
+        this, SLOT(propertiesChanged(const QString &,const QVariantMap &)));
+}
+
+MMModemLocationInterface::~MMModemLocationInterface()
+{
+}
+
+void MMModemLocationInterface::propertiesChanged(const QString & interface, const QVariantMap & properties)
+{
+    kDebug(1441) << interface << properties.keys();
+
+    if (interface == QString("org.freedesktop.ModemManager.Modem.Location")) {
+        QLatin1String capabilities("Capabilities");
+        QLatin1String enabled("Enabled");
+        QLatin1String signalsLocation("SignalsLocation");
+        QLatin1String location("Location");
+
+        QVariantMap::const_iterator it = properties.find(capabilities);
+        if ( it != properties.end()) {
+            emit capabilitiesChanged((Solid::Control::ModemLocationInterface::Capability)it->toInt());
+        }
+        it = properties.find(enabled);
+        if ( it != properties.end()) {
+            emit enabledChanged(it->toBool());
+        }
+        it = properties.find(signalsLocation);
+        if ( it != properties.end()) {
+            emit signalsLocationChanged(it->toBool());
+        }
+        it = properties.find(location);
+        if ( it != properties.end()) {
+            QVariant v = it.value();
+            LocationInformationMap map;
+            if (v.canConvert<LocationInformationMap>()) {
+                map = v.value<LocationInformationMap>();
+            } else {
+                kDebug(1441) << "Error converting LocationInformationMap property";
+            }
+            emit locationChanged(map);
+        }
+    }
+}
+
+void MMModemLocationInterface::enableLocation(const bool enable, const bool signalLocation)
+{
+    Q_D(MMModemLocationInterface);
+    d->modemLocationIface.Enable(enable, signalLocation);
+}
+
+Solid::Control::ModemLocationInterface::LocationInformationMap MMModemLocationInterface::getLocation()
+{
+    Q_D(MMModemLocationInterface);
+    QDBusReply<LocationInformationMap> location = d->modemLocationIface.GetLocation();
+
+    if (location.isValid()) {
+        return location.value();
+    }
+
+    return LocationInformationMap();
+}
+
+Solid::Control::ModemLocationInterface::Capability MMModemLocationInterface::getCapability() const
+{
+    Q_D(const MMModemLocationInterface);
+    return (Solid::Control::ModemLocationInterface::Capability) d->modemLocationIface.capabilities();
+}
+
+bool MMModemLocationInterface::enabled() const
+{
+    Q_D(const MMModemLocationInterface);
+    return d->modemLocationIface.enabled();
+}
+
+bool MMModemLocationInterface::signalsLocation() const
+{
+    Q_D(const MMModemLocationInterface);
+    return d->modemLocationIface.signalsLocation();
+}
+
+#include "modemlocationinterface.moc"
+
Index: solid/modemmanager-0.4/modemgsmsmsinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmsmsinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmsmsinterface.cpp	(revision 1145887)
@@ -0,0 +1,131 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmsmsinterface.h"
+#include "modemgsmsmsinterface_p.h"
+
+#include <KDebug>
+
+MMModemGsmSmsInterfacePrivate::MMModemGsmSmsInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmSmsIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmSmsInterface::MMModemGsmSmsInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmSmsInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(const MMModemGsmSmsInterface);
+    connect( &d->modemGsmSmsIface, SIGNAL(smsReceived(uint, bool)),
+                this, SIGNAL(smsReceived(int, bool)));
+    connect( &d->modemGsmSmsIface, SIGNAL(completed(uint, bool)),
+                this, SIGNAL(completed(int, bool)));
+}
+
+MMModemGsmSmsInterface::~MMModemGsmSmsInterface()
+{
+}
+
+void MMModemGsmSmsInterface::deleteSms(const int index)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.Delete(index);
+}
+
+QVariantMap MMModemGsmSmsInterface::get(const int index)
+{
+    Q_D(MMModemGsmSmsInterface);
+    QDBusReply<QVariantMap> sms = d->modemGsmSmsIface.Get(index);
+
+    if (sms.isValid()) {
+        return sms.value();
+    }
+
+    return QVariantMap();
+}
+
+int MMModemGsmSmsInterface::getFormat()
+{
+    Q_D(MMModemGsmSmsInterface);
+    QDBusReply<uint> format = d->modemGsmSmsIface.GetFormat();
+
+    if (format.isValid()) {
+        return format.value();
+    }
+
+    return 0;
+}
+
+void MMModemGsmSmsInterface::setFormat(const int format)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.SetFormat(format);
+}
+
+QString MMModemGsmSmsInterface::getSmsc()
+{
+    Q_D(MMModemGsmSmsInterface);
+    QDBusReply<QString> smsc = d->modemGsmSmsIface.GetSmsc();
+
+    if (smsc.isValid()) {
+        return smsc.value();
+    }
+
+    return QString();
+}
+
+QList<QVariantMap> MMModemGsmSmsInterface::list()
+{
+    Q_D(MMModemGsmSmsInterface);
+    QDBusReply<QList<QVariantMap> > sms = d->modemGsmSmsIface.List();
+
+    if (sms.isValid()) {
+        return sms.value();
+    }
+
+    return QList<QVariantMap>();
+}
+
+void MMModemGsmSmsInterface::save(const QVariantMap & properties)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.Save(properties);
+}
+
+void MMModemGsmSmsInterface::send(const QVariantMap & properties)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.Save(properties);
+}
+
+void MMModemGsmSmsInterface::sendFromStorage(const int index)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.SendFromStorage(index);
+}
+
+void MMModemGsmSmsInterface::setIndication(const int mode, const int mt, const int bm, const int ds, const int brf)
+{
+    Q_D(MMModemGsmSmsInterface);
+    d->modemGsmSmsIface.SetIndication(mode, mt, bm, ds, brf);
+}
+
+#include "modemgsmsmsinterface.moc"
+
Index: solid/modemmanager-0.4/modemgsmussdinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmussdinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmussdinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMUSSDINTERFACE_P_H
+#define MM04_MODEMGSMUSSDINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-ussdinterface.h"
+
+class MMModemGsmUssdInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmUssdInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmUssdInterface modemGsmUssdIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modeminterface.cpp
===================================================================
--- solid/modemmanager-0.4/modeminterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modeminterface.cpp	(revision 1145887)
@@ -0,0 +1,237 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <KDebug>
+
+#include "manager.h"
+#include "modeminterface.h"
+#include "modeminterface_p.h"
+
+MMModemInterfacePrivate::MMModemInterfacePrivate( const QString & path, QObject * owner ) : modemIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus()), modemSimpleIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus()), udi(path), manager(0)
+{
+    Q_UNUSED(owner);
+}
+
+MMModemInterface::MMModemInterface(const QString & path, MMModemManager * manager, QObject * parent) : QObject(parent), d_ptr(new MMModemInterfacePrivate(path, this))
+{
+    Q_D(MMModemInterface);
+    init();
+    d->manager = manager;
+}
+
+MMModemInterface::MMModemInterface(MMModemInterfacePrivate & dd, MMModemManager * manager, QObject * parent) : QObject(parent), d_ptr(&dd)
+{
+    Q_D(MMModemInterface);
+    init();
+    d->manager = manager;
+}
+
+MMModemInterface::~MMModemInterface()
+{
+    delete d_ptr;
+}
+
+void MMModemInterface::init()
+{
+    Q_D(MMModemInterface);
+    d->device = d->modemIface.device();
+    d->masterDevice = d->modemIface.masterDevice();
+    d->driver = d->modemIface.driver();
+    d->type = (Solid::Control::ModemInterface::Type) d->modemIface.type();
+    d->enabled = d->modemIface.enabled();
+    d->unlockRequired = d->modemIface.unlockRequired();
+    d->ipMethod = (Solid::Control::ModemInterface::Method) d->modemIface.ipMethod();
+
+    d->modemIface.connection().connect(MMModemManager::DBUS_SERVICE,
+                                       d->udi, QLatin1String("org.freedesktop.DBus.Properties"),
+                                       QLatin1String("MmPropertiesChanged"), QLatin1String("sa{sv}"),
+                                       this, SLOT(propertiesChanged(const QString &,const QVariantMap &)));
+}
+
+QString MMModemInterface::udi() const
+{
+    Q_D(const MMModemInterface);
+    return d->udi;
+}
+
+
+/*** From org.freedesktop.ModemManager.Modem ***/
+
+void MMModemInterface::enable(const bool enable)
+{
+    Q_D(MMModemInterface);
+    d->modemIface.Enable(enable);
+}
+
+void MMModemInterface::connectModem(const QString & number)
+{
+    Q_D(MMModemInterface);
+    d->modemIface.Connect(number);
+}
+
+void MMModemInterface::disconnectModem()
+{
+    Q_D(MMModemInterface);
+    d->modemIface.Disconnect();
+}
+
+Solid::Control::ModemInterface::Ip4ConfigType MMModemInterface::getIp4Config()
+{
+    Q_D(MMModemInterface);
+    QDBusReply<Ip4ConfigType> config = d->modemIface.GetIP4Config();
+
+    if (config.isValid()) {
+        return config.value();
+    }
+
+    return Ip4ConfigType();
+}
+
+Solid::Control::ModemInterface::InfoType MMModemInterface::getInfo()
+{
+    Q_D(MMModemInterface);
+    QDBusReply<InfoType> info = d->modemIface.GetInfo();
+
+    if (info.isValid()) {
+        return info.value();
+    }
+
+    return InfoType();
+}
+
+QString MMModemInterface::device() const
+{
+    Q_D(const MMModemInterface);
+    return d->device;
+}
+
+QString MMModemInterface::masterDevice() const
+{
+    Q_D(const MMModemInterface);
+    return d->masterDevice;
+}
+
+QString MMModemInterface::driver() const
+{
+    Q_D(const MMModemInterface);
+    return d->driver;
+}
+
+Solid::Control::ModemInterface::Type MMModemInterface::type() const
+{
+    Q_D(const MMModemInterface);
+    return d->type;
+}
+
+bool MMModemInterface::enabled() const
+{
+    Q_D(const MMModemInterface);
+    return d->enabled;
+}
+
+QString MMModemInterface::unlockRequired() const
+{
+    Q_D(const MMModemInterface);
+    return d->unlockRequired;
+}
+
+Solid::Control::ModemInterface::Method MMModemInterface::ipMethod() const
+{
+    Q_D(const MMModemInterface);
+    return d->ipMethod;
+}
+
+void MMModemInterface::propertiesChanged(const QString & interface, const QVariantMap & properties)
+{
+    Q_D(MMModemInterface);
+    kDebug(1441) << interface << properties.keys();
+
+    if (interface == QString("org.freedesktop.ModemManager.Modem")) {
+        QLatin1String device("Device");
+        QLatin1String masterDevice("MasterDevice");
+        QLatin1String driver("Driver");
+        QLatin1String type("Type");
+        QLatin1String enabled("Enabled");
+        QLatin1String unlockRequired("UnlockRequired");
+        QLatin1String ipMethod("IpMethod");
+
+        QVariantMap::const_iterator it = properties.find(device);
+        if ( it != properties.end()) {
+            d->device = it->toString();
+            emit deviceChanged(d->device);
+        }
+        it = properties.find(masterDevice);
+        if ( it != properties.end()) {
+            d->masterDevice = it->toString();
+            emit masterDeviceChanged(d->masterDevice);
+        }
+        it = properties.find(driver);
+        if ( it != properties.end()) {
+            d->driver = it->toString();
+            emit driverChanged(d->driver);
+        }
+        it = properties.find(type);
+        if ( it != properties.end()) {
+            d->type = (Solid::Control::ModemInterface::Type) it->toInt();
+            emit typeChanged(d->type);
+        }
+        it = properties.find(enabled);
+        if ( it != properties.end()) {
+            d->enabled = it->toBool();
+            emit enabledChanged(d->enabled);
+        }
+        it = properties.find(unlockRequired);
+        if ( it != properties.end()) {
+            d->unlockRequired = it->toString();
+            emit unlockRequiredChanged(d->unlockRequired);
+        }
+        it = properties.find(ipMethod);
+        if ( it != properties.end()) {
+            d->ipMethod = (Solid::Control::ModemInterface::Method) it->toInt();
+            emit ipMethodChanged(d->ipMethod);
+        }
+    }
+}
+
+
+/*** From org.freedesktop.ModemManager.Modem.Simple ***/
+
+void MMModemInterface::connectModem(const QVariantMap & properties)
+{
+    Q_D(MMModemInterface);
+    d->modemSimpleIface.Connect(properties);
+}
+
+QVariantMap MMModemInterface::getStatus()
+{
+    Q_D(MMModemInterface);
+
+    QDBusReply<QVariantMap> status = d->modemSimpleIface.GetStatus();
+
+    if (status.isValid()) {
+        return status.value();
+    }
+
+    return QVariantMap();
+}
+
+#include "modeminterface.moc"
+
Index: solid/modemmanager-0.4/modemgsmcardinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmcardinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcardinterface.cpp	(revision 1145887)
@@ -0,0 +1,128 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmcardinterface.h"
+#include "modemgsmcardinterface_p.h"
+
+#include <KDebug>
+
+MMModemGsmCardInterfacePrivate::MMModemGsmCardInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmCardIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmCardInterface::MMModemGsmCardInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmCardInterfacePrivate(path, this), manager, parent)
+{
+    Q_D(MMModemGsmCardInterface);
+
+    d->modemGsmCardIface.connection().connect(MMModemManager::DBUS_SERVICE,
+        path, QLatin1String("org.freedesktop.DBus.Properties"),
+        QLatin1String("MmPropertiesChanged"), QLatin1String("sa{sv}"),
+        this, SLOT(propertiesChanged(const QString &,const QVariantMap &)));
+}
+
+MMModemGsmCardInterface::~MMModemGsmCardInterface()
+{
+
+}
+
+void MMModemGsmCardInterface::propertiesChanged(const QString & interface, const QVariantMap & properties)
+{
+    kDebug(1441) << interface << properties.keys();
+
+    if (interface == QString("org.freedesktop.ModemManager.Modem.Gsm.Card")) {
+        QLatin1String supportedBands("SupportedBands");
+        QLatin1String supportedModes("SupportedModes");
+
+        QVariantMap::const_iterator it = properties.find(supportedBands);
+        if ( it != properties.end()) {
+            emit supportedBandsChanged((Solid::Control::ModemInterface::Band) it->toInt());
+        }
+        it = properties.find(supportedModes);
+        if ( it != properties.end()) {
+            emit supportedModesChanged((Solid::Control::ModemInterface::Mode) it->toInt());
+        }
+    }
+}
+
+QString MMModemGsmCardInterface::getImei()
+{
+    Q_D(MMModemGsmCardInterface);
+    QDBusReply<QString> imei = d->modemGsmCardIface.GetImei();
+
+    if (imei.isValid()) {
+        return imei.value();
+    }
+
+    return QString();
+}
+
+QString MMModemGsmCardInterface::getImsi()
+{
+    Q_D(MMModemGsmCardInterface);
+    QDBusReply<QString> imsi = d->modemGsmCardIface.GetImsi();
+
+    if (imsi.isValid()) {
+        return imsi.value();
+    }
+
+    return QString();
+}
+
+void MMModemGsmCardInterface::sendPuk(const QString & puk, const QString & pin)
+{
+    Q_D(MMModemGsmCardInterface);
+    d->modemGsmCardIface.SendPuk(puk, pin);
+}
+
+void MMModemGsmCardInterface::sendPin(const QString & pin)
+{
+    Q_D(MMModemGsmCardInterface);
+    d->modemGsmCardIface.SendPin(pin);
+}
+
+void MMModemGsmCardInterface::enablePin(const QString & pin, const bool enabled)
+{
+    Q_D(MMModemGsmCardInterface);
+    d->modemGsmCardIface.EnablePin(pin, enabled);
+}
+
+void MMModemGsmCardInterface::changePin(const QString & oldPin, const QString & newPin)
+{
+    Q_D(MMModemGsmCardInterface);
+    d->modemGsmCardIface.ChangePin(oldPin, newPin);
+}
+
+Solid::Control::ModemInterface::Band MMModemGsmCardInterface::getSupportedBands() const
+{
+    Q_D(const MMModemGsmCardInterface);
+    return (Solid::Control::ModemInterface::Band) d->modemGsmCardIface.supportedBands();
+}
+
+Solid::Control::ModemInterface::Mode MMModemGsmCardInterface::getSupportedModes() const
+{
+    Q_D(const MMModemGsmCardInterface);
+    return (Solid::Control::ModemInterface::Mode) d->modemGsmCardIface.supportedModes();
+}
+
+#include "modemgsmcardinterface.moc"
+
Index: solid/modemmanager-0.4/modemgsmnetworkinterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemgsmnetworkinterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmnetworkinterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMNETWORKINTERFACE_P_H
+#define MM04_MODEMGSMNETWORKINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-gsm-networkinterface.h"
+
+class MMModemGsmNetworkInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemGsmNetworkInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemGsmNetworkInterface modemGsmNetworkIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmcontactsinterface.cpp
===================================================================
--- solid/modemmanager-0.4/modemgsmcontactsinterface.cpp	(revision 0)
+++ solid/modemmanager-0.4/modemgsmcontactsinterface.cpp	(revision 1145887)
@@ -0,0 +1,107 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "manager.h"
+#include "modemgsmcontactsinterface.h"
+#include "modemgsmcontactsinterface_p.h"
+
+#include <KDebug>
+
+MMModemGsmContactsInterfacePrivate::MMModemGsmContactsInterfacePrivate(const QString &path, QObject *owner)
+    : MMModemInterfacePrivate(path, owner), modemGsmContactsIface(MMModemManager::DBUS_SERVICE, path, QDBusConnection::systemBus())
+{
+}
+
+MMModemGsmContactsInterface::MMModemGsmContactsInterface(const QString & path, MMModemManager * manager, QObject * parent)
+    : MMModemInterface(*new MMModemGsmContactsInterfacePrivate(path, this), manager, parent)
+{
+}
+
+MMModemGsmContactsInterface::~MMModemGsmContactsInterface()
+{
+}
+
+int MMModemGsmContactsInterface::addContact(const QString & name, const QString & number)
+{
+    Q_D(MMModemGsmContactsInterface);
+    QDBusReply<uint> index = d->modemGsmContactsIface.Add(name, number);
+
+    if (index.isValid()) {
+        return index.value();
+    }
+    return -1;
+}
+
+void MMModemGsmContactsInterface::deleteContact(const int index)
+{
+    Q_D(MMModemGsmContactsInterface);
+    d->modemGsmContactsIface.Delete(index);
+}
+
+ContactType MMModemGsmContactsInterface::get(const int index)
+{
+    Q_D(MMModemGsmContactsInterface);
+    QDBusReply<ContactType> contact = d->modemGsmContactsIface.Get(index);
+
+    if (contact.isValid()) {
+        return contact.value();
+    }
+
+    return ContactType();
+}
+
+Solid::Control::ModemGsmContactsInterface::ContactTypeList MMModemGsmContactsInterface::list()
+{
+    Q_D(MMModemGsmContactsInterface);
+    QDBusReply<ContactTypeList> contacts = d->modemGsmContactsIface.List();
+
+    if (contacts.isValid()) {
+        return contacts.value();
+    }
+
+    return ContactTypeList();
+}
+
+Solid::Control::ModemGsmContactsInterface::ContactTypeList MMModemGsmContactsInterface::find(const QString & pattern)
+{
+    Q_D(MMModemGsmContactsInterface);
+    QDBusReply<ContactTypeList > contacts = d->modemGsmContactsIface.Find(pattern);
+
+    if (contacts.isValid()) {
+        return contacts.value();
+    }
+
+    return ContactTypeList();
+}
+
+int MMModemGsmContactsInterface::getCount()
+{
+    Q_D(MMModemGsmContactsInterface);
+    QDBusReply<uint> count = d->modemGsmContactsIface.GetCount();
+
+    if (count.isValid()) {
+        return count.value();
+    }
+
+    return 0;
+}
+
+#include "modemgsmcontactsinterface.moc"
+
Index: solid/modemmanager-0.4/modemcdmainterface_p.h
===================================================================
--- solid/modemmanager-0.4/modemcdmainterface_p.h	(revision 0)
+++ solid/modemmanager-0.4/modemcdmainterface_p.h	(revision 1145887)
@@ -0,0 +1,36 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMCDMAINTERFACE_P_H
+#define MM04_MODEMCDMAINTERFACE_P_H
+
+#include "modeminterface_p.h"
+#include "dbus/mm-modem-cdmainterface.h"
+
+class MMModemCdmaInterfacePrivate: public MMModemInterfacePrivate
+{
+public:
+    MMModemCdmaInterfacePrivate(const QString &path, QObject *owner);
+    OrgFreedesktopModemManagerModemCdmaInterface modemCdmaIface;
+};
+
+#endif
+
Index: solid/modemmanager-0.4/modemgsmussdinterface.h
===================================================================
--- solid/modemmanager-0.4/modemgsmussdinterface.h	(revision 0)
+++ solid/modemmanager-0.4/modemgsmussdinterface.h	(revision 1145887)
@@ -0,0 +1,58 @@
+/*
+Copyright 2008 Will Stephenson <wstephenson@kde.org>
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License or (at your option) version 3 or any later version
+accepted by the membership of KDE e.V. (or its successor approved
+by the membership of KDE e.V.), which shall act as a proxy
+defined in Section 14 of version 3 of the license.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef MM04_MODEMGSMUSSDINTERFACE_H
+#define MM04_MODEMGSMUSSDINTERFACE_H
+
+#include "modeminterface.h"
+#include "solid/control/ifaces/modemgsmussdinterface.h"
+#include "dbus/generic-types.h"
+
+class MMModemGsmUssdInterfacePrivate;
+
+class KDE_EXPORT MMModemGsmUssdInterface : public MMModemInterface, virtual public Solid::Control::Ifaces::ModemGsmUssdInterface
+{
+Q_OBJECT
+Q_DECLARE_PRIVATE(MMModemGsmUssdInterface)
+Q_INTERFACES(Solid::Control::Ifaces::ModemGsmUssdInterface)
+
+public:
+    MMModemGsmUssdInterface(const QString & path, MMModemManager * manager, QObject * parent);
+    ~MMModemGsmUssdInterface();
+
+    QString initiate(const QString & command);
+    void respond(const QString response);
+    void cancel();
+    // properties
+    QString getState();
+    QString getNetworkNotification();
+    QString getNetworkRequest();
+public Q_SLOTS:
+    void propertiesChanged(const QString & interface, const QVariantMap & properties);
+Q_SIGNALS:
+    // properties
+    void stateChanged(const QString & state);
+    void networkNotificationChanged(const QString & networkNotification);
+    void networkRequestChanged(const QString & networkRequest);
+};
+
+#endif
+
Index: solid/CMakeLists.txt
===================================================================
--- solid/CMakeLists.txt	(revision 1145886)
+++ solid/CMakeLists.txt	(revision 1145887)
@@ -34,6 +34,10 @@
 endif (NETWORKMANAGER_FOUND)
 macro_log_feature(HAVE_NETWORKMANAGER "NetworkManager" "A daemon for user controlled networking" "http://www.gnome.org/projects/NetworkManager" FALSE "0.6.5" "Needed for building Network Management support in Solid.")
 
+message(STATUS "Will build modemmanager-0.4")
+set(HAVE_MODEMMANAGER TRUE)
+add_subdirectory(modemmanager-0.4)
+
 if(NOT WIN32)
   macro_optional_add_subdirectory(wicd)
   add_subdirectory(lirc)
Index: libs/solid/control/modemlocationinterface_p.h
===================================================================
--- libs/solid/control/modemlocationinterface_p.h	(revision 0)
+++ libs/solid/control/modemlocationinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMLOCATIONINTERFACE_P_H
+#define SOLID_CONTROL_MODEMLOCATIONINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemLocationInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemLocationInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMLOCATIONINTERFACE_P_H
Index: libs/solid/control/modemmanagerinterface.cpp
===================================================================
--- libs/solid/control/modemmanagerinterface.cpp	(revision 0)
+++ libs/solid/control/modemmanagerinterface.cpp	(revision 1145887)
@@ -0,0 +1,69 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "modemmanagerinterface.h"
+#include "modemmanagerinterface_p.h"
+
+#include "soliddefs_p.h"
+#include "ifaces/modemmanagerinterface.h"
+
+Solid::Control::ModemManagerInterface::ModemManagerInterface(QObject *backendObject)
+    : QObject(), d_ptr(new ModemManagerInterfacePrivate(this))
+{
+    Q_D(ModemManagerInterface); d->setBackendObject(backendObject);
+}
+
+Solid::Control::ModemManagerInterface::ModemManagerInterface(const ModemManagerInterface &other)
+    : QObject(), d_ptr(new ModemManagerInterfacePrivate(this))
+{
+    Q_D(ModemManagerInterface);
+    d->setBackendObject(other.d_ptr->backendObject());
+}
+
+Solid::Control::ModemManagerInterface::ModemManagerInterface(ModemManagerInterfacePrivate &dd, QObject *backendObject)
+    : QObject(), d_ptr(&dd)
+{
+    Q_UNUSED(backendObject);
+}
+
+Solid::Control::ModemManagerInterface::ModemManagerInterface(ModemManagerInterfacePrivate &dd, const ModemManagerInterface &other)
+    : d_ptr(&dd)
+{
+    Q_UNUSED(other);
+}
+
+Solid::Control::ModemManagerInterface::~ModemManagerInterface()
+{
+    delete d_ptr;
+}
+
+void Solid::Control::ModemManagerInterfacePrivate::setBackendObject(QObject *object)
+{
+    FrontendObjectPrivate::setBackendObject(object);
+
+    if (object) {
+        QObject::connect(object, SIGNAL(connectionStateChanged(int)),
+                         parent(), SIGNAL(connectionStateChanged(int)));
+        QObject::connect(object, SIGNAL(connectionStateChanged(int,int,int)),
+                         parent(), SIGNAL(connectionStateChanged(int,int,int)));
+    }
+}
+
+
+#include "modemmanagerinterface.moc"
Index: libs/solid/control/networkinterface.h
===================================================================
--- libs/solid/control/networkinterface.h	(revision 1145886)
+++ libs/solid/control/networkinterface.h	(revision 1145887)
@@ -130,6 +130,14 @@
         QString uni() const;
 
         /**
+         * Retrieves the Unique Device Identifier (UDI).
+         * This is needed for ModemManager support.
+         *
+         * @returns the Unique Device Identifier of the current device
+         */
+        QString udi() const;
+
+        /**
          * The system name for the network interface
          */
         QString interfaceName() const;
Index: libs/solid/control/modemlocationinterface.h
===================================================================
--- libs/solid/control/modemlocationinterface.h	(revision 0)
+++ libs/solid/control/modemlocationinterface.h	(revision 1145887)
@@ -0,0 +1,92 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMLOCATIONINTERFACE_H
+#define SOLID_CONTROL_MODEMLOCATIONINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemLocationInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemLocationInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_ENUMS(Capability)
+        Q_DECLARE_PRIVATE(ModemLocationInterface)
+
+    public:
+
+        enum Capability { Unknown = 0x0, GpsNmea = 0x1, GpsLacCi = 0x2 };
+
+        typedef QList<QMap<Capability, QVariant> > LocationInformationMap;
+
+        ModemLocationInterface(QObject *backendObject = 0);
+
+        ModemLocationInterface(const ModemLocationInterface &locationIface);
+
+        virtual ~ModemLocationInterface();
+
+        void enableLocation(const bool enable, const bool signalLocation) const;
+
+        LocationInformationMap getLocation() const;
+
+        Solid::Control::ModemLocationInterface::Capability getCapability() const;
+
+        bool enabled() const;
+
+        bool signalsLocation() const;
+
+    Q_SIGNALS:
+        void capabilitiesChanged(const Solid::Control::ModemLocationInterface::Capability capability);
+
+        void enabledChanged(const bool enabled);
+
+        void signalsLocationChanged(const bool signalsLocation);
+
+        void locationChanged(const LocationInformationMap & location);
+
+    protected Q_SLOTS:
+       void slotLocationChanged(const LocationInformationMap & location);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemLocationInterface(ModemLocationInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemLocationInterface(ModemLocationInterfacePrivate &dd, const ModemLocationInterface &locationinterface);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmsmsinterface.h
===================================================================
--- libs/solid/control/modemgsmsmsinterface.h	(revision 0)
+++ libs/solid/control/modemgsmsmsinterface.h	(revision 1145887)
@@ -0,0 +1,90 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMSMSINTERFACE_H
+#define SOLID_CONTROL_MODEMGSMSMSINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmSmsInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmSmsInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmSmsInterface)
+
+    public:
+
+        ModemGsmSmsInterface(QObject *backendObject = 0);
+
+        ModemGsmSmsInterface(const ModemGsmSmsInterface &smsIface);
+
+        virtual ~ModemGsmSmsInterface();
+
+        void deleteSms(const int index) const;
+
+        QVariantMap get(const int index) const;
+
+        int getFormat() const;
+
+        void setFormat(const int format) const;
+
+        QString getSmsc() const;
+
+        QList<QVariantMap> list() const;
+
+        void save(const QVariantMap & properties) const;
+
+        void send(const QVariantMap & properties) const;
+
+        void sendFromStorage(const int index) const;
+
+        void setIndication(const int mode, const int mt, const int bm, const int ds, const int brf) const;
+
+    Q_SIGNALS:
+        void smsReceived(int index, bool complete);
+
+        void completed(int index, bool completed);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmSmsInterface(ModemGsmSmsInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmSmsInterface(ModemGsmSmsInterfacePrivate &dd, const ModemGsmSmsInterface &smsinterface);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmhsointerface_p.h
===================================================================
--- libs/solid/control/modemgsmhsointerface_p.h	(revision 0)
+++ libs/solid/control/modemgsmhsointerface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGHSOMSINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGHSOMSINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmHsoInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmHsoInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGHSOMSINTERFACE_P_H
Index: libs/solid/control/modeminterface.h
===================================================================
--- libs/solid/control/modeminterface.h	(revision 0)
+++ libs/solid/control/modeminterface.h	(revision 1145887)
@@ -0,0 +1,255 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMINTERFACE_H
+#define SOLID_CONTROL_MODEMINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QVariant>
+
+#include <solid/networking.h>
+#include "solid_control_export.h"
+#include "networkipv4config.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemInterface: public QObject
+    {
+    Q_OBJECT
+    Q_ENUMS(Type Method AllowedMode AccessTechnology Mode Band)
+    Q_DECLARE_PRIVATE(ModemInterface)
+
+    public:
+        enum Type {
+            UnknownType = 0, /* MM specification does not include this type though. */
+            GsmType = 1,
+            CdmaType = 2,
+        };
+
+        enum Method {
+            Ppp = 0, /* Use PPP to get the address. */
+            Static = 1, /* Static configuration, the modem will provide IP information. */
+            Dhcp = 2, /*Use DHCP */
+            UnknownMethod = 0xff,
+        };
+
+        /* Describes the device's current access mode preference;
+         * ie the specific technology preferences the device is allowed to use
+         * when connecting to a mobile network. */
+        enum AllowedMode {
+             AnyModeAllowed = 0x0, /* Any mode can be used */
+             Prefer2g, /* Prefer 2G (GPRS or EDGE) */
+             Prefer3g, /* Prefer 3G (UMTS or HSxPA) */
+             UseOnly2g, /* Use only 2G (GPRS or EDGE) */
+             UseOnly3g, /* Use only 3G (UMTS or HSxPA) */
+        };
+
+        /* Describes various access technologies that a device uses when connected to a mobile network. */
+        enum AccessTechnology {
+            UnknownTechnology = 0x0, /* The access technology used is unknown */
+            Gsm, /* GSM */
+            GsmCompact, /* Compact GSM */
+            Gprs, /* GPRS */
+            Edge, /* EDGE (ETSI 27.007: "GSM w/EGPRS") */
+            Umts, /* UMTS (ETSI 27.007: "UTRAN") */
+            Hsdpa, /* HSDPA (ETSI 27.007: "UTRAN w/HSDPA") */
+            Hsupa, /* HSUPA (ETSI 27.007: "UTRAN w/HSUPA") */
+            Hspa, /* HSPA (ETSI 27.007: "UTRAN w/HSDPA and HSUPA") */
+        };
+
+        /* A bitfield describing the specifc access modes and technologies supported by a device
+         * and the access technology in-use when connected to a mobile network. */
+        enum Mode {
+            UnknownMode = 0x0, /* Unknown or invalid mode. */
+            AnyMode = 0x1, /* For certain operations, allow the modem to pick any available mode. */
+            GprsMode = 0x2, /* GPRS */
+            EdgeMode = 0x4, /* EDGE */
+            UmtsMode = 0x8, /* UMTS (3G) */
+            HsdpaMode = 0x10, /* HSDPA (3G) */
+            Prefer2gMode = 0x20, /* Prefer 2G (GPRS or EDGE) */
+            Prefer3gMode = 0x40, /* Prefer 3G (UMTS/HSDPA/HSUPA/HSPA) */
+            UseOnly2gMode = 0x80, /* Use only 2G (GPRS or EDGE) */
+            UseOnly3gMode = 0x100, /* Use only 3G (UMTS/HSDPA/HSUPA/HSPA) */
+            HsupaMode = 0x200, /* HSUPA (3G) */
+            HspaMode = 0x400, /* HSPA (3G) */
+            GsmMode = 0x800, /* GSM */
+            GsmCompactMode = 0x1000, /* GSM Compact */
+        };
+
+        /* A bitfield describing the specific radio bands supported by the device
+         * and the radio bands the device is allowed to use when connecting to a mobile network. */
+        enum Band {
+            UnknownBand = 0x0, /* Unknown or invalid band */
+            AnyBand = 0x1, /* For certain operations allow the modem to select a band automatically. */
+            Egsm = 0x2, /* GSM/GPRS/EDGE 900 MHz */
+            Dcs = 0x4, /* GSM/GPRS/EDGE 1800 MHz */
+            Pcs = 0x8, /* GSM/GPRS/EDGE 1900 MHz */
+            G850 = 0x10, /* GSM/GPRS/EDGE 850 MHz */
+            U2100 = 0x20, /* WCDMA 2100 MHz (Class I) */
+            U1800 = 0x40, /* WCDMA 3GPP 1800 MHz (Class III) */
+            U17IV = 0x80, /* WCDMA 3GPP AWS 1700/2100 MHz (Class IV) */
+            U800 = 0x100, /* WCDMA 3GPP UMTS 800 MHz (Class VI) */
+            U850 = 0x200, /* WCDMA 3GPP UMTS 850 MHz (Class V) */
+            U900 = 0x400, /* WCDMA 3GPP UMTS 900 MHz (Class VIII) */
+            U17IX = 0x800, /* WCDMA 3GPP UMTS 1700 MHz (Class IX) */
+            U19IX = 0x1000, /* WCDMA 3GPP UMTS 1900 MHz (Class II) */
+        };
+
+        enum GsmInterfaceType {
+            NotGsm,
+            GsmCard,
+            GsmContacts,
+            GsmNetwork,
+            GsmSms,
+            GsmHso,
+            GsmUssd,
+        };
+
+        class Ip4ConfigType
+        {
+        public:
+            QString ip4Address,
+                    dns1,
+                    dns2,
+                    dns3;
+        };
+
+        class InfoType
+        {
+        public:
+            QString manufacturer,
+                    model,
+                    version;
+        };
+
+        /**
+         * Creates a new ModemInterface object.
+         *
+         * @param backendObject the modem object provided by the backend
+         */
+        explicit ModemInterface(QObject *backendObject);
+
+        /**
+         * Constructs a copy of a modem.
+         *
+         * @param modem the modem to copy
+         */
+        ModemInterface(const ModemInterface &modem);
+
+        /**
+         * Destroys a ModemInterface object.
+         */
+        virtual ~ModemInterface();
+
+        QString udi() const;
+
+        void enable(const bool enable) const;
+
+        void connectModem(const QString & number) const;
+
+        void connectModem(const QVariantMap & properties) const;
+
+        void disconnectModem() const;
+
+        Ip4ConfigType getIp4Config() const;
+
+        InfoType getInfo() const;
+
+        QVariantMap getStatus() const;
+
+        /*
+         * Properties
+         */
+        QString device() const;
+
+        QString masterDevice() const;
+
+        QString driver() const;
+
+        Type type() const;
+
+        bool enabled() const;
+
+        QString unlockRequired() const;
+
+        Method ipMethod() const;
+
+        static QString convertTypeToString(const Type type);
+
+        /**
+         * Return a description of the band id.
+         *
+         * @param band the band id
+         */
+        static QString convertBandToString(const Band band);
+
+        static QString convertAllowedModeToString(const AllowedMode mode);
+
+        /**
+         * Return a description of the access technology used.
+         *
+         * @param tech the access technology.
+         */
+        static QString convertAccessTechnologyToString(const AccessTechnology tech);
+
+    public Q_SLOTS:
+        void slotDeviceChanged(const QString & device);
+
+        void slotMasterDeviceChanged(const QString & masterDevice);
+
+        void slotDriverChanged(const QString & driver);
+
+        void slotUnlockRequiredChanged(const QString & codeRequired);
+    Q_SIGNALS:
+        void deviceChanged(const QString & device);
+
+        void masterDeviceChanged(const QString & masterDevice);
+
+        void driverChanged(const QString & driver);
+
+        void typeChanged(const Solid::Control::ModemInterface::Type type);
+
+        void enabledChanged(const bool enabled);
+
+        void unlockRequiredChanged(const QString & codeRequired);
+
+        void ipMethodChanged(const Solid::Control::ModemInterface::Method ipMethod);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemInterface(ModemInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemInterface(ModemInterfacePrivate &dd, const ModemInterface &modem);
+
+        ModemInterfacePrivate *d_ptr;
+    };
+
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmussdinterface.cpp
===================================================================
--- libs/solid/control/modemgsmussdinterface.cpp	(revision 0)
+++ libs/solid/control/modemgsmussdinterface.cpp	(revision 1145887)
@@ -0,0 +1,120 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+
+#include "modemgsmussdinterface.h"
+#include "modemgsmussdinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmussdinterface.h"
+
+Solid::Control::ModemGsmUssdInterface::ModemGsmUssdInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmUssdInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmUssdInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmUssdInterface::ModemGsmUssdInterface(const ModemGsmUssdInterface &ussdinterface)
+    : ModemInterface(*new ModemGsmUssdInterfacePrivate(this), ussdinterface)
+{
+    Q_D(ModemGsmUssdInterface);
+    d->setBackendObject(ussdinterface.d_ptr->backendObject());
+    makeConnections(ussdinterface.d_ptr->backendObject());
+}
+
+Solid::Control::ModemGsmUssdInterface::~ModemGsmUssdInterface()
+{
+}
+
+QString Solid::Control::ModemGsmUssdInterface::initiate(const QString & command) const
+{
+    Q_D(const ModemGsmUssdInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), QString(), initiate(command));
+}
+
+void Solid::Control::ModemGsmUssdInterface::respond(const QString response) const
+{
+    Q_D(const ModemGsmUssdInterface);
+    SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), respond(response));
+}
+
+void Solid::Control::ModemGsmUssdInterface::cancel() const
+{
+    Q_D(const ModemGsmUssdInterface);
+    SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), cancel());
+}
+
+QString Solid::Control::ModemGsmUssdInterface::getState() const
+{
+    Q_D(const ModemGsmUssdInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), QString(), getState());
+}
+
+QString Solid::Control::ModemGsmUssdInterface::getNetworkNotification() const
+{
+    Q_D(const ModemGsmUssdInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), QString(), getNetworkNotification());
+}
+
+QString Solid::Control::ModemGsmUssdInterface::getNetworkRequest() const
+{
+    Q_D(const ModemGsmUssdInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmUssdInterface *, d->backendObject(), QString(), getNetworkRequest());
+}
+
+void Solid::Control::ModemGsmUssdInterface::slotStateChanged(const QString & state)
+{
+    emit stateChanged(state);
+}
+
+void Solid::Control::ModemGsmUssdInterface::slotNetworkNotificationChanged(const QString & networkNotification)
+{
+    emit networkNotificationChanged(networkNotification);
+}
+
+void Solid::Control::ModemGsmUssdInterface::slotNetworkRequestChanged(const QString & networkRequest)
+{
+    emit networkRequestChanged(networkRequest);
+}
+
+void Solid::Control::ModemGsmUssdInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(stateChanged(const QString &)),
+                this, SLOT(slotStateChanged(const QString &)));
+        QObject::connect(source, SIGNAL(networkNotificationChanged(const QString &)),
+                this, SLOT(slotNetworkNotificationChanged(const QString &)));
+        QObject::connect(source, SIGNAL(networkRequestChanged(const QString &)),
+                this, SLOT(slotNetworkRequestChanged(const QString &)));
+    }
+}
+
+void Solid::Control::ModemGsmUssdInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmUssdInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/modemgsmcontactsinterface.h
===================================================================
--- libs/solid/control/modemgsmcontactsinterface.h	(revision 0)
+++ libs/solid/control/modemgsmcontactsinterface.h	(revision 1145887)
@@ -0,0 +1,89 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMCONTACTSINTERFACE_H
+#define SOLID_CONTROL_MODEMGSMCONTACTSINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmContactsInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmContactsInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmContactsInterface)
+
+    public:
+
+        class ContactType
+        {
+        public:
+            int index;
+            QString name,
+                    number;
+        };
+
+        typedef QList <Solid::Control::ModemGsmContactsInterface::ContactType> ContactTypeList;
+
+        ModemGsmContactsInterface(QObject *backendObject = 0);
+
+        ModemGsmContactsInterface(const ModemGsmContactsInterface &contactsIface);
+
+        virtual ~ModemGsmContactsInterface();
+
+        int addContact(const QString & name, const QString & number) const;
+
+        void deleteContact(const int index) const;
+
+        ContactType get(const int index) const;
+
+        QList<ContactType> list() const;
+
+        QList<ContactType> find(const QString & pattern) const;
+
+        int getCount() const;
+
+    Q_SIGNALS:
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmContactsInterface(ModemGsmContactsInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmContactsInterface(ModemGsmContactsInterfacePrivate &dd, const ModemGsmContactsInterface &contactsIface);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemmanager.h
===================================================================
--- libs/solid/control/modemmanager.h	(revision 0)
+++ libs/solid/control/modemmanager.h	(revision 1145887)
@@ -0,0 +1,112 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMMANAGER
+#define SOLID_CONTROL_MODEMMANAGER
+
+#include <QtCore/QObject>
+#include <QtCore/QVariant>
+
+#include <solid/networking.h>
+#include "solid_control_export.h"
+#include "modemmanagerinterface.h"
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    namespace Ifaces
+    {
+        class ModemManager;
+    }
+    class Network;
+    typedef QList<ModemInterface*> ModemInterfaceList;
+
+    /**
+     * This class allow to query the underlying system to discover the available
+     * modem interfaces and reachable network. It has also the
+     * responsibility to notify when a modem interface or a modem appear or disappear.
+     *
+     * Note that it's implemented as a singleton and encapsulates the backend logic.
+     */
+    namespace ModemManager
+    {
+        /**
+         * Get the manager connection state
+         */
+        SOLIDCONTROL_EXPORT Solid::Networking::Status status();
+
+        /**
+         * Retrieves the list of all modem interfaces Unique Device Identifiers (UDIs)
+         * in the system. This method is the equivalent of enumerateDevices described
+         * in Modem Manager specification.
+         * @return the list of modem interfaces available in this system
+         */
+        SOLIDCONTROL_EXPORT ModemInterfaceList modemInterfaces();
+
+        /**
+         * Find a new ModemManagerInterface object given its UDNI.  This pointer is owned by the Solid
+         * infrastructure.
+         *
+         * @param udi the identifier of the modem interface to find
+         * @returns a valid ModemManagerInterface object if there's a device having the given UDI, an invalid one otherwise
+         */
+        SOLIDCONTROL_EXPORT ModemInterface * findModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType);
+
+        /**
+         * Retrieves the interface types supported by this modem manager.
+         *
+         * @return the interface types supported by the modem manager
+         *
+         * @since 4.5
+         */
+        SOLIDCONTROL_EXPORT Solid::Control::ModemInterface::Type supportedInterfaceTypes();
+
+        class SOLIDCONTROL_EXPORT Notifier : public QObject
+        {
+            Q_OBJECT
+        Q_SIGNALS:
+            /**
+             * This signal is emitted when the system's connection state changes
+             */
+            void statusChanged(Solid::Networking::Status status);
+
+            /**
+             * This signal is emitted when a new modem interface is available.
+             *
+             * @param udi the network interface identifier
+             */
+            void modemInterfaceAdded(const QString &udi);
+
+            /**
+             * This signal is emitted when a network interface is not available anymore.
+             *
+             * @param udi the network interface identifier
+             */
+            void modemInterfaceRemoved(const QString &udi);
+        };
+
+        SOLIDCONTROL_EXPORT Notifier *notifier();
+    }
+
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmhsointerface.h
===================================================================
--- libs/solid/control/modemgsmhsointerface.h	(revision 0)
+++ libs/solid/control/modemgsmhsointerface.h	(revision 1145887)
@@ -0,0 +1,67 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGHSOMSINTERFACE_H
+#define SOLID_CONTROL_MODEMGHSOMSINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmHsoInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmHsoInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmHsoInterface)
+
+    public:
+
+        ModemGsmHsoInterface(QObject *backendObject = 0);
+
+        ModemGsmHsoInterface(const ModemGsmHsoInterface &hsoIface);
+
+        virtual ~ModemGsmHsoInterface();
+
+        void authenticate(const QString & username, const QString & password) const;
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmHsoInterface(ModemGsmHsoInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmHsoInterface(ModemGsmHsoInterfacePrivate &dd, const ModemGsmHsoInterface &hsointerface);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemlocationinterface.cpp
===================================================================
--- libs/solid/control/modemlocationinterface.cpp	(revision 0)
+++ libs/solid/control/modemlocationinterface.cpp	(revision 1145887)
@@ -0,0 +1,77 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+#include <KLocale>
+
+#include "modemlocationinterface.h"
+#include "modemlocationinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemlocationinterface.h"
+
+Solid::Control::ModemLocationInterface::ModemLocationInterface(QObject *backendObject)
+    : ModemInterface(*new ModemLocationInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemLocationInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemLocationInterface::ModemLocationInterface(const ModemLocationInterface &locationinterface)
+    : ModemInterface(*new ModemLocationInterfacePrivate(this), locationinterface)
+{
+    Q_D(ModemLocationInterface);
+    d->setBackendObject(locationinterface.d_ptr->backendObject());
+    makeConnections( locationinterface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemLocationInterface::~ModemLocationInterface()
+{
+}
+
+void Solid::Control::ModemLocationInterface::slotLocationChanged(const LocationInformationMap & location)
+{
+    emit locationChanged(location);
+}
+
+void Solid::Control::ModemLocationInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(capabilitiesChanged(const Solid::Control::ModemLocationInterface::Capability)),
+                this, SIGNAL(capabilitiesChanged(const Solid::Control::ModemLocationInterface::Capability)));
+        QObject::connect(source, SIGNAL(enabledChanged(const bool)),
+                this, SIGNAL(enabledChanged(const bool)));
+        QObject::connect(source, SIGNAL(signalsLocationChanged(const bool)),
+                this, SIGNAL(signalsLocationChanged(const bool)));
+        QObject::connect(source, SIGNAL(locationChanged(const LocationInformationMap &)),
+                this, SIGNAL(slotLocationChanged(const LocationInformationMap &)));
+    }
+}
+
+void Solid::Control::ModemLocationInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemLocationInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/modemgsmnetworkinterface_p.h
===================================================================
--- libs/solid/control/modemgsmnetworkinterface_p.h	(revision 0)
+++ libs/solid/control/modemgsmnetworkinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMNETWORKINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGSMNETWORKINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmNetworkInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmNetworkInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGSMNETWORKINTERFACE_P_H
Index: libs/solid/control/modemcdmainterface_p.h
===================================================================
--- libs/solid/control/modemcdmainterface_p.h	(revision 0)
+++ libs/solid/control/modemcdmainterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMCDMAINTERFACE_P_H
+#define SOLID_CONTROL_MODEMCDMAINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemCdmaInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemCdmaInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMCDMAINTERFACE_P_H
Index: libs/solid/control/modemgsmussdinterface.h
===================================================================
--- libs/solid/control/modemgsmussdinterface.h	(revision 0)
+++ libs/solid/control/modemgsmussdinterface.h	(revision 1145887)
@@ -0,0 +1,91 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMUSSDINTERFACE_H
+#define SOLID_CONTROL_MODEMGSMUSSDINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmUssdInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmUssdInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmUssdInterface)
+
+    public:
+
+        ModemGsmUssdInterface(QObject *backendObject = 0);
+
+        ModemGsmUssdInterface(const ModemGsmUssdInterface &ussd);
+
+        virtual ~ModemGsmUssdInterface();
+
+        QString initiate(const QString & command) const;
+
+        void respond(const QString response) const;
+
+        void cancel() const;
+
+        QString getState() const;
+
+        QString getNetworkNotification() const;
+
+        QString getNetworkRequest() const;
+
+    Q_SIGNALS:
+        void stateChanged(const QString & state);
+
+        void networkNotificationChanged(const QString & networkNotification);
+
+        void networkRequestChanged(const QString & networkRequest);
+
+    protected Q_SLOTS:
+        void slotStateChanged(const QString & state);
+
+        void slotNetworkNotificationChanged(const QString & networkNotification);
+
+        void slotNetworkRequestChanged(const QString & networkRequest);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmUssdInterface(ModemGsmUssdInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmUssdInterface(ModemGsmUssdInterfacePrivate &dd, const ModemGsmUssdInterface &ussd);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmsmsinterface_p.h
===================================================================
--- libs/solid/control/modemgsmsmsinterface_p.h	(revision 0)
+++ libs/solid/control/modemgsmsmsinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMSMSINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGSMSMSINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmSmsInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmSmsInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGSMSMSINTERFACE_P_H
Index: libs/solid/control/modemgsmhsointerface.cpp
===================================================================
--- libs/solid/control/modemgsmhsointerface.cpp	(revision 0)
+++ libs/solid/control/modemgsmhsointerface.cpp	(revision 1145887)
@@ -0,0 +1,70 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+#include <KLocale>
+
+#include "modemgsmhsointerface.h"
+#include "modemgsmhsointerface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmhsointerface.h"
+
+Solid::Control::ModemGsmHsoInterface::ModemGsmHsoInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmHsoInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmHsoInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmHsoInterface::ModemGsmHsoInterface(const ModemGsmHsoInterface &hsointerface)
+    : ModemInterface(*new ModemGsmHsoInterfacePrivate(this), hsointerface)
+{
+    Q_D(ModemGsmHsoInterface);
+    d->setBackendObject(hsointerface.d_ptr->backendObject());
+    makeConnections( hsointerface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemGsmHsoInterface::~ModemGsmHsoInterface()
+{
+}
+
+void Solid::Control::ModemGsmHsoInterface::authenticate(const QString & username, const QString & password) const
+{
+    Q_D(const ModemGsmHsoInterface);
+    SOLID_CALL(Ifaces::ModemGsmHsoInterface *, d->backendObject(), authenticate(username, password));
+}
+
+void Solid::Control::ModemGsmHsoInterface::makeConnections(QObject * source)
+{
+    if (source) {
+    }
+}
+
+void Solid::Control::ModemGsmHsoInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmHsoInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/modeminterface_p.h
===================================================================
--- libs/solid/control/modeminterface_p.h	(revision 0)
+++ libs/solid/control/modeminterface_p.h	(revision 1145887)
@@ -0,0 +1,42 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Will Stephenson <wstephenson@kde.org>
+    Copyright (C) 2007 Kevin Ottens <ervin@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_MODEMINTERFACE_P_H
+#define SOLID_MODEMINTERFACE_P_H
+
+#include "frontendobject_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemInterfacePrivate : public FrontendObjectPrivate
+    {
+    public:
+        explicit ModemInterfacePrivate(QObject *parent)
+            : FrontendObjectPrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_MODEMINTERFACE_P_H
+
Index: libs/solid/control/modemgsmcardinterface_p.h
===================================================================
--- libs/solid/control/modemgsmcardinterface_p.h	(revision 0)
+++ libs/solid/control/modemgsmcardinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMCARDINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGSMCARDINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmCardInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmCardInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGSMCARDINTERFACE_P_H
Index: libs/solid/control/modemgsmnetworkinterface.h
===================================================================
--- libs/solid/control/modemgsmnetworkinterface.h	(revision 0)
+++ libs/solid/control/modemgsmnetworkinterface.h	(revision 1145887)
@@ -0,0 +1,209 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMNETWORKINTERFACE_H
+#define SOLID_CONTROL_MODEMGSMNETWORKINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmNetworkInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmNetworkInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmNetworkInterface)
+
+    public:
+
+        ModemGsmNetworkInterface(QObject *backendObject = 0);
+
+        ModemGsmNetworkInterface(const ModemGsmNetworkInterface &network);
+
+        virtual ~ModemGsmNetworkInterface();
+
+        /*
+         * Each item list may include one or more of the following keys:
+         *
+         * "status": a number representing network availability status as defined in 3GPP TS 27.007
+         *           section 7.3. e.g. "0" (unknown), "1" (available), "2" (current), or "3" (forbidden).
+         *           This key will always be present.
+         * "operator-long": long-format name of operator. If the name is unknown, this field should not be present.
+         * "operator-short": short-format name of operator. If the name is unknown, this field should not be present.
+         * "operator-num": mobile code of the operator. Returned in the format "MCCMNC",
+         *                 where MCC is the three-digit ITU E.212 Mobile Country Code and MNC is the two- or
+         *                 three-digit GSM Mobile Network Code. e.g. "31026" or "310260".
+         * "access-tech": a number representing the access technology used by this mobile network as described
+         *                in 3GPP TS 27.007 section 7.3. e.g. "0" (GSM), "1" (GSM Compact), "2" (UTRAN/UMTS), "3" (EDGE), etc.
+         */
+        typedef QList< QMap<QString,QString> > ScanResultsType;
+
+        /* GSM registration code as defined in 3GPP TS 27.007 section 10.1.19. */
+        enum RegistrationStatus {
+            StatusIdle = 0x0, /* Not registered, not searching for new operator to register. */
+            StatusHome, /* Registered on home network. */
+            StatusSearching, /* Not registered, searching for new operator to register with. */
+            StatusDenied, /* Registration denied. */
+            StatusUnknown, /* Unknown registration status. */
+            StatusRoaming, /* Registered on a roaming network. */
+        };
+
+        class RegistrationInfoType
+        {
+        public:
+            RegistrationStatus status; /* Mobile registration status as defined in 3GPP TS 27.007 section 10.1.19. */
+            QString operatorCode, /* Current operator code of the operator to which the mobile is currently registered.
+                                     Returned in the format "MCCMNC", where MCC is the three-digit ITU E.212 Mobile Country Code
+                                     and MNC is the two- or three-digit GSM Mobile Network Code. If the MCC and MNC are not known
+                                     or the mobile is not registered to a mobile network, this value should be a zero-length (blank)
+                                     string. e.g. "31026" or "310260". */
+                    operatorName /* Current operator name of the operator to which the mobile is currently registered.
+                                    If the operator name is not knowon or the mobile is not registered to a mobile network,
+                                    this value should be a zero-length (blank) string. */;
+        };
+
+        ModemInterface::Type type() const;
+
+        /**
+         * Register the device to network.
+         *
+         * @param networkId the network ID to register. An empty string can be used to register to the home network.
+         */
+        void registerToNetwork(const QString & networkId) const;
+
+        /**
+         * Scan for available networks.
+         *
+         * @return Found networks. It's an array of dictionaries (strings for both keys and values) with each
+         * array element describing a mobile network found in the scan.
+         */
+        ScanResultsType scan() const;
+
+        /**
+         * Sets the Access Point Name (APN).
+         *
+         * @param apn the APN to set to.
+         */
+        void setApn(const QString & apn) const;
+
+        /**
+         * Retrieves the current signal quality of the gsm connection.
+         *
+         * @return the signal quality as a percentage
+         */
+        uint getSignalQuality() const;
+
+        /**
+         * Sets the band the device is allowed to use when connecting to a mobile network.
+         *
+         * @param band the desired band. Only one band may be specified, and may not be UNKNOWN.
+         */
+        void setBand(const Band band) const;
+
+        /**
+         * Returns the current band the device is using. (Note for plugin writers: returned value must not be ANY)
+         *
+         * @return the current band.
+         */
+        Band getBand() const;
+
+        /**
+         * Retrieves the current registration info.
+         *
+         * @return the registration info.
+         */
+        RegistrationInfoType getRegistrationInfo() const;
+
+        /**
+         * Set the access technologies a device is allowed to use when connecting to a mobile network.
+         *
+         * @param mode The allowed mode. The device may not support all modes;
+         * see the org.freedesktop.ModemManager.Gsm.Card.SupportedModes property for allowed modes for each device.
+         * All devices support the "ANY" flag.
+         */
+        void setAllowedMode(const ModemInterface::AllowedMode mode) const;
+
+        /**
+         * Retrieves the current allowed mode.
+         *
+         * @return the allowed mode.
+         */
+        ModemInterface::AllowedMode getAllowedMode() const;
+
+        /**
+         * Retrieves the current used access technology.
+         *
+         * @return the access technology
+         */
+        ModemInterface::AccessTechnology getAccessTechnology() const;
+
+    Q_SIGNALS:
+        /**
+         * This signal is emitted when the registration info this network changes
+         *
+         * @param registrationInfo the new registration info (status, operatorCode, operatorName)
+         */
+        void registrationInfoChanged(const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType & registrationInfo) const;
+
+        /**
+         * This signal is emitted when the signal quality of this network changes.
+         *
+         * @param signalQuality the new signal quality value for this network.
+         */
+        void signalQualityChanged(uint signalQuality);
+
+        /**
+         * This signal is emitted when the AllowedMode property changes.
+         *
+         * @param mode the new allowed mode.
+         */
+        void allowedModeChanged(const Solid::Control::ModemInterface::AllowedMode mode);
+
+        /**
+         * This signal is emitted when the AccessTechnology property changes.
+         *
+         * @param mode the new access technology used by the modem.
+         */
+        void accessTechnologyChanged(const Solid::Control::ModemInterface::AccessTechnology tech);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmNetworkInterface(ModemGsmNetworkInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmNetworkInterface(ModemGsmNetworkInterfacePrivate &dd, const ModemGsmNetworkInterface &network);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/ifaces/modemgsmhsointerface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmhsointerface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmhsointerface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmhsointerface.h"
+
+Solid::Control::Ifaces::ModemGsmHsoInterface::~ModemGsmHsoInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemgsmnetworkinterface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmnetworkinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmnetworkinterface.h	(revision 1145887)
@@ -0,0 +1,146 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMNETWORKINTERFACE_H
+#define SOLID_IFACES_MODEMGSMNETWORKINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmnetworkinterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmNetworkInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmNetworkInterface();
+
+        /**
+         * Register the device to network.
+         *
+         * @param networkId the network ID to register. An empty string can be used to register to the home network.
+         */
+        virtual void registerToNetwork(const QString & networkId) = 0;
+
+        /**
+         * Scan for available networks.
+         *
+         * @return Found networks. It's an array of dictionaries (strings for both keys and values) with each
+         * array element describing a mobile network found in the scan.
+         */
+        virtual Solid::Control::ModemGsmNetworkInterface::ScanResultsType scan() = 0;
+
+        /**
+         * Sets the Access Point Name (APN).
+         *
+         * @param apn the APN to set to.
+         */
+        virtual void setApn(const QString & apn) = 0;
+
+        /**
+         * Retrieves the current signal quality of the gsm connection.
+         *
+         * @return the signal quality as a percentage
+         */
+        virtual uint getSignalQuality() = 0;
+
+        /**
+         * Sets the band the device is allowed to use when connecting to a mobile network.
+         *
+         * @param band the desired band. Only one band may be specified, and may not be UNKNOWN.
+         */
+        virtual void setBand(const Solid::Control::ModemGsmNetworkInterface::Band band) = 0;
+
+        /**
+         * Returns the current band the device is using. (Note for plugin writers: returned value must not be ANY)
+         *
+         * @return the current band.
+         */
+        virtual Solid::Control::ModemGsmNetworkInterface::Band getBand() = 0;
+
+        /**
+         * Retrieves the current registration info.
+         *
+         * @return the registration info.
+         */
+        virtual Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType getRegistrationInfo() = 0;
+
+        /**
+         * Set the access technologies a device is allowed to use when connecting to a mobile network.
+         *
+         * @param mode The allowed mode. The device may not support all modes;
+         * see the org.freedesktop.ModemManager.Gsm.Card.SupportedModes property for allowed modes for each device.
+         * All devices support the "ANY" flag.
+         */
+        virtual void setAllowedMode(const Solid::Control::ModemInterface::AllowedMode mode) = 0;
+
+        /**
+         * Retrieves the current allowed mode.
+         *
+         * @return the allowed mode.
+         */
+        virtual Solid::Control::ModemInterface::AllowedMode getAllowedMode() const = 0;
+
+        /**
+         * Retrieves the current used access technology.
+         *
+         * @return the access technology
+         */
+        virtual Solid::Control::ModemInterface::AccessTechnology getAccessTechnology() const = 0;
+
+    protected:
+    //Q_SIGNALS:
+        /**
+         * This signal is emitted when the registration info this network changes
+         *
+         * @param registrationInfo the new registration info (status, operatorCode, operatorName)
+         */
+        void registrationInfoChanged(const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType & registrationInfo);
+
+        /**
+         * This signal is emitted when the signal quality of this network changes.
+         *
+         * @param signalQuality the new signal quality value for this network.
+         */
+        void signalQualityChanged(uint signalQuality);
+
+        /**
+         * This signal is emitted when the AllowedMode property changes.
+         *
+         * @param mode the new allowed mode.
+         */
+        void gsmNetworkAllowedModeChanged(const Solid::Control::ModemGsmNetworkInterface::AllowedMode mode);
+
+        /**
+         * This signal is emitted when the AccessTechnology property changes.
+         *
+         * @param mode the new access technology used by the modem.
+         */
+        void gsmNetworkAccessTechnologyChanged(const Solid::Control::ModemGsmNetworkInterface::AccessTechnology tech);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmNetworkInterface, "org.kde.Solid.Control.Ifaces.ModemGsmNetworkInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemcdmainterface.h
===================================================================
--- libs/solid/control/ifaces/modemcdmainterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemcdmainterface.h	(revision 1145887)
@@ -0,0 +1,67 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMCDMAINTERFACE_H
+#define SOLID_IFACES_MODEMCDMAINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemcdmainterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemCdmaInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemCdmaInterface();
+
+        virtual uint getSignalQuality() = 0;
+
+        virtual QString getEsn() = 0;
+
+        virtual Solid::Control::ModemCdmaInterface::ServingSystemType getServingSystem() = 0;
+
+        virtual Solid::Control::ModemCdmaInterface::RegistrationStateResult getRegistrationState() = 0;
+
+    protected:
+    //Q_SIGNALS:
+        /**
+         * This signal is emitted when the signal quality of this network changes.
+         *
+         * @param signalQuality the new signal quality value for this network.
+         */
+        void signalQualityChanged(uint signalQuality);
+
+        /**
+         * This signal is emitted when the registration info this network changes
+         *
+         * @param registrationInfo the new registration info (status, operatorCode, operatorName)
+         */
+        void registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState cdma_1x_state, Solid::Control::ModemCdmaInterface::RegistrationState evdo_state);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemCdmaInterface, "org.kde.Solid.Control.Ifaces.ModemCdmaInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemmanagerinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemmanagerinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemmanagerinterface.cpp	(revision 1145887)
@@ -0,0 +1,24 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "modemmanagerinterface.h"
+
+Solid::Control::Ifaces::ModemManagerInterface::~ModemManagerInterface()
+{
+}
Index: libs/solid/control/ifaces/networkinterface.h
===================================================================
--- libs/solid/control/ifaces/networkinterface.h	(revision 1145886)
+++ libs/solid/control/ifaces/networkinterface.h	(revision 1145887)
@@ -53,6 +53,13 @@
          */
         virtual QString uni() const = 0;
         /**
+         * Retrieves the Unique Device Identifier (UDI).
+         * This is needed for ModemManager support.
+         *
+         * @returns the Unique Device Identifier of the current device
+         */
+        virtual QString udi() const = 0;
+        /**
          * The system name for the network interface
          */
         virtual QString interfaceName() const = 0;
Index: libs/solid/control/ifaces/modemlocationinterface.h
===================================================================
--- libs/solid/control/ifaces/modemlocationinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemlocationinterface.h	(revision 1145887)
@@ -0,0 +1,63 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMHSOINTERFACE_H
+#define SOLID_IFACES_MODEMGSMHSOINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemlocationinterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemLocationInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemLocationInterface();
+
+        void enableLocation(const bool enable, const bool signalLocation) const;
+
+        Solid::Control::ModemLocationInterface::LocationInformationMap getLocation() const;
+
+        Solid::Control::ModemLocationInterface::Capability getCapability() const;
+
+        bool enabled() const;
+
+        bool signalsLocation();
+
+    protected:
+    //Q_SIGNALS:
+        void capabilitiesChanged(const Solid::Control::ModemLocationInterface::Capability capability);
+
+        void enabledChanged(const bool enabled);
+
+        void signalsLocationChanged(const bool signalsLocation);
+
+        void locationChanged(const Solid::Control::ModemLocationInterface::LocationInformationMap & location);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemLocationInterface, "org.kde.Solid.Control.Ifaces.ModemLocationInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemgsmsmsinterface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmsmsinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmsmsinterface.h	(revision 1145887)
@@ -0,0 +1,69 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMSMSINTERFACE_H
+#define SOLID_IFACES_MODEMGSMSMSINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmhsointerface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmSmsInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmSmsInterface();
+
+        virtual void deleteSms(const int index) = 0;
+
+        virtual QVariantMap get(const int index) = 0;
+
+        virtual int getFormat() = 0;
+
+        virtual void setFormat(const int format) = 0;
+
+        virtual QString getSmsc() = 0;
+
+        virtual QList<QVariantMap> list() = 0;
+
+        virtual void save(const QVariantMap & properties) = 0;
+
+        virtual void send(const QVariantMap & properties) = 0;
+
+        virtual void sendFromStorage(const int index) = 0;
+
+        virtual void setIndication(const int mode, const int mt, const int bm, const int ds, const int brf) = 0;
+
+    protected:
+    //Q_SIGNALS:
+        void smsReceived(int index, bool complete);
+
+        void completed(int index, bool completed);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmSmsInterface, "org.kde.Solid.Control.Ifaces.ModemGsmSmsInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/networkgsminterface.h
===================================================================
--- libs/solid/control/ifaces/networkgsminterface.h	(revision 1145886)
+++ libs/solid/control/ifaces/networkgsminterface.h	(revision 1145887)
@@ -45,8 +45,23 @@
          * Destroys a GsmNetworkInterface object
          */
         virtual ~GsmNetworkInterface();
+
+        virtual Solid::Control::ModemGsmCardInterface * getModemCardIface() = 0;
+
+        virtual void setModemCardIface(Solid::Control::ModemGsmCardInterface * iface) = 0;
+
+        virtual Solid::Control::ModemGsmNetworkInterface * getModemNetworkIface() = 0;
+
+        virtual void setModemNetworkIface(Solid::Control::ModemGsmNetworkInterface * iface) = 0;
+
     protected:
     //Q_SIGNALS:
+        /**
+         * This signal is emitted when the network name of this network changes
+         *
+         * @param networkName the new network name
+         */
+        void networkNameChanged(const QString & networkName);
     };
 } //Ifaces
 } //Control
Index: libs/solid/control/ifaces/modeminterface.h
===================================================================
--- libs/solid/control/ifaces/modeminterface.h	(revision 0)
+++ libs/solid/control/ifaces/modeminterface.h	(revision 1145887)
@@ -0,0 +1,98 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_IFACES_MODEMINTERFACE_H
+#define SOLID_CONTROL_IFACES_MODEMINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modeminterface.h"
+#include <QtCore/QObject>
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemInterface
+    {
+    public:
+        virtual ~ModemInterface();
+
+        /**
+         * Retrieves the Unique Device Identifier (UDI).
+         *
+         * @returns the Unique Device Identifier of the current device
+         */
+        virtual QString udi() const = 0;
+
+        virtual void enable(const bool enable) = 0;
+
+        virtual void connectModem(const QString & number) = 0;
+
+        virtual void connectModem(const QVariantMap & properties) = 0;
+
+        virtual void disconnectModem() = 0;
+
+        virtual Solid::Control::ModemInterface::Ip4ConfigType getIp4Config() = 0;
+
+        virtual Solid::Control::ModemInterface::InfoType getInfo() = 0;
+
+        virtual QVariantMap getStatus() = 0;
+
+        /*
+         * Properties
+         */
+        virtual QString device() const = 0;
+
+        virtual QString masterDevice() const = 0;
+
+        virtual QString driver() const = 0;
+
+        virtual Solid::Control::ModemInterface::Type type() const = 0;
+
+        virtual bool enabled() const = 0;
+
+        virtual QString unlockRequired() const = 0;
+
+        virtual Solid::Control::ModemInterface::Method ipMethod() const = 0;
+
+    Q_SIGNALS:
+        void deviceChanged(const QString & device);
+
+        void masterDeviceChanged(const QString & masterDevice);
+
+        void driverChanged(const QString & driver);
+
+        void typeChanged(const Solid::Control::ModemInterface::Type type);
+
+        void enabledChanged(const bool enabled);
+
+        void unlockRequiredChanged(const QString & codeRequired);
+
+        void ipMethodChanged(const Solid::Control::ModemInterface::Method ipMethod);
+    };
+
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemInterface, "org.kde.Solid.Control.Ifaces.ModemInterface/0.1")
+
+#endif
Index: libs/solid/control/ifaces/modemgsmcardinterface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmcardinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmcardinterface.h	(revision 1145887)
@@ -0,0 +1,65 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMCARDINTERFACE_H
+#define SOLID_IFACES_MODEMGSMCARDINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmcardinterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmCardInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmCardInterface();
+
+        virtual QString getImei() = 0;
+
+        virtual QString getImsi() = 0;
+
+        virtual void sendPuk(const QString & puk, const QString & pin) = 0;
+
+        virtual void sendPin(const QString & pin) = 0;
+
+        virtual void enablePin(const QString & pin, const bool enabled) = 0;
+
+        virtual void changePin(const QString & oldPin, const QString & newPin) = 0;
+
+        virtual Solid::Control::ModemInterface::Band getSupportedBands() const = 0;
+
+        virtual Solid::Control::ModemInterface::Mode getSupportedModes() const = 0;
+
+    protected:
+    //Q_SIGNALS:
+        void supportedBandsChanged(const Solid::Control::ModemInterface::Band band);
+
+        void supportedModesChanged(const Solid::Control::ModemInterface::Mode modes);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmCardInterface, "org.kde.Solid.Control.Ifaces.ModemGsmCardInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemgsmussdinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmussdinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmussdinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmussdinterface.h"
+
+Solid::Control::Ifaces::ModemGsmUssdInterface::~ModemGsmUssdInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/CMakeLists.txt
===================================================================
--- libs/solid/control/ifaces/CMakeLists.txt	(revision 1145886)
+++ libs/solid/control/ifaces/CMakeLists.txt	(revision 1145887)
@@ -18,10 +18,22 @@
    bluetoothmanager.cpp
    bluetoothsecurity.cpp
    remotecontrol.cpp
-   remotecontrolmanager.cpp )
+   remotecontrolmanager.cpp
+   modemmanager.cpp
+   modemmanagerinterface.cpp
+   modeminterface.cpp
+   modemlocationinterface.cpp
+   modemcdmainterface.cpp
+   modemgsmcardinterface.cpp
+   modemgsmcontactsinterface.cpp
+   modemgsmnetworkinterface.cpp
+   modemgsmsmsinterface.cpp
+   modemgsmhsointerface.cpp
+   modemgsmussdinterface.cpp )
 
 set(unused
    networkmanager.cpp
+   modemmanager.cpp
    network.cpp
    wirelessnetwork.cpp
    authentication.cpp
@@ -38,5 +50,5 @@
 
 ########### install files ###############
 
-install( FILES powermanager.h networkmanager.h networkinterface.h networkcdmainterface.h networkgsminterface.h networkserialinterface.h wirednetworkinterface.h wirelessnetworkinterface.h wirelessaccesspoint.h bluetoothremotedevice.h bluetoothinputdevice.h bluetoothinterface.h bluetoothmanager.h remotecontrol.h remotecontrolmanager.h DESTINATION ${INCLUDE_INSTALL_DIR}/solid/control/ifaces COMPONENT Devel)
+install( FILES powermanager.h networkmanager.h networkinterface.h networkcdmainterface.h networkgsminterface.h networkserialinterface.h wirednetworkinterface.h wirelessnetworkinterface.h wirelessaccesspoint.h bluetoothremotedevice.h bluetoothinputdevice.h bluetoothinterface.h bluetoothmanager.h remotecontrol.h remotecontrolmanager.h modemmanager.h modeminterface.h modemlocationinterface.h modemcdmainterface.h modemgsmcardinterface.h modemgsmcontactsinterface.h modemgsmnetworkinterface.h modemgsmsmsinterface.h modemgsmhsointerface.h modemgsmussdinterface.h DESTINATION ${INCLUDE_INSTALL_DIR}/solid/control/ifaces COMPONENT Devel)
 
Index: libs/solid/control/ifaces/modemgsmcontactsinterface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmcontactsinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmcontactsinterface.h	(revision 1145887)
@@ -0,0 +1,58 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMCONTACTSINTERFACE_H
+#define SOLID_IFACES_MODEMGSMCONTACTSINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmcontactsinterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmContactsInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmContactsInterface();
+
+        virtual int addContact(const QString & name, const QString & number) = 0;
+
+        virtual void deleteContact(const int index) = 0;
+
+        virtual Solid::Control::ModemGsmContactsInterface::ContactType get(const int index) = 0;
+
+        virtual QList<Solid::Control::ModemGsmContactsInterface::ContactType> list() = 0;
+
+        virtual QList<Solid::Control::ModemGsmContactsInterface::ContactType> find(const QString & pattern) = 0;
+
+        virtual int getCount() = 0;
+
+    protected:
+    //Q_SIGNALS:
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmContactsInterface, "org.kde.Solid.Control.Ifaces.ModemGsmContactsInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemmanager.h
===================================================================
--- libs/solid/control/ifaces/modemmanager.h	(revision 0)
+++ libs/solid/control/ifaces/modemmanager.h	(revision 1145887)
@@ -0,0 +1,107 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Will Stephenson <wstephenson@kde.org>
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMMANAGER
+#define SOLID_IFACES_MODEMMANAGER
+
+#include <QtCore/QObject>
+#include <QtCore/QStringList>
+#include <solid/networking.h>
+#include "../solid_control_export.h"
+#include "../modemmanager.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    /**
+     * This class specifies the interface a backend will have to implement in
+     * order to be used in the system.
+     *
+     */
+    class SOLIDCONTROLIFACES_EXPORT ModemManager : public QObject
+    {
+        Q_OBJECT
+    public:
+        /**
+         * Constructs a ModemManager.
+         *
+         * @param parent the parent object
+         */
+        ModemManager(QObject * parent = 0);
+        /**
+         * Destructs a ModemManager object.
+         */
+        virtual ~ModemManager();
+
+        /**
+         * Get the manager connection state
+         */
+        virtual Solid::Networking::Status status() const = 0;
+
+        /**
+         * Retrieves the list of all modem interfaces Unique Device Identifiers (UDIs)
+         * in the system. This method is the equivalent of enumerateDevices described
+         * in Modem Manager specification.
+         *
+         * @return the list of modem interfaces available in this system
+         */
+        virtual QStringList modemInterfaces() const = 0;
+
+        /**
+         * Instantiates a new ModemInterface object from this backend given its UDI.
+         *
+         * @param udi the identifier of the modem instantiated
+         * @returns a new ModemInterface object if there's a device having the given UDI, 0 otherwise
+         */
+        virtual QObject *createModemInterface(const QString & udi, const Solid::Control::ModemInterface::GsmInterfaceType ifaceType) = 0;
+
+    Q_SIGNALS:
+        /**
+         * This signal is emitted when the system's connection state changes
+         */
+        void statusChanged(Solid::Networking::Status status);
+
+        /**
+         * This signal is emitted when a device was added to the system.
+         *
+         * @param device object path of the newly added device.
+         */
+        void deviceAdded(const QString & device);
+
+        /**
+         * This signal is emitted when a device was removed from the system.
+         *
+         * @param device object path of the device that was just removed.
+         */
+        void deviceRemoved(const QString & device);
+    };
+
+} // Ifaces
+
+} // Control
+
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemManager, "org.kde.Solid.Control.Ifaces.ModemManager/0.1")
+
+#endif
Index: libs/solid/control/ifaces/modemgsmnetworkinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmnetworkinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmnetworkinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmnetworkinterface.h"
+
+Solid::Control::Ifaces::ModemGsmNetworkInterface::~ModemGsmNetworkInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemcdmainterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemcdmainterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemcdmainterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemcdmainterface.h"
+
+Solid::Control::Ifaces::ModemCdmaInterface::~ModemCdmaInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemgsmhsointerface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmhsointerface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmhsointerface.h	(revision 1145887)
@@ -0,0 +1,51 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMHSOINTERFACE_H
+#define SOLID_IFACES_MODEMGSMHSOINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmhsointerface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmHsoInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmHsoInterface();
+
+        virtual void authenticate(const QString & username, const QString & password) = 0;
+
+    protected:
+    //Q_SIGNALS:
+        void hsoReceived(int index, bool complete);
+
+        void completed(int index, bool completed);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmHsoInterface, "org.kde.Solid.Control.Ifaces.ModemGsmHsoInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemlocationinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemlocationinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemlocationinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemlocationinterface.h"
+
+Solid::Control::Ifaces::ModemLocationInterface::~ModemLocationInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemgsmsmsinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmsmsinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmsmsinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmsmsinterface.h"
+
+Solid::Control::Ifaces::ModemGsmSmsInterface::~ModemGsmSmsInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modeminterface.cpp
===================================================================
--- libs/solid/control/ifaces/modeminterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modeminterface.cpp	(revision 1145887)
@@ -0,0 +1,26 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "modeminterface.h"
+
+Solid::Control::Ifaces::ModemInterface::~ModemInterface()
+{
+
+}
+
Index: libs/solid/control/ifaces/modemmanagerinterface.h
===================================================================
--- libs/solid/control/ifaces/modemmanagerinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemmanagerinterface.h	(revision 1145887)
@@ -0,0 +1,52 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMMANAGERINTERFACE_H
+#define SOLID_IFACES_MODEMMANAGERINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemmanagerinterface.h"
+#include <QtCore/QObject>
+#include <QtCore/QList>
+
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemManagerInterface
+    {
+    public:
+        /**
+         * Destroys a ModemManagerInterface object.
+         */
+        virtual ~ModemManagerInterface();
+
+    protected:
+    //Q_SIGNALS:
+
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemManagerInterface, "org.kde.Solid.Control.Ifaces.ModemManagerInterface/0.1")
+#endif
Index: libs/solid/control/ifaces/modemgsmcardinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmcardinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmcardinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmcardinterface.h"
+
+Solid::Control::Ifaces::ModemGsmCardInterface::~ModemGsmCardInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemgsmcontactsinterface.cpp
===================================================================
--- libs/solid/control/ifaces/modemgsmcontactsinterface.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemgsmcontactsinterface.cpp	(revision 1145887)
@@ -0,0 +1,27 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "modemgsmcontactsinterface.h"
+
+Solid::Control::Ifaces::ModemGsmContactsInterface::~ModemGsmContactsInterface()
+{
+
+}
+
+// vim: sw=4 sts=4 et tw=100
Index: libs/solid/control/ifaces/modemmanager.cpp
===================================================================
--- libs/solid/control/ifaces/modemmanager.cpp	(revision 0)
+++ libs/solid/control/ifaces/modemmanager.cpp	(revision 1145887)
@@ -0,0 +1,32 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "modemmanager.h"
+
+Solid::Control::Ifaces::ModemManager::ModemManager(QObject * parent) : QObject(parent)
+{
+
+}
+
+Solid::Control::Ifaces::ModemManager::~ModemManager()
+{
+
+}
+
+#include "modemmanager.moc"
Index: libs/solid/control/ifaces/modemgsmussdinterface.h
===================================================================
--- libs/solid/control/ifaces/modemgsmussdinterface.h	(revision 0)
+++ libs/solid/control/ifaces/modemgsmussdinterface.h	(revision 1145887)
@@ -0,0 +1,63 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_IFACES_MODEMGSMUSSDINTERFACE_H
+#define SOLID_IFACES_MODEMGSMUSSDINTERFACE_H
+
+#include "../solid_control_export.h"
+#include "../modemgsmussdinterface.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+namespace Ifaces
+{
+    class SOLIDCONTROLIFACES_EXPORT ModemGsmUssdInterface: virtual public ModemManagerInterface
+    {
+    public:
+        virtual ~ModemGsmUssdInterface();
+
+        virtual QString initiate(const QString & command) = 0;
+
+        virtual void respond(const QString response) = 0;
+
+        virtual void cancel() = 0;
+
+        virtual QString getState() = 0;
+
+        virtual QString getNetworkNotification() = 0;
+
+        virtual QString getNetworkRequest() = 0;
+
+    protected:
+    //Q_SIGNALS:
+        void stateChanged(const QString & state);
+
+        void networkNotificationChanged(const QString & networkNotification);
+
+        void networkRequestChanged(const QString & networkRequest);
+    };
+} // Ifaces
+} // Control
+} // Solid
+
+Q_DECLARE_INTERFACE(Solid::Control::Ifaces::ModemGsmUssdInterface, "org.kde.Solid.Control.Ifaces.ModemGsmUssdInterface/0.1")
+#endif
Index: libs/solid/control/modemcdmainterface.h
===================================================================
--- libs/solid/control/modemcdmainterface.h	(revision 0)
+++ libs/solid/control/modemcdmainterface.h	(revision 1145887)
@@ -0,0 +1,109 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMCDMAINTERFACE_H
+#define SOLID_CONTROL_MODEMCDMAINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemCdmaInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemCdmaInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemCdmaInterface)
+
+    public:
+
+        ModemCdmaInterface(QObject *backendObject = 0);
+
+        ModemCdmaInterface(const ModemCdmaInterface &network);
+
+        virtual ~ModemCdmaInterface();
+
+        enum BandClass { Unknown = 0x0, B800 = 0x01, B1900 = 0x2, };
+
+        class ServingSystemType
+        {
+        public:
+            BandClass bandClass;
+            QString band;
+            uint systemId;
+        };
+
+        enum RegistrationState { UnknownState = 0x0, Registered = 0x1, Home = 0x2, Roaming = 0x3, };
+
+        class RegistrationStateResult
+        {
+        public:
+            RegistrationState cdma_1x_state, evdo_state;
+        };
+
+        ModemInterface::Type type() const;
+
+        uint getSignalQuality() const;
+
+        QString getEsn() const;
+
+        ServingSystemType getServingSystem() const;
+
+        RegistrationStateResult getRegistrationState() const;
+
+    Q_SIGNALS:
+        /**
+         * This signal is emitted when the signal quality of this network changes.
+         *
+         * @param signalQuality the new signal quality value for this network.
+         */
+        void signalQualityChanged(uint signalQuality);
+
+        /**
+         * This signal is emitted when the registration info this network changes
+         *
+         * @param registrationInfo the new registration info (status, operatorCode, operatorName)
+         */
+        void registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState cdma_1x_state,
+                                      const Solid::Control::ModemCdmaInterface::RegistrationState evdo_state);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemCdmaInterface(ModemCdmaInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemCdmaInterface(ModemCdmaInterfacePrivate &dd, const ModemCdmaInterface &network);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modemgsmcontactsinterface_p.h
===================================================================
--- libs/solid/control/modemgsmcontactsinterface_p.h	(revision 0)
+++ libs/solid/control/modemgsmcontactsinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMCONTACTSINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGSMCONTACTSINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmContactsInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmContactsInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGSMCONTACTSINTERFACE_P_H
Index: libs/solid/control/modemmanager_p.h
===================================================================
--- libs/solid/control/modemmanager_p.h	(revision 0)
+++ libs/solid/control/modemmanager_p.h	(revision 1145887)
@@ -0,0 +1,66 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Will Stephenson <wstephenson@kde.org>
+    Copyright (C) 2006-2007 Kevin Ottens <ervin@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+#ifndef SOLID_MODEMMANAGER_P_H
+#define SOLID_MODEMMANAGER_P_H
+
+#include <QObject>
+#include <QMap>
+#include <QPair>
+
+#include "managerbase_p.h"
+
+#include "modemmanager.h"
+#include "modemmanagerinterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    namespace Ifaces
+    {
+        class ModemManagerInterface;
+    }
+
+    class ModemManagerPrivate : public ModemManager::Notifier, public ManagerBasePrivate
+    {
+        Q_OBJECT
+    public:
+        ModemManagerPrivate();
+        ~ModemManagerPrivate();
+
+        ModemInterfaceList modemInterfaces();
+        ModemInterface *findModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType);
+
+    private Q_SLOTS:
+        void _k_modemInterfaceAdded(const QString &udi);
+        void _k_modemInterfaceRemoved(const QString &udi);
+        void _k_destroyed(QObject *object);
+
+    private:
+        ModemInterfaceList buildDeviceList(const QStringList &udiList);
+        QPair<ModemInterface *, QObject *> findRegisteredModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType);
+
+        QMap<QString, QMap<ModemInterface::GsmInterfaceType, QPair<ModemInterface *, QObject *> > > m_modemInterfaceMap;
+        ModemInterface m_invalidDevice;
+    };
+}
+}
+
+#endif
Index: libs/solid/control/networkgsminterface.h
===================================================================
--- libs/solid/control/networkgsminterface.h	(revision 1145886)
+++ libs/solid/control/networkgsminterface.h	(revision 1145887)
@@ -22,6 +22,8 @@
 #define SOLID_CONTROL_GSMNETWORKINTERFACE_H
 
 #include "networkserialinterface.h"
+#include "modemgsmcardinterface.h"
+#include "modemgsmnetworkinterface.h"
 
 namespace Solid
 {
@@ -63,7 +65,13 @@
          */
         virtual NetworkInterface::Type type() const;
 
-    Q_SIGNALS:
+        ModemGsmCardInterface * getModemCardIface();
+
+        void setModemCardIface(Solid::Control::ModemGsmCardInterface * iface);
+
+        ModemGsmNetworkInterface * getModemNetworkIface();
+
+        void setModemNetworkIface(Solid::Control::ModemGsmNetworkInterface * iface);
     protected:
         /**
          * @internal
Index: libs/solid/control/modemgsmcardinterface.h
===================================================================
--- libs/solid/control/modemgsmcardinterface.h	(revision 0)
+++ libs/solid/control/modemgsmcardinterface.h	(revision 1145887)
@@ -0,0 +1,86 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMCARDINTERFACE_H
+#define SOLID_CONTROL_MODEMGSMCARDINTERFACE_H
+
+#include "modeminterface.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmCardInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemGsmCardInterface: public ModemInterface
+    {
+        Q_OBJECT
+        Q_DECLARE_PRIVATE(ModemGsmCardInterface)
+
+    public:
+
+        ModemGsmCardInterface(QObject *backendObject = 0);
+
+        ModemGsmCardInterface(const ModemGsmCardInterface &card);
+
+        virtual ~ModemGsmCardInterface();
+
+        QString getImei() const;
+
+        QString getImsi() const;
+
+        void sendPuk(const QString & puk, const QString & pin) const;
+
+        void sendPin(const QString & pin) const;
+
+        void enablePin(const QString & pin, const bool enabled) const;
+
+        void changePin(const QString & oldPin, const QString & newPin) const;
+
+        Solid::Control::ModemInterface::Band getSupportedBands() const;
+
+        Solid::Control::ModemInterface::Mode getSupportedModes() const;
+
+    Q_SIGNALS:
+        void supportedBandsChanged(const Solid::Control::ModemInterface::Band band);
+
+        void supportedModesChanged(const Solid::Control::ModemInterface::Mode modes);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemGsmCardInterface(ModemGsmCardInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemGsmCardInterface(ModemGsmCardInterfacePrivate &dd, const ModemGsmCardInterface &card);
+
+        void makeConnections(QObject * source);
+    private Q_SLOTS:
+        void _k_destroyed(QObject *object);
+    private:
+        friend class ModemManagerInterface;
+        friend class ModemManagerInterfacePrivate;
+    };
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/CMakeLists.txt
===================================================================
--- libs/solid/control/CMakeLists.txt	(revision 1145886)
+++ libs/solid/control/CMakeLists.txt	(revision 1145887)
@@ -30,6 +30,17 @@
    remotecontrolbutton.cpp
    remotecontrol.cpp
    remotecontrolmanager.cpp
+   modemmanager.cpp
+   modemmanagerinterface.cpp
+   modeminterface.cpp
+   modemlocationinterface.cpp
+   modemcdmainterface.cpp
+   modemgsmcardinterface.cpp
+   modemgsmcontactsinterface.cpp
+   modemgsmnetworkinterface.cpp
+   modemgsmsmsinterface.cpp
+   modemgsmhsointerface.cpp
+   modemgsmussdinterface.cpp
 )
 
 # FIXME: this should be XRANDR_FOUND instead
@@ -53,13 +64,18 @@
 
 ########### install files ###############
 
-install( FILES solidpowermanager.desktop solidnetworkmanager.desktop solidbluetoothmanager.desktop solidremotecontrolmanager.desktop DESTINATION ${SERVICETYPES_INSTALL_DIR}  )
+install( FILES solidpowermanager.desktop solidnetworkmanager.desktop solidbluetoothmanager.desktop solidremotecontrolmanager.desktop solidmodemmanager.desktop DESTINATION ${SERVICETYPES_INSTALL_DIR}  )
 install( FILES powermanager.h networkmanager.h networkinterface.h remotecontrolmanager.h 
     remotecontrol.h remotecontrolbutton.h wirednetworkinterface.h wirelessnetworkinterface.h
     wirelessaccesspoint.h bluetoothmanager.h bluetoothinterface.h
     bluetoothremotedevice.h bluetoothinputdevice.h bluetoothsecurity.h
     singletondefs.h networking.h networkipv4config.h solid_control_export.h 
     networkcdmainterface.h networkgsminterface.h networkserialinterface.h
+    modemmanager.h modemmanagerinterface.h
+    modeminterface.h modemlocationinterface.h modemcdmainterface.h
+    modemgsmcardinterface.h modemgsmcontactsinterface.h
+    modemgsmnetworkinterface.h modemgsmsmsinterface.h
+    modemgsmhsointerface.h modemgsmussdinterface.h
     DESTINATION
 ${INCLUDE_INSTALL_DIR}/solid/control COMPONENT Devel)
 
Index: libs/solid/control/modemmanagerinterface_p.h
===================================================================
--- libs/solid/control/modemmanagerinterface_p.h	(revision 0)
+++ libs/solid/control/modemmanagerinterface_p.h	(revision 1145887)
@@ -0,0 +1,39 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+#ifndef SOLID_MODEMMANAGERINTERFACE_P_H
+#define SOLID_MODEMMANAGERINTERFACE_P_H
+
+#include "frontendobject_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemManagerInterfacePrivate : public FrontendObjectPrivate
+    {
+    public:
+        explicit ModemManagerInterfacePrivate(QObject *parent)
+            : FrontendObjectPrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif
Index: libs/solid/control/modemgsmnetworkinterface.cpp
===================================================================
--- libs/solid/control/modemgsmnetworkinterface.cpp	(revision 0)
+++ libs/solid/control/modemgsmnetworkinterface.cpp	(revision 1145887)
@@ -0,0 +1,138 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+
+#include "modemgsmnetworkinterface.h"
+#include "modemgsmnetworkinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmnetworkinterface.h"
+
+Solid::Control::ModemGsmNetworkInterface::ModemGsmNetworkInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmNetworkInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmNetworkInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmNetworkInterface::ModemGsmNetworkInterface(const ModemGsmNetworkInterface &networkinterface)
+    : ModemInterface(*new ModemGsmNetworkInterfacePrivate(this), networkinterface)
+{
+    Q_D(ModemGsmNetworkInterface);
+    d->setBackendObject(networkinterface.d_ptr->backendObject());
+    makeConnections( networkinterface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemGsmNetworkInterface::~ModemGsmNetworkInterface()
+{
+}
+
+Solid::Control::ModemInterface::Type Solid::Control::ModemGsmNetworkInterface::type() const
+{
+    return GsmType;
+}
+
+void Solid::Control::ModemGsmNetworkInterface::registerToNetwork(const QString & networkId) const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), registerToNetwork(networkId));
+}
+
+Solid::Control::ModemGsmNetworkInterface::ScanResultsType Solid::Control::ModemGsmNetworkInterface::scan() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), ScanResultsType(), scan());
+}
+
+void Solid::Control::ModemGsmNetworkInterface::setApn(const QString & apn) const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), setApn(apn));
+}
+
+uint Solid::Control::ModemGsmNetworkInterface::getSignalQuality() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), 0, getSignalQuality());
+}
+
+void Solid::Control::ModemGsmNetworkInterface::setBand(const Band band) const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), setBand(band));
+}
+
+Solid::Control::ModemInterface::Band Solid::Control::ModemGsmNetworkInterface::getBand() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), UnknownBand, getBand());
+}
+
+Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType Solid::Control::ModemGsmNetworkInterface::getRegistrationInfo() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), RegistrationInfoType(), getRegistrationInfo());
+}
+
+void Solid::Control::ModemGsmNetworkInterface::setAllowedMode(const AllowedMode mode) const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), setAllowedMode(mode));
+}
+
+Solid::Control::ModemInterface::AllowedMode Solid::Control::ModemGsmNetworkInterface::getAllowedMode() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), AnyModeAllowed, getAllowedMode());
+}
+
+Solid::Control::ModemInterface::AccessTechnology Solid::Control::ModemGsmNetworkInterface::getAccessTechnology() const
+{
+    Q_D(const ModemGsmNetworkInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmNetworkInterface *, d->backendObject(), UnknownTechnology, getAccessTechnology());
+}
+
+void Solid::Control::ModemGsmNetworkInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(registrationInfoChanged(const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &)),
+                this, SIGNAL(registrationInfoChanged(const Solid::Control::ModemGsmNetworkInterface::RegistrationInfoType &)));
+        QObject::connect(source, SIGNAL(signalQualityChanged(uint)),
+                this, SIGNAL(signalQualityChanged(uint)));
+        QObject::connect(source, SIGNAL(allowedModeChanged(const Solid::Control::ModemInterface::AllowedMode)),
+                this, SIGNAL(allowedModeChanged(const Solid::Control::ModemInterface::AllowedMode)));
+        QObject::connect(source, SIGNAL(accessTechnologyChanged(const Solid::Control::ModemInterface::AccessTechnology)),
+                this, SIGNAL(accessTechnologyChanged(const Solid::Control::ModemInterface::AccessTechnology)));
+    }
+}
+
+void Solid::Control::ModemGsmNetworkInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmNetworkInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
+
+
Index: libs/solid/control/modemcdmainterface.cpp
===================================================================
--- libs/solid/control/modemcdmainterface.cpp	(revision 0)
+++ libs/solid/control/modemcdmainterface.cpp	(revision 1145887)
@@ -0,0 +1,96 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+
+#include "modemcdmainterface.h"
+#include "modemcdmainterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemcdmainterface.h"
+
+Solid::Control::ModemCdmaInterface::ModemCdmaInterface(QObject *backendObject)
+    : ModemInterface(*new ModemCdmaInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemCdmaInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemCdmaInterface::ModemCdmaInterface(const ModemCdmaInterface &networkinterface)
+    : ModemInterface(*new ModemCdmaInterfacePrivate(this), networkinterface)
+{
+    Q_D(ModemCdmaInterface);
+    d->setBackendObject(networkinterface.d_ptr->backendObject());
+    makeConnections( networkinterface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemCdmaInterface::~ModemCdmaInterface()
+{
+}
+
+Solid::Control::ModemInterface::Type Solid::Control::ModemCdmaInterface::type() const
+{
+    return CdmaType;
+}
+
+uint Solid::Control::ModemCdmaInterface::getSignalQuality() const
+{
+    Q_D(const ModemCdmaInterface);
+    return_SOLID_CALL(Ifaces::ModemCdmaInterface *, d->backendObject(), 0, getSignalQuality());
+}
+
+QString Solid::Control::ModemCdmaInterface::getEsn() const
+{
+    Q_D(const ModemCdmaInterface);
+    return_SOLID_CALL(Ifaces::ModemCdmaInterface *, d->backendObject(), 0, getEsn());
+}
+
+Solid::Control::ModemCdmaInterface::ServingSystemType Solid::Control::ModemCdmaInterface::getServingSystem() const
+{
+    Q_D(const ModemCdmaInterface);
+    return_SOLID_CALL(Ifaces::ModemCdmaInterface *, d->backendObject(), ServingSystemType(), getServingSystem());
+}
+
+Solid::Control::ModemCdmaInterface::RegistrationStateResult Solid::Control::ModemCdmaInterface::getRegistrationState() const
+{
+    Q_D(const ModemCdmaInterface);
+    return_SOLID_CALL(Ifaces::ModemCdmaInterface *, d->backendObject(), RegistrationStateResult(), getRegistrationState());
+}
+
+void Solid::Control::ModemCdmaInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(signalQualityChanged(uint)),
+                this, SIGNAL(signalQualityChanged(uint)));
+        QObject::connect(source, SIGNAL(registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState, const Solid::Control::ModemCdmaInterface::RegistrationState)),
+                this, SIGNAL(registrationStateChanged(const Solid::Control::ModemCdmaInterface::RegistrationState, const Solid::Control::ModemCdmaInterface::RegistrationState)));
+    }
+}
+
+void Solid::Control::ModemCdmaInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemCdmaInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/networkinterface.cpp
===================================================================
--- libs/solid/control/networkinterface.cpp	(revision 1145886)
+++ libs/solid/control/networkinterface.cpp	(revision 1145887)
@@ -27,7 +27,9 @@
 Solid::Control::NetworkInterface::NetworkInterface(QObject *backendObject)
     : QObject(), d_ptr(new NetworkInterfacePrivate(this))
 {
-    Q_D(NetworkInterface); d->setBackendObject(backendObject); } 
+    Q_D(NetworkInterface); d->setBackendObject(backendObject);
+}
+
 Solid::Control::NetworkInterface::NetworkInterface(const NetworkInterface &other)
     : QObject(), d_ptr(new NetworkInterfacePrivate(this))
 {
@@ -63,6 +65,12 @@
     return_SOLID_CALL(Ifaces::NetworkInterface *, d->backendObject(), QString(), uni());
 }
 
+QString Solid::Control::NetworkInterface::udi() const
+{
+    Q_D(const NetworkInterface);
+    return_SOLID_CALL(Ifaces::NetworkInterface *, d->backendObject(), QString(), udi());
+}
+
 QString Solid::Control::NetworkInterface::interfaceName() const
 {
     Q_D(const NetworkInterface);
Index: libs/solid/control/modemgsmussdinterface_p.h
===================================================================
--- libs/solid/control/modemgsmussdinterface_p.h	(revision 0)
+++ libs/solid/control/modemgsmussdinterface_p.h	(revision 1145887)
@@ -0,0 +1,41 @@
+/*
+Copyright 2010 Lamarque Souza <lamarque@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef SOLID_CONTROL_MODEMGSMUSSDINTERFACE_P_H
+#define SOLID_CONTROL_MODEMGSMUSSDINTERFACE_P_H
+
+#include "modeminterface_p.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemGsmUssdInterfacePrivate: public ModemInterfacePrivate
+    {
+    public:
+        explicit ModemGsmUssdInterfacePrivate(QObject *parent)
+            : ModemInterfacePrivate(parent) { }
+
+        void setBackendObject(QObject *object);
+    };
+}
+}
+
+#endif //SOLID_CONTROL_MODEMGSMUSSDINTERFACE_P_H
Index: libs/solid/control/modemgsmsmsinterface.cpp
===================================================================
--- libs/solid/control/modemgsmsmsinterface.cpp	(revision 0)
+++ libs/solid/control/modemgsmsmsinterface.cpp	(revision 1145887)
@@ -0,0 +1,128 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+#include <KLocale>
+
+#include "modemgsmsmsinterface.h"
+#include "modemgsmsmsinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmsmsinterface.h"
+
+Solid::Control::ModemGsmSmsInterface::ModemGsmSmsInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmSmsInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmSmsInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmSmsInterface::ModemGsmSmsInterface(const ModemGsmSmsInterface &smsinterface)
+    : ModemInterface(*new ModemGsmSmsInterfacePrivate(this), smsinterface)
+{
+    Q_D(ModemGsmSmsInterface);
+    d->setBackendObject(smsinterface.d_ptr->backendObject());
+    makeConnections( smsinterface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemGsmSmsInterface::~ModemGsmSmsInterface()
+{
+}
+
+void Solid::Control::ModemGsmSmsInterface::deleteSms(const int index) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), deleteSms(index));
+}
+
+QVariantMap Solid::Control::ModemGsmSmsInterface::get(const int index) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), QVariantMap(), get(index));
+}
+
+int Solid::Control::ModemGsmSmsInterface::getFormat() const
+{
+    Q_D(const ModemGsmSmsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), -1, getFormat());
+}
+
+void Solid::Control::ModemGsmSmsInterface::setFormat(const int format) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), setFormat(format));
+}
+
+QString Solid::Control::ModemGsmSmsInterface::getSmsc() const
+{
+    Q_D(const ModemGsmSmsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), QString(), getSmsc());
+}
+
+QList<QVariantMap> Solid::Control::ModemGsmSmsInterface::list() const
+{
+    Q_D(const ModemGsmSmsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), QList<QVariantMap>(), list());
+}
+
+void Solid::Control::ModemGsmSmsInterface::save(const QVariantMap & properties) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), save(properties));
+}
+
+void Solid::Control::ModemGsmSmsInterface::send(const QVariantMap & properties) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), send(properties));
+}
+
+void Solid::Control::ModemGsmSmsInterface::sendFromStorage(const int index) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), sendFromStorage(index));
+}
+
+void Solid::Control::ModemGsmSmsInterface::setIndication(const int mode, const int mt, const int bm, const int ds, const int brf) const
+{
+    Q_D(const ModemGsmSmsInterface);
+    SOLID_CALL(Ifaces::ModemGsmSmsInterface *, d->backendObject(), setIndication(mode, mt, bm, ds, brf));
+}
+
+void Solid::Control::ModemGsmSmsInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(smsReceived(int, bool)),
+                this, SIGNAL(smsReceived(int, bool)));
+        QObject::connect(source, SIGNAL(completed(int, bool)),
+                this, SIGNAL(completed(int, bool)));
+    }
+}
+
+void Solid::Control::ModemGsmSmsInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmSmsInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/solidmodemmanager.desktop
===================================================================
--- libs/solid/control/solidmodemmanager.desktop	(revision 0)
+++ libs/solid/control/solidmodemmanager.desktop	(revision 1145887)
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Type=ServiceType
+X-KDE-ServiceType=SolidModemManager
+
+Comment=Modem Management Backend
+Comment[pt_BR]=Infraestrutura de gerenciamento de modem
+
+[PropertyDef::X-KDE-SolidBackendInfo-Version]
+Type=QString
+
Index: libs/solid/control/networkgsminterface.cpp
===================================================================
--- libs/solid/control/networkgsminterface.cpp	(revision 1145886)
+++ libs/solid/control/networkgsminterface.cpp	(revision 1145887)
@@ -18,12 +18,15 @@
 License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include <KLocale>
+
 #include "networkgsminterface.h"
 #include "networkgsminterface_p.h"
 
 #include "frontendobject_p.h"
 #include "soliddefs_p.h"
-#include "ifaces/wirelessaccesspoint.h"
+#include "ifaces/networkgsminterface.h"
+#include "ifaces/modemgsmnetworkinterface.h"
 
 Solid::Control::GsmNetworkInterface::GsmNetworkInterface(QObject *backendObject)
     : SerialNetworkInterface(*new GsmNetworkInterfacePrivate(this), backendObject)
@@ -62,6 +65,38 @@
     return Gsm;
 }
 
+Solid::Control::ModemGsmNetworkInterface * Solid::Control::GsmNetworkInterface::getModemNetworkIface()
+{
+    Q_D(const GsmNetworkInterface);
+    Ifaces::GsmNetworkInterface *t = qobject_cast<Ifaces::GsmNetworkInterface *>(d->backendObject());
+    if (t != 0)
+    {
+        return t->getModemNetworkIface();
+    }
+    return 0;
+}
+
+Solid::Control::ModemGsmCardInterface * Solid::Control::GsmNetworkInterface::getModemCardIface()
+{
+    Q_D(const GsmNetworkInterface);
+    Ifaces::GsmNetworkInterface *t = qobject_cast<Ifaces::GsmNetworkInterface *>(d->backendObject());
+    if (t != 0)
+    {
+        return t->getModemCardIface();
+    }
+    return 0;
+}
+
+void Solid::Control::GsmNetworkInterface::setModemNetworkIface(Solid::Control::ModemGsmNetworkInterface * iface)
+{
+    Q_D(const GsmNetworkInterface);
+    Ifaces::GsmNetworkInterface *t = qobject_cast<Ifaces::GsmNetworkInterface *>(d->backendObject());
+    if (t != 0)
+    {
+        t->setModemNetworkIface(iface);
+    }
+}
+
 void Solid::Control::GsmNetworkInterface::makeConnections(QObject * source)
 {
 }
Index: libs/solid/control/modemmanagerinterface.h
===================================================================
--- libs/solid/control/modemmanagerinterface.h	(revision 0)
+++ libs/solid/control/modemmanagerinterface.h	(revision 1145887)
@@ -0,0 +1,92 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SOLID_CONTROL_MODEMMANAGERINTERFACE_H
+#define SOLID_CONTROL_MODEMMANAGERINTERFACE_H
+
+#include <QtCore/QObject>
+#include <QtCore/QVariant>
+
+#include <solid/networking.h>
+#include "solid_control_export.h"
+#include "networkipv4config.h"
+
+namespace Solid
+{
+namespace Control
+{
+    class ModemManagerInterfacePrivate;
+
+    class SOLIDCONTROL_EXPORT ModemManagerInterface: public QObject
+    {
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(ModemManagerInterface)
+
+    public:
+        /**
+         * Creates a new ModemManagerInterface object.
+         *
+         * @param backendObject the modem object provided by the backend
+         */
+        explicit ModemManagerInterface(QObject *backendObject);
+
+        /**
+         * Constructs a copy of a modem.
+         *
+         * @param modem the modem to copy
+         */
+        ModemManagerInterface(const ModemManagerInterface &modem);
+
+        /**
+         * Destroys a ModemManagerInterface object.
+         */
+        virtual ~ModemManagerInterface();
+
+    Q_SIGNALS:
+        /**
+         * This signal is emitted when a device was added to the system.
+         *
+         * @param device object path of the newly added device.
+         */
+        void deviceAdded(QString &device);
+        /**
+         * This signal is emitted when a device was removed from the system.
+         *
+         * @param device object path of the device that was just removed.
+         */
+        void deviceRemoved(QString &device);
+
+    protected:
+        /**
+         * @internal
+         */
+        ModemManagerInterface(ModemManagerInterfacePrivate &dd, QObject *backendObject);
+
+        /**
+         * @internal
+         */
+        ModemManagerInterface(ModemManagerInterfacePrivate &dd, const ModemManagerInterface &modem);
+
+        ModemManagerInterfacePrivate *d_ptr;
+    };
+
+} // Control
+} // Solid
+
+#endif
Index: libs/solid/control/modeminterface.cpp
===================================================================
--- libs/solid/control/modeminterface.cpp	(revision 0)
+++ libs/solid/control/modeminterface.cpp	(revision 1145887)
@@ -0,0 +1,253 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KLocale>
+
+#include "modeminterface.h"
+#include "modeminterface_p.h"
+
+#include "soliddefs_p.h"
+#include "ifaces/modeminterface.h"
+
+Solid::Control::ModemInterface::ModemInterface(QObject *backendObject)
+    : QObject(), d_ptr(new ModemInterfacePrivate(this))
+{
+    Q_D(ModemInterface); d->setBackendObject(backendObject);
+}
+
+Solid::Control::ModemInterface::ModemInterface(const ModemInterface &other)
+    : QObject(), d_ptr(new ModemInterfacePrivate(this))
+{
+    Q_D(ModemInterface);
+    d->setBackendObject(other.d_ptr->backendObject());
+}
+
+Solid::Control::ModemInterface::ModemInterface(ModemInterfacePrivate &dd, QObject *backendObject)
+    : QObject(), d_ptr(&dd)
+{
+    Q_UNUSED(backendObject);
+}
+
+Solid::Control::ModemInterface::ModemInterface(ModemInterfacePrivate &dd, const ModemInterface &other)
+    : d_ptr(&dd)
+{
+    Q_UNUSED(other);
+}
+
+Solid::Control::ModemInterface::~ModemInterface()
+{
+    delete d_ptr;
+}
+
+QString Solid::Control::ModemInterface::udi() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QString(), udi());
+}
+
+void Solid::Control::ModemInterface::enable(const bool enable) const
+{
+    Q_D(const ModemInterface);
+    SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), enable(enable));
+}
+
+void Solid::Control::ModemInterface::connectModem(const QString & number) const
+{
+    Q_D(const ModemInterface);
+    SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), connectModem(number));
+}
+
+void Solid::Control::ModemInterface::connectModem(const QVariantMap & properties) const
+{
+    Q_D(const ModemInterface);
+    SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), connectModem(properties));
+}
+
+void Solid::Control::ModemInterface::disconnectModem() const
+{
+    Q_D(const ModemInterface);
+    SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), disconnectModem());
+}
+
+Solid::Control::ModemInterface::Ip4ConfigType Solid::Control::ModemInterface::getIp4Config() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), Ip4ConfigType(), getIp4Config());
+}
+
+Solid::Control::ModemInterface::InfoType Solid::Control::ModemInterface::getInfo() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), InfoType(), getInfo());
+}
+
+QVariantMap Solid::Control::ModemInterface::getStatus() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QVariantMap(), getStatus());
+}
+
+QString Solid::Control::ModemInterface::device() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QString(), device());
+}
+
+QString Solid::Control::ModemInterface::masterDevice() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QString(), masterDevice());
+}
+
+QString Solid::Control::ModemInterface::driver() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QString(), driver());
+}
+
+Solid::Control::ModemInterface::Type Solid::Control::ModemInterface::type() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), Solid::Control::ModemInterface::UnknownType, type());
+}
+
+bool Solid::Control::ModemInterface::enabled() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), false, enabled());
+}
+
+QString Solid::Control::ModemInterface::unlockRequired() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), QString(), unlockRequired());
+}
+
+Solid::Control::ModemInterface::Method Solid::Control::ModemInterface::ipMethod() const
+{
+    Q_D(const ModemInterface);
+    return_SOLID_CALL(Ifaces::ModemInterface *, d->backendObject(), UnknownMethod, ipMethod());
+}
+
+void Solid::Control::ModemInterface::slotDeviceChanged(const QString & device)
+{
+    emit deviceChanged(device);
+}
+
+void Solid::Control::ModemInterface::slotMasterDeviceChanged(const QString & masterDevice)
+{
+    emit masterDeviceChanged(masterDevice);
+}
+
+void Solid::Control::ModemInterface::slotDriverChanged(const QString & driver)
+{
+    emit driverChanged(driver);
+}
+
+void Solid::Control::ModemInterface::slotUnlockRequiredChanged(const QString & codeRequired)
+{
+    emit unlockRequiredChanged(codeRequired);
+}
+
+void Solid::Control::ModemInterfacePrivate::setBackendObject(QObject *object)
+{
+    FrontendObjectPrivate::setBackendObject(object);
+
+    if (object) {
+        QObject::connect(object, SIGNAL(deviceChanged(const QString &)),
+                         parent(), SLOT(slotDeviceChanged(const QString &)));
+        QObject::connect(object, SIGNAL(masterDeviceChanged(const QString &)),
+                         parent(), SLOT(slotMasterDeviceChanged(const QString &)));
+        QObject::connect(object, SIGNAL(driverChanged(const QString &)),
+                         parent(), SLOT(slotDriverChanged(const QString &)));
+        QObject::connect(object, SIGNAL(typeChanged(const Solid::Control::ModemInterface::Type)),
+                         parent(), SIGNAL(typeChanged(const Solid::Control::ModemInterface::Type)));
+        QObject::connect(object, SIGNAL(enabledChanged(const bool)),
+                         parent(), SIGNAL(enabledChanged(const bool)));
+        QObject::connect(object, SIGNAL(unlockRequiredChanged(const QString &)),
+                         parent(), SLOT(slotUnlockRequiredChanged(const QString &)));
+        QObject::connect(object, SIGNAL(ipMethodChanged(const Solid::Control::ModemInterface::Method)),
+                         parent(), SIGNAL(ipMethodChanged(const Solid::Control::ModemInterface::Method)));
+    }
+}
+
+QString Solid::Control::ModemInterface::convertTypeToString(const Solid::Control::ModemInterface::Type type)
+{
+    switch (type) {
+        case UnknownType: return i18nc("Unknown cellular type","Unknown");
+        case GsmType: return i18nc("Gsm cellular type","Gsm");
+        case CdmaType: return i18nc("Cdma cellular type","Cdma");
+    }
+
+    return i18nc("Unknown cellular type","Unknown");
+}
+
+QString Solid::Control::ModemInterface::convertBandToString(const Solid::Control::ModemInterface::Band band)
+{
+    switch (band) {
+        case UnknownBand: return i18nc("Unknown cellular frequency band","Unknown");
+        case AnyBand: return i18nc("Any cellular frequency band","Any");
+        case Egsm: return i18nc("Cellular frequency band","GSM/GPRS/EDGE 900 MHz");
+        case Dcs: return i18nc("Cellular frequency band","GSM/GPRS/EDGE 1800 MHz");
+        case Pcs: return i18nc("Cellular frequency band","GSM/GPRS/EDGE 1900 MHz");
+        case G850: return i18nc("Cellular frequency band","GSM/GPRS/EDGE 850 MHz");
+        case U2100: return i18nc("Cellular frequency band","WCDMA 2100 MHz (Class I)");
+        case U1800: return i18nc("Cellular frequency band","WCDMA 3GPP 1800 MHz (Class III)");
+        case U17IV: return i18nc("Cellular frequency band","WCDMA 3GPP AWS 1700/2100 MHz (Class IV)");
+        case U800: return i18nc("Cellular frequency band","WCDMA 3GPP UMTS 800 MHz (Class VI)");
+        case U850: return i18nc("Cellular frequency band","WCDMA 3GPP UMTS 850 MHz (Class V)");
+        case U900: return i18nc("Cellular frequency band","WCDMA 3GPP UMTS 900 MHz (Class VIII)");
+        case U17IX: return i18nc("Cellular frequency band","WCDMA 3GPP UMTS 1700 MHz (Class IX)");
+        case U19IX: return i18nc("Cellular frequency band","WCDMA 3GPP UMTS 1900 MHz (Class II)");
+    }
+
+    return i18nc("Unknown cellular frequency band","Unknown");
+}
+
+QString Solid::Control::ModemInterface::convertAllowedModeToString(const Solid::Control::ModemInterface::AllowedMode mode)
+{
+    switch (mode) {
+        case AnyModeAllowed: return i18nc("Allowed Gsm modes (2G/3G/any)","Any");
+        case Prefer2g: return i18nc("Allowed Gsm modes (2G/3G/any)","Prefer 2G");
+        case Prefer3g: return i18nc("Allowed Gsm modes (2G/3G/any)","Prefer 3G");
+        case UseOnly2g: return i18nc("Allowed Gsm modes (2G/3G/any)","Only 2G");
+        case UseOnly3g: return i18nc("Allowed Gsm modes (2G/3G/any)","Only 3G");
+    }
+
+    return i18nc("Allowed Gsm modes (2G/3G/any)","Any");
+}
+
+QString Solid::Control::ModemInterface::convertAccessTechnologyToString(const Solid::Control::ModemInterface::AccessTechnology tech)
+{
+    switch (tech) {
+        case UnknownTechnology: return i18nc("Unknown cellular access technology","Unknown");
+        case Gsm: return i18nc("Cellular access technology","GSM");
+        case GsmCompact: return i18nc("Cellular access technology","Compact GSM");
+        case Gprs: return i18nc("Cellular access technology","GPRS");
+        case Edge: return i18nc("Cellular access technology","EDGE");
+        case Umts: return i18nc("Cellular access technology","UMTS");
+        case Hsdpa: return i18nc("Cellular access technology","HSDPA");
+        case Hsupa: return i18nc("Cellular access technology","HSUPA");
+        case Hspa: return i18nc("Cellular access technology","HSPA");
+    }
+
+    return i18nc("Unknown cellular access technology","Unknown");
+}
+
+#include "modeminterface.moc"
Index: libs/solid/control/modemgsmcardinterface.cpp
===================================================================
--- libs/solid/control/modemgsmcardinterface.cpp	(revision 0)
+++ libs/solid/control/modemgsmcardinterface.cpp	(revision 1145887)
@@ -0,0 +1,116 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+#include <KLocale>
+
+#include "modemgsmcardinterface.h"
+#include "modemgsmcardinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmcardinterface.h"
+
+Solid::Control::ModemGsmCardInterface::ModemGsmCardInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmCardInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmCardInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmCardInterface::ModemGsmCardInterface(const ModemGsmCardInterface &cardinterface)
+    : ModemInterface(*new ModemGsmCardInterfacePrivate(this), cardinterface)
+{
+    Q_D(ModemGsmCardInterface);
+    d->setBackendObject(cardinterface.d_ptr->backendObject());
+    makeConnections( cardinterface.d_ptr->backendObject() );
+}
+
+Solid::Control::ModemGsmCardInterface::~ModemGsmCardInterface()
+{
+}
+
+QString Solid::Control::ModemGsmCardInterface::getImei() const
+{
+    Q_D(const ModemGsmCardInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), QString(), getImei());
+}
+
+QString Solid::Control::ModemGsmCardInterface::getImsi() const
+{
+    Q_D(const ModemGsmCardInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), QString(), getImsi());
+}
+
+void Solid::Control::ModemGsmCardInterface::sendPuk(const QString & puk, const QString & pin) const
+{
+    Q_D(const ModemGsmCardInterface);
+    SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), sendPuk(puk, pin));
+}
+
+void Solid::Control::ModemGsmCardInterface::sendPin(const QString & pin) const
+{
+    Q_D(const ModemGsmCardInterface);
+    SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), sendPin(pin));
+}
+
+void Solid::Control::ModemGsmCardInterface::enablePin(const QString & pin, const bool enabled) const
+{
+    Q_D(const ModemGsmCardInterface);
+    SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), enablePin(pin, enabled));
+}
+
+void Solid::Control::ModemGsmCardInterface::changePin(const QString & oldPin, const QString & newPin) const
+{
+    Q_D(const ModemGsmCardInterface);
+    SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), changePin(oldPin, newPin));
+}
+
+Solid::Control::ModemInterface::Band Solid::Control::ModemGsmCardInterface::getSupportedBands() const
+{
+    Q_D(const ModemGsmCardInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), Solid::Control::ModemInterface::UnknownBand, getSupportedBands());
+}
+
+Solid::Control::ModemInterface::Mode Solid::Control::ModemGsmCardInterface::getSupportedModes() const
+{
+    Q_D(const ModemGsmCardInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmCardInterface *, d->backendObject(), Solid::Control::ModemInterface::UnknownMode, getSupportedModes());
+}
+
+void Solid::Control::ModemGsmCardInterface::makeConnections(QObject * source)
+{
+    if (source) {
+        QObject::connect(source, SIGNAL(supportedBandsChanged(const Solid::Control::ModemInterface::Band)),
+                this, SIGNAL(supportedBandsChanged(const Solid::Control::ModemInterface::Band)));
+        QObject::connect(source, SIGNAL(supportedModesChanged(const Solid::Control::ModemInterface::Mode)),
+                this, SIGNAL(supportedModesChanged(const Solid::Control::ModemInterface::Mode)));
+    }
+}
+
+void Solid::Control::ModemGsmCardInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmCardInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/modemgsmcontactsinterface.cpp
===================================================================
--- libs/solid/control/modemgsmcontactsinterface.cpp	(revision 0)
+++ libs/solid/control/modemgsmcontactsinterface.cpp	(revision 1145887)
@@ -0,0 +1,100 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include <KDebug>
+#include <KLocale>
+
+#include "modemgsmcontactsinterface.h"
+#include "modemgsmcontactsinterface_p.h"
+
+#include "frontendobject_p.h"
+#include "soliddefs_p.h"
+#include "ifaces/modemgsmcontactsinterface.h"
+
+Solid::Control::ModemGsmContactsInterface::ModemGsmContactsInterface(QObject *backendObject)
+    : ModemInterface(*new ModemGsmContactsInterfacePrivate(this), backendObject)
+{
+    Q_D(ModemGsmContactsInterface);
+    d->setBackendObject(backendObject);
+    makeConnections( backendObject );
+}
+
+Solid::Control::ModemGsmContactsInterface::ModemGsmContactsInterface(const ModemGsmContactsInterface &contactsIface)
+    : ModemInterface(*new ModemGsmContactsInterfacePrivate(this), contactsIface)
+{
+    Q_D(ModemGsmContactsInterface);
+    d->setBackendObject(contactsIface.d_ptr->backendObject());
+    makeConnections(contactsIface.d_ptr->backendObject());
+}
+
+Solid::Control::ModemGsmContactsInterface::~ModemGsmContactsInterface()
+{
+}
+
+int Solid::Control::ModemGsmContactsInterface::addContact(const QString & name, const QString & number) const
+{
+    Q_D(const ModemGsmContactsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), -1, addContact(name, number));
+}
+
+void Solid::Control::ModemGsmContactsInterface::deleteContact(const int index) const
+{
+    Q_D(const ModemGsmContactsInterface);
+    SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), deleteContact(index));
+}
+
+Solid::Control::ModemGsmContactsInterface::ContactType Solid::Control::ModemGsmContactsInterface::get(const int index) const
+{
+    Q_D(const ModemGsmContactsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), ContactType(), get(index));
+}
+
+QList<Solid::Control::ModemGsmContactsInterface::ContactType> Solid::Control::ModemGsmContactsInterface::list() const
+{
+    Q_D(const ModemGsmContactsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), QList<ContactType>(), list());
+}
+
+QList<Solid::Control::ModemGsmContactsInterface::ContactType> Solid::Control::ModemGsmContactsInterface::find(const QString & pattern) const
+{
+    Q_D(const ModemGsmContactsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), QList<ContactType>(), find(pattern));
+}
+
+int Solid::Control::ModemGsmContactsInterface::getCount() const
+{
+    Q_D(const ModemGsmContactsInterface);
+    return_SOLID_CALL(Ifaces::ModemGsmContactsInterface *, d->backendObject(), 0, getCount());
+}
+
+void Solid::Control::ModemGsmContactsInterface::makeConnections(QObject * source)
+{
+    if (source) {
+    }
+}
+
+void Solid::Control::ModemGsmContactsInterfacePrivate::setBackendObject(QObject *object)
+{
+    ModemInterfacePrivate::setBackendObject(object);
+}
+
+void Solid::Control::ModemGsmContactsInterface::_k_destroyed(QObject *object)
+{
+    Q_UNUSED(object);
+}
Index: libs/solid/control/backends/fakenet/fakenetworkinterface.cpp
===================================================================
--- libs/solid/control/backends/fakenet/fakenetworkinterface.cpp	(revision 1145886)
+++ libs/solid/control/backends/fakenet/fakenetworkinterface.cpp	(revision 1145887)
@@ -38,7 +38,12 @@
     return mPropertyMap["uni"].toString();
 }
 
+QString FakeNetworkInterface::udi() const
+{
+    return mPropertyMap["udi"].toString();
+}
 
+
 QString FakeNetworkInterface::interfaceName() const
 {
     return mPropertyMap["interface"].toString();
Index: libs/solid/control/backends/fakenet/fakeaccesspoint.cpp
===================================================================
--- libs/solid/control/backends/fakenet/fakeaccesspoint.cpp	(revision 1145886)
+++ libs/solid/control/backends/fakenet/fakeaccesspoint.cpp	(revision 1145887)
@@ -37,6 +37,10 @@
     return mPropertyMap["uni"].toString();
 }
 
+QString FakeAccessPoint::udi() const
+{
+    return mPropertyMap["udi"].toString();
+}
 
 QString FakeAccessPoint::ssid() const
 {
Index: libs/solid/control/backends/fakenet/fakenetworkinterface.h
===================================================================
--- libs/solid/control/backends/fakenet/fakenetworkinterface.h	(revision 1145886)
+++ libs/solid/control/backends/fakenet/fakenetworkinterface.h	(revision 1145887)
@@ -40,6 +40,7 @@
                           QObject *parent = 0);
         virtual ~FakeNetworkInterface();
         QString uni() const;
+        QString udi() const;
         QString interfaceName() const;
         QString driver() const;
         bool isActive() const;
Index: libs/solid/control/backends/fakenet/fakeaccesspoint.h
===================================================================
--- libs/solid/control/backends/fakenet/fakeaccesspoint.h	(revision 1145886)
+++ libs/solid/control/backends/fakenet/fakeaccesspoint.h	(revision 1145887)
@@ -36,6 +36,7 @@
     FakeAccessPoint(const QMap<QString,QVariant> & propsMap, QObject * parent = 0 );
     ~FakeAccessPoint();
     QString uni() const;
+    QString udi() const;
     Solid::Control::AccessPoint::Capabilities capabilities() const;
     Solid::Control::AccessPoint::WpaFlags wpaFlags() const;
     Solid::Control::AccessPoint::WpaFlags rsnFlags() const;
Index: libs/solid/control/modemmanager.cpp
===================================================================
--- libs/solid/control/modemmanager.cpp	(revision 0)
+++ libs/solid/control/modemmanager.cpp	(revision 1145887)
@@ -0,0 +1,224 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2010 Lamarque Souza <lamarque@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "ifaces/modemmanager.h"
+#include "ifaces/modeminterface.h"
+#include "ifaces/modemmanagerinterface.h"
+#include "ifaces/modemgsmcardinterface.h"
+#include "ifaces/modemgsmnetworkinterface.h"
+
+#include "soliddefs_p.h"
+#include "modemmanager_p.h"
+#include "modemmanagerinterface.h"
+
+#include "modemmanager.h"
+
+#include <kglobal.h>
+#include <kdebug.h>
+
+K_GLOBAL_STATIC(Solid::Control::ModemManagerPrivate, globalModemManager)
+
+Solid::Control::ModemManagerPrivate::ModemManagerPrivate() : m_invalidDevice(0)
+{
+    loadBackend("Modem Management",
+                "SolidModemManager",
+                "Solid::Control::Ifaces::ModemManager");
+
+    if (managerBackend()!=0) {
+        connect(managerBackend(), SIGNAL(modemInterfaceAdded(const QString &)),
+                this, SLOT(_k_modemInterfaceAdded(const QString &)));
+        connect(managerBackend(), SIGNAL(modemInterfaceRemoved(const QString &)),
+                this, SLOT(_k_modemInterfaceRemoved(const QString &)));
+    }
+}
+
+Solid::Control::ModemManagerPrivate::~ModemManagerPrivate()
+{
+    // Delete all the devices, they are now outdated
+    typedef QPair<ModemInterface *, QObject *> ModemInterfaceIfacePair;
+    typedef QMap<ModemInterface::GsmInterfaceType, ModemInterfaceIfacePair> ModemInterfaceIfaceMap;
+
+    foreach (const ModemInterfaceIfaceMap &map, m_modemInterfaceMap) {
+        foreach (const ModemInterfaceIfacePair &pair, map) {
+            delete pair.first;
+            delete pair.second;
+        }
+    }
+
+    m_modemInterfaceMap.clear();
+}
+
+Solid::Control::ModemInterfaceList Solid::Control::ModemManagerPrivate::buildDeviceList(const QStringList &udiList)
+{
+    ModemInterfaceList list;
+    Ifaces::ModemManager *backend = qobject_cast<Ifaces::ModemManager *>(managerBackend());
+
+    if (backend == 0) return list;
+
+    foreach (const QString &udi, udiList)
+    {
+        QPair<ModemInterface *, QObject *> pair = findRegisteredModemInterface(udi, ModemInterface::GsmNetwork);
+
+        if (pair.first!= 0)
+        {
+            list.append(pair.first);
+        }
+    }
+
+    return list;
+}
+
+Solid::Control::ModemInterfaceList Solid::Control::ModemManagerPrivate::modemInterfaces()
+{
+    Ifaces::ModemManager *backend = qobject_cast<Ifaces::ModemManager *>(managerBackend());
+
+    if (backend!= 0)
+    {
+        return buildDeviceList(backend->modemInterfaces());
+    }
+    else
+    {
+        return ModemInterfaceList();
+    }
+}
+
+Solid::Control::ModemInterfaceList Solid::Control::ModemManager::modemInterfaces()
+{
+    return globalModemManager->modemInterfaces();
+}
+
+Solid::Control::ModemInterface * Solid::Control::ModemManagerPrivate::findModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType)
+{
+    Ifaces::ModemManager *backend = qobject_cast<Ifaces::ModemManager *>(managerBackend());
+
+    if (backend == 0) return 0;
+
+    if (!backend->modemInterfaces().contains(udi)) {
+        return 0;
+    }
+
+    QPair<ModemInterface *, QObject *> pair = findRegisteredModemInterface(udi, ifaceType);
+
+    if (pair.first != 0)
+    {
+        return pair.first;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+Solid::Control::ModemInterface * Solid::Control::ModemManager::findModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType)
+{
+    return globalModemManager->findModemInterface(udi, ifaceType);
+}
+
+Solid::Control::ModemManager::Notifier * Solid::Control::ModemManager::notifier()
+{
+    return globalModemManager;
+}
+
+void Solid::Control::ModemManagerPrivate::_k_modemInterfaceAdded(const QString &udi)
+{
+    typedef QPair<ModemInterface *, QObject *> ModemInterfaceIfacePair;
+    QMap<ModemInterface::GsmInterfaceType, ModemInterfaceIfacePair> map = m_modemInterfaceMap.take(udi);
+
+    foreach (const ModemInterfaceIfacePair &pair, map) {
+        if (pair.first!= 0)
+        {
+            // Oops, I'm not sure it should happen...
+            // But well in this case we'd better kill the old device we got, it's probably outdated
+
+            delete pair.first;
+            delete pair.second;
+        }
+    }
+
+    emit modemInterfaceAdded(udi);
+}
+
+void Solid::Control::ModemManagerPrivate::_k_modemInterfaceRemoved(const QString &udi)
+{
+    typedef QPair<ModemInterface *, QObject *> ModemInterfaceIfacePair;
+    QMap<ModemInterface::GsmInterfaceType, ModemInterfaceIfacePair> map = m_modemInterfaceMap.take(udi);
+
+    foreach (const ModemInterfaceIfacePair &pair, map) {
+        if (pair.first!= 0)
+        {
+            delete pair.first;
+            delete pair.second;
+        }
+    }
+
+    emit modemInterfaceRemoved(udi);
+}
+
+void Solid::Control::ModemManagerPrivate::_k_destroyed(QObject *object)
+{
+    Ifaces::ModemInterface *device = qobject_cast<Ifaces::ModemInterface *>(object);
+
+    if (device!=0)
+    {
+        typedef QPair<ModemInterface *, QObject *> ModemInterfaceIfacePair;
+
+        QString udi = device->udi();
+        QMap<ModemInterface::GsmInterfaceType, ModemInterfaceIfacePair> map = m_modemInterfaceMap.take(udi);
+        foreach (const ModemInterfaceIfacePair &pair, map) {
+            delete pair.first;
+        }
+    }
+}
+
+QPair<Solid::Control::ModemInterface *, QObject *>
+Solid::Control::ModemManagerPrivate::findRegisteredModemInterface(const QString &udi, const ModemInterface::GsmInterfaceType ifaceType)
+{
+    if (m_modemInterfaceMap.contains(udi) && m_modemInterfaceMap[udi].contains(ifaceType)) {
+        return m_modemInterfaceMap[udi][ifaceType];
+    } else {
+        Ifaces::ModemManager *backend = qobject_cast<Ifaces::ModemManager *>(managerBackend());
+
+        if (backend!=0)
+        {
+            QObject * iface = backend->createModemInterface(udi, ifaceType);
+            ModemInterface *device = 0;
+            if (qobject_cast<Ifaces::ModemGsmCardInterface *>(iface) != 0) {
+                device = new ModemGsmCardInterface(iface);
+            } else if (qobject_cast<Ifaces::ModemGsmNetworkInterface *>(iface) != 0) {
+                device = new ModemGsmNetworkInterface(iface);
+            } else { // TODO: Add ModemCdmaInterface, ModemLocationInterface and the other Gsm interfaces.
+                kDebug() << "Unhandled network interface: " << udi;
+            }
+            if (device != 0) {
+                QPair<ModemInterface *, QObject *> pair(device, iface);
+                connect(iface, SIGNAL(destroyed(QObject *)),
+                        this, SLOT(_k_destroyed(QObject *)));
+                QMap<ModemInterface::GsmInterfaceType, QPair<ModemInterface *, QObject *> > map;
+                map.insert(ifaceType, pair);
+                m_modemInterfaceMap[udi] = map;
+                return pair;
+            }
+        }
+    }
+
+    return QPair<ModemInterface *, QObject *>(0, 0);
+}
+
+#include "modemmanager_p.moc"
+#include "modemmanager.moc"
Index: solid/wicd/networkinterface.cpp
===================================================================
--- solid/wicd/networkinterface.cpp	(revision 1145988)
+++ solid/wicd/networkinterface.cpp	(revision 1199124)
@@ -115,6 +115,11 @@
     return d->name;
 }
 
+QString WicdNetworkInterface::udi() const
+{
+    return d->name;
+}
+
 int WicdNetworkInterface::designSpeed() const
 {
     return 0;
